// AUTOGENERATED - DO NOT EDIT

package tdlib

import (
	"encoding/json"
)

// Error An object of this type can be returned on every function call, in case of an error
type Error struct {
	tdCommon
	Code    int32  `json:"code"`    // Error code; subject to future changes. If the error code is 406, the error message must not be processed in any way and must not be displayed to the user
	Message string `json:"message"` // Error message; subject to future changes
}

// MessageType return the string telegram-type of Error
func (error *Error) MessageType() string {
	return "error"
}

// NewError creates a new Error
//
// @param code Error code; subject to future changes. If the error code is 406, the error message must not be processed in any way and must not be displayed to the user
// @param message Error message; subject to future changes
func NewError(code int32, message string) *Error {
	errorTemp := Error{
		tdCommon: tdCommon{Type: "error"},
		Code:     code,
		Message:  message,
	}

	return &errorTemp
}

// UnmarshalJSON unmarshal to json
func (error *Error) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Code    int32  `json:"code"`    // Error code; subject to future changes. If the error code is 406, the error message must not be processed in any way and must not be displayed to the user
		Message string `json:"message"` // Error message; subject to future changes
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	error.tdCommon = tempObj.tdCommon
	error.Code = tempObj.Code
	error.Message = tempObj.Message

	return nil
}

// Ok An object of this type is returned on a successful function call for certain functions
type Ok struct {
	tdCommon
}

// MessageType return the string telegram-type of Ok
func (ok *Ok) MessageType() string {
	return "ok"
}

// NewOk creates a new Ok
//
func NewOk() *Ok {
	okTemp := Ok{
		tdCommon: tdCommon{Type: "ok"},
	}

	return &okTemp
}

// UnmarshalJSON unmarshal to json
func (ok *Ok) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	ok.tdCommon = tempObj.tdCommon

	return nil
}

// AuthenticationCodeTypeTelegramMessage A digit-only authentication code is delivered via a private Telegram message, which can be viewed from another active session
type AuthenticationCodeTypeTelegramMessage struct {
	tdCommon
	Length int32 `json:"length"` // Length of the code
}

// MessageType return the string telegram-type of AuthenticationCodeTypeTelegramMessage
func (authenticationCodeTypeTelegramMessage *AuthenticationCodeTypeTelegramMessage) MessageType() string {
	return "authenticationCodeTypeTelegramMessage"
}

// NewAuthenticationCodeTypeTelegramMessage creates a new AuthenticationCodeTypeTelegramMessage
//
// @param length Length of the code
func NewAuthenticationCodeTypeTelegramMessage(length int32) *AuthenticationCodeTypeTelegramMessage {
	authenticationCodeTypeTelegramMessageTemp := AuthenticationCodeTypeTelegramMessage{
		tdCommon: tdCommon{Type: "authenticationCodeTypeTelegramMessage"},
		Length:   length,
	}

	return &authenticationCodeTypeTelegramMessageTemp
}

// UnmarshalJSON unmarshal to json
func (authenticationCodeTypeTelegramMessage *AuthenticationCodeTypeTelegramMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Length int32 `json:"length"` // Length of the code
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authenticationCodeTypeTelegramMessage.tdCommon = tempObj.tdCommon
	authenticationCodeTypeTelegramMessage.Length = tempObj.Length

	return nil
}

// GetAuthenticationCodeTypeEnum return the enum type of this object
func (authenticationCodeTypeTelegramMessage *AuthenticationCodeTypeTelegramMessage) GetAuthenticationCodeTypeEnum() AuthenticationCodeTypeEnum {
	return AuthenticationCodeTypeTelegramMessageType
}

// AuthenticationCodeTypeSms A digit-only authentication code is delivered via an SMS message to the specified phone number; non-official applications may not receive this type of code
type AuthenticationCodeTypeSms struct {
	tdCommon
	Length int32 `json:"length"` // Length of the code
}

// MessageType return the string telegram-type of AuthenticationCodeTypeSms
func (authenticationCodeTypeSms *AuthenticationCodeTypeSms) MessageType() string {
	return "authenticationCodeTypeSms"
}

// NewAuthenticationCodeTypeSms creates a new AuthenticationCodeTypeSms
//
// @param length Length of the code
func NewAuthenticationCodeTypeSms(length int32) *AuthenticationCodeTypeSms {
	authenticationCodeTypeSmsTemp := AuthenticationCodeTypeSms{
		tdCommon: tdCommon{Type: "authenticationCodeTypeSms"},
		Length:   length,
	}

	return &authenticationCodeTypeSmsTemp
}

// UnmarshalJSON unmarshal to json
func (authenticationCodeTypeSms *AuthenticationCodeTypeSms) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Length int32 `json:"length"` // Length of the code
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authenticationCodeTypeSms.tdCommon = tempObj.tdCommon
	authenticationCodeTypeSms.Length = tempObj.Length

	return nil
}

// GetAuthenticationCodeTypeEnum return the enum type of this object
func (authenticationCodeTypeSms *AuthenticationCodeTypeSms) GetAuthenticationCodeTypeEnum() AuthenticationCodeTypeEnum {
	return AuthenticationCodeTypeSmsType
}

// AuthenticationCodeTypeSmsWord An authentication code is a word delivered via an SMS message to the specified phone number; non-official applications may not receive this type of code
type AuthenticationCodeTypeSmsWord struct {
	tdCommon
	FirstLetter string `json:"first_letter"` // The first letters of the word if known
}

// MessageType return the string telegram-type of AuthenticationCodeTypeSmsWord
func (authenticationCodeTypeSmsWord *AuthenticationCodeTypeSmsWord) MessageType() string {
	return "authenticationCodeTypeSmsWord"
}

// NewAuthenticationCodeTypeSmsWord creates a new AuthenticationCodeTypeSmsWord
//
// @param firstLetter The first letters of the word if known
func NewAuthenticationCodeTypeSmsWord(firstLetter string) *AuthenticationCodeTypeSmsWord {
	authenticationCodeTypeSmsWordTemp := AuthenticationCodeTypeSmsWord{
		tdCommon:    tdCommon{Type: "authenticationCodeTypeSmsWord"},
		FirstLetter: firstLetter,
	}

	return &authenticationCodeTypeSmsWordTemp
}

// UnmarshalJSON unmarshal to json
func (authenticationCodeTypeSmsWord *AuthenticationCodeTypeSmsWord) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		FirstLetter string `json:"first_letter"` // The first letters of the word if known
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authenticationCodeTypeSmsWord.tdCommon = tempObj.tdCommon
	authenticationCodeTypeSmsWord.FirstLetter = tempObj.FirstLetter

	return nil
}

// GetAuthenticationCodeTypeEnum return the enum type of this object
func (authenticationCodeTypeSmsWord *AuthenticationCodeTypeSmsWord) GetAuthenticationCodeTypeEnum() AuthenticationCodeTypeEnum {
	return AuthenticationCodeTypeSmsWordType
}

// AuthenticationCodeTypeSmsPhrase An authentication code is a phrase from multiple words delivered via an SMS message to the specified phone number; non-official applications may not receive this type of code
type AuthenticationCodeTypeSmsPhrase struct {
	tdCommon
	FirstWord string `json:"first_word"` // The first word of the phrase if known
}

// MessageType return the string telegram-type of AuthenticationCodeTypeSmsPhrase
func (authenticationCodeTypeSmsPhrase *AuthenticationCodeTypeSmsPhrase) MessageType() string {
	return "authenticationCodeTypeSmsPhrase"
}

// NewAuthenticationCodeTypeSmsPhrase creates a new AuthenticationCodeTypeSmsPhrase
//
// @param firstWord The first word of the phrase if known
func NewAuthenticationCodeTypeSmsPhrase(firstWord string) *AuthenticationCodeTypeSmsPhrase {
	authenticationCodeTypeSmsPhraseTemp := AuthenticationCodeTypeSmsPhrase{
		tdCommon:  tdCommon{Type: "authenticationCodeTypeSmsPhrase"},
		FirstWord: firstWord,
	}

	return &authenticationCodeTypeSmsPhraseTemp
}

// UnmarshalJSON unmarshal to json
func (authenticationCodeTypeSmsPhrase *AuthenticationCodeTypeSmsPhrase) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		FirstWord string `json:"first_word"` // The first word of the phrase if known
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authenticationCodeTypeSmsPhrase.tdCommon = tempObj.tdCommon
	authenticationCodeTypeSmsPhrase.FirstWord = tempObj.FirstWord

	return nil
}

// GetAuthenticationCodeTypeEnum return the enum type of this object
func (authenticationCodeTypeSmsPhrase *AuthenticationCodeTypeSmsPhrase) GetAuthenticationCodeTypeEnum() AuthenticationCodeTypeEnum {
	return AuthenticationCodeTypeSmsPhraseType
}

// AuthenticationCodeTypeCall A digit-only authentication code is delivered via a phone call to the specified phone number
type AuthenticationCodeTypeCall struct {
	tdCommon
	Length int32 `json:"length"` // Length of the code
}

// MessageType return the string telegram-type of AuthenticationCodeTypeCall
func (authenticationCodeTypeCall *AuthenticationCodeTypeCall) MessageType() string {
	return "authenticationCodeTypeCall"
}

// NewAuthenticationCodeTypeCall creates a new AuthenticationCodeTypeCall
//
// @param length Length of the code
func NewAuthenticationCodeTypeCall(length int32) *AuthenticationCodeTypeCall {
	authenticationCodeTypeCallTemp := AuthenticationCodeTypeCall{
		tdCommon: tdCommon{Type: "authenticationCodeTypeCall"},
		Length:   length,
	}

	return &authenticationCodeTypeCallTemp
}

// UnmarshalJSON unmarshal to json
func (authenticationCodeTypeCall *AuthenticationCodeTypeCall) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Length int32 `json:"length"` // Length of the code
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authenticationCodeTypeCall.tdCommon = tempObj.tdCommon
	authenticationCodeTypeCall.Length = tempObj.Length

	return nil
}

// GetAuthenticationCodeTypeEnum return the enum type of this object
func (authenticationCodeTypeCall *AuthenticationCodeTypeCall) GetAuthenticationCodeTypeEnum() AuthenticationCodeTypeEnum {
	return AuthenticationCodeTypeCallType
}

// AuthenticationCodeTypeFlashCall An authentication code is delivered by an immediately canceled call to the specified phone number. The phone number that calls is the code that must be entered automatically
type AuthenticationCodeTypeFlashCall struct {
	tdCommon
	Pattern string `json:"pattern"` // Pattern of the phone number from which the call will be made
}

// MessageType return the string telegram-type of AuthenticationCodeTypeFlashCall
func (authenticationCodeTypeFlashCall *AuthenticationCodeTypeFlashCall) MessageType() string {
	return "authenticationCodeTypeFlashCall"
}

// NewAuthenticationCodeTypeFlashCall creates a new AuthenticationCodeTypeFlashCall
//
// @param pattern Pattern of the phone number from which the call will be made
func NewAuthenticationCodeTypeFlashCall(pattern string) *AuthenticationCodeTypeFlashCall {
	authenticationCodeTypeFlashCallTemp := AuthenticationCodeTypeFlashCall{
		tdCommon: tdCommon{Type: "authenticationCodeTypeFlashCall"},
		Pattern:  pattern,
	}

	return &authenticationCodeTypeFlashCallTemp
}

// UnmarshalJSON unmarshal to json
func (authenticationCodeTypeFlashCall *AuthenticationCodeTypeFlashCall) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Pattern string `json:"pattern"` // Pattern of the phone number from which the call will be made
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authenticationCodeTypeFlashCall.tdCommon = tempObj.tdCommon
	authenticationCodeTypeFlashCall.Pattern = tempObj.Pattern

	return nil
}

// GetAuthenticationCodeTypeEnum return the enum type of this object
func (authenticationCodeTypeFlashCall *AuthenticationCodeTypeFlashCall) GetAuthenticationCodeTypeEnum() AuthenticationCodeTypeEnum {
	return AuthenticationCodeTypeFlashCallType
}

// AuthenticationCodeTypeMissedCall An authentication code is delivered by an immediately canceled call to the specified phone number. The last digits of the phone number that calls are the code that must be entered manually by the user
type AuthenticationCodeTypeMissedCall struct {
	tdCommon
	PhoneNumberPrefix string `json:"phone_number_prefix"` // Prefix of the phone number from which the call will be made
	Length            int32  `json:"length"`              // Number of digits in the code, excluding the prefix
}

// MessageType return the string telegram-type of AuthenticationCodeTypeMissedCall
func (authenticationCodeTypeMissedCall *AuthenticationCodeTypeMissedCall) MessageType() string {
	return "authenticationCodeTypeMissedCall"
}

// NewAuthenticationCodeTypeMissedCall creates a new AuthenticationCodeTypeMissedCall
//
// @param phoneNumberPrefix Prefix of the phone number from which the call will be made
// @param length Number of digits in the code, excluding the prefix
func NewAuthenticationCodeTypeMissedCall(phoneNumberPrefix string, length int32) *AuthenticationCodeTypeMissedCall {
	authenticationCodeTypeMissedCallTemp := AuthenticationCodeTypeMissedCall{
		tdCommon:          tdCommon{Type: "authenticationCodeTypeMissedCall"},
		PhoneNumberPrefix: phoneNumberPrefix,
		Length:            length,
	}

	return &authenticationCodeTypeMissedCallTemp
}

// UnmarshalJSON unmarshal to json
func (authenticationCodeTypeMissedCall *AuthenticationCodeTypeMissedCall) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PhoneNumberPrefix string `json:"phone_number_prefix"` // Prefix of the phone number from which the call will be made
		Length            int32  `json:"length"`              // Number of digits in the code, excluding the prefix
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authenticationCodeTypeMissedCall.tdCommon = tempObj.tdCommon
	authenticationCodeTypeMissedCall.PhoneNumberPrefix = tempObj.PhoneNumberPrefix
	authenticationCodeTypeMissedCall.Length = tempObj.Length

	return nil
}

// GetAuthenticationCodeTypeEnum return the enum type of this object
func (authenticationCodeTypeMissedCall *AuthenticationCodeTypeMissedCall) GetAuthenticationCodeTypeEnum() AuthenticationCodeTypeEnum {
	return AuthenticationCodeTypeMissedCallType
}

// AuthenticationCodeTypeFragment A digit-only authentication code is delivered to https://fragment.com. The user must be logged in there via a wallet owning the phone number's NFT
type AuthenticationCodeTypeFragment struct {
	tdCommon
	URL    string `json:"url"`    // URL to open to receive the code
	Length int32  `json:"length"` // Length of the code
}

// MessageType return the string telegram-type of AuthenticationCodeTypeFragment
func (authenticationCodeTypeFragment *AuthenticationCodeTypeFragment) MessageType() string {
	return "authenticationCodeTypeFragment"
}

// NewAuthenticationCodeTypeFragment creates a new AuthenticationCodeTypeFragment
//
// @param uRL URL to open to receive the code
// @param length Length of the code
func NewAuthenticationCodeTypeFragment(uRL string, length int32) *AuthenticationCodeTypeFragment {
	authenticationCodeTypeFragmentTemp := AuthenticationCodeTypeFragment{
		tdCommon: tdCommon{Type: "authenticationCodeTypeFragment"},
		URL:      uRL,
		Length:   length,
	}

	return &authenticationCodeTypeFragmentTemp
}

// UnmarshalJSON unmarshal to json
func (authenticationCodeTypeFragment *AuthenticationCodeTypeFragment) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL    string `json:"url"`    // URL to open to receive the code
		Length int32  `json:"length"` // Length of the code
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authenticationCodeTypeFragment.tdCommon = tempObj.tdCommon
	authenticationCodeTypeFragment.URL = tempObj.URL
	authenticationCodeTypeFragment.Length = tempObj.Length

	return nil
}

// GetAuthenticationCodeTypeEnum return the enum type of this object
func (authenticationCodeTypeFragment *AuthenticationCodeTypeFragment) GetAuthenticationCodeTypeEnum() AuthenticationCodeTypeEnum {
	return AuthenticationCodeTypeFragmentType
}

// AuthenticationCodeTypeFirebaseAndroid A digit-only authentication code is delivered via Firebase Authentication to the official Android application
type AuthenticationCodeTypeFirebaseAndroid struct {
	tdCommon
	DeviceVerificationParameters FirebaseDeviceVerificationParameters `json:"device_verification_parameters"` // Parameters to be used for device verification
	Length                       int32                                `json:"length"`                         // Length of the code
}

// MessageType return the string telegram-type of AuthenticationCodeTypeFirebaseAndroid
func (authenticationCodeTypeFirebaseAndroid *AuthenticationCodeTypeFirebaseAndroid) MessageType() string {
	return "authenticationCodeTypeFirebaseAndroid"
}

// NewAuthenticationCodeTypeFirebaseAndroid creates a new AuthenticationCodeTypeFirebaseAndroid
//
// @param deviceVerificationParameters Parameters to be used for device verification
// @param length Length of the code
func NewAuthenticationCodeTypeFirebaseAndroid(deviceVerificationParameters FirebaseDeviceVerificationParameters, length int32) *AuthenticationCodeTypeFirebaseAndroid {
	authenticationCodeTypeFirebaseAndroidTemp := AuthenticationCodeTypeFirebaseAndroid{
		tdCommon:                     tdCommon{Type: "authenticationCodeTypeFirebaseAndroid"},
		DeviceVerificationParameters: deviceVerificationParameters,
		Length:                       length,
	}

	return &authenticationCodeTypeFirebaseAndroidTemp
}

// UnmarshalJSON unmarshal to json
func (authenticationCodeTypeFirebaseAndroid *AuthenticationCodeTypeFirebaseAndroid) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Length int32 `json:"length"` // Length of the code
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authenticationCodeTypeFirebaseAndroid.tdCommon = tempObj.tdCommon
	authenticationCodeTypeFirebaseAndroid.Length = tempObj.Length

	fieldDeviceVerificationParameters, _ := unmarshalFirebaseDeviceVerificationParameters(objMap["device_verification_parameters"])
	authenticationCodeTypeFirebaseAndroid.DeviceVerificationParameters = fieldDeviceVerificationParameters

	return nil
}

// GetAuthenticationCodeTypeEnum return the enum type of this object
func (authenticationCodeTypeFirebaseAndroid *AuthenticationCodeTypeFirebaseAndroid) GetAuthenticationCodeTypeEnum() AuthenticationCodeTypeEnum {
	return AuthenticationCodeTypeFirebaseAndroidType
}

// AuthenticationCodeTypeFirebaseIos A digit-only authentication code is delivered via Firebase Authentication to the official iOS application
type AuthenticationCodeTypeFirebaseIos struct {
	tdCommon
	Receipt     string `json:"receipt"`      // Receipt of successful application token validation to compare with receipt from push notification
	PushTimeout int32  `json:"push_timeout"` // Time after the next authentication method is supposed to be used if verification push notification isn't received, in seconds
	Length      int32  `json:"length"`       // Length of the code
}

// MessageType return the string telegram-type of AuthenticationCodeTypeFirebaseIos
func (authenticationCodeTypeFirebaseIos *AuthenticationCodeTypeFirebaseIos) MessageType() string {
	return "authenticationCodeTypeFirebaseIos"
}

// NewAuthenticationCodeTypeFirebaseIos creates a new AuthenticationCodeTypeFirebaseIos
//
// @param receipt Receipt of successful application token validation to compare with receipt from push notification
// @param pushTimeout Time after the next authentication method is supposed to be used if verification push notification isn't received, in seconds
// @param length Length of the code
func NewAuthenticationCodeTypeFirebaseIos(receipt string, pushTimeout int32, length int32) *AuthenticationCodeTypeFirebaseIos {
	authenticationCodeTypeFirebaseIosTemp := AuthenticationCodeTypeFirebaseIos{
		tdCommon:    tdCommon{Type: "authenticationCodeTypeFirebaseIos"},
		Receipt:     receipt,
		PushTimeout: pushTimeout,
		Length:      length,
	}

	return &authenticationCodeTypeFirebaseIosTemp
}

// UnmarshalJSON unmarshal to json
func (authenticationCodeTypeFirebaseIos *AuthenticationCodeTypeFirebaseIos) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Receipt     string `json:"receipt"`      // Receipt of successful application token validation to compare with receipt from push notification
		PushTimeout int32  `json:"push_timeout"` // Time after the next authentication method is supposed to be used if verification push notification isn't received, in seconds
		Length      int32  `json:"length"`       // Length of the code
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authenticationCodeTypeFirebaseIos.tdCommon = tempObj.tdCommon
	authenticationCodeTypeFirebaseIos.Receipt = tempObj.Receipt
	authenticationCodeTypeFirebaseIos.PushTimeout = tempObj.PushTimeout
	authenticationCodeTypeFirebaseIos.Length = tempObj.Length

	return nil
}

// GetAuthenticationCodeTypeEnum return the enum type of this object
func (authenticationCodeTypeFirebaseIos *AuthenticationCodeTypeFirebaseIos) GetAuthenticationCodeTypeEnum() AuthenticationCodeTypeEnum {
	return AuthenticationCodeTypeFirebaseIosType
}

// AuthenticationCodeInfo Information about the authentication code that was sent
type AuthenticationCodeInfo struct {
	tdCommon
	PhoneNumber string                  `json:"phone_number"` // A phone number that is being authenticated
	Type        AuthenticationCodeType  `json:"type"`         // The way the code was sent to the user
	NextType    *AuthenticationCodeType `json:"next_type"`    // The way the next code will be sent to the user; may be null
	Timeout     int32                   `json:"timeout"`      // Timeout before the code can be re-sent, in seconds
}

// MessageType return the string telegram-type of AuthenticationCodeInfo
func (authenticationCodeInfo *AuthenticationCodeInfo) MessageType() string {
	return "authenticationCodeInfo"
}

// NewAuthenticationCodeInfo creates a new AuthenticationCodeInfo
//
// @param phoneNumber A phone number that is being authenticated
// @param typeParam The way the code was sent to the user
// @param nextType The way the next code will be sent to the user; may be null
// @param timeout Timeout before the code can be re-sent, in seconds
func NewAuthenticationCodeInfo(phoneNumber string, typeParam AuthenticationCodeType, nextType *AuthenticationCodeType, timeout int32) *AuthenticationCodeInfo {
	authenticationCodeInfoTemp := AuthenticationCodeInfo{
		tdCommon:    tdCommon{Type: "authenticationCodeInfo"},
		PhoneNumber: phoneNumber,
		Type:        typeParam,
		NextType:    nextType,
		Timeout:     timeout,
	}

	return &authenticationCodeInfoTemp
}

// UnmarshalJSON unmarshal to json
func (authenticationCodeInfo *AuthenticationCodeInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PhoneNumber string `json:"phone_number"` // A phone number that is being authenticated
		Timeout     int32  `json:"timeout"`      // Timeout before the code can be re-sent, in seconds
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authenticationCodeInfo.tdCommon = tempObj.tdCommon
	authenticationCodeInfo.PhoneNumber = tempObj.PhoneNumber
	authenticationCodeInfo.Timeout = tempObj.Timeout

	fieldType, _ := unmarshalAuthenticationCodeType(objMap["type"])
	authenticationCodeInfo.Type = fieldType

	fieldNextType, _ := unmarshalAuthenticationCodeType(objMap["next_type"])
	authenticationCodeInfo.NextType = &fieldNextType

	return nil
}

// EmailAddressAuthenticationCodeInfo Information about the email address authentication code that was sent
type EmailAddressAuthenticationCodeInfo struct {
	tdCommon
	EmailAddressPattern string `json:"email_address_pattern"` // Pattern of the email address to which an authentication code was sent
	Length              int32  `json:"length"`                // Length of the code; 0 if unknown
}

// MessageType return the string telegram-type of EmailAddressAuthenticationCodeInfo
func (emailAddressAuthenticationCodeInfo *EmailAddressAuthenticationCodeInfo) MessageType() string {
	return "emailAddressAuthenticationCodeInfo"
}

// NewEmailAddressAuthenticationCodeInfo creates a new EmailAddressAuthenticationCodeInfo
//
// @param emailAddressPattern Pattern of the email address to which an authentication code was sent
// @param length Length of the code; 0 if unknown
func NewEmailAddressAuthenticationCodeInfo(emailAddressPattern string, length int32) *EmailAddressAuthenticationCodeInfo {
	emailAddressAuthenticationCodeInfoTemp := EmailAddressAuthenticationCodeInfo{
		tdCommon:            tdCommon{Type: "emailAddressAuthenticationCodeInfo"},
		EmailAddressPattern: emailAddressPattern,
		Length:              length,
	}

	return &emailAddressAuthenticationCodeInfoTemp
}

// UnmarshalJSON unmarshal to json
func (emailAddressAuthenticationCodeInfo *EmailAddressAuthenticationCodeInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		EmailAddressPattern string `json:"email_address_pattern"` // Pattern of the email address to which an authentication code was sent
		Length              int32  `json:"length"`                // Length of the code; 0 if unknown
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	emailAddressAuthenticationCodeInfo.tdCommon = tempObj.tdCommon
	emailAddressAuthenticationCodeInfo.EmailAddressPattern = tempObj.EmailAddressPattern
	emailAddressAuthenticationCodeInfo.Length = tempObj.Length

	return nil
}

// EmailAddressAuthenticationCode An authentication code delivered to a user's email address
type EmailAddressAuthenticationCode struct {
	tdCommon
	Code string `json:"code"` // The code
}

// MessageType return the string telegram-type of EmailAddressAuthenticationCode
func (emailAddressAuthenticationCode *EmailAddressAuthenticationCode) MessageType() string {
	return "emailAddressAuthenticationCode"
}

// NewEmailAddressAuthenticationCode creates a new EmailAddressAuthenticationCode
//
// @param code The code
func NewEmailAddressAuthenticationCode(code string) *EmailAddressAuthenticationCode {
	emailAddressAuthenticationCodeTemp := EmailAddressAuthenticationCode{
		tdCommon: tdCommon{Type: "emailAddressAuthenticationCode"},
		Code:     code,
	}

	return &emailAddressAuthenticationCodeTemp
}

// UnmarshalJSON unmarshal to json
func (emailAddressAuthenticationCode *EmailAddressAuthenticationCode) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Code string `json:"code"` // The code
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	emailAddressAuthenticationCode.tdCommon = tempObj.tdCommon
	emailAddressAuthenticationCode.Code = tempObj.Code

	return nil
}

// GetEmailAddressAuthenticationEnum return the enum type of this object
func (emailAddressAuthenticationCode *EmailAddressAuthenticationCode) GetEmailAddressAuthenticationEnum() EmailAddressAuthenticationEnum {
	return EmailAddressAuthenticationCodeType
}

// EmailAddressAuthenticationAppleID An authentication token received through Apple ID
type EmailAddressAuthenticationAppleID struct {
	tdCommon
	Token string `json:"token"` // The token
}

// MessageType return the string telegram-type of EmailAddressAuthenticationAppleID
func (emailAddressAuthenticationAppleID *EmailAddressAuthenticationAppleID) MessageType() string {
	return "emailAddressAuthenticationAppleId"
}

// NewEmailAddressAuthenticationAppleID creates a new EmailAddressAuthenticationAppleID
//
// @param token The token
func NewEmailAddressAuthenticationAppleID(token string) *EmailAddressAuthenticationAppleID {
	emailAddressAuthenticationAppleIDTemp := EmailAddressAuthenticationAppleID{
		tdCommon: tdCommon{Type: "emailAddressAuthenticationAppleId"},
		Token:    token,
	}

	return &emailAddressAuthenticationAppleIDTemp
}

// UnmarshalJSON unmarshal to json
func (emailAddressAuthenticationAppleID *EmailAddressAuthenticationAppleID) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Token string `json:"token"` // The token
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	emailAddressAuthenticationAppleID.tdCommon = tempObj.tdCommon
	emailAddressAuthenticationAppleID.Token = tempObj.Token

	return nil
}

// GetEmailAddressAuthenticationEnum return the enum type of this object
func (emailAddressAuthenticationAppleID *EmailAddressAuthenticationAppleID) GetEmailAddressAuthenticationEnum() EmailAddressAuthenticationEnum {
	return EmailAddressAuthenticationAppleIDType
}

// EmailAddressAuthenticationGoogleID An authentication token received through Google ID
type EmailAddressAuthenticationGoogleID struct {
	tdCommon
	Token string `json:"token"` // The token
}

// MessageType return the string telegram-type of EmailAddressAuthenticationGoogleID
func (emailAddressAuthenticationGoogleID *EmailAddressAuthenticationGoogleID) MessageType() string {
	return "emailAddressAuthenticationGoogleId"
}

// NewEmailAddressAuthenticationGoogleID creates a new EmailAddressAuthenticationGoogleID
//
// @param token The token
func NewEmailAddressAuthenticationGoogleID(token string) *EmailAddressAuthenticationGoogleID {
	emailAddressAuthenticationGoogleIDTemp := EmailAddressAuthenticationGoogleID{
		tdCommon: tdCommon{Type: "emailAddressAuthenticationGoogleId"},
		Token:    token,
	}

	return &emailAddressAuthenticationGoogleIDTemp
}

// UnmarshalJSON unmarshal to json
func (emailAddressAuthenticationGoogleID *EmailAddressAuthenticationGoogleID) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Token string `json:"token"` // The token
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	emailAddressAuthenticationGoogleID.tdCommon = tempObj.tdCommon
	emailAddressAuthenticationGoogleID.Token = tempObj.Token

	return nil
}

// GetEmailAddressAuthenticationEnum return the enum type of this object
func (emailAddressAuthenticationGoogleID *EmailAddressAuthenticationGoogleID) GetEmailAddressAuthenticationEnum() EmailAddressAuthenticationEnum {
	return EmailAddressAuthenticationGoogleIDType
}

// EmailAddressResetStateAvailable Email address can be reset after the given period. Call resetAuthenticationEmailAddress to reset it and allow the user to authorize with a code sent to the user's phone number
type EmailAddressResetStateAvailable struct {
	tdCommon
	WaitPeriod int32 `json:"wait_period"` // Time required to wait before the email address can be reset; 0 if the user is subscribed to Telegram Premium
}

// MessageType return the string telegram-type of EmailAddressResetStateAvailable
func (emailAddressResetStateAvailable *EmailAddressResetStateAvailable) MessageType() string {
	return "emailAddressResetStateAvailable"
}

// NewEmailAddressResetStateAvailable creates a new EmailAddressResetStateAvailable
//
// @param waitPeriod Time required to wait before the email address can be reset; 0 if the user is subscribed to Telegram Premium
func NewEmailAddressResetStateAvailable(waitPeriod int32) *EmailAddressResetStateAvailable {
	emailAddressResetStateAvailableTemp := EmailAddressResetStateAvailable{
		tdCommon:   tdCommon{Type: "emailAddressResetStateAvailable"},
		WaitPeriod: waitPeriod,
	}

	return &emailAddressResetStateAvailableTemp
}

// UnmarshalJSON unmarshal to json
func (emailAddressResetStateAvailable *EmailAddressResetStateAvailable) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		WaitPeriod int32 `json:"wait_period"` // Time required to wait before the email address can be reset; 0 if the user is subscribed to Telegram Premium
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	emailAddressResetStateAvailable.tdCommon = tempObj.tdCommon
	emailAddressResetStateAvailable.WaitPeriod = tempObj.WaitPeriod

	return nil
}

// GetEmailAddressResetStateEnum return the enum type of this object
func (emailAddressResetStateAvailable *EmailAddressResetStateAvailable) GetEmailAddressResetStateEnum() EmailAddressResetStateEnum {
	return EmailAddressResetStateAvailableType
}

// EmailAddressResetStatePending Email address reset has already been requested. Call resetAuthenticationEmailAddress to check whether immediate reset is possible
type EmailAddressResetStatePending struct {
	tdCommon
	ResetIn int32 `json:"reset_in"` // Left time before the email address will be reset, in seconds. updateAuthorizationState is not sent when this field changes
}

// MessageType return the string telegram-type of EmailAddressResetStatePending
func (emailAddressResetStatePending *EmailAddressResetStatePending) MessageType() string {
	return "emailAddressResetStatePending"
}

// NewEmailAddressResetStatePending creates a new EmailAddressResetStatePending
//
// @param resetIn Left time before the email address will be reset, in seconds. updateAuthorizationState is not sent when this field changes
func NewEmailAddressResetStatePending(resetIn int32) *EmailAddressResetStatePending {
	emailAddressResetStatePendingTemp := EmailAddressResetStatePending{
		tdCommon: tdCommon{Type: "emailAddressResetStatePending"},
		ResetIn:  resetIn,
	}

	return &emailAddressResetStatePendingTemp
}

// UnmarshalJSON unmarshal to json
func (emailAddressResetStatePending *EmailAddressResetStatePending) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ResetIn int32 `json:"reset_in"` // Left time before the email address will be reset, in seconds. updateAuthorizationState is not sent when this field changes
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	emailAddressResetStatePending.tdCommon = tempObj.tdCommon
	emailAddressResetStatePending.ResetIn = tempObj.ResetIn

	return nil
}

// GetEmailAddressResetStateEnum return the enum type of this object
func (emailAddressResetStatePending *EmailAddressResetStatePending) GetEmailAddressResetStateEnum() EmailAddressResetStateEnum {
	return EmailAddressResetStatePendingType
}

// TextEntity Represents a part of the text that needs to be formatted in some unusual way
type TextEntity struct {
	tdCommon
	Offset int32          `json:"offset"` // Offset of the entity, in UTF-16 code units
	Length int32          `json:"length"` // Length of the entity, in UTF-16 code units
	Type   TextEntityType `json:"type"`   // Type of the entity
}

// MessageType return the string telegram-type of TextEntity
func (textEntity *TextEntity) MessageType() string {
	return "textEntity"
}

// NewTextEntity creates a new TextEntity
//
// @param offset Offset of the entity, in UTF-16 code units
// @param length Length of the entity, in UTF-16 code units
// @param typeParam Type of the entity
func NewTextEntity(offset int32, length int32, typeParam TextEntityType) *TextEntity {
	textEntityTemp := TextEntity{
		tdCommon: tdCommon{Type: "textEntity"},
		Offset:   offset,
		Length:   length,
		Type:     typeParam,
	}

	return &textEntityTemp
}

// UnmarshalJSON unmarshal to json
func (textEntity *TextEntity) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Offset int32 `json:"offset"` // Offset of the entity, in UTF-16 code units
		Length int32 `json:"length"` // Length of the entity, in UTF-16 code units

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntity.tdCommon = tempObj.tdCommon
	textEntity.Offset = tempObj.Offset
	textEntity.Length = tempObj.Length

	fieldType, _ := unmarshalTextEntityType(objMap["type"])
	textEntity.Type = fieldType

	return nil
}

// TextEntities Contains a list of text entities
type TextEntities struct {
	tdCommon
	Entities []TextEntity `json:"entities"` // List of text entities
}

// MessageType return the string telegram-type of TextEntities
func (textEntities *TextEntities) MessageType() string {
	return "textEntities"
}

// NewTextEntities creates a new TextEntities
//
// @param entities List of text entities
func NewTextEntities(entities []TextEntity) *TextEntities {
	textEntitiesTemp := TextEntities{
		tdCommon: tdCommon{Type: "textEntities"},
		Entities: entities,
	}

	return &textEntitiesTemp
}

// UnmarshalJSON unmarshal to json
func (textEntities *TextEntities) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Entities []TextEntity `json:"entities"` // List of text entities
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntities.tdCommon = tempObj.tdCommon
	textEntities.Entities = tempObj.Entities

	return nil
}

// FormattedText A text with some entities
type FormattedText struct {
	tdCommon
	Text     string       `json:"text"`     // The text
	Entities []TextEntity `json:"entities"` // Entities contained in the text. Entities can be nested, but must not mutually intersect with each other. Pre, Code and PreCode entities can't contain other entities. BlockQuote entities can't contain other BlockQuote entities. Bold, Italic, Underline, Strikethrough, and Spoiler entities can contain and can be part of any other entities. All other entities can't contain each other
}

// MessageType return the string telegram-type of FormattedText
func (formattedText *FormattedText) MessageType() string {
	return "formattedText"
}

// NewFormattedText creates a new FormattedText
//
// @param text The text
// @param entities Entities contained in the text. Entities can be nested, but must not mutually intersect with each other. Pre, Code and PreCode entities can't contain other entities. BlockQuote entities can't contain other BlockQuote entities. Bold, Italic, Underline, Strikethrough, and Spoiler entities can contain and can be part of any other entities. All other entities can't contain each other
func NewFormattedText(text string, entities []TextEntity) *FormattedText {
	formattedTextTemp := FormattedText{
		tdCommon: tdCommon{Type: "formattedText"},
		Text:     text,
		Entities: entities,
	}

	return &formattedTextTemp
}

// UnmarshalJSON unmarshal to json
func (formattedText *FormattedText) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Text     string       `json:"text"`     // The text
		Entities []TextEntity `json:"entities"` // Entities contained in the text. Entities can be nested, but must not mutually intersect with each other. Pre, Code and PreCode entities can't contain other entities. BlockQuote entities can't contain other BlockQuote entities. Bold, Italic, Underline, Strikethrough, and Spoiler entities can contain and can be part of any other entities. All other entities can't contain each other
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	formattedText.tdCommon = tempObj.tdCommon
	formattedText.Text = tempObj.Text
	formattedText.Entities = tempObj.Entities

	return nil
}

// TermsOfService Contains Telegram terms of service
type TermsOfService struct {
	tdCommon
	Text       *FormattedText `json:"text"`         // Text of the terms of service
	MinUserAge int32          `json:"min_user_age"` // The minimum age of a user to be able to accept the terms; 0 if age isn't restricted
	ShowPopup  bool           `json:"show_popup"`   // True, if a blocking popup with terms of service must be shown to the user
}

// MessageType return the string telegram-type of TermsOfService
func (termsOfService *TermsOfService) MessageType() string {
	return "termsOfService"
}

// NewTermsOfService creates a new TermsOfService
//
// @param text Text of the terms of service
// @param minUserAge The minimum age of a user to be able to accept the terms; 0 if age isn't restricted
// @param showPopup True, if a blocking popup with terms of service must be shown to the user
func NewTermsOfService(text *FormattedText, minUserAge int32, showPopup bool) *TermsOfService {
	termsOfServiceTemp := TermsOfService{
		tdCommon:   tdCommon{Type: "termsOfService"},
		Text:       text,
		MinUserAge: minUserAge,
		ShowPopup:  showPopup,
	}

	return &termsOfServiceTemp
}

// UnmarshalJSON unmarshal to json
func (termsOfService *TermsOfService) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Text       *FormattedText `json:"text"`         // Text of the terms of service
		MinUserAge int32          `json:"min_user_age"` // The minimum age of a user to be able to accept the terms; 0 if age isn't restricted
		ShowPopup  bool           `json:"show_popup"`   // True, if a blocking popup with terms of service must be shown to the user
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	termsOfService.tdCommon = tempObj.tdCommon
	termsOfService.Text = tempObj.Text
	termsOfService.MinUserAge = tempObj.MinUserAge
	termsOfService.ShowPopup = tempObj.ShowPopup

	return nil
}

// AuthorizationStateWaitTdlibParameters Initialization parameters are needed. Call setTdlibParameters to provide them
type AuthorizationStateWaitTdlibParameters struct {
	tdCommon
}

// MessageType return the string telegram-type of AuthorizationStateWaitTdlibParameters
func (authorizationStateWaitTdlibParameters *AuthorizationStateWaitTdlibParameters) MessageType() string {
	return "authorizationStateWaitTdlibParameters"
}

// NewAuthorizationStateWaitTdlibParameters creates a new AuthorizationStateWaitTdlibParameters
//
func NewAuthorizationStateWaitTdlibParameters() *AuthorizationStateWaitTdlibParameters {
	authorizationStateWaitTdlibParametersTemp := AuthorizationStateWaitTdlibParameters{
		tdCommon: tdCommon{Type: "authorizationStateWaitTdlibParameters"},
	}

	return &authorizationStateWaitTdlibParametersTemp
}

// UnmarshalJSON unmarshal to json
func (authorizationStateWaitTdlibParameters *AuthorizationStateWaitTdlibParameters) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authorizationStateWaitTdlibParameters.tdCommon = tempObj.tdCommon

	return nil
}

// GetAuthorizationStateEnum return the enum type of this object
func (authorizationStateWaitTdlibParameters *AuthorizationStateWaitTdlibParameters) GetAuthorizationStateEnum() AuthorizationStateEnum {
	return AuthorizationStateWaitTdlibParametersType
}

// AuthorizationStateWaitPhoneNumber TDLib needs the user's phone number to authorize. Call setAuthenticationPhoneNumber to provide the phone number, or use requestQrCodeAuthentication or checkAuthenticationBotToken for other authentication options
type AuthorizationStateWaitPhoneNumber struct {
	tdCommon
}

// MessageType return the string telegram-type of AuthorizationStateWaitPhoneNumber
func (authorizationStateWaitPhoneNumber *AuthorizationStateWaitPhoneNumber) MessageType() string {
	return "authorizationStateWaitPhoneNumber"
}

// NewAuthorizationStateWaitPhoneNumber creates a new AuthorizationStateWaitPhoneNumber
//
func NewAuthorizationStateWaitPhoneNumber() *AuthorizationStateWaitPhoneNumber {
	authorizationStateWaitPhoneNumberTemp := AuthorizationStateWaitPhoneNumber{
		tdCommon: tdCommon{Type: "authorizationStateWaitPhoneNumber"},
	}

	return &authorizationStateWaitPhoneNumberTemp
}

// UnmarshalJSON unmarshal to json
func (authorizationStateWaitPhoneNumber *AuthorizationStateWaitPhoneNumber) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authorizationStateWaitPhoneNumber.tdCommon = tempObj.tdCommon

	return nil
}

// GetAuthorizationStateEnum return the enum type of this object
func (authorizationStateWaitPhoneNumber *AuthorizationStateWaitPhoneNumber) GetAuthorizationStateEnum() AuthorizationStateEnum {
	return AuthorizationStateWaitPhoneNumberType
}

// AuthorizationStateWaitEmailAddress TDLib needs the user's email address to authorize. Call setAuthenticationEmailAddress to provide the email address, or directly call checkAuthenticationEmailCode with Apple ID/Google ID token if allowed
type AuthorizationStateWaitEmailAddress struct {
	tdCommon
	AllowAppleID  bool `json:"allow_apple_id"`  // True, if authorization through Apple ID is allowed
	AllowGoogleID bool `json:"allow_google_id"` // True, if authorization through Google ID is allowed
}

// MessageType return the string telegram-type of AuthorizationStateWaitEmailAddress
func (authorizationStateWaitEmailAddress *AuthorizationStateWaitEmailAddress) MessageType() string {
	return "authorizationStateWaitEmailAddress"
}

// NewAuthorizationStateWaitEmailAddress creates a new AuthorizationStateWaitEmailAddress
//
// @param allowAppleID True, if authorization through Apple ID is allowed
// @param allowGoogleID True, if authorization through Google ID is allowed
func NewAuthorizationStateWaitEmailAddress(allowAppleID bool, allowGoogleID bool) *AuthorizationStateWaitEmailAddress {
	authorizationStateWaitEmailAddressTemp := AuthorizationStateWaitEmailAddress{
		tdCommon:      tdCommon{Type: "authorizationStateWaitEmailAddress"},
		AllowAppleID:  allowAppleID,
		AllowGoogleID: allowGoogleID,
	}

	return &authorizationStateWaitEmailAddressTemp
}

// UnmarshalJSON unmarshal to json
func (authorizationStateWaitEmailAddress *AuthorizationStateWaitEmailAddress) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		AllowAppleID  bool `json:"allow_apple_id"`  // True, if authorization through Apple ID is allowed
		AllowGoogleID bool `json:"allow_google_id"` // True, if authorization through Google ID is allowed
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authorizationStateWaitEmailAddress.tdCommon = tempObj.tdCommon
	authorizationStateWaitEmailAddress.AllowAppleID = tempObj.AllowAppleID
	authorizationStateWaitEmailAddress.AllowGoogleID = tempObj.AllowGoogleID

	return nil
}

// GetAuthorizationStateEnum return the enum type of this object
func (authorizationStateWaitEmailAddress *AuthorizationStateWaitEmailAddress) GetAuthorizationStateEnum() AuthorizationStateEnum {
	return AuthorizationStateWaitEmailAddressType
}

// AuthorizationStateWaitEmailCode TDLib needs the user's authentication code sent to an email address to authorize. Call checkAuthenticationEmailCode to provide the code
type AuthorizationStateWaitEmailCode struct {
	tdCommon
	AllowAppleID           bool                                `json:"allow_apple_id"`            // True, if authorization through Apple ID is allowed
	AllowGoogleID          bool                                `json:"allow_google_id"`           // True, if authorization through Google ID is allowed
	CodeInfo               *EmailAddressAuthenticationCodeInfo `json:"code_info"`                 // Information about the sent authentication code
	EmailAddressResetState *EmailAddressResetState             `json:"email_address_reset_state"` // Reset state of the email address; may be null if the email address can't be reset
}

// MessageType return the string telegram-type of AuthorizationStateWaitEmailCode
func (authorizationStateWaitEmailCode *AuthorizationStateWaitEmailCode) MessageType() string {
	return "authorizationStateWaitEmailCode"
}

// NewAuthorizationStateWaitEmailCode creates a new AuthorizationStateWaitEmailCode
//
// @param allowAppleID True, if authorization through Apple ID is allowed
// @param allowGoogleID True, if authorization through Google ID is allowed
// @param codeInfo Information about the sent authentication code
// @param emailAddressResetState Reset state of the email address; may be null if the email address can't be reset
func NewAuthorizationStateWaitEmailCode(allowAppleID bool, allowGoogleID bool, codeInfo *EmailAddressAuthenticationCodeInfo, emailAddressResetState *EmailAddressResetState) *AuthorizationStateWaitEmailCode {
	authorizationStateWaitEmailCodeTemp := AuthorizationStateWaitEmailCode{
		tdCommon:               tdCommon{Type: "authorizationStateWaitEmailCode"},
		AllowAppleID:           allowAppleID,
		AllowGoogleID:          allowGoogleID,
		CodeInfo:               codeInfo,
		EmailAddressResetState: emailAddressResetState,
	}

	return &authorizationStateWaitEmailCodeTemp
}

// UnmarshalJSON unmarshal to json
func (authorizationStateWaitEmailCode *AuthorizationStateWaitEmailCode) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		AllowAppleID  bool                                `json:"allow_apple_id"`  // True, if authorization through Apple ID is allowed
		AllowGoogleID bool                                `json:"allow_google_id"` // True, if authorization through Google ID is allowed
		CodeInfo      *EmailAddressAuthenticationCodeInfo `json:"code_info"`       // Information about the sent authentication code

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authorizationStateWaitEmailCode.tdCommon = tempObj.tdCommon
	authorizationStateWaitEmailCode.AllowAppleID = tempObj.AllowAppleID
	authorizationStateWaitEmailCode.AllowGoogleID = tempObj.AllowGoogleID
	authorizationStateWaitEmailCode.CodeInfo = tempObj.CodeInfo

	fieldEmailAddressResetState, _ := unmarshalEmailAddressResetState(objMap["email_address_reset_state"])
	authorizationStateWaitEmailCode.EmailAddressResetState = &fieldEmailAddressResetState

	return nil
}

// GetAuthorizationStateEnum return the enum type of this object
func (authorizationStateWaitEmailCode *AuthorizationStateWaitEmailCode) GetAuthorizationStateEnum() AuthorizationStateEnum {
	return AuthorizationStateWaitEmailCodeType
}

// AuthorizationStateWaitCode TDLib needs the user's authentication code to authorize. Call checkAuthenticationCode to check the code
type AuthorizationStateWaitCode struct {
	tdCommon
	CodeInfo *AuthenticationCodeInfo `json:"code_info"` // Information about the authorization code that was sent
}

// MessageType return the string telegram-type of AuthorizationStateWaitCode
func (authorizationStateWaitCode *AuthorizationStateWaitCode) MessageType() string {
	return "authorizationStateWaitCode"
}

// NewAuthorizationStateWaitCode creates a new AuthorizationStateWaitCode
//
// @param codeInfo Information about the authorization code that was sent
func NewAuthorizationStateWaitCode(codeInfo *AuthenticationCodeInfo) *AuthorizationStateWaitCode {
	authorizationStateWaitCodeTemp := AuthorizationStateWaitCode{
		tdCommon: tdCommon{Type: "authorizationStateWaitCode"},
		CodeInfo: codeInfo,
	}

	return &authorizationStateWaitCodeTemp
}

// UnmarshalJSON unmarshal to json
func (authorizationStateWaitCode *AuthorizationStateWaitCode) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authorizationStateWaitCode.tdCommon = tempObj.tdCommon

	var codeInfo AuthenticationCodeInfo
	if objMap["code_info"] != nil {
		err = codeInfo.UnmarshalJSON(*objMap["code_info"])
		if err != nil {
			return err
		}
	}

	authorizationStateWaitCode.CodeInfo = &codeInfo

	return nil
}

// GetAuthorizationStateEnum return the enum type of this object
func (authorizationStateWaitCode *AuthorizationStateWaitCode) GetAuthorizationStateEnum() AuthorizationStateEnum {
	return AuthorizationStateWaitCodeType
}

// AuthorizationStateWaitOtherDeviceConfirmation The user needs to confirm authorization on another logged in device by scanning a QR code with the provided link
type AuthorizationStateWaitOtherDeviceConfirmation struct {
	tdCommon
	Link string `json:"link"` // A tg:// URL for the QR code. The link will be updated frequently
}

// MessageType return the string telegram-type of AuthorizationStateWaitOtherDeviceConfirmation
func (authorizationStateWaitOtherDeviceConfirmation *AuthorizationStateWaitOtherDeviceConfirmation) MessageType() string {
	return "authorizationStateWaitOtherDeviceConfirmation"
}

// NewAuthorizationStateWaitOtherDeviceConfirmation creates a new AuthorizationStateWaitOtherDeviceConfirmation
//
// @param link A tg:// URL for the QR code. The link will be updated frequently
func NewAuthorizationStateWaitOtherDeviceConfirmation(link string) *AuthorizationStateWaitOtherDeviceConfirmation {
	authorizationStateWaitOtherDeviceConfirmationTemp := AuthorizationStateWaitOtherDeviceConfirmation{
		tdCommon: tdCommon{Type: "authorizationStateWaitOtherDeviceConfirmation"},
		Link:     link,
	}

	return &authorizationStateWaitOtherDeviceConfirmationTemp
}

// UnmarshalJSON unmarshal to json
func (authorizationStateWaitOtherDeviceConfirmation *AuthorizationStateWaitOtherDeviceConfirmation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Link string `json:"link"` // A tg:// URL for the QR code. The link will be updated frequently
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authorizationStateWaitOtherDeviceConfirmation.tdCommon = tempObj.tdCommon
	authorizationStateWaitOtherDeviceConfirmation.Link = tempObj.Link

	return nil
}

// GetAuthorizationStateEnum return the enum type of this object
func (authorizationStateWaitOtherDeviceConfirmation *AuthorizationStateWaitOtherDeviceConfirmation) GetAuthorizationStateEnum() AuthorizationStateEnum {
	return AuthorizationStateWaitOtherDeviceConfirmationType
}

// AuthorizationStateWaitRegistration The user is unregistered and need to accept terms of service and enter their first name and last name to finish registration. Call registerUser to accept the terms of service and provide the data
type AuthorizationStateWaitRegistration struct {
	tdCommon
	TermsOfService *TermsOfService `json:"terms_of_service"` // Telegram terms of service
}

// MessageType return the string telegram-type of AuthorizationStateWaitRegistration
func (authorizationStateWaitRegistration *AuthorizationStateWaitRegistration) MessageType() string {
	return "authorizationStateWaitRegistration"
}

// NewAuthorizationStateWaitRegistration creates a new AuthorizationStateWaitRegistration
//
// @param termsOfService Telegram terms of service
func NewAuthorizationStateWaitRegistration(termsOfService *TermsOfService) *AuthorizationStateWaitRegistration {
	authorizationStateWaitRegistrationTemp := AuthorizationStateWaitRegistration{
		tdCommon:       tdCommon{Type: "authorizationStateWaitRegistration"},
		TermsOfService: termsOfService,
	}

	return &authorizationStateWaitRegistrationTemp
}

// UnmarshalJSON unmarshal to json
func (authorizationStateWaitRegistration *AuthorizationStateWaitRegistration) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TermsOfService *TermsOfService `json:"terms_of_service"` // Telegram terms of service
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authorizationStateWaitRegistration.tdCommon = tempObj.tdCommon
	authorizationStateWaitRegistration.TermsOfService = tempObj.TermsOfService

	return nil
}

// GetAuthorizationStateEnum return the enum type of this object
func (authorizationStateWaitRegistration *AuthorizationStateWaitRegistration) GetAuthorizationStateEnum() AuthorizationStateEnum {
	return AuthorizationStateWaitRegistrationType
}

// AuthorizationStateWaitPassword The user has been authorized, but needs to enter a 2-step verification password to start using the application. Call checkAuthenticationPassword to provide the password, or requestAuthenticationPasswordRecovery to recover the password, or deleteAccount to delete the account after a week
type AuthorizationStateWaitPassword struct {
	tdCommon
	PasswordHint                string `json:"password_hint"`                  // Hint for the password; may be empty
	HasRecoveryEmailAddress     bool   `json:"has_recovery_email_address"`     // True, if a recovery email address has been set up
	HasPassportData             bool   `json:"has_passport_data"`              // True, if some Telegram Passport elements were saved
	RecoveryEmailAddressPattern string `json:"recovery_email_address_pattern"` // Pattern of the email address to which the recovery email was sent; empty until a recovery email has been sent
}

// MessageType return the string telegram-type of AuthorizationStateWaitPassword
func (authorizationStateWaitPassword *AuthorizationStateWaitPassword) MessageType() string {
	return "authorizationStateWaitPassword"
}

// NewAuthorizationStateWaitPassword creates a new AuthorizationStateWaitPassword
//
// @param passwordHint Hint for the password; may be empty
// @param hasRecoveryEmailAddress True, if a recovery email address has been set up
// @param hasPassportData True, if some Telegram Passport elements were saved
// @param recoveryEmailAddressPattern Pattern of the email address to which the recovery email was sent; empty until a recovery email has been sent
func NewAuthorizationStateWaitPassword(passwordHint string, hasRecoveryEmailAddress bool, hasPassportData bool, recoveryEmailAddressPattern string) *AuthorizationStateWaitPassword {
	authorizationStateWaitPasswordTemp := AuthorizationStateWaitPassword{
		tdCommon:                    tdCommon{Type: "authorizationStateWaitPassword"},
		PasswordHint:                passwordHint,
		HasRecoveryEmailAddress:     hasRecoveryEmailAddress,
		HasPassportData:             hasPassportData,
		RecoveryEmailAddressPattern: recoveryEmailAddressPattern,
	}

	return &authorizationStateWaitPasswordTemp
}

// UnmarshalJSON unmarshal to json
func (authorizationStateWaitPassword *AuthorizationStateWaitPassword) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PasswordHint                string `json:"password_hint"`                  // Hint for the password; may be empty
		HasRecoveryEmailAddress     bool   `json:"has_recovery_email_address"`     // True, if a recovery email address has been set up
		HasPassportData             bool   `json:"has_passport_data"`              // True, if some Telegram Passport elements were saved
		RecoveryEmailAddressPattern string `json:"recovery_email_address_pattern"` // Pattern of the email address to which the recovery email was sent; empty until a recovery email has been sent
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authorizationStateWaitPassword.tdCommon = tempObj.tdCommon
	authorizationStateWaitPassword.PasswordHint = tempObj.PasswordHint
	authorizationStateWaitPassword.HasRecoveryEmailAddress = tempObj.HasRecoveryEmailAddress
	authorizationStateWaitPassword.HasPassportData = tempObj.HasPassportData
	authorizationStateWaitPassword.RecoveryEmailAddressPattern = tempObj.RecoveryEmailAddressPattern

	return nil
}

// GetAuthorizationStateEnum return the enum type of this object
func (authorizationStateWaitPassword *AuthorizationStateWaitPassword) GetAuthorizationStateEnum() AuthorizationStateEnum {
	return AuthorizationStateWaitPasswordType
}

// AuthorizationStateReady The user has been successfully authorized. TDLib is now ready to answer general requests
type AuthorizationStateReady struct {
	tdCommon
}

// MessageType return the string telegram-type of AuthorizationStateReady
func (authorizationStateReady *AuthorizationStateReady) MessageType() string {
	return "authorizationStateReady"
}

// NewAuthorizationStateReady creates a new AuthorizationStateReady
//
func NewAuthorizationStateReady() *AuthorizationStateReady {
	authorizationStateReadyTemp := AuthorizationStateReady{
		tdCommon: tdCommon{Type: "authorizationStateReady"},
	}

	return &authorizationStateReadyTemp
}

// UnmarshalJSON unmarshal to json
func (authorizationStateReady *AuthorizationStateReady) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authorizationStateReady.tdCommon = tempObj.tdCommon

	return nil
}

// GetAuthorizationStateEnum return the enum type of this object
func (authorizationStateReady *AuthorizationStateReady) GetAuthorizationStateEnum() AuthorizationStateEnum {
	return AuthorizationStateReadyType
}

// AuthorizationStateLoggingOut The user is currently logging out
type AuthorizationStateLoggingOut struct {
	tdCommon
}

// MessageType return the string telegram-type of AuthorizationStateLoggingOut
func (authorizationStateLoggingOut *AuthorizationStateLoggingOut) MessageType() string {
	return "authorizationStateLoggingOut"
}

// NewAuthorizationStateLoggingOut creates a new AuthorizationStateLoggingOut
//
func NewAuthorizationStateLoggingOut() *AuthorizationStateLoggingOut {
	authorizationStateLoggingOutTemp := AuthorizationStateLoggingOut{
		tdCommon: tdCommon{Type: "authorizationStateLoggingOut"},
	}

	return &authorizationStateLoggingOutTemp
}

// UnmarshalJSON unmarshal to json
func (authorizationStateLoggingOut *AuthorizationStateLoggingOut) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authorizationStateLoggingOut.tdCommon = tempObj.tdCommon

	return nil
}

// GetAuthorizationStateEnum return the enum type of this object
func (authorizationStateLoggingOut *AuthorizationStateLoggingOut) GetAuthorizationStateEnum() AuthorizationStateEnum {
	return AuthorizationStateLoggingOutType
}

// AuthorizationStateClosing TDLib is closing, all subsequent queries will be answered with the error 500. Note that closing TDLib can take a while. All resources will be freed only after authorizationStateClosed has been received
type AuthorizationStateClosing struct {
	tdCommon
}

// MessageType return the string telegram-type of AuthorizationStateClosing
func (authorizationStateClosing *AuthorizationStateClosing) MessageType() string {
	return "authorizationStateClosing"
}

// NewAuthorizationStateClosing creates a new AuthorizationStateClosing
//
func NewAuthorizationStateClosing() *AuthorizationStateClosing {
	authorizationStateClosingTemp := AuthorizationStateClosing{
		tdCommon: tdCommon{Type: "authorizationStateClosing"},
	}

	return &authorizationStateClosingTemp
}

// UnmarshalJSON unmarshal to json
func (authorizationStateClosing *AuthorizationStateClosing) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authorizationStateClosing.tdCommon = tempObj.tdCommon

	return nil
}

// GetAuthorizationStateEnum return the enum type of this object
func (authorizationStateClosing *AuthorizationStateClosing) GetAuthorizationStateEnum() AuthorizationStateEnum {
	return AuthorizationStateClosingType
}

// AuthorizationStateClosed TDLib client is in its final state. All databases are closed and all resources are released. No other updates will be received after this. All queries will be responded to with error code 500. To continue working, one must create a new instance of the TDLib client
type AuthorizationStateClosed struct {
	tdCommon
}

// MessageType return the string telegram-type of AuthorizationStateClosed
func (authorizationStateClosed *AuthorizationStateClosed) MessageType() string {
	return "authorizationStateClosed"
}

// NewAuthorizationStateClosed creates a new AuthorizationStateClosed
//
func NewAuthorizationStateClosed() *AuthorizationStateClosed {
	authorizationStateClosedTemp := AuthorizationStateClosed{
		tdCommon: tdCommon{Type: "authorizationStateClosed"},
	}

	return &authorizationStateClosedTemp
}

// UnmarshalJSON unmarshal to json
func (authorizationStateClosed *AuthorizationStateClosed) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	authorizationStateClosed.tdCommon = tempObj.tdCommon

	return nil
}

// GetAuthorizationStateEnum return the enum type of this object
func (authorizationStateClosed *AuthorizationStateClosed) GetAuthorizationStateEnum() AuthorizationStateEnum {
	return AuthorizationStateClosedType
}

// FirebaseDeviceVerificationParametersSafetyNet Device verification must be performed with the SafetyNet Attestation API
type FirebaseDeviceVerificationParametersSafetyNet struct {
	tdCommon
	Nonce []byte `json:"nonce"` // Nonce to pass to the SafetyNet Attestation API
}

// MessageType return the string telegram-type of FirebaseDeviceVerificationParametersSafetyNet
func (firebaseDeviceVerificationParametersSafetyNet *FirebaseDeviceVerificationParametersSafetyNet) MessageType() string {
	return "firebaseDeviceVerificationParametersSafetyNet"
}

// NewFirebaseDeviceVerificationParametersSafetyNet creates a new FirebaseDeviceVerificationParametersSafetyNet
//
// @param nonce Nonce to pass to the SafetyNet Attestation API
func NewFirebaseDeviceVerificationParametersSafetyNet(nonce []byte) *FirebaseDeviceVerificationParametersSafetyNet {
	firebaseDeviceVerificationParametersSafetyNetTemp := FirebaseDeviceVerificationParametersSafetyNet{
		tdCommon: tdCommon{Type: "firebaseDeviceVerificationParametersSafetyNet"},
		Nonce:    nonce,
	}

	return &firebaseDeviceVerificationParametersSafetyNetTemp
}

// UnmarshalJSON unmarshal to json
func (firebaseDeviceVerificationParametersSafetyNet *FirebaseDeviceVerificationParametersSafetyNet) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Nonce []byte `json:"nonce"` // Nonce to pass to the SafetyNet Attestation API
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	firebaseDeviceVerificationParametersSafetyNet.tdCommon = tempObj.tdCommon
	firebaseDeviceVerificationParametersSafetyNet.Nonce = tempObj.Nonce

	return nil
}

// GetFirebaseDeviceVerificationParametersEnum return the enum type of this object
func (firebaseDeviceVerificationParametersSafetyNet *FirebaseDeviceVerificationParametersSafetyNet) GetFirebaseDeviceVerificationParametersEnum() FirebaseDeviceVerificationParametersEnum {
	return FirebaseDeviceVerificationParametersSafetyNetType
}

// FirebaseDeviceVerificationParametersPlayIntegrity Device verification must be performed with the classic Play Integrity verification (https://developer.android.com/google/play/integrity/classic)
type FirebaseDeviceVerificationParametersPlayIntegrity struct {
	tdCommon
	Nonce              string    `json:"nonce"`                // Base64url-encoded nonce to pass to the Play Integrity API
	CloudProjectNumber JSONInt64 `json:"cloud_project_number"` // Cloud project number to pass to the Play Integrity API
}

// MessageType return the string telegram-type of FirebaseDeviceVerificationParametersPlayIntegrity
func (firebaseDeviceVerificationParametersPlayIntegrity *FirebaseDeviceVerificationParametersPlayIntegrity) MessageType() string {
	return "firebaseDeviceVerificationParametersPlayIntegrity"
}

// NewFirebaseDeviceVerificationParametersPlayIntegrity creates a new FirebaseDeviceVerificationParametersPlayIntegrity
//
// @param nonce Base64url-encoded nonce to pass to the Play Integrity API
// @param cloudProjectNumber Cloud project number to pass to the Play Integrity API
func NewFirebaseDeviceVerificationParametersPlayIntegrity(nonce string, cloudProjectNumber JSONInt64) *FirebaseDeviceVerificationParametersPlayIntegrity {
	firebaseDeviceVerificationParametersPlayIntegrityTemp := FirebaseDeviceVerificationParametersPlayIntegrity{
		tdCommon:           tdCommon{Type: "firebaseDeviceVerificationParametersPlayIntegrity"},
		Nonce:              nonce,
		CloudProjectNumber: cloudProjectNumber,
	}

	return &firebaseDeviceVerificationParametersPlayIntegrityTemp
}

// UnmarshalJSON unmarshal to json
func (firebaseDeviceVerificationParametersPlayIntegrity *FirebaseDeviceVerificationParametersPlayIntegrity) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Nonce              string    `json:"nonce"`                // Base64url-encoded nonce to pass to the Play Integrity API
		CloudProjectNumber JSONInt64 `json:"cloud_project_number"` // Cloud project number to pass to the Play Integrity API
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	firebaseDeviceVerificationParametersPlayIntegrity.tdCommon = tempObj.tdCommon
	firebaseDeviceVerificationParametersPlayIntegrity.Nonce = tempObj.Nonce
	firebaseDeviceVerificationParametersPlayIntegrity.CloudProjectNumber = tempObj.CloudProjectNumber

	return nil
}

// GetFirebaseDeviceVerificationParametersEnum return the enum type of this object
func (firebaseDeviceVerificationParametersPlayIntegrity *FirebaseDeviceVerificationParametersPlayIntegrity) GetFirebaseDeviceVerificationParametersEnum() FirebaseDeviceVerificationParametersEnum {
	return FirebaseDeviceVerificationParametersPlayIntegrityType
}

// PasswordState Represents the current state of 2-step verification
type PasswordState struct {
	tdCommon
	HasPassword                  bool                                `json:"has_password"`                     // True, if a 2-step verification password is set
	PasswordHint                 string                              `json:"password_hint"`                    // Hint for the password; may be empty
	HasRecoveryEmailAddress      bool                                `json:"has_recovery_email_address"`       // True, if a recovery email is set
	HasPassportData              bool                                `json:"has_passport_data"`                // True, if some Telegram Passport elements were saved
	RecoveryEmailAddressCodeInfo *EmailAddressAuthenticationCodeInfo `json:"recovery_email_address_code_info"` // Information about the recovery email address to which the confirmation email was sent; may be null
	LoginEmailAddressPattern     string                              `json:"login_email_address_pattern"`      // Pattern of the email address set up for logging in
	PendingResetDate             int32                               `json:"pending_reset_date"`               // If not 0, point in time (Unix timestamp) after which the 2-step verification password can be reset immediately using resetPassword
}

// MessageType return the string telegram-type of PasswordState
func (passwordState *PasswordState) MessageType() string {
	return "passwordState"
}

// NewPasswordState creates a new PasswordState
//
// @param hasPassword True, if a 2-step verification password is set
// @param passwordHint Hint for the password; may be empty
// @param hasRecoveryEmailAddress True, if a recovery email is set
// @param hasPassportData True, if some Telegram Passport elements were saved
// @param recoveryEmailAddressCodeInfo Information about the recovery email address to which the confirmation email was sent; may be null
// @param loginEmailAddressPattern Pattern of the email address set up for logging in
// @param pendingResetDate If not 0, point in time (Unix timestamp) after which the 2-step verification password can be reset immediately using resetPassword
func NewPasswordState(hasPassword bool, passwordHint string, hasRecoveryEmailAddress bool, hasPassportData bool, recoveryEmailAddressCodeInfo *EmailAddressAuthenticationCodeInfo, loginEmailAddressPattern string, pendingResetDate int32) *PasswordState {
	passwordStateTemp := PasswordState{
		tdCommon:                     tdCommon{Type: "passwordState"},
		HasPassword:                  hasPassword,
		PasswordHint:                 passwordHint,
		HasRecoveryEmailAddress:      hasRecoveryEmailAddress,
		HasPassportData:              hasPassportData,
		RecoveryEmailAddressCodeInfo: recoveryEmailAddressCodeInfo,
		LoginEmailAddressPattern:     loginEmailAddressPattern,
		PendingResetDate:             pendingResetDate,
	}

	return &passwordStateTemp
}

// UnmarshalJSON unmarshal to json
func (passwordState *PasswordState) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		HasPassword                  bool                                `json:"has_password"`                     // True, if a 2-step verification password is set
		PasswordHint                 string                              `json:"password_hint"`                    // Hint for the password; may be empty
		HasRecoveryEmailAddress      bool                                `json:"has_recovery_email_address"`       // True, if a recovery email is set
		HasPassportData              bool                                `json:"has_passport_data"`                // True, if some Telegram Passport elements were saved
		RecoveryEmailAddressCodeInfo *EmailAddressAuthenticationCodeInfo `json:"recovery_email_address_code_info"` // Information about the recovery email address to which the confirmation email was sent; may be null
		LoginEmailAddressPattern     string                              `json:"login_email_address_pattern"`      // Pattern of the email address set up for logging in
		PendingResetDate             int32                               `json:"pending_reset_date"`               // If not 0, point in time (Unix timestamp) after which the 2-step verification password can be reset immediately using resetPassword
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passwordState.tdCommon = tempObj.tdCommon
	passwordState.HasPassword = tempObj.HasPassword
	passwordState.PasswordHint = tempObj.PasswordHint
	passwordState.HasRecoveryEmailAddress = tempObj.HasRecoveryEmailAddress
	passwordState.HasPassportData = tempObj.HasPassportData
	passwordState.RecoveryEmailAddressCodeInfo = tempObj.RecoveryEmailAddressCodeInfo
	passwordState.LoginEmailAddressPattern = tempObj.LoginEmailAddressPattern
	passwordState.PendingResetDate = tempObj.PendingResetDate

	return nil
}

// RecoveryEmailAddress Contains information about the current recovery email address
type RecoveryEmailAddress struct {
	tdCommon
	RecoveryEmailAddress string `json:"recovery_email_address"` // Recovery email address
}

// MessageType return the string telegram-type of RecoveryEmailAddress
func (recoveryEmailAddress *RecoveryEmailAddress) MessageType() string {
	return "recoveryEmailAddress"
}

// NewRecoveryEmailAddress creates a new RecoveryEmailAddress
//
// @param recoveryEmailAddress Recovery email address
func NewRecoveryEmailAddress(recoveryEmailAddress string) *RecoveryEmailAddress {
	recoveryEmailAddressTemp := RecoveryEmailAddress{
		tdCommon:             tdCommon{Type: "recoveryEmailAddress"},
		RecoveryEmailAddress: recoveryEmailAddress,
	}

	return &recoveryEmailAddressTemp
}

// UnmarshalJSON unmarshal to json
func (recoveryEmailAddress *RecoveryEmailAddress) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		RecoveryEmailAddress string `json:"recovery_email_address"` // Recovery email address
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	recoveryEmailAddress.tdCommon = tempObj.tdCommon
	recoveryEmailAddress.RecoveryEmailAddress = tempObj.RecoveryEmailAddress

	return nil
}

// TemporaryPasswordState Returns information about the availability of a temporary password, which can be used for payments
type TemporaryPasswordState struct {
	tdCommon
	HasPassword bool  `json:"has_password"` // True, if a temporary password is available
	ValidFor    int32 `json:"valid_for"`    // Time left before the temporary password expires, in seconds
}

// MessageType return the string telegram-type of TemporaryPasswordState
func (temporaryPasswordState *TemporaryPasswordState) MessageType() string {
	return "temporaryPasswordState"
}

// NewTemporaryPasswordState creates a new TemporaryPasswordState
//
// @param hasPassword True, if a temporary password is available
// @param validFor Time left before the temporary password expires, in seconds
func NewTemporaryPasswordState(hasPassword bool, validFor int32) *TemporaryPasswordState {
	temporaryPasswordStateTemp := TemporaryPasswordState{
		tdCommon:    tdCommon{Type: "temporaryPasswordState"},
		HasPassword: hasPassword,
		ValidFor:    validFor,
	}

	return &temporaryPasswordStateTemp
}

// UnmarshalJSON unmarshal to json
func (temporaryPasswordState *TemporaryPasswordState) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		HasPassword bool  `json:"has_password"` // True, if a temporary password is available
		ValidFor    int32 `json:"valid_for"`    // Time left before the temporary password expires, in seconds
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	temporaryPasswordState.tdCommon = tempObj.tdCommon
	temporaryPasswordState.HasPassword = tempObj.HasPassword
	temporaryPasswordState.ValidFor = tempObj.ValidFor

	return nil
}

// LocalFile Represents a local file
type LocalFile struct {
	tdCommon
	Path                   string `json:"path"`                     // Local path to the locally available file part; may be empty
	CanBeDownloaded        bool   `json:"can_be_downloaded"`        // True, if it is possible to download or generate the file
	CanBeDeleted           bool   `json:"can_be_deleted"`           // True, if the file can be deleted
	IsDownloadingActive    bool   `json:"is_downloading_active"`    // True, if the file is currently being downloaded (or a local copy is being generated by some other means)
	IsDownloadingCompleted bool   `json:"is_downloading_completed"` // True, if the local copy is fully available
	DownloadOffset         int64  `json:"download_offset"`          // Download will be started from this offset. downloaded_prefix_size is calculated from this offset
	DownloadedPrefixSize   int64  `json:"downloaded_prefix_size"`   // If is_downloading_completed is false, then only some prefix of the file starting from download_offset is ready to be read. downloaded_prefix_size is the size of that prefix in bytes
	DownloadedSize         int64  `json:"downloaded_size"`          // Total downloaded file size, in bytes. Can be used only for calculating download progress. The actual file size may be bigger, and some parts of it may contain garbage
}

// MessageType return the string telegram-type of LocalFile
func (localFile *LocalFile) MessageType() string {
	return "localFile"
}

// NewLocalFile creates a new LocalFile
//
// @param path Local path to the locally available file part; may be empty
// @param canBeDownloaded True, if it is possible to download or generate the file
// @param canBeDeleted True, if the file can be deleted
// @param isDownloadingActive True, if the file is currently being downloaded (or a local copy is being generated by some other means)
// @param isDownloadingCompleted True, if the local copy is fully available
// @param downloadOffset Download will be started from this offset. downloaded_prefix_size is calculated from this offset
// @param downloadedPrefixSize If is_downloading_completed is false, then only some prefix of the file starting from download_offset is ready to be read. downloaded_prefix_size is the size of that prefix in bytes
// @param downloadedSize Total downloaded file size, in bytes. Can be used only for calculating download progress. The actual file size may be bigger, and some parts of it may contain garbage
func NewLocalFile(path string, canBeDownloaded bool, canBeDeleted bool, isDownloadingActive bool, isDownloadingCompleted bool, downloadOffset int64, downloadedPrefixSize int64, downloadedSize int64) *LocalFile {
	localFileTemp := LocalFile{
		tdCommon:               tdCommon{Type: "localFile"},
		Path:                   path,
		CanBeDownloaded:        canBeDownloaded,
		CanBeDeleted:           canBeDeleted,
		IsDownloadingActive:    isDownloadingActive,
		IsDownloadingCompleted: isDownloadingCompleted,
		DownloadOffset:         downloadOffset,
		DownloadedPrefixSize:   downloadedPrefixSize,
		DownloadedSize:         downloadedSize,
	}

	return &localFileTemp
}

// UnmarshalJSON unmarshal to json
func (localFile *LocalFile) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Path                   string `json:"path"`                     // Local path to the locally available file part; may be empty
		CanBeDownloaded        bool   `json:"can_be_downloaded"`        // True, if it is possible to download or generate the file
		CanBeDeleted           bool   `json:"can_be_deleted"`           // True, if the file can be deleted
		IsDownloadingActive    bool   `json:"is_downloading_active"`    // True, if the file is currently being downloaded (or a local copy is being generated by some other means)
		IsDownloadingCompleted bool   `json:"is_downloading_completed"` // True, if the local copy is fully available
		DownloadOffset         int64  `json:"download_offset"`          // Download will be started from this offset. downloaded_prefix_size is calculated from this offset
		DownloadedPrefixSize   int64  `json:"downloaded_prefix_size"`   // If is_downloading_completed is false, then only some prefix of the file starting from download_offset is ready to be read. downloaded_prefix_size is the size of that prefix in bytes
		DownloadedSize         int64  `json:"downloaded_size"`          // Total downloaded file size, in bytes. Can be used only for calculating download progress. The actual file size may be bigger, and some parts of it may contain garbage
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	localFile.tdCommon = tempObj.tdCommon
	localFile.Path = tempObj.Path
	localFile.CanBeDownloaded = tempObj.CanBeDownloaded
	localFile.CanBeDeleted = tempObj.CanBeDeleted
	localFile.IsDownloadingActive = tempObj.IsDownloadingActive
	localFile.IsDownloadingCompleted = tempObj.IsDownloadingCompleted
	localFile.DownloadOffset = tempObj.DownloadOffset
	localFile.DownloadedPrefixSize = tempObj.DownloadedPrefixSize
	localFile.DownloadedSize = tempObj.DownloadedSize

	return nil
}

// RemoteFile Represents a remote file
type RemoteFile struct {
	tdCommon
	ID                   string `json:"id"`                     // Remote file identifier; may be empty. Can be used by the current user across application restarts or even from other devices. Uniquely identifies a file, but a file can have a lot of different valid identifiers. If the identifier starts with "http://" or "https://", it represents the HTTP URL of the file. TDLib is currently unable to download files if only their URL is known. If downloadFile/addFileToDownloads is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the application with the HTTP URL in the original_path and "#url#" as the conversion string. Application must generate the file by downloading it to the specified location
	UniqueID             string `json:"unique_id"`              // Unique file identifier; may be empty if unknown. The unique file identifier which is the same for the same file even for different users and is persistent over time
	IsUploadingActive    bool   `json:"is_uploading_active"`    // True, if the file is currently being uploaded (or a remote copy is being generated by some other means)
	IsUploadingCompleted bool   `json:"is_uploading_completed"` // True, if a remote copy is fully available
	UploadedSize         int64  `json:"uploaded_size"`          // Size of the remote available part of the file, in bytes; 0 if unknown
}

// MessageType return the string telegram-type of RemoteFile
func (remoteFile *RemoteFile) MessageType() string {
	return "remoteFile"
}

// NewRemoteFile creates a new RemoteFile
//
// @param iD Remote file identifier; may be empty. Can be used by the current user across application restarts or even from other devices. Uniquely identifies a file, but a file can have a lot of different valid identifiers. If the identifier starts with "http://" or "https://", it represents the HTTP URL of the file. TDLib is currently unable to download files if only their URL is known. If downloadFile/addFileToDownloads is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the application with the HTTP URL in the original_path and "#url#" as the conversion string. Application must generate the file by downloading it to the specified location
// @param uniqueID Unique file identifier; may be empty if unknown. The unique file identifier which is the same for the same file even for different users and is persistent over time
// @param isUploadingActive True, if the file is currently being uploaded (or a remote copy is being generated by some other means)
// @param isUploadingCompleted True, if a remote copy is fully available
// @param uploadedSize Size of the remote available part of the file, in bytes; 0 if unknown
func NewRemoteFile(iD string, uniqueID string, isUploadingActive bool, isUploadingCompleted bool, uploadedSize int64) *RemoteFile {
	remoteFileTemp := RemoteFile{
		tdCommon:             tdCommon{Type: "remoteFile"},
		ID:                   iD,
		UniqueID:             uniqueID,
		IsUploadingActive:    isUploadingActive,
		IsUploadingCompleted: isUploadingCompleted,
		UploadedSize:         uploadedSize,
	}

	return &remoteFileTemp
}

// UnmarshalJSON unmarshal to json
func (remoteFile *RemoteFile) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID                   string `json:"id"`                     // Remote file identifier; may be empty. Can be used by the current user across application restarts or even from other devices. Uniquely identifies a file, but a file can have a lot of different valid identifiers. If the identifier starts with "http://" or "https://", it represents the HTTP URL of the file. TDLib is currently unable to download files if only their URL is known. If downloadFile/addFileToDownloads is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the application with the HTTP URL in the original_path and "#url#" as the conversion string. Application must generate the file by downloading it to the specified location
		UniqueID             string `json:"unique_id"`              // Unique file identifier; may be empty if unknown. The unique file identifier which is the same for the same file even for different users and is persistent over time
		IsUploadingActive    bool   `json:"is_uploading_active"`    // True, if the file is currently being uploaded (or a remote copy is being generated by some other means)
		IsUploadingCompleted bool   `json:"is_uploading_completed"` // True, if a remote copy is fully available
		UploadedSize         int64  `json:"uploaded_size"`          // Size of the remote available part of the file, in bytes; 0 if unknown
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	remoteFile.tdCommon = tempObj.tdCommon
	remoteFile.ID = tempObj.ID
	remoteFile.UniqueID = tempObj.UniqueID
	remoteFile.IsUploadingActive = tempObj.IsUploadingActive
	remoteFile.IsUploadingCompleted = tempObj.IsUploadingCompleted
	remoteFile.UploadedSize = tempObj.UploadedSize

	return nil
}

// File Represents a file
type File struct {
	tdCommon
	ID           int32       `json:"id"`            // Unique file identifier
	Size         int64       `json:"size"`          // File size, in bytes; 0 if unknown
	ExpectedSize int64       `json:"expected_size"` // Approximate file size in bytes in case the exact file size is unknown. Can be used to show download/upload progress
	Local        *LocalFile  `json:"local"`         // Information about the local copy of the file
	Remote       *RemoteFile `json:"remote"`        // Information about the remote copy of the file
}

// MessageType return the string telegram-type of File
func (file *File) MessageType() string {
	return "file"
}

// NewFile creates a new File
//
// @param iD Unique file identifier
// @param size File size, in bytes; 0 if unknown
// @param expectedSize Approximate file size in bytes in case the exact file size is unknown. Can be used to show download/upload progress
// @param local Information about the local copy of the file
// @param remote Information about the remote copy of the file
func NewFile(iD int32, size int64, expectedSize int64, local *LocalFile, remote *RemoteFile) *File {
	fileTemp := File{
		tdCommon:     tdCommon{Type: "file"},
		ID:           iD,
		Size:         size,
		ExpectedSize: expectedSize,
		Local:        local,
		Remote:       remote,
	}

	return &fileTemp
}

// UnmarshalJSON unmarshal to json
func (file *File) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID           int32       `json:"id"`            // Unique file identifier
		Size         int64       `json:"size"`          // File size, in bytes; 0 if unknown
		ExpectedSize int64       `json:"expected_size"` // Approximate file size in bytes in case the exact file size is unknown. Can be used to show download/upload progress
		Local        *LocalFile  `json:"local"`         // Information about the local copy of the file
		Remote       *RemoteFile `json:"remote"`        // Information about the remote copy of the file
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	file.tdCommon = tempObj.tdCommon
	file.ID = tempObj.ID
	file.Size = tempObj.Size
	file.ExpectedSize = tempObj.ExpectedSize
	file.Local = tempObj.Local
	file.Remote = tempObj.Remote

	return nil
}

// InputFileID A file defined by its unique identifier
type InputFileID struct {
	tdCommon
	ID int32 `json:"id"` // Unique file identifier
}

// MessageType return the string telegram-type of InputFileID
func (inputFileID *InputFileID) MessageType() string {
	return "inputFileId"
}

// NewInputFileID creates a new InputFileID
//
// @param iD Unique file identifier
func NewInputFileID(iD int32) *InputFileID {
	inputFileIDTemp := InputFileID{
		tdCommon: tdCommon{Type: "inputFileId"},
		ID:       iD,
	}

	return &inputFileIDTemp
}

// UnmarshalJSON unmarshal to json
func (inputFileID *InputFileID) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID int32 `json:"id"` // Unique file identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputFileID.tdCommon = tempObj.tdCommon
	inputFileID.ID = tempObj.ID

	return nil
}

// GetInputFileEnum return the enum type of this object
func (inputFileID *InputFileID) GetInputFileEnum() InputFileEnum {
	return InputFileIDType
}

// InputFileRemote A file defined by its remote identifier. The remote identifier is guaranteed to be usable only if the corresponding file is still accessible to the user and known to TDLib. For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application
type InputFileRemote struct {
	tdCommon
	ID string `json:"id"` // Remote file identifier
}

// MessageType return the string telegram-type of InputFileRemote
func (inputFileRemote *InputFileRemote) MessageType() string {
	return "inputFileRemote"
}

// NewInputFileRemote creates a new InputFileRemote
//
// @param iD Remote file identifier
func NewInputFileRemote(iD string) *InputFileRemote {
	inputFileRemoteTemp := InputFileRemote{
		tdCommon: tdCommon{Type: "inputFileRemote"},
		ID:       iD,
	}

	return &inputFileRemoteTemp
}

// UnmarshalJSON unmarshal to json
func (inputFileRemote *InputFileRemote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID string `json:"id"` // Remote file identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputFileRemote.tdCommon = tempObj.tdCommon
	inputFileRemote.ID = tempObj.ID

	return nil
}

// GetInputFileEnum return the enum type of this object
func (inputFileRemote *InputFileRemote) GetInputFileEnum() InputFileEnum {
	return InputFileRemoteType
}

// InputFileLocal A file defined by a local path
type InputFileLocal struct {
	tdCommon
	Path string `json:"path"` // Local path to the file
}

// MessageType return the string telegram-type of InputFileLocal
func (inputFileLocal *InputFileLocal) MessageType() string {
	return "inputFileLocal"
}

// NewInputFileLocal creates a new InputFileLocal
//
// @param path Local path to the file
func NewInputFileLocal(path string) *InputFileLocal {
	inputFileLocalTemp := InputFileLocal{
		tdCommon: tdCommon{Type: "inputFileLocal"},
		Path:     path,
	}

	return &inputFileLocalTemp
}

// UnmarshalJSON unmarshal to json
func (inputFileLocal *InputFileLocal) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Path string `json:"path"` // Local path to the file
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputFileLocal.tdCommon = tempObj.tdCommon
	inputFileLocal.Path = tempObj.Path

	return nil
}

// GetInputFileEnum return the enum type of this object
func (inputFileLocal *InputFileLocal) GetInputFileEnum() InputFileEnum {
	return InputFileLocalType
}

// InputFileGenerated A file generated by the application
type InputFileGenerated struct {
	tdCommon
	OriginalPath string `json:"original_path"` // Local path to a file from which the file is generated; may be empty if there is no such file
	Conversion   string `json:"conversion"`    // String specifying the conversion applied to the original file; must be persistent across application restarts. Conversions beginning with '#' are reserved for internal TDLib usage
	ExpectedSize int64  `json:"expected_size"` // Expected size of the generated file, in bytes; 0 if unknown
}

// MessageType return the string telegram-type of InputFileGenerated
func (inputFileGenerated *InputFileGenerated) MessageType() string {
	return "inputFileGenerated"
}

// NewInputFileGenerated creates a new InputFileGenerated
//
// @param originalPath Local path to a file from which the file is generated; may be empty if there is no such file
// @param conversion String specifying the conversion applied to the original file; must be persistent across application restarts. Conversions beginning with '#' are reserved for internal TDLib usage
// @param expectedSize Expected size of the generated file, in bytes; 0 if unknown
func NewInputFileGenerated(originalPath string, conversion string, expectedSize int64) *InputFileGenerated {
	inputFileGeneratedTemp := InputFileGenerated{
		tdCommon:     tdCommon{Type: "inputFileGenerated"},
		OriginalPath: originalPath,
		Conversion:   conversion,
		ExpectedSize: expectedSize,
	}

	return &inputFileGeneratedTemp
}

// UnmarshalJSON unmarshal to json
func (inputFileGenerated *InputFileGenerated) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OriginalPath string `json:"original_path"` // Local path to a file from which the file is generated; may be empty if there is no such file
		Conversion   string `json:"conversion"`    // String specifying the conversion applied to the original file; must be persistent across application restarts. Conversions beginning with '#' are reserved for internal TDLib usage
		ExpectedSize int64  `json:"expected_size"` // Expected size of the generated file, in bytes; 0 if unknown
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputFileGenerated.tdCommon = tempObj.tdCommon
	inputFileGenerated.OriginalPath = tempObj.OriginalPath
	inputFileGenerated.Conversion = tempObj.Conversion
	inputFileGenerated.ExpectedSize = tempObj.ExpectedSize

	return nil
}

// GetInputFileEnum return the enum type of this object
func (inputFileGenerated *InputFileGenerated) GetInputFileEnum() InputFileEnum {
	return InputFileGeneratedType
}

// PhotoSize Describes an image in JPEG format
type PhotoSize struct {
	tdCommon
	Type             string  `json:"type"`              // Image type (see https://core.telegram.org/constructor/photoSize)
	Photo            *File   `json:"photo"`             // Information about the image file
	Width            int32   `json:"width"`             // Image width
	Height           int32   `json:"height"`            // Image height
	ProgressiveSizes []int32 `json:"progressive_sizes"` // Sizes of progressive JPEG file prefixes, which can be used to preliminarily show the image; in bytes
}

// MessageType return the string telegram-type of PhotoSize
func (photoSize *PhotoSize) MessageType() string {
	return "photoSize"
}

// NewPhotoSize creates a new PhotoSize
//
// @param typeParam Image type (see https://core.telegram.org/constructor/photoSize)
// @param photo Information about the image file
// @param width Image width
// @param height Image height
// @param progressiveSizes Sizes of progressive JPEG file prefixes, which can be used to preliminarily show the image; in bytes
func NewPhotoSize(typeParam string, photo *File, width int32, height int32, progressiveSizes []int32) *PhotoSize {
	photoSizeTemp := PhotoSize{
		tdCommon:         tdCommon{Type: "photoSize"},
		Type:             typeParam,
		Photo:            photo,
		Width:            width,
		Height:           height,
		ProgressiveSizes: progressiveSizes,
	}

	return &photoSizeTemp
}

// UnmarshalJSON unmarshal to json
func (photoSize *PhotoSize) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Type             string  `json:"type"`              // Image type (see https://core.telegram.org/constructor/photoSize)
		Photo            *File   `json:"photo"`             // Information about the image file
		Width            int32   `json:"width"`             // Image width
		Height           int32   `json:"height"`            // Image height
		ProgressiveSizes []int32 `json:"progressive_sizes"` // Sizes of progressive JPEG file prefixes, which can be used to preliminarily show the image; in bytes
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	photoSize.tdCommon = tempObj.tdCommon
	photoSize.Type = tempObj.Type
	photoSize.Photo = tempObj.Photo
	photoSize.Width = tempObj.Width
	photoSize.Height = tempObj.Height
	photoSize.ProgressiveSizes = tempObj.ProgressiveSizes

	return nil
}

// Minithumbnail Thumbnail image of a very poor quality and low resolution
type Minithumbnail struct {
	tdCommon
	Width  int32  `json:"width"`  // Thumbnail width, usually doesn't exceed 40
	Height int32  `json:"height"` // Thumbnail height, usually doesn't exceed 40
	Data   []byte `json:"data"`   // The thumbnail in JPEG format
}

// MessageType return the string telegram-type of Minithumbnail
func (minithumbnail *Minithumbnail) MessageType() string {
	return "minithumbnail"
}

// NewMinithumbnail creates a new Minithumbnail
//
// @param width Thumbnail width, usually doesn't exceed 40
// @param height Thumbnail height, usually doesn't exceed 40
// @param data The thumbnail in JPEG format
func NewMinithumbnail(width int32, height int32, data []byte) *Minithumbnail {
	minithumbnailTemp := Minithumbnail{
		tdCommon: tdCommon{Type: "minithumbnail"},
		Width:    width,
		Height:   height,
		Data:     data,
	}

	return &minithumbnailTemp
}

// UnmarshalJSON unmarshal to json
func (minithumbnail *Minithumbnail) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Width  int32  `json:"width"`  // Thumbnail width, usually doesn't exceed 40
		Height int32  `json:"height"` // Thumbnail height, usually doesn't exceed 40
		Data   []byte `json:"data"`   // The thumbnail in JPEG format
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	minithumbnail.tdCommon = tempObj.tdCommon
	minithumbnail.Width = tempObj.Width
	minithumbnail.Height = tempObj.Height
	minithumbnail.Data = tempObj.Data

	return nil
}

// ThumbnailFormatJpeg The thumbnail is in JPEG format
type ThumbnailFormatJpeg struct {
	tdCommon
}

// MessageType return the string telegram-type of ThumbnailFormatJpeg
func (thumbnailFormatJpeg *ThumbnailFormatJpeg) MessageType() string {
	return "thumbnailFormatJpeg"
}

// NewThumbnailFormatJpeg creates a new ThumbnailFormatJpeg
//
func NewThumbnailFormatJpeg() *ThumbnailFormatJpeg {
	thumbnailFormatJpegTemp := ThumbnailFormatJpeg{
		tdCommon: tdCommon{Type: "thumbnailFormatJpeg"},
	}

	return &thumbnailFormatJpegTemp
}

// UnmarshalJSON unmarshal to json
func (thumbnailFormatJpeg *ThumbnailFormatJpeg) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	thumbnailFormatJpeg.tdCommon = tempObj.tdCommon

	return nil
}

// GetThumbnailFormatEnum return the enum type of this object
func (thumbnailFormatJpeg *ThumbnailFormatJpeg) GetThumbnailFormatEnum() ThumbnailFormatEnum {
	return ThumbnailFormatJpegType
}

// ThumbnailFormatGif The thumbnail is in static GIF format. It will be used only for some bot inline query results
type ThumbnailFormatGif struct {
	tdCommon
}

// MessageType return the string telegram-type of ThumbnailFormatGif
func (thumbnailFormatGif *ThumbnailFormatGif) MessageType() string {
	return "thumbnailFormatGif"
}

// NewThumbnailFormatGif creates a new ThumbnailFormatGif
//
func NewThumbnailFormatGif() *ThumbnailFormatGif {
	thumbnailFormatGifTemp := ThumbnailFormatGif{
		tdCommon: tdCommon{Type: "thumbnailFormatGif"},
	}

	return &thumbnailFormatGifTemp
}

// UnmarshalJSON unmarshal to json
func (thumbnailFormatGif *ThumbnailFormatGif) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	thumbnailFormatGif.tdCommon = tempObj.tdCommon

	return nil
}

// GetThumbnailFormatEnum return the enum type of this object
func (thumbnailFormatGif *ThumbnailFormatGif) GetThumbnailFormatEnum() ThumbnailFormatEnum {
	return ThumbnailFormatGifType
}

// ThumbnailFormatMpeg4 The thumbnail is in MPEG4 format. It will be used only for some animations and videos
type ThumbnailFormatMpeg4 struct {
	tdCommon
}

// MessageType return the string telegram-type of ThumbnailFormatMpeg4
func (thumbnailFormatMpeg4 *ThumbnailFormatMpeg4) MessageType() string {
	return "thumbnailFormatMpeg4"
}

// NewThumbnailFormatMpeg4 creates a new ThumbnailFormatMpeg4
//
func NewThumbnailFormatMpeg4() *ThumbnailFormatMpeg4 {
	thumbnailFormatMpeg4Temp := ThumbnailFormatMpeg4{
		tdCommon: tdCommon{Type: "thumbnailFormatMpeg4"},
	}

	return &thumbnailFormatMpeg4Temp
}

// UnmarshalJSON unmarshal to json
func (thumbnailFormatMpeg4 *ThumbnailFormatMpeg4) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	thumbnailFormatMpeg4.tdCommon = tempObj.tdCommon

	return nil
}

// GetThumbnailFormatEnum return the enum type of this object
func (thumbnailFormatMpeg4 *ThumbnailFormatMpeg4) GetThumbnailFormatEnum() ThumbnailFormatEnum {
	return ThumbnailFormatMpeg4Type
}

// ThumbnailFormatPng The thumbnail is in PNG format. It will be used only for background patterns
type ThumbnailFormatPng struct {
	tdCommon
}

// MessageType return the string telegram-type of ThumbnailFormatPng
func (thumbnailFormatPng *ThumbnailFormatPng) MessageType() string {
	return "thumbnailFormatPng"
}

// NewThumbnailFormatPng creates a new ThumbnailFormatPng
//
func NewThumbnailFormatPng() *ThumbnailFormatPng {
	thumbnailFormatPngTemp := ThumbnailFormatPng{
		tdCommon: tdCommon{Type: "thumbnailFormatPng"},
	}

	return &thumbnailFormatPngTemp
}

// UnmarshalJSON unmarshal to json
func (thumbnailFormatPng *ThumbnailFormatPng) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	thumbnailFormatPng.tdCommon = tempObj.tdCommon

	return nil
}

// GetThumbnailFormatEnum return the enum type of this object
func (thumbnailFormatPng *ThumbnailFormatPng) GetThumbnailFormatEnum() ThumbnailFormatEnum {
	return ThumbnailFormatPngType
}

// ThumbnailFormatTgs The thumbnail is in TGS format. It will be used only for sticker sets
type ThumbnailFormatTgs struct {
	tdCommon
}

// MessageType return the string telegram-type of ThumbnailFormatTgs
func (thumbnailFormatTgs *ThumbnailFormatTgs) MessageType() string {
	return "thumbnailFormatTgs"
}

// NewThumbnailFormatTgs creates a new ThumbnailFormatTgs
//
func NewThumbnailFormatTgs() *ThumbnailFormatTgs {
	thumbnailFormatTgsTemp := ThumbnailFormatTgs{
		tdCommon: tdCommon{Type: "thumbnailFormatTgs"},
	}

	return &thumbnailFormatTgsTemp
}

// UnmarshalJSON unmarshal to json
func (thumbnailFormatTgs *ThumbnailFormatTgs) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	thumbnailFormatTgs.tdCommon = tempObj.tdCommon

	return nil
}

// GetThumbnailFormatEnum return the enum type of this object
func (thumbnailFormatTgs *ThumbnailFormatTgs) GetThumbnailFormatEnum() ThumbnailFormatEnum {
	return ThumbnailFormatTgsType
}

// ThumbnailFormatWebm The thumbnail is in WEBM format. It will be used only for sticker sets
type ThumbnailFormatWebm struct {
	tdCommon
}

// MessageType return the string telegram-type of ThumbnailFormatWebm
func (thumbnailFormatWebm *ThumbnailFormatWebm) MessageType() string {
	return "thumbnailFormatWebm"
}

// NewThumbnailFormatWebm creates a new ThumbnailFormatWebm
//
func NewThumbnailFormatWebm() *ThumbnailFormatWebm {
	thumbnailFormatWebmTemp := ThumbnailFormatWebm{
		tdCommon: tdCommon{Type: "thumbnailFormatWebm"},
	}

	return &thumbnailFormatWebmTemp
}

// UnmarshalJSON unmarshal to json
func (thumbnailFormatWebm *ThumbnailFormatWebm) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	thumbnailFormatWebm.tdCommon = tempObj.tdCommon

	return nil
}

// GetThumbnailFormatEnum return the enum type of this object
func (thumbnailFormatWebm *ThumbnailFormatWebm) GetThumbnailFormatEnum() ThumbnailFormatEnum {
	return ThumbnailFormatWebmType
}

// ThumbnailFormatWebp The thumbnail is in WEBP format. It will be used only for some stickers and sticker sets
type ThumbnailFormatWebp struct {
	tdCommon
}

// MessageType return the string telegram-type of ThumbnailFormatWebp
func (thumbnailFormatWebp *ThumbnailFormatWebp) MessageType() string {
	return "thumbnailFormatWebp"
}

// NewThumbnailFormatWebp creates a new ThumbnailFormatWebp
//
func NewThumbnailFormatWebp() *ThumbnailFormatWebp {
	thumbnailFormatWebpTemp := ThumbnailFormatWebp{
		tdCommon: tdCommon{Type: "thumbnailFormatWebp"},
	}

	return &thumbnailFormatWebpTemp
}

// UnmarshalJSON unmarshal to json
func (thumbnailFormatWebp *ThumbnailFormatWebp) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	thumbnailFormatWebp.tdCommon = tempObj.tdCommon

	return nil
}

// GetThumbnailFormatEnum return the enum type of this object
func (thumbnailFormatWebp *ThumbnailFormatWebp) GetThumbnailFormatEnum() ThumbnailFormatEnum {
	return ThumbnailFormatWebpType
}

// Thumbnail Represents a thumbnail
type Thumbnail struct {
	tdCommon
	Format ThumbnailFormat `json:"format"` // Thumbnail format
	Width  int32           `json:"width"`  // Thumbnail width
	Height int32           `json:"height"` // Thumbnail height
	File   *File           `json:"file"`   // The thumbnail
}

// MessageType return the string telegram-type of Thumbnail
func (thumbnail *Thumbnail) MessageType() string {
	return "thumbnail"
}

// NewThumbnail creates a new Thumbnail
//
// @param format Thumbnail format
// @param width Thumbnail width
// @param height Thumbnail height
// @param file The thumbnail
func NewThumbnail(format ThumbnailFormat, width int32, height int32, file *File) *Thumbnail {
	thumbnailTemp := Thumbnail{
		tdCommon: tdCommon{Type: "thumbnail"},
		Format:   format,
		Width:    width,
		Height:   height,
		File:     file,
	}

	return &thumbnailTemp
}

// UnmarshalJSON unmarshal to json
func (thumbnail *Thumbnail) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Width  int32 `json:"width"`  // Thumbnail width
		Height int32 `json:"height"` // Thumbnail height
		File   *File `json:"file"`   // The thumbnail
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	thumbnail.tdCommon = tempObj.tdCommon
	thumbnail.Width = tempObj.Width
	thumbnail.Height = tempObj.Height
	thumbnail.File = tempObj.File

	fieldFormat, _ := unmarshalThumbnailFormat(objMap["format"])
	thumbnail.Format = fieldFormat

	return nil
}

// MaskPointForehead The mask is placed relatively to the forehead
type MaskPointForehead struct {
	tdCommon
}

// MessageType return the string telegram-type of MaskPointForehead
func (maskPointForehead *MaskPointForehead) MessageType() string {
	return "maskPointForehead"
}

// NewMaskPointForehead creates a new MaskPointForehead
//
func NewMaskPointForehead() *MaskPointForehead {
	maskPointForeheadTemp := MaskPointForehead{
		tdCommon: tdCommon{Type: "maskPointForehead"},
	}

	return &maskPointForeheadTemp
}

// UnmarshalJSON unmarshal to json
func (maskPointForehead *MaskPointForehead) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	maskPointForehead.tdCommon = tempObj.tdCommon

	return nil
}

// GetMaskPointEnum return the enum type of this object
func (maskPointForehead *MaskPointForehead) GetMaskPointEnum() MaskPointEnum {
	return MaskPointForeheadType
}

// MaskPointEyes The mask is placed relatively to the eyes
type MaskPointEyes struct {
	tdCommon
}

// MessageType return the string telegram-type of MaskPointEyes
func (maskPointEyes *MaskPointEyes) MessageType() string {
	return "maskPointEyes"
}

// NewMaskPointEyes creates a new MaskPointEyes
//
func NewMaskPointEyes() *MaskPointEyes {
	maskPointEyesTemp := MaskPointEyes{
		tdCommon: tdCommon{Type: "maskPointEyes"},
	}

	return &maskPointEyesTemp
}

// UnmarshalJSON unmarshal to json
func (maskPointEyes *MaskPointEyes) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	maskPointEyes.tdCommon = tempObj.tdCommon

	return nil
}

// GetMaskPointEnum return the enum type of this object
func (maskPointEyes *MaskPointEyes) GetMaskPointEnum() MaskPointEnum {
	return MaskPointEyesType
}

// MaskPointMouth The mask is placed relatively to the mouth
type MaskPointMouth struct {
	tdCommon
}

// MessageType return the string telegram-type of MaskPointMouth
func (maskPointMouth *MaskPointMouth) MessageType() string {
	return "maskPointMouth"
}

// NewMaskPointMouth creates a new MaskPointMouth
//
func NewMaskPointMouth() *MaskPointMouth {
	maskPointMouthTemp := MaskPointMouth{
		tdCommon: tdCommon{Type: "maskPointMouth"},
	}

	return &maskPointMouthTemp
}

// UnmarshalJSON unmarshal to json
func (maskPointMouth *MaskPointMouth) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	maskPointMouth.tdCommon = tempObj.tdCommon

	return nil
}

// GetMaskPointEnum return the enum type of this object
func (maskPointMouth *MaskPointMouth) GetMaskPointEnum() MaskPointEnum {
	return MaskPointMouthType
}

// MaskPointChin The mask is placed relatively to the chin
type MaskPointChin struct {
	tdCommon
}

// MessageType return the string telegram-type of MaskPointChin
func (maskPointChin *MaskPointChin) MessageType() string {
	return "maskPointChin"
}

// NewMaskPointChin creates a new MaskPointChin
//
func NewMaskPointChin() *MaskPointChin {
	maskPointChinTemp := MaskPointChin{
		tdCommon: tdCommon{Type: "maskPointChin"},
	}

	return &maskPointChinTemp
}

// UnmarshalJSON unmarshal to json
func (maskPointChin *MaskPointChin) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	maskPointChin.tdCommon = tempObj.tdCommon

	return nil
}

// GetMaskPointEnum return the enum type of this object
func (maskPointChin *MaskPointChin) GetMaskPointEnum() MaskPointEnum {
	return MaskPointChinType
}

// MaskPosition Position on a photo where a mask is placed
type MaskPosition struct {
	tdCommon
	Point  MaskPoint `json:"point"`   // Part of the face, relative to which the mask is placed
	XShift float64   `json:"x_shift"` // Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. (For example, -1.0 will place the mask just to the left of the default mask position)
	YShift float64   `json:"y_shift"` // Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. (For example, 1.0 will place the mask just below the default mask position)
	Scale  float64   `json:"scale"`   // Mask scaling coefficient. (For example, 2.0 means a doubled size)
}

// MessageType return the string telegram-type of MaskPosition
func (maskPosition *MaskPosition) MessageType() string {
	return "maskPosition"
}

// NewMaskPosition creates a new MaskPosition
//
// @param point Part of the face, relative to which the mask is placed
// @param xShift Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. (For example, -1.0 will place the mask just to the left of the default mask position)
// @param yShift Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. (For example, 1.0 will place the mask just below the default mask position)
// @param scale Mask scaling coefficient. (For example, 2.0 means a doubled size)
func NewMaskPosition(point MaskPoint, xShift float64, yShift float64, scale float64) *MaskPosition {
	maskPositionTemp := MaskPosition{
		tdCommon: tdCommon{Type: "maskPosition"},
		Point:    point,
		XShift:   xShift,
		YShift:   yShift,
		Scale:    scale,
	}

	return &maskPositionTemp
}

// UnmarshalJSON unmarshal to json
func (maskPosition *MaskPosition) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		XShift float64 `json:"x_shift"` // Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. (For example, -1.0 will place the mask just to the left of the default mask position)
		YShift float64 `json:"y_shift"` // Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. (For example, 1.0 will place the mask just below the default mask position)
		Scale  float64 `json:"scale"`   // Mask scaling coefficient. (For example, 2.0 means a doubled size)
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	maskPosition.tdCommon = tempObj.tdCommon
	maskPosition.XShift = tempObj.XShift
	maskPosition.YShift = tempObj.YShift
	maskPosition.Scale = tempObj.Scale

	fieldPoint, _ := unmarshalMaskPoint(objMap["point"])
	maskPosition.Point = fieldPoint

	return nil
}

// StickerFormatWebp The sticker is an image in WEBP format
type StickerFormatWebp struct {
	tdCommon
}

// MessageType return the string telegram-type of StickerFormatWebp
func (stickerFormatWebp *StickerFormatWebp) MessageType() string {
	return "stickerFormatWebp"
}

// NewStickerFormatWebp creates a new StickerFormatWebp
//
func NewStickerFormatWebp() *StickerFormatWebp {
	stickerFormatWebpTemp := StickerFormatWebp{
		tdCommon: tdCommon{Type: "stickerFormatWebp"},
	}

	return &stickerFormatWebpTemp
}

// UnmarshalJSON unmarshal to json
func (stickerFormatWebp *StickerFormatWebp) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	stickerFormatWebp.tdCommon = tempObj.tdCommon

	return nil
}

// GetStickerFormatEnum return the enum type of this object
func (stickerFormatWebp *StickerFormatWebp) GetStickerFormatEnum() StickerFormatEnum {
	return StickerFormatWebpType
}

// StickerFormatTgs The sticker is an animation in TGS format
type StickerFormatTgs struct {
	tdCommon
}

// MessageType return the string telegram-type of StickerFormatTgs
func (stickerFormatTgs *StickerFormatTgs) MessageType() string {
	return "stickerFormatTgs"
}

// NewStickerFormatTgs creates a new StickerFormatTgs
//
func NewStickerFormatTgs() *StickerFormatTgs {
	stickerFormatTgsTemp := StickerFormatTgs{
		tdCommon: tdCommon{Type: "stickerFormatTgs"},
	}

	return &stickerFormatTgsTemp
}

// UnmarshalJSON unmarshal to json
func (stickerFormatTgs *StickerFormatTgs) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	stickerFormatTgs.tdCommon = tempObj.tdCommon

	return nil
}

// GetStickerFormatEnum return the enum type of this object
func (stickerFormatTgs *StickerFormatTgs) GetStickerFormatEnum() StickerFormatEnum {
	return StickerFormatTgsType
}

// StickerFormatWebm The sticker is a video in WEBM format
type StickerFormatWebm struct {
	tdCommon
}

// MessageType return the string telegram-type of StickerFormatWebm
func (stickerFormatWebm *StickerFormatWebm) MessageType() string {
	return "stickerFormatWebm"
}

// NewStickerFormatWebm creates a new StickerFormatWebm
//
func NewStickerFormatWebm() *StickerFormatWebm {
	stickerFormatWebmTemp := StickerFormatWebm{
		tdCommon: tdCommon{Type: "stickerFormatWebm"},
	}

	return &stickerFormatWebmTemp
}

// UnmarshalJSON unmarshal to json
func (stickerFormatWebm *StickerFormatWebm) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	stickerFormatWebm.tdCommon = tempObj.tdCommon

	return nil
}

// GetStickerFormatEnum return the enum type of this object
func (stickerFormatWebm *StickerFormatWebm) GetStickerFormatEnum() StickerFormatEnum {
	return StickerFormatWebmType
}

// StickerTypeRegular The sticker is a regular sticker
type StickerTypeRegular struct {
	tdCommon
}

// MessageType return the string telegram-type of StickerTypeRegular
func (stickerTypeRegular *StickerTypeRegular) MessageType() string {
	return "stickerTypeRegular"
}

// NewStickerTypeRegular creates a new StickerTypeRegular
//
func NewStickerTypeRegular() *StickerTypeRegular {
	stickerTypeRegularTemp := StickerTypeRegular{
		tdCommon: tdCommon{Type: "stickerTypeRegular"},
	}

	return &stickerTypeRegularTemp
}

// UnmarshalJSON unmarshal to json
func (stickerTypeRegular *StickerTypeRegular) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	stickerTypeRegular.tdCommon = tempObj.tdCommon

	return nil
}

// GetStickerTypeEnum return the enum type of this object
func (stickerTypeRegular *StickerTypeRegular) GetStickerTypeEnum() StickerTypeEnum {
	return StickerTypeRegularType
}

// StickerTypeMask The sticker is a mask in WEBP format to be placed on photos or videos
type StickerTypeMask struct {
	tdCommon
}

// MessageType return the string telegram-type of StickerTypeMask
func (stickerTypeMask *StickerTypeMask) MessageType() string {
	return "stickerTypeMask"
}

// NewStickerTypeMask creates a new StickerTypeMask
//
func NewStickerTypeMask() *StickerTypeMask {
	stickerTypeMaskTemp := StickerTypeMask{
		tdCommon: tdCommon{Type: "stickerTypeMask"},
	}

	return &stickerTypeMaskTemp
}

// UnmarshalJSON unmarshal to json
func (stickerTypeMask *StickerTypeMask) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	stickerTypeMask.tdCommon = tempObj.tdCommon

	return nil
}

// GetStickerTypeEnum return the enum type of this object
func (stickerTypeMask *StickerTypeMask) GetStickerTypeEnum() StickerTypeEnum {
	return StickerTypeMaskType
}

// StickerTypeCustomEmoji The sticker is a custom emoji to be used inside message text and caption
type StickerTypeCustomEmoji struct {
	tdCommon
}

// MessageType return the string telegram-type of StickerTypeCustomEmoji
func (stickerTypeCustomEmoji *StickerTypeCustomEmoji) MessageType() string {
	return "stickerTypeCustomEmoji"
}

// NewStickerTypeCustomEmoji creates a new StickerTypeCustomEmoji
//
func NewStickerTypeCustomEmoji() *StickerTypeCustomEmoji {
	stickerTypeCustomEmojiTemp := StickerTypeCustomEmoji{
		tdCommon: tdCommon{Type: "stickerTypeCustomEmoji"},
	}

	return &stickerTypeCustomEmojiTemp
}

// UnmarshalJSON unmarshal to json
func (stickerTypeCustomEmoji *StickerTypeCustomEmoji) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	stickerTypeCustomEmoji.tdCommon = tempObj.tdCommon

	return nil
}

// GetStickerTypeEnum return the enum type of this object
func (stickerTypeCustomEmoji *StickerTypeCustomEmoji) GetStickerTypeEnum() StickerTypeEnum {
	return StickerTypeCustomEmojiType
}

// StickerFullTypeRegular The sticker is a regular sticker
type StickerFullTypeRegular struct {
	tdCommon
	PremiumAnimation *File `json:"premium_animation"` // Premium animation of the sticker; may be null. If present, only Telegram Premium users can use the sticker
}

// MessageType return the string telegram-type of StickerFullTypeRegular
func (stickerFullTypeRegular *StickerFullTypeRegular) MessageType() string {
	return "stickerFullTypeRegular"
}

// NewStickerFullTypeRegular creates a new StickerFullTypeRegular
//
// @param premiumAnimation Premium animation of the sticker; may be null. If present, only Telegram Premium users can use the sticker
func NewStickerFullTypeRegular(premiumAnimation *File) *StickerFullTypeRegular {
	stickerFullTypeRegularTemp := StickerFullTypeRegular{
		tdCommon:         tdCommon{Type: "stickerFullTypeRegular"},
		PremiumAnimation: premiumAnimation,
	}

	return &stickerFullTypeRegularTemp
}

// UnmarshalJSON unmarshal to json
func (stickerFullTypeRegular *StickerFullTypeRegular) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PremiumAnimation *File `json:"premium_animation"` // Premium animation of the sticker; may be null. If present, only Telegram Premium users can use the sticker
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	stickerFullTypeRegular.tdCommon = tempObj.tdCommon
	stickerFullTypeRegular.PremiumAnimation = tempObj.PremiumAnimation

	return nil
}

// GetStickerFullTypeEnum return the enum type of this object
func (stickerFullTypeRegular *StickerFullTypeRegular) GetStickerFullTypeEnum() StickerFullTypeEnum {
	return StickerFullTypeRegularType
}

// StickerFullTypeMask The sticker is a mask in WEBP format to be placed on photos or videos
type StickerFullTypeMask struct {
	tdCommon
	MaskPosition *MaskPosition `json:"mask_position"` // Position where the mask is placed; may be null
}

// MessageType return the string telegram-type of StickerFullTypeMask
func (stickerFullTypeMask *StickerFullTypeMask) MessageType() string {
	return "stickerFullTypeMask"
}

// NewStickerFullTypeMask creates a new StickerFullTypeMask
//
// @param maskPosition Position where the mask is placed; may be null
func NewStickerFullTypeMask(maskPosition *MaskPosition) *StickerFullTypeMask {
	stickerFullTypeMaskTemp := StickerFullTypeMask{
		tdCommon:     tdCommon{Type: "stickerFullTypeMask"},
		MaskPosition: maskPosition,
	}

	return &stickerFullTypeMaskTemp
}

// UnmarshalJSON unmarshal to json
func (stickerFullTypeMask *StickerFullTypeMask) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	stickerFullTypeMask.tdCommon = tempObj.tdCommon

	var maskPosition MaskPosition
	if objMap["mask_position"] != nil {
		err = maskPosition.UnmarshalJSON(*objMap["mask_position"])
		if err != nil {
			return err
		}
	}

	stickerFullTypeMask.MaskPosition = &maskPosition

	return nil
}

// GetStickerFullTypeEnum return the enum type of this object
func (stickerFullTypeMask *StickerFullTypeMask) GetStickerFullTypeEnum() StickerFullTypeEnum {
	return StickerFullTypeMaskType
}

// StickerFullTypeCustomEmoji The sticker is a custom emoji to be used inside message text and caption. Currently, only Telegram Premium users can use custom emoji
type StickerFullTypeCustomEmoji struct {
	tdCommon
	CustomEmojiID   JSONInt64 `json:"custom_emoji_id"`  // Identifier of the custom emoji
	NeedsRepainting bool      `json:"needs_repainting"` // True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places
}

// MessageType return the string telegram-type of StickerFullTypeCustomEmoji
func (stickerFullTypeCustomEmoji *StickerFullTypeCustomEmoji) MessageType() string {
	return "stickerFullTypeCustomEmoji"
}

// NewStickerFullTypeCustomEmoji creates a new StickerFullTypeCustomEmoji
//
// @param customEmojiID Identifier of the custom emoji
// @param needsRepainting True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places
func NewStickerFullTypeCustomEmoji(customEmojiID JSONInt64, needsRepainting bool) *StickerFullTypeCustomEmoji {
	stickerFullTypeCustomEmojiTemp := StickerFullTypeCustomEmoji{
		tdCommon:        tdCommon{Type: "stickerFullTypeCustomEmoji"},
		CustomEmojiID:   customEmojiID,
		NeedsRepainting: needsRepainting,
	}

	return &stickerFullTypeCustomEmojiTemp
}

// UnmarshalJSON unmarshal to json
func (stickerFullTypeCustomEmoji *StickerFullTypeCustomEmoji) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CustomEmojiID   JSONInt64 `json:"custom_emoji_id"`  // Identifier of the custom emoji
		NeedsRepainting bool      `json:"needs_repainting"` // True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	stickerFullTypeCustomEmoji.tdCommon = tempObj.tdCommon
	stickerFullTypeCustomEmoji.CustomEmojiID = tempObj.CustomEmojiID
	stickerFullTypeCustomEmoji.NeedsRepainting = tempObj.NeedsRepainting

	return nil
}

// GetStickerFullTypeEnum return the enum type of this object
func (stickerFullTypeCustomEmoji *StickerFullTypeCustomEmoji) GetStickerFullTypeEnum() StickerFullTypeEnum {
	return StickerFullTypeCustomEmojiType
}

// ClosedVectorPath Represents a closed vector path. The path begins at the end point of the last command
type ClosedVectorPath struct {
	tdCommon
	Commands []VectorPathCommand `json:"commands"` // List of vector path commands
}

// MessageType return the string telegram-type of ClosedVectorPath
func (closedVectorPath *ClosedVectorPath) MessageType() string {
	return "closedVectorPath"
}

// NewClosedVectorPath creates a new ClosedVectorPath
//
// @param commands List of vector path commands
func NewClosedVectorPath(commands []VectorPathCommand) *ClosedVectorPath {
	closedVectorPathTemp := ClosedVectorPath{
		tdCommon: tdCommon{Type: "closedVectorPath"},
		Commands: commands,
	}

	return &closedVectorPathTemp
}

// UnmarshalJSON unmarshal to json
func (closedVectorPath *ClosedVectorPath) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	closedVectorPath.tdCommon = tempObj.tdCommon

	fieldCommands, _ := unmarshalVectorPathCommandSlice(objMap["commands"])
	closedVectorPath.Commands = fieldCommands

	return nil
}

// PollOption Describes one answer option of a poll
type PollOption struct {
	tdCommon
	Text           *FormattedText `json:"text"`            // Option text; 1-100 characters. Only custom emoji entities are allowed
	VoterCount     int32          `json:"voter_count"`     // Number of voters for this option, available only for closed or voted polls
	VotePercentage int32          `json:"vote_percentage"` // The percentage of votes for this option; 0-100
	IsChosen       bool           `json:"is_chosen"`       // True, if the option was chosen by the user
	IsBeingChosen  bool           `json:"is_being_chosen"` // True, if the option is being chosen by a pending setPollAnswer request
}

// MessageType return the string telegram-type of PollOption
func (pollOption *PollOption) MessageType() string {
	return "pollOption"
}

// NewPollOption creates a new PollOption
//
// @param text Option text; 1-100 characters. Only custom emoji entities are allowed
// @param voterCount Number of voters for this option, available only for closed or voted polls
// @param votePercentage The percentage of votes for this option; 0-100
// @param isChosen True, if the option was chosen by the user
// @param isBeingChosen True, if the option is being chosen by a pending setPollAnswer request
func NewPollOption(text *FormattedText, voterCount int32, votePercentage int32, isChosen bool, isBeingChosen bool) *PollOption {
	pollOptionTemp := PollOption{
		tdCommon:       tdCommon{Type: "pollOption"},
		Text:           text,
		VoterCount:     voterCount,
		VotePercentage: votePercentage,
		IsChosen:       isChosen,
		IsBeingChosen:  isBeingChosen,
	}

	return &pollOptionTemp
}

// UnmarshalJSON unmarshal to json
func (pollOption *PollOption) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Text           *FormattedText `json:"text"`            // Option text; 1-100 characters. Only custom emoji entities are allowed
		VoterCount     int32          `json:"voter_count"`     // Number of voters for this option, available only for closed or voted polls
		VotePercentage int32          `json:"vote_percentage"` // The percentage of votes for this option; 0-100
		IsChosen       bool           `json:"is_chosen"`       // True, if the option was chosen by the user
		IsBeingChosen  bool           `json:"is_being_chosen"` // True, if the option is being chosen by a pending setPollAnswer request
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pollOption.tdCommon = tempObj.tdCommon
	pollOption.Text = tempObj.Text
	pollOption.VoterCount = tempObj.VoterCount
	pollOption.VotePercentage = tempObj.VotePercentage
	pollOption.IsChosen = tempObj.IsChosen
	pollOption.IsBeingChosen = tempObj.IsBeingChosen

	return nil
}

// PollTypeRegular A regular poll
type PollTypeRegular struct {
	tdCommon
	AllowMultipleAnswers bool `json:"allow_multiple_answers"` // True, if multiple answer options can be chosen simultaneously
}

// MessageType return the string telegram-type of PollTypeRegular
func (pollTypeRegular *PollTypeRegular) MessageType() string {
	return "pollTypeRegular"
}

// NewPollTypeRegular creates a new PollTypeRegular
//
// @param allowMultipleAnswers True, if multiple answer options can be chosen simultaneously
func NewPollTypeRegular(allowMultipleAnswers bool) *PollTypeRegular {
	pollTypeRegularTemp := PollTypeRegular{
		tdCommon:             tdCommon{Type: "pollTypeRegular"},
		AllowMultipleAnswers: allowMultipleAnswers,
	}

	return &pollTypeRegularTemp
}

// UnmarshalJSON unmarshal to json
func (pollTypeRegular *PollTypeRegular) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		AllowMultipleAnswers bool `json:"allow_multiple_answers"` // True, if multiple answer options can be chosen simultaneously
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pollTypeRegular.tdCommon = tempObj.tdCommon
	pollTypeRegular.AllowMultipleAnswers = tempObj.AllowMultipleAnswers

	return nil
}

// GetPollTypeEnum return the enum type of this object
func (pollTypeRegular *PollTypeRegular) GetPollTypeEnum() PollTypeEnum {
	return PollTypeRegularType
}

// PollTypeQuiz A poll in quiz mode, which has exactly one correct answer option and can be answered only once
type PollTypeQuiz struct {
	tdCommon
	CorrectOptionID int32          `json:"correct_option_id"` // 0-based identifier of the correct answer option; -1 for a yet unanswered poll
	Explanation     *FormattedText `json:"explanation"`       // Text that is shown when the user chooses an incorrect answer or taps on the lamp icon; 0-200 characters with at most 2 line feeds; empty for a yet unanswered poll
}

// MessageType return the string telegram-type of PollTypeQuiz
func (pollTypeQuiz *PollTypeQuiz) MessageType() string {
	return "pollTypeQuiz"
}

// NewPollTypeQuiz creates a new PollTypeQuiz
//
// @param correctOptionID 0-based identifier of the correct answer option; -1 for a yet unanswered poll
// @param explanation Text that is shown when the user chooses an incorrect answer or taps on the lamp icon; 0-200 characters with at most 2 line feeds; empty for a yet unanswered poll
func NewPollTypeQuiz(correctOptionID int32, explanation *FormattedText) *PollTypeQuiz {
	pollTypeQuizTemp := PollTypeQuiz{
		tdCommon:        tdCommon{Type: "pollTypeQuiz"},
		CorrectOptionID: correctOptionID,
		Explanation:     explanation,
	}

	return &pollTypeQuizTemp
}

// UnmarshalJSON unmarshal to json
func (pollTypeQuiz *PollTypeQuiz) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CorrectOptionID int32          `json:"correct_option_id"` // 0-based identifier of the correct answer option; -1 for a yet unanswered poll
		Explanation     *FormattedText `json:"explanation"`       // Text that is shown when the user chooses an incorrect answer or taps on the lamp icon; 0-200 characters with at most 2 line feeds; empty for a yet unanswered poll
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pollTypeQuiz.tdCommon = tempObj.tdCommon
	pollTypeQuiz.CorrectOptionID = tempObj.CorrectOptionID
	pollTypeQuiz.Explanation = tempObj.Explanation

	return nil
}

// GetPollTypeEnum return the enum type of this object
func (pollTypeQuiz *PollTypeQuiz) GetPollTypeEnum() PollTypeEnum {
	return PollTypeQuizType
}

// Animation Describes an animation file. The animation must be encoded in GIF or MPEG4 format
type Animation struct {
	tdCommon
	Duration      int32          `json:"duration"`      // Duration of the animation, in seconds; as defined by the sender
	Width         int32          `json:"width"`         // Width of the animation
	Height        int32          `json:"height"`        // Height of the animation
	FileName      string         `json:"file_name"`     // Original name of the file; as defined by the sender
	MimeType      string         `json:"mime_type"`     // MIME type of the file, usually "image/gif" or "video/mp4"
	HasStickers   bool           `json:"has_stickers"`  // True, if stickers were added to the animation. The list of corresponding sticker set can be received using getAttachedStickerSets
	Minithumbnail *Minithumbnail `json:"minithumbnail"` // Animation minithumbnail; may be null
	Thumbnail     *Thumbnail     `json:"thumbnail"`     // Animation thumbnail in JPEG or MPEG4 format; may be null
	Animation     *File          `json:"animation"`     // File containing the animation
}

// MessageType return the string telegram-type of Animation
func (animation *Animation) MessageType() string {
	return "animation"
}

// NewAnimation creates a new Animation
//
// @param duration Duration of the animation, in seconds; as defined by the sender
// @param width Width of the animation
// @param height Height of the animation
// @param fileName Original name of the file; as defined by the sender
// @param mimeType MIME type of the file, usually "image/gif" or "video/mp4"
// @param hasStickers True, if stickers were added to the animation. The list of corresponding sticker set can be received using getAttachedStickerSets
// @param minithumbnail Animation minithumbnail; may be null
// @param thumbnail Animation thumbnail in JPEG or MPEG4 format; may be null
// @param animation File containing the animation
func NewAnimation(duration int32, width int32, height int32, fileName string, mimeType string, hasStickers bool, minithumbnail *Minithumbnail, thumbnail *Thumbnail, animation *File) *Animation {
	animationTemp := Animation{
		tdCommon:      tdCommon{Type: "animation"},
		Duration:      duration,
		Width:         width,
		Height:        height,
		FileName:      fileName,
		MimeType:      mimeType,
		HasStickers:   hasStickers,
		Minithumbnail: minithumbnail,
		Thumbnail:     thumbnail,
		Animation:     animation,
	}

	return &animationTemp
}

// UnmarshalJSON unmarshal to json
func (animation *Animation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Duration      int32          `json:"duration"`      // Duration of the animation, in seconds; as defined by the sender
		Width         int32          `json:"width"`         // Width of the animation
		Height        int32          `json:"height"`        // Height of the animation
		FileName      string         `json:"file_name"`     // Original name of the file; as defined by the sender
		MimeType      string         `json:"mime_type"`     // MIME type of the file, usually "image/gif" or "video/mp4"
		HasStickers   bool           `json:"has_stickers"`  // True, if stickers were added to the animation. The list of corresponding sticker set can be received using getAttachedStickerSets
		Minithumbnail *Minithumbnail `json:"minithumbnail"` // Animation minithumbnail; may be null
		Animation     *File          `json:"animation"`     // File containing the animation
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	animation.tdCommon = tempObj.tdCommon
	animation.Duration = tempObj.Duration
	animation.Width = tempObj.Width
	animation.Height = tempObj.Height
	animation.FileName = tempObj.FileName
	animation.MimeType = tempObj.MimeType
	animation.HasStickers = tempObj.HasStickers
	animation.Minithumbnail = tempObj.Minithumbnail
	animation.Animation = tempObj.Animation

	var thumbnail Thumbnail
	if objMap["thumbnail"] != nil {
		err = thumbnail.UnmarshalJSON(*objMap["thumbnail"])
		if err != nil {
			return err
		}
	}

	animation.Thumbnail = &thumbnail

	return nil
}

// Audio Describes an audio file. Audio is usually in MP3 or M4A format
type Audio struct {
	tdCommon
	Duration                int32          `json:"duration"`                  // Duration of the audio, in seconds; as defined by the sender
	Title                   string         `json:"title"`                     // Title of the audio; as defined by the sender
	Performer               string         `json:"performer"`                 // Performer of the audio; as defined by the sender
	FileName                string         `json:"file_name"`                 // Original name of the file; as defined by the sender
	MimeType                string         `json:"mime_type"`                 // The MIME type of the file; as defined by the sender
	AlbumCoverMinithumbnail *Minithumbnail `json:"album_cover_minithumbnail"` // The minithumbnail of the album cover; may be null
	AlbumCoverThumbnail     *Thumbnail     `json:"album_cover_thumbnail"`     // The thumbnail of the album cover in JPEG format; as defined by the sender. The full size thumbnail is supposed to be extracted from the downloaded audio file; may be null
	ExternalAlbumCovers     []Thumbnail    `json:"external_album_covers"`     // Album cover variants to use if the downloaded audio file contains no album cover. Provided thumbnail dimensions are approximate
	Audio                   *File          `json:"audio"`                     // File containing the audio
}

// MessageType return the string telegram-type of Audio
func (audio *Audio) MessageType() string {
	return "audio"
}

// NewAudio creates a new Audio
//
// @param duration Duration of the audio, in seconds; as defined by the sender
// @param title Title of the audio; as defined by the sender
// @param performer Performer of the audio; as defined by the sender
// @param fileName Original name of the file; as defined by the sender
// @param mimeType The MIME type of the file; as defined by the sender
// @param albumCoverMinithumbnail The minithumbnail of the album cover; may be null
// @param albumCoverThumbnail The thumbnail of the album cover in JPEG format; as defined by the sender. The full size thumbnail is supposed to be extracted from the downloaded audio file; may be null
// @param externalAlbumCovers Album cover variants to use if the downloaded audio file contains no album cover. Provided thumbnail dimensions are approximate
// @param audio File containing the audio
func NewAudio(duration int32, title string, performer string, fileName string, mimeType string, albumCoverMinithumbnail *Minithumbnail, albumCoverThumbnail *Thumbnail, externalAlbumCovers []Thumbnail, audio *File) *Audio {
	audioTemp := Audio{
		tdCommon:                tdCommon{Type: "audio"},
		Duration:                duration,
		Title:                   title,
		Performer:               performer,
		FileName:                fileName,
		MimeType:                mimeType,
		AlbumCoverMinithumbnail: albumCoverMinithumbnail,
		AlbumCoverThumbnail:     albumCoverThumbnail,
		ExternalAlbumCovers:     externalAlbumCovers,
		Audio:                   audio,
	}

	return &audioTemp
}

// UnmarshalJSON unmarshal to json
func (audio *Audio) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Duration                int32          `json:"duration"`                  // Duration of the audio, in seconds; as defined by the sender
		Title                   string         `json:"title"`                     // Title of the audio; as defined by the sender
		Performer               string         `json:"performer"`                 // Performer of the audio; as defined by the sender
		FileName                string         `json:"file_name"`                 // Original name of the file; as defined by the sender
		MimeType                string         `json:"mime_type"`                 // The MIME type of the file; as defined by the sender
		AlbumCoverMinithumbnail *Minithumbnail `json:"album_cover_minithumbnail"` // The minithumbnail of the album cover; may be null
		ExternalAlbumCovers     []Thumbnail    `json:"external_album_covers"`     // Album cover variants to use if the downloaded audio file contains no album cover. Provided thumbnail dimensions are approximate
		Audio                   *File          `json:"audio"`                     // File containing the audio
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	audio.tdCommon = tempObj.tdCommon
	audio.Duration = tempObj.Duration
	audio.Title = tempObj.Title
	audio.Performer = tempObj.Performer
	audio.FileName = tempObj.FileName
	audio.MimeType = tempObj.MimeType
	audio.AlbumCoverMinithumbnail = tempObj.AlbumCoverMinithumbnail
	audio.ExternalAlbumCovers = tempObj.ExternalAlbumCovers
	audio.Audio = tempObj.Audio

	var albumCoverThumbnail Thumbnail
	if objMap["album_cover_thumbnail"] != nil {
		err = albumCoverThumbnail.UnmarshalJSON(*objMap["album_cover_thumbnail"])
		if err != nil {
			return err
		}
	}

	audio.AlbumCoverThumbnail = &albumCoverThumbnail

	return nil
}

// Document Describes a document of any type
type Document struct {
	tdCommon
	FileName      string         `json:"file_name"`     // Original name of the file; as defined by the sender
	MimeType      string         `json:"mime_type"`     // MIME type of the file; as defined by the sender
	Minithumbnail *Minithumbnail `json:"minithumbnail"` // Document minithumbnail; may be null
	Thumbnail     *Thumbnail     `json:"thumbnail"`     // Document thumbnail in JPEG or PNG format (PNG will be used only for background patterns); as defined by the sender; may be null
	Document      *File          `json:"document"`      // File containing the document
}

// MessageType return the string telegram-type of Document
func (document *Document) MessageType() string {
	return "document"
}

// NewDocument creates a new Document
//
// @param fileName Original name of the file; as defined by the sender
// @param mimeType MIME type of the file; as defined by the sender
// @param minithumbnail Document minithumbnail; may be null
// @param thumbnail Document thumbnail in JPEG or PNG format (PNG will be used only for background patterns); as defined by the sender; may be null
// @param document File containing the document
func NewDocument(fileName string, mimeType string, minithumbnail *Minithumbnail, thumbnail *Thumbnail, document *File) *Document {
	documentTemp := Document{
		tdCommon:      tdCommon{Type: "document"},
		FileName:      fileName,
		MimeType:      mimeType,
		Minithumbnail: minithumbnail,
		Thumbnail:     thumbnail,
		Document:      document,
	}

	return &documentTemp
}

// UnmarshalJSON unmarshal to json
func (document *Document) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		FileName      string         `json:"file_name"`     // Original name of the file; as defined by the sender
		MimeType      string         `json:"mime_type"`     // MIME type of the file; as defined by the sender
		Minithumbnail *Minithumbnail `json:"minithumbnail"` // Document minithumbnail; may be null
		Document      *File          `json:"document"`      // File containing the document
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	document.tdCommon = tempObj.tdCommon
	document.FileName = tempObj.FileName
	document.MimeType = tempObj.MimeType
	document.Minithumbnail = tempObj.Minithumbnail
	document.Document = tempObj.Document

	var thumbnail Thumbnail
	if objMap["thumbnail"] != nil {
		err = thumbnail.UnmarshalJSON(*objMap["thumbnail"])
		if err != nil {
			return err
		}
	}

	document.Thumbnail = &thumbnail

	return nil
}

// Photo Describes a photo
type Photo struct {
	tdCommon
	HasStickers   bool           `json:"has_stickers"`  // True, if stickers were added to the photo. The list of corresponding sticker sets can be received using getAttachedStickerSets
	Minithumbnail *Minithumbnail `json:"minithumbnail"` // Photo minithumbnail; may be null
	Sizes         []PhotoSize    `json:"sizes"`         // Available variants of the photo, in different sizes
}

// MessageType return the string telegram-type of Photo
func (photo *Photo) MessageType() string {
	return "photo"
}

// NewPhoto creates a new Photo
//
// @param hasStickers True, if stickers were added to the photo. The list of corresponding sticker sets can be received using getAttachedStickerSets
// @param minithumbnail Photo minithumbnail; may be null
// @param sizes Available variants of the photo, in different sizes
func NewPhoto(hasStickers bool, minithumbnail *Minithumbnail, sizes []PhotoSize) *Photo {
	photoTemp := Photo{
		tdCommon:      tdCommon{Type: "photo"},
		HasStickers:   hasStickers,
		Minithumbnail: minithumbnail,
		Sizes:         sizes,
	}

	return &photoTemp
}

// UnmarshalJSON unmarshal to json
func (photo *Photo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		HasStickers   bool           `json:"has_stickers"`  // True, if stickers were added to the photo. The list of corresponding sticker sets can be received using getAttachedStickerSets
		Minithumbnail *Minithumbnail `json:"minithumbnail"` // Photo minithumbnail; may be null
		Sizes         []PhotoSize    `json:"sizes"`         // Available variants of the photo, in different sizes
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	photo.tdCommon = tempObj.tdCommon
	photo.HasStickers = tempObj.HasStickers
	photo.Minithumbnail = tempObj.Minithumbnail
	photo.Sizes = tempObj.Sizes

	return nil
}

// Sticker Describes a sticker
type Sticker struct {
	tdCommon
	ID        JSONInt64          `json:"id"`        // Unique sticker identifier within the set; 0 if none
	SetID     JSONInt64          `json:"set_id"`    // Identifier of the sticker set to which the sticker belongs; 0 if none
	Width     int32              `json:"width"`     // Sticker width; as defined by the sender
	Height    int32              `json:"height"`    // Sticker height; as defined by the sender
	Emoji     string             `json:"emoji"`     // Emoji corresponding to the sticker
	Format    StickerFormat      `json:"format"`    // Sticker format
	FullType  StickerFullType    `json:"full_type"` // Sticker's full type
	Outline   []ClosedVectorPath `json:"outline"`   // Sticker's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
	Thumbnail *Thumbnail         `json:"thumbnail"` // Sticker thumbnail in WEBP or JPEG format; may be null
	Sticker   *File              `json:"sticker"`   // File containing the sticker
}

// MessageType return the string telegram-type of Sticker
func (sticker *Sticker) MessageType() string {
	return "sticker"
}

// NewSticker creates a new Sticker
//
// @param iD Unique sticker identifier within the set; 0 if none
// @param setID Identifier of the sticker set to which the sticker belongs; 0 if none
// @param width Sticker width; as defined by the sender
// @param height Sticker height; as defined by the sender
// @param emoji Emoji corresponding to the sticker
// @param format Sticker format
// @param fullType Sticker's full type
// @param outline Sticker's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
// @param thumbnail Sticker thumbnail in WEBP or JPEG format; may be null
// @param sticker File containing the sticker
func NewSticker(iD JSONInt64, setID JSONInt64, width int32, height int32, emoji string, format StickerFormat, fullType StickerFullType, outline []ClosedVectorPath, thumbnail *Thumbnail, sticker *File) *Sticker {
	stickerTemp := Sticker{
		tdCommon:  tdCommon{Type: "sticker"},
		ID:        iD,
		SetID:     setID,
		Width:     width,
		Height:    height,
		Emoji:     emoji,
		Format:    format,
		FullType:  fullType,
		Outline:   outline,
		Thumbnail: thumbnail,
		Sticker:   sticker,
	}

	return &stickerTemp
}

// UnmarshalJSON unmarshal to json
func (sticker *Sticker) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID      JSONInt64          `json:"id"`      // Unique sticker identifier within the set; 0 if none
		SetID   JSONInt64          `json:"set_id"`  // Identifier of the sticker set to which the sticker belongs; 0 if none
		Width   int32              `json:"width"`   // Sticker width; as defined by the sender
		Height  int32              `json:"height"`  // Sticker height; as defined by the sender
		Emoji   string             `json:"emoji"`   // Emoji corresponding to the sticker
		Outline []ClosedVectorPath `json:"outline"` // Sticker's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
		Sticker *File              `json:"sticker"` // File containing the sticker
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sticker.tdCommon = tempObj.tdCommon
	sticker.ID = tempObj.ID
	sticker.SetID = tempObj.SetID
	sticker.Width = tempObj.Width
	sticker.Height = tempObj.Height
	sticker.Emoji = tempObj.Emoji
	sticker.Outline = tempObj.Outline
	sticker.Sticker = tempObj.Sticker

	fieldFormat, _ := unmarshalStickerFormat(objMap["format"])
	sticker.Format = fieldFormat

	fieldFullType, _ := unmarshalStickerFullType(objMap["full_type"])
	sticker.FullType = fieldFullType

	var thumbnail Thumbnail
	if objMap["thumbnail"] != nil {
		err = thumbnail.UnmarshalJSON(*objMap["thumbnail"])
		if err != nil {
			return err
		}
	}

	sticker.Thumbnail = &thumbnail

	return nil
}

// Video Describes a video file
type Video struct {
	tdCommon
	Duration          int32          `json:"duration"`           // Duration of the video, in seconds; as defined by the sender
	Width             int32          `json:"width"`              // Video width; as defined by the sender
	Height            int32          `json:"height"`             // Video height; as defined by the sender
	FileName          string         `json:"file_name"`          // Original name of the file; as defined by the sender
	MimeType          string         `json:"mime_type"`          // MIME type of the file; as defined by the sender
	HasStickers       bool           `json:"has_stickers"`       // True, if stickers were added to the video. The list of corresponding sticker sets can be received using getAttachedStickerSets
	SupportsStreaming bool           `json:"supports_streaming"` // True, if the video is supposed to be streamed
	Minithumbnail     *Minithumbnail `json:"minithumbnail"`      // Video minithumbnail; may be null
	Thumbnail         *Thumbnail     `json:"thumbnail"`          // Video thumbnail in JPEG or MPEG4 format; as defined by the sender; may be null
	Video             *File          `json:"video"`              // File containing the video
}

// MessageType return the string telegram-type of Video
func (video *Video) MessageType() string {
	return "video"
}

// NewVideo creates a new Video
//
// @param duration Duration of the video, in seconds; as defined by the sender
// @param width Video width; as defined by the sender
// @param height Video height; as defined by the sender
// @param fileName Original name of the file; as defined by the sender
// @param mimeType MIME type of the file; as defined by the sender
// @param hasStickers True, if stickers were added to the video. The list of corresponding sticker sets can be received using getAttachedStickerSets
// @param supportsStreaming True, if the video is supposed to be streamed
// @param minithumbnail Video minithumbnail; may be null
// @param thumbnail Video thumbnail in JPEG or MPEG4 format; as defined by the sender; may be null
// @param video File containing the video
func NewVideo(duration int32, width int32, height int32, fileName string, mimeType string, hasStickers bool, supportsStreaming bool, minithumbnail *Minithumbnail, thumbnail *Thumbnail, video *File) *Video {
	videoTemp := Video{
		tdCommon:          tdCommon{Type: "video"},
		Duration:          duration,
		Width:             width,
		Height:            height,
		FileName:          fileName,
		MimeType:          mimeType,
		HasStickers:       hasStickers,
		SupportsStreaming: supportsStreaming,
		Minithumbnail:     minithumbnail,
		Thumbnail:         thumbnail,
		Video:             video,
	}

	return &videoTemp
}

// UnmarshalJSON unmarshal to json
func (video *Video) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Duration          int32          `json:"duration"`           // Duration of the video, in seconds; as defined by the sender
		Width             int32          `json:"width"`              // Video width; as defined by the sender
		Height            int32          `json:"height"`             // Video height; as defined by the sender
		FileName          string         `json:"file_name"`          // Original name of the file; as defined by the sender
		MimeType          string         `json:"mime_type"`          // MIME type of the file; as defined by the sender
		HasStickers       bool           `json:"has_stickers"`       // True, if stickers were added to the video. The list of corresponding sticker sets can be received using getAttachedStickerSets
		SupportsStreaming bool           `json:"supports_streaming"` // True, if the video is supposed to be streamed
		Minithumbnail     *Minithumbnail `json:"minithumbnail"`      // Video minithumbnail; may be null
		Video             *File          `json:"video"`              // File containing the video
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	video.tdCommon = tempObj.tdCommon
	video.Duration = tempObj.Duration
	video.Width = tempObj.Width
	video.Height = tempObj.Height
	video.FileName = tempObj.FileName
	video.MimeType = tempObj.MimeType
	video.HasStickers = tempObj.HasStickers
	video.SupportsStreaming = tempObj.SupportsStreaming
	video.Minithumbnail = tempObj.Minithumbnail
	video.Video = tempObj.Video

	var thumbnail Thumbnail
	if objMap["thumbnail"] != nil {
		err = thumbnail.UnmarshalJSON(*objMap["thumbnail"])
		if err != nil {
			return err
		}
	}

	video.Thumbnail = &thumbnail

	return nil
}

// VideoNote Describes a video note. The video must be equal in width and height, cropped to a circle, and stored in MPEG4 format
type VideoNote struct {
	tdCommon
	Duration                int32                    `json:"duration"`                  // Duration of the video, in seconds; as defined by the sender
	Waveform                []byte                   `json:"waveform"`                  // A waveform representation of the video note's audio in 5-bit format; may be empty if unknown
	Length                  int32                    `json:"length"`                    // Video width and height; as defined by the sender
	Minithumbnail           *Minithumbnail           `json:"minithumbnail"`             // Video minithumbnail; may be null
	Thumbnail               *Thumbnail               `json:"thumbnail"`                 // Video thumbnail in JPEG format; as defined by the sender; may be null
	SpeechRecognitionResult *SpeechRecognitionResult `json:"speech_recognition_result"` // Result of speech recognition in the video note; may be null
	Video                   *File                    `json:"video"`                     // File containing the video
}

// MessageType return the string telegram-type of VideoNote
func (videoNote *VideoNote) MessageType() string {
	return "videoNote"
}

// NewVideoNote creates a new VideoNote
//
// @param duration Duration of the video, in seconds; as defined by the sender
// @param waveform A waveform representation of the video note's audio in 5-bit format; may be empty if unknown
// @param length Video width and height; as defined by the sender
// @param minithumbnail Video minithumbnail; may be null
// @param thumbnail Video thumbnail in JPEG format; as defined by the sender; may be null
// @param speechRecognitionResult Result of speech recognition in the video note; may be null
// @param video File containing the video
func NewVideoNote(duration int32, waveform []byte, length int32, minithumbnail *Minithumbnail, thumbnail *Thumbnail, speechRecognitionResult *SpeechRecognitionResult, video *File) *VideoNote {
	videoNoteTemp := VideoNote{
		tdCommon:                tdCommon{Type: "videoNote"},
		Duration:                duration,
		Waveform:                waveform,
		Length:                  length,
		Minithumbnail:           minithumbnail,
		Thumbnail:               thumbnail,
		SpeechRecognitionResult: speechRecognitionResult,
		Video:                   video,
	}

	return &videoNoteTemp
}

// UnmarshalJSON unmarshal to json
func (videoNote *VideoNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Duration      int32          `json:"duration"`      // Duration of the video, in seconds; as defined by the sender
		Waveform      []byte         `json:"waveform"`      // A waveform representation of the video note's audio in 5-bit format; may be empty if unknown
		Length        int32          `json:"length"`        // Video width and height; as defined by the sender
		Minithumbnail *Minithumbnail `json:"minithumbnail"` // Video minithumbnail; may be null
		Video         *File          `json:"video"`         // File containing the video
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	videoNote.tdCommon = tempObj.tdCommon
	videoNote.Duration = tempObj.Duration
	videoNote.Waveform = tempObj.Waveform
	videoNote.Length = tempObj.Length
	videoNote.Minithumbnail = tempObj.Minithumbnail
	videoNote.Video = tempObj.Video

	fieldSpeechRecognitionResult, _ := unmarshalSpeechRecognitionResult(objMap["speech_recognition_result"])
	videoNote.SpeechRecognitionResult = &fieldSpeechRecognitionResult

	var thumbnail Thumbnail
	if objMap["thumbnail"] != nil {
		err = thumbnail.UnmarshalJSON(*objMap["thumbnail"])
		if err != nil {
			return err
		}
	}

	videoNote.Thumbnail = &thumbnail

	return nil
}

// VoiceNote Describes a voice note
type VoiceNote struct {
	tdCommon
	Duration                int32                    `json:"duration"`                  // Duration of the voice note, in seconds; as defined by the sender
	Waveform                []byte                   `json:"waveform"`                  // A waveform representation of the voice note in 5-bit format
	MimeType                string                   `json:"mime_type"`                 // MIME type of the file; as defined by the sender. Usually, one of "audio/ogg" for Opus in an OGG container, "audio/mpeg" for an MP3 audio, or "audio/mp4" for an M4A audio
	SpeechRecognitionResult *SpeechRecognitionResult `json:"speech_recognition_result"` // Result of speech recognition in the voice note; may be null
	Voice                   *File                    `json:"voice"`                     // File containing the voice note
}

// MessageType return the string telegram-type of VoiceNote
func (voiceNote *VoiceNote) MessageType() string {
	return "voiceNote"
}

// NewVoiceNote creates a new VoiceNote
//
// @param duration Duration of the voice note, in seconds; as defined by the sender
// @param waveform A waveform representation of the voice note in 5-bit format
// @param mimeType MIME type of the file; as defined by the sender. Usually, one of "audio/ogg" for Opus in an OGG container, "audio/mpeg" for an MP3 audio, or "audio/mp4" for an M4A audio
// @param speechRecognitionResult Result of speech recognition in the voice note; may be null
// @param voice File containing the voice note
func NewVoiceNote(duration int32, waveform []byte, mimeType string, speechRecognitionResult *SpeechRecognitionResult, voice *File) *VoiceNote {
	voiceNoteTemp := VoiceNote{
		tdCommon:                tdCommon{Type: "voiceNote"},
		Duration:                duration,
		Waveform:                waveform,
		MimeType:                mimeType,
		SpeechRecognitionResult: speechRecognitionResult,
		Voice:                   voice,
	}

	return &voiceNoteTemp
}

// UnmarshalJSON unmarshal to json
func (voiceNote *VoiceNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Duration int32  `json:"duration"`  // Duration of the voice note, in seconds; as defined by the sender
		Waveform []byte `json:"waveform"`  // A waveform representation of the voice note in 5-bit format
		MimeType string `json:"mime_type"` // MIME type of the file; as defined by the sender. Usually, one of "audio/ogg" for Opus in an OGG container, "audio/mpeg" for an MP3 audio, or "audio/mp4" for an M4A audio
		Voice    *File  `json:"voice"`     // File containing the voice note
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	voiceNote.tdCommon = tempObj.tdCommon
	voiceNote.Duration = tempObj.Duration
	voiceNote.Waveform = tempObj.Waveform
	voiceNote.MimeType = tempObj.MimeType
	voiceNote.Voice = tempObj.Voice

	fieldSpeechRecognitionResult, _ := unmarshalSpeechRecognitionResult(objMap["speech_recognition_result"])
	voiceNote.SpeechRecognitionResult = &fieldSpeechRecognitionResult

	return nil
}

// AnimatedEmoji Describes an animated or custom representation of an emoji
type AnimatedEmoji struct {
	tdCommon
	Sticker         *Sticker `json:"sticker"`          // Sticker for the emoji; may be null if yet unknown for a custom emoji. If the sticker is a custom emoji, then it can have arbitrary format
	StickerWidth    int32    `json:"sticker_width"`    // Expected width of the sticker, which can be used if the sticker is null
	StickerHeight   int32    `json:"sticker_height"`   // Expected height of the sticker, which can be used if the sticker is null
	FitzpatrickType int32    `json:"fitzpatrick_type"` // Emoji modifier fitzpatrick type; 0-6; 0 if none
	Sound           *File    `json:"sound"`            // File containing the sound to be played when the sticker is clicked; may be null. The sound is encoded with the Opus codec, and stored inside an OGG container
}

// MessageType return the string telegram-type of AnimatedEmoji
func (animatedEmoji *AnimatedEmoji) MessageType() string {
	return "animatedEmoji"
}

// NewAnimatedEmoji creates a new AnimatedEmoji
//
// @param sticker Sticker for the emoji; may be null if yet unknown for a custom emoji. If the sticker is a custom emoji, then it can have arbitrary format
// @param stickerWidth Expected width of the sticker, which can be used if the sticker is null
// @param stickerHeight Expected height of the sticker, which can be used if the sticker is null
// @param fitzpatrickType Emoji modifier fitzpatrick type; 0-6; 0 if none
// @param sound File containing the sound to be played when the sticker is clicked; may be null. The sound is encoded with the Opus codec, and stored inside an OGG container
func NewAnimatedEmoji(sticker *Sticker, stickerWidth int32, stickerHeight int32, fitzpatrickType int32, sound *File) *AnimatedEmoji {
	animatedEmojiTemp := AnimatedEmoji{
		tdCommon:        tdCommon{Type: "animatedEmoji"},
		Sticker:         sticker,
		StickerWidth:    stickerWidth,
		StickerHeight:   stickerHeight,
		FitzpatrickType: fitzpatrickType,
		Sound:           sound,
	}

	return &animatedEmojiTemp
}

// UnmarshalJSON unmarshal to json
func (animatedEmoji *AnimatedEmoji) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StickerWidth    int32 `json:"sticker_width"`    // Expected width of the sticker, which can be used if the sticker is null
		StickerHeight   int32 `json:"sticker_height"`   // Expected height of the sticker, which can be used if the sticker is null
		FitzpatrickType int32 `json:"fitzpatrick_type"` // Emoji modifier fitzpatrick type; 0-6; 0 if none
		Sound           *File `json:"sound"`            // File containing the sound to be played when the sticker is clicked; may be null. The sound is encoded with the Opus codec, and stored inside an OGG container
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	animatedEmoji.tdCommon = tempObj.tdCommon
	animatedEmoji.StickerWidth = tempObj.StickerWidth
	animatedEmoji.StickerHeight = tempObj.StickerHeight
	animatedEmoji.FitzpatrickType = tempObj.FitzpatrickType
	animatedEmoji.Sound = tempObj.Sound

	var sticker Sticker
	if objMap["sticker"] != nil {
		err = sticker.UnmarshalJSON(*objMap["sticker"])
		if err != nil {
			return err
		}
	}

	animatedEmoji.Sticker = &sticker

	return nil
}

// Contact Describes a user contact
type Contact struct {
	tdCommon
	PhoneNumber string `json:"phone_number"` // Phone number of the user
	FirstName   string `json:"first_name"`   // First name of the user; 1-255 characters in length
	LastName    string `json:"last_name"`    // Last name of the user
	Vcard       string `json:"vcard"`        // Additional data about the user in a form of vCard; 0-2048 bytes in length
	UserID      int64  `json:"user_id"`      // Identifier of the user, if known; 0 otherwise
}

// MessageType return the string telegram-type of Contact
func (contact *Contact) MessageType() string {
	return "contact"
}

// NewContact creates a new Contact
//
// @param phoneNumber Phone number of the user
// @param firstName First name of the user; 1-255 characters in length
// @param lastName Last name of the user
// @param vcard Additional data about the user in a form of vCard; 0-2048 bytes in length
// @param userID Identifier of the user, if known; 0 otherwise
func NewContact(phoneNumber string, firstName string, lastName string, vcard string, userID int64) *Contact {
	contactTemp := Contact{
		tdCommon:    tdCommon{Type: "contact"},
		PhoneNumber: phoneNumber,
		FirstName:   firstName,
		LastName:    lastName,
		Vcard:       vcard,
		UserID:      userID,
	}

	return &contactTemp
}

// UnmarshalJSON unmarshal to json
func (contact *Contact) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PhoneNumber string `json:"phone_number"` // Phone number of the user
		FirstName   string `json:"first_name"`   // First name of the user; 1-255 characters in length
		LastName    string `json:"last_name"`    // Last name of the user
		Vcard       string `json:"vcard"`        // Additional data about the user in a form of vCard; 0-2048 bytes in length
		UserID      int64  `json:"user_id"`      // Identifier of the user, if known; 0 otherwise
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	contact.tdCommon = tempObj.tdCommon
	contact.PhoneNumber = tempObj.PhoneNumber
	contact.FirstName = tempObj.FirstName
	contact.LastName = tempObj.LastName
	contact.Vcard = tempObj.Vcard
	contact.UserID = tempObj.UserID

	return nil
}

// Location Describes a location on planet Earth
type Location struct {
	tdCommon
	Latitude           float64 `json:"latitude"`            // Latitude of the location in degrees; as defined by the sender
	Longitude          float64 `json:"longitude"`           // Longitude of the location, in degrees; as defined by the sender
	HorizontalAccuracy float64 `json:"horizontal_accuracy"` // The estimated horizontal accuracy of the location, in meters; as defined by the sender. 0 if unknown
}

// MessageType return the string telegram-type of Location
func (location *Location) MessageType() string {
	return "location"
}

// NewLocation creates a new Location
//
// @param latitude Latitude of the location in degrees; as defined by the sender
// @param longitude Longitude of the location, in degrees; as defined by the sender
// @param horizontalAccuracy The estimated horizontal accuracy of the location, in meters; as defined by the sender. 0 if unknown
func NewLocation(latitude float64, longitude float64, horizontalAccuracy float64) *Location {
	locationTemp := Location{
		tdCommon:           tdCommon{Type: "location"},
		Latitude:           latitude,
		Longitude:          longitude,
		HorizontalAccuracy: horizontalAccuracy,
	}

	return &locationTemp
}

// UnmarshalJSON unmarshal to json
func (location *Location) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Latitude           float64 `json:"latitude"`            // Latitude of the location in degrees; as defined by the sender
		Longitude          float64 `json:"longitude"`           // Longitude of the location, in degrees; as defined by the sender
		HorizontalAccuracy float64 `json:"horizontal_accuracy"` // The estimated horizontal accuracy of the location, in meters; as defined by the sender. 0 if unknown
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	location.tdCommon = tempObj.tdCommon
	location.Latitude = tempObj.Latitude
	location.Longitude = tempObj.Longitude
	location.HorizontalAccuracy = tempObj.HorizontalAccuracy

	return nil
}

// Venue Describes a venue
type Venue struct {
	tdCommon
	Location *Location `json:"location"` // Venue location; as defined by the sender
	Title    string    `json:"title"`    // Venue name; as defined by the sender
	Address  string    `json:"address"`  // Venue address; as defined by the sender
	Provider string    `json:"provider"` // Provider of the venue database; as defined by the sender. Currently, only "foursquare" and "gplaces" (Google Places) need to be supported
	ID       string    `json:"id"`       // Identifier of the venue in the provider database; as defined by the sender
	Type     string    `json:"type"`     // Type of the venue in the provider database; as defined by the sender
}

// MessageType return the string telegram-type of Venue
func (venue *Venue) MessageType() string {
	return "venue"
}

// NewVenue creates a new Venue
//
// @param location Venue location; as defined by the sender
// @param title Venue name; as defined by the sender
// @param address Venue address; as defined by the sender
// @param provider Provider of the venue database; as defined by the sender. Currently, only "foursquare" and "gplaces" (Google Places) need to be supported
// @param iD Identifier of the venue in the provider database; as defined by the sender
// @param typeParam Type of the venue in the provider database; as defined by the sender
func NewVenue(location *Location, title string, address string, provider string, iD string, typeParam string) *Venue {
	venueTemp := Venue{
		tdCommon: tdCommon{Type: "venue"},
		Location: location,
		Title:    title,
		Address:  address,
		Provider: provider,
		ID:       iD,
		Type:     typeParam,
	}

	return &venueTemp
}

// UnmarshalJSON unmarshal to json
func (venue *Venue) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Location *Location `json:"location"` // Venue location; as defined by the sender
		Title    string    `json:"title"`    // Venue name; as defined by the sender
		Address  string    `json:"address"`  // Venue address; as defined by the sender
		Provider string    `json:"provider"` // Provider of the venue database; as defined by the sender. Currently, only "foursquare" and "gplaces" (Google Places) need to be supported
		ID       string    `json:"id"`       // Identifier of the venue in the provider database; as defined by the sender
		Type     string    `json:"type"`     // Type of the venue in the provider database; as defined by the sender
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	venue.tdCommon = tempObj.tdCommon
	venue.Location = tempObj.Location
	venue.Title = tempObj.Title
	venue.Address = tempObj.Address
	venue.Provider = tempObj.Provider
	venue.ID = tempObj.ID
	venue.Type = tempObj.Type

	return nil
}

// Game Describes a game. Use getInternalLink with internalLinkTypeGame to share the game
type Game struct {
	tdCommon
	ID          JSONInt64      `json:"id"`          // Unique game identifier
	ShortName   string         `json:"short_name"`  // Game short name
	Title       string         `json:"title"`       // Game title
	Text        *FormattedText `json:"text"`        // Game text, usually containing scoreboards for a game
	Description string         `json:"description"` // Game description
	Photo       *Photo         `json:"photo"`       // Game photo
	Animation   *Animation     `json:"animation"`   // Game animation; may be null
}

// MessageType return the string telegram-type of Game
func (game *Game) MessageType() string {
	return "game"
}

// NewGame creates a new Game
//
// @param iD Unique game identifier
// @param shortName Game short name
// @param title Game title
// @param text Game text, usually containing scoreboards for a game
// @param description Game description
// @param photo Game photo
// @param animation Game animation; may be null
func NewGame(iD JSONInt64, shortName string, title string, text *FormattedText, description string, photo *Photo, animation *Animation) *Game {
	gameTemp := Game{
		tdCommon:    tdCommon{Type: "game"},
		ID:          iD,
		ShortName:   shortName,
		Title:       title,
		Text:        text,
		Description: description,
		Photo:       photo,
		Animation:   animation,
	}

	return &gameTemp
}

// UnmarshalJSON unmarshal to json
func (game *Game) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID          JSONInt64      `json:"id"`          // Unique game identifier
		ShortName   string         `json:"short_name"`  // Game short name
		Title       string         `json:"title"`       // Game title
		Text        *FormattedText `json:"text"`        // Game text, usually containing scoreboards for a game
		Description string         `json:"description"` // Game description
		Photo       *Photo         `json:"photo"`       // Game photo
		Animation   *Animation     `json:"animation"`   // Game animation; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	game.tdCommon = tempObj.tdCommon
	game.ID = tempObj.ID
	game.ShortName = tempObj.ShortName
	game.Title = tempObj.Title
	game.Text = tempObj.Text
	game.Description = tempObj.Description
	game.Photo = tempObj.Photo
	game.Animation = tempObj.Animation

	return nil
}

// WebApp Describes a Web App. Use getInternalLink with internalLinkTypeWebApp to share the Web App
type WebApp struct {
	tdCommon
	ShortName   string     `json:"short_name"`  // Web App short name
	Title       string     `json:"title"`       // Web App title
	Description string     `json:"description"` // Web App description
	Photo       *Photo     `json:"photo"`       // Web App photo
	Animation   *Animation `json:"animation"`   // Web App animation; may be null
}

// MessageType return the string telegram-type of WebApp
func (webApp *WebApp) MessageType() string {
	return "webApp"
}

// NewWebApp creates a new WebApp
//
// @param shortName Web App short name
// @param title Web App title
// @param description Web App description
// @param photo Web App photo
// @param animation Web App animation; may be null
func NewWebApp(shortName string, title string, description string, photo *Photo, animation *Animation) *WebApp {
	webAppTemp := WebApp{
		tdCommon:    tdCommon{Type: "webApp"},
		ShortName:   shortName,
		Title:       title,
		Description: description,
		Photo:       photo,
		Animation:   animation,
	}

	return &webAppTemp
}

// UnmarshalJSON unmarshal to json
func (webApp *WebApp) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ShortName   string     `json:"short_name"`  // Web App short name
		Title       string     `json:"title"`       // Web App title
		Description string     `json:"description"` // Web App description
		Photo       *Photo     `json:"photo"`       // Web App photo
		Animation   *Animation `json:"animation"`   // Web App animation; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	webApp.tdCommon = tempObj.tdCommon
	webApp.ShortName = tempObj.ShortName
	webApp.Title = tempObj.Title
	webApp.Description = tempObj.Description
	webApp.Photo = tempObj.Photo
	webApp.Animation = tempObj.Animation

	return nil
}

// Poll Describes a poll
type Poll struct {
	tdCommon
	ID              JSONInt64       `json:"id"`                // Unique poll identifier
	Question        *FormattedText  `json:"question"`          // Poll question; 1-300 characters. Only custom emoji entities are allowed
	Options         []PollOption    `json:"options"`           // List of poll answer options
	TotalVoterCount int32           `json:"total_voter_count"` // Total number of voters, participating in the poll
	RecentVoterIDs  []MessageSender `json:"recent_voter_ids"`  // Identifiers of recent voters, if the poll is non-anonymous
	IsAnonymous     bool            `json:"is_anonymous"`      // True, if the poll is anonymous
	Type            PollType        `json:"type"`              // Type of the poll
	OpenPeriod      int32           `json:"open_period"`       // Amount of time the poll will be active after creation, in seconds
	CloseDate       int32           `json:"close_date"`        // Point in time (Unix timestamp) when the poll will automatically be closed
	IsClosed        bool            `json:"is_closed"`         // True, if the poll is closed
}

// MessageType return the string telegram-type of Poll
func (poll *Poll) MessageType() string {
	return "poll"
}

// NewPoll creates a new Poll
//
// @param iD Unique poll identifier
// @param question Poll question; 1-300 characters. Only custom emoji entities are allowed
// @param options List of poll answer options
// @param totalVoterCount Total number of voters, participating in the poll
// @param recentVoterIDs Identifiers of recent voters, if the poll is non-anonymous
// @param isAnonymous True, if the poll is anonymous
// @param typeParam Type of the poll
// @param openPeriod Amount of time the poll will be active after creation, in seconds
// @param closeDate Point in time (Unix timestamp) when the poll will automatically be closed
// @param isClosed True, if the poll is closed
func NewPoll(iD JSONInt64, question *FormattedText, options []PollOption, totalVoterCount int32, recentVoterIDs []MessageSender, isAnonymous bool, typeParam PollType, openPeriod int32, closeDate int32, isClosed bool) *Poll {
	pollTemp := Poll{
		tdCommon:        tdCommon{Type: "poll"},
		ID:              iD,
		Question:        question,
		Options:         options,
		TotalVoterCount: totalVoterCount,
		RecentVoterIDs:  recentVoterIDs,
		IsAnonymous:     isAnonymous,
		Type:            typeParam,
		OpenPeriod:      openPeriod,
		CloseDate:       closeDate,
		IsClosed:        isClosed,
	}

	return &pollTemp
}

// UnmarshalJSON unmarshal to json
func (poll *Poll) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID              JSONInt64      `json:"id"`                // Unique poll identifier
		Question        *FormattedText `json:"question"`          // Poll question; 1-300 characters. Only custom emoji entities are allowed
		Options         []PollOption   `json:"options"`           // List of poll answer options
		TotalVoterCount int32          `json:"total_voter_count"` // Total number of voters, participating in the poll
		IsAnonymous     bool           `json:"is_anonymous"`      // True, if the poll is anonymous
		OpenPeriod      int32          `json:"open_period"`       // Amount of time the poll will be active after creation, in seconds
		CloseDate       int32          `json:"close_date"`        // Point in time (Unix timestamp) when the poll will automatically be closed
		IsClosed        bool           `json:"is_closed"`         // True, if the poll is closed
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	poll.tdCommon = tempObj.tdCommon
	poll.ID = tempObj.ID
	poll.Question = tempObj.Question
	poll.Options = tempObj.Options
	poll.TotalVoterCount = tempObj.TotalVoterCount
	poll.IsAnonymous = tempObj.IsAnonymous
	poll.OpenPeriod = tempObj.OpenPeriod
	poll.CloseDate = tempObj.CloseDate
	poll.IsClosed = tempObj.IsClosed

	fieldType, _ := unmarshalPollType(objMap["type"])
	poll.Type = fieldType

	fieldRecentVoterIDs, _ := unmarshalMessageSenderSlice(objMap["recent_voter_ids"])
	poll.RecentVoterIDs = fieldRecentVoterIDs

	return nil
}

// Background Describes a chat background
type Background struct {
	tdCommon
	ID        JSONInt64      `json:"id"`         // Unique background identifier
	IsDefault bool           `json:"is_default"` // True, if this is one of default backgrounds
	IsDark    bool           `json:"is_dark"`    // True, if the background is dark and is recommended to be used with dark theme
	Name      string         `json:"name"`       // Unique background name
	Document  *Document      `json:"document"`   // Document with the background; may be null. Null only for filled and chat theme backgrounds
	Type      BackgroundType `json:"type"`       // Type of the background
}

// MessageType return the string telegram-type of Background
func (background *Background) MessageType() string {
	return "background"
}

// NewBackground creates a new Background
//
// @param iD Unique background identifier
// @param isDefault True, if this is one of default backgrounds
// @param isDark True, if the background is dark and is recommended to be used with dark theme
// @param name Unique background name
// @param document Document with the background; may be null. Null only for filled and chat theme backgrounds
// @param typeParam Type of the background
func NewBackground(iD JSONInt64, isDefault bool, isDark bool, name string, document *Document, typeParam BackgroundType) *Background {
	backgroundTemp := Background{
		tdCommon:  tdCommon{Type: "background"},
		ID:        iD,
		IsDefault: isDefault,
		IsDark:    isDark,
		Name:      name,
		Document:  document,
		Type:      typeParam,
	}

	return &backgroundTemp
}

// UnmarshalJSON unmarshal to json
func (background *Background) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID        JSONInt64 `json:"id"`         // Unique background identifier
		IsDefault bool      `json:"is_default"` // True, if this is one of default backgrounds
		IsDark    bool      `json:"is_dark"`    // True, if the background is dark and is recommended to be used with dark theme
		Name      string    `json:"name"`       // Unique background name
		Document  *Document `json:"document"`   // Document with the background; may be null. Null only for filled and chat theme backgrounds

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	background.tdCommon = tempObj.tdCommon
	background.ID = tempObj.ID
	background.IsDefault = tempObj.IsDefault
	background.IsDark = tempObj.IsDark
	background.Name = tempObj.Name
	background.Document = tempObj.Document

	fieldType, _ := unmarshalBackgroundType(objMap["type"])
	background.Type = fieldType

	return nil
}

// Backgrounds Contains a list of backgrounds
type Backgrounds struct {
	tdCommon
	Backgrounds []Background `json:"backgrounds"` // A list of backgrounds
}

// MessageType return the string telegram-type of Backgrounds
func (backgrounds *Backgrounds) MessageType() string {
	return "backgrounds"
}

// NewBackgrounds creates a new Backgrounds
//
// @param backgrounds A list of backgrounds
func NewBackgrounds(backgrounds []Background) *Backgrounds {
	backgroundsTemp := Backgrounds{
		tdCommon:    tdCommon{Type: "backgrounds"},
		Backgrounds: backgrounds,
	}

	return &backgroundsTemp
}

// UnmarshalJSON unmarshal to json
func (backgrounds *Backgrounds) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Backgrounds []Background `json:"backgrounds"` // A list of backgrounds
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	backgrounds.tdCommon = tempObj.tdCommon
	backgrounds.Backgrounds = tempObj.Backgrounds

	return nil
}

// ChatBackground Describes a background set for a specific chat
type ChatBackground struct {
	tdCommon
	Background       *Background `json:"background"`         // The background
	DarkThemeDimming int32       `json:"dark_theme_dimming"` // Dimming of the background in dark themes, as a percentage; 0-100. Applied only to Wallpaper and Fill types of background
}

// MessageType return the string telegram-type of ChatBackground
func (chatBackground *ChatBackground) MessageType() string {
	return "chatBackground"
}

// NewChatBackground creates a new ChatBackground
//
// @param background The background
// @param darkThemeDimming Dimming of the background in dark themes, as a percentage; 0-100. Applied only to Wallpaper and Fill types of background
func NewChatBackground(background *Background, darkThemeDimming int32) *ChatBackground {
	chatBackgroundTemp := ChatBackground{
		tdCommon:         tdCommon{Type: "chatBackground"},
		Background:       background,
		DarkThemeDimming: darkThemeDimming,
	}

	return &chatBackgroundTemp
}

// UnmarshalJSON unmarshal to json
func (chatBackground *ChatBackground) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		DarkThemeDimming int32 `json:"dark_theme_dimming"` // Dimming of the background in dark themes, as a percentage; 0-100. Applied only to Wallpaper and Fill types of background
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatBackground.tdCommon = tempObj.tdCommon
	chatBackground.DarkThemeDimming = tempObj.DarkThemeDimming

	var background Background
	if objMap["background"] != nil {
		err = background.UnmarshalJSON(*objMap["background"])
		if err != nil {
			return err
		}
	}

	chatBackground.Background = &background

	return nil
}

// ProfilePhoto Describes a user profile photo
type ProfilePhoto struct {
	tdCommon
	ID            JSONInt64      `json:"id"`            // Photo identifier; 0 for an empty photo. Can be used to find a photo in a list of user profile photos
	Small         *File          `json:"small"`         // A small (160x160) user profile photo. The file can be downloaded only before the photo is changed
	Big           *File          `json:"big"`           // A big (640x640) user profile photo. The file can be downloaded only before the photo is changed
	Minithumbnail *Minithumbnail `json:"minithumbnail"` // User profile photo minithumbnail; may be null
	HasAnimation  bool           `json:"has_animation"` // True, if the photo has animated variant
	IsPersonal    bool           `json:"is_personal"`   // True, if the photo is visible only for the current user
}

// MessageType return the string telegram-type of ProfilePhoto
func (profilePhoto *ProfilePhoto) MessageType() string {
	return "profilePhoto"
}

// NewProfilePhoto creates a new ProfilePhoto
//
// @param iD Photo identifier; 0 for an empty photo. Can be used to find a photo in a list of user profile photos
// @param small A small (160x160) user profile photo. The file can be downloaded only before the photo is changed
// @param big A big (640x640) user profile photo. The file can be downloaded only before the photo is changed
// @param minithumbnail User profile photo minithumbnail; may be null
// @param hasAnimation True, if the photo has animated variant
// @param isPersonal True, if the photo is visible only for the current user
func NewProfilePhoto(iD JSONInt64, small *File, big *File, minithumbnail *Minithumbnail, hasAnimation bool, isPersonal bool) *ProfilePhoto {
	profilePhotoTemp := ProfilePhoto{
		tdCommon:      tdCommon{Type: "profilePhoto"},
		ID:            iD,
		Small:         small,
		Big:           big,
		Minithumbnail: minithumbnail,
		HasAnimation:  hasAnimation,
		IsPersonal:    isPersonal,
	}

	return &profilePhotoTemp
}

// UnmarshalJSON unmarshal to json
func (profilePhoto *ProfilePhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID            JSONInt64      `json:"id"`            // Photo identifier; 0 for an empty photo. Can be used to find a photo in a list of user profile photos
		Small         *File          `json:"small"`         // A small (160x160) user profile photo. The file can be downloaded only before the photo is changed
		Big           *File          `json:"big"`           // A big (640x640) user profile photo. The file can be downloaded only before the photo is changed
		Minithumbnail *Minithumbnail `json:"minithumbnail"` // User profile photo minithumbnail; may be null
		HasAnimation  bool           `json:"has_animation"` // True, if the photo has animated variant
		IsPersonal    bool           `json:"is_personal"`   // True, if the photo is visible only for the current user
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	profilePhoto.tdCommon = tempObj.tdCommon
	profilePhoto.ID = tempObj.ID
	profilePhoto.Small = tempObj.Small
	profilePhoto.Big = tempObj.Big
	profilePhoto.Minithumbnail = tempObj.Minithumbnail
	profilePhoto.HasAnimation = tempObj.HasAnimation
	profilePhoto.IsPersonal = tempObj.IsPersonal

	return nil
}

// ChatPhotoInfo Contains basic information about the photo of a chat
type ChatPhotoInfo struct {
	tdCommon
	Small         *File          `json:"small"`         // A small (160x160) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed
	Big           *File          `json:"big"`           // A big (640x640) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed
	Minithumbnail *Minithumbnail `json:"minithumbnail"` // Chat photo minithumbnail; may be null
	HasAnimation  bool           `json:"has_animation"` // True, if the photo has animated variant
	IsPersonal    bool           `json:"is_personal"`   // True, if the photo is visible only for the current user
}

// MessageType return the string telegram-type of ChatPhotoInfo
func (chatPhotoInfo *ChatPhotoInfo) MessageType() string {
	return "chatPhotoInfo"
}

// NewChatPhotoInfo creates a new ChatPhotoInfo
//
// @param small A small (160x160) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed
// @param big A big (640x640) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed
// @param minithumbnail Chat photo minithumbnail; may be null
// @param hasAnimation True, if the photo has animated variant
// @param isPersonal True, if the photo is visible only for the current user
func NewChatPhotoInfo(small *File, big *File, minithumbnail *Minithumbnail, hasAnimation bool, isPersonal bool) *ChatPhotoInfo {
	chatPhotoInfoTemp := ChatPhotoInfo{
		tdCommon:      tdCommon{Type: "chatPhotoInfo"},
		Small:         small,
		Big:           big,
		Minithumbnail: minithumbnail,
		HasAnimation:  hasAnimation,
		IsPersonal:    isPersonal,
	}

	return &chatPhotoInfoTemp
}

// UnmarshalJSON unmarshal to json
func (chatPhotoInfo *ChatPhotoInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Small         *File          `json:"small"`         // A small (160x160) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed
		Big           *File          `json:"big"`           // A big (640x640) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed
		Minithumbnail *Minithumbnail `json:"minithumbnail"` // Chat photo minithumbnail; may be null
		HasAnimation  bool           `json:"has_animation"` // True, if the photo has animated variant
		IsPersonal    bool           `json:"is_personal"`   // True, if the photo is visible only for the current user
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatPhotoInfo.tdCommon = tempObj.tdCommon
	chatPhotoInfo.Small = tempObj.Small
	chatPhotoInfo.Big = tempObj.Big
	chatPhotoInfo.Minithumbnail = tempObj.Minithumbnail
	chatPhotoInfo.HasAnimation = tempObj.HasAnimation
	chatPhotoInfo.IsPersonal = tempObj.IsPersonal

	return nil
}

// UserTypeRegular A regular user
type UserTypeRegular struct {
	tdCommon
}

// MessageType return the string telegram-type of UserTypeRegular
func (userTypeRegular *UserTypeRegular) MessageType() string {
	return "userTypeRegular"
}

// NewUserTypeRegular creates a new UserTypeRegular
//
func NewUserTypeRegular() *UserTypeRegular {
	userTypeRegularTemp := UserTypeRegular{
		tdCommon: tdCommon{Type: "userTypeRegular"},
	}

	return &userTypeRegularTemp
}

// UnmarshalJSON unmarshal to json
func (userTypeRegular *UserTypeRegular) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userTypeRegular.tdCommon = tempObj.tdCommon

	return nil
}

// GetUserTypeEnum return the enum type of this object
func (userTypeRegular *UserTypeRegular) GetUserTypeEnum() UserTypeEnum {
	return UserTypeRegularType
}

// UserTypeDeleted A deleted user or deleted bot. No information on the user besides the user identifier is available. It is not possible to perform any active actions on this type of user
type UserTypeDeleted struct {
	tdCommon
}

// MessageType return the string telegram-type of UserTypeDeleted
func (userTypeDeleted *UserTypeDeleted) MessageType() string {
	return "userTypeDeleted"
}

// NewUserTypeDeleted creates a new UserTypeDeleted
//
func NewUserTypeDeleted() *UserTypeDeleted {
	userTypeDeletedTemp := UserTypeDeleted{
		tdCommon: tdCommon{Type: "userTypeDeleted"},
	}

	return &userTypeDeletedTemp
}

// UnmarshalJSON unmarshal to json
func (userTypeDeleted *UserTypeDeleted) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userTypeDeleted.tdCommon = tempObj.tdCommon

	return nil
}

// GetUserTypeEnum return the enum type of this object
func (userTypeDeleted *UserTypeDeleted) GetUserTypeEnum() UserTypeEnum {
	return UserTypeDeletedType
}

// UserTypeBot A bot (see https://core.telegram.org/bots)
type UserTypeBot struct {
	tdCommon
	CanBeEdited                bool   `json:"can_be_edited"`                   // True, if the bot is owned by the current user and can be edited using the methods toggleBotUsernameIsActive, reorderBotActiveUsernames, setBotProfilePhoto, setBotName, setBotInfoDescription, and setBotInfoShortDescription
	CanJoinGroups              bool   `json:"can_join_groups"`                 // True, if the bot can be invited to basic group and supergroup chats
	CanReadAllGroupMessages    bool   `json:"can_read_all_group_messages"`     // True, if the bot can read all messages in basic group or supergroup chats and not just those addressed to the bot. In private and channel chats a bot can always read all messages
	HasMainWebApp              bool   `json:"has_main_web_app"`                // True, if the bot has the main Web App
	IsInline                   bool   `json:"is_inline"`                       // True, if the bot supports inline queries
	InlineQueryPlaceholder     string `json:"inline_query_placeholder"`        // Placeholder for inline queries (displayed on the application input field)
	NeedLocation               bool   `json:"need_location"`                   // True, if the location of the user is expected to be sent with every inline query to this bot
	CanConnectToBusiness       bool   `json:"can_connect_to_business"`         // True, if the bot supports connection to Telegram Business accounts
	CanBeAddedToAttachmentMenu bool   `json:"can_be_added_to_attachment_menu"` // True, if the bot can be added to attachment or side menu
	ActiveUserCount            int32  `json:"active_user_count"`               // The number of recently active users of the bot
}

// MessageType return the string telegram-type of UserTypeBot
func (userTypeBot *UserTypeBot) MessageType() string {
	return "userTypeBot"
}

// NewUserTypeBot creates a new UserTypeBot
//
// @param canBeEdited True, if the bot is owned by the current user and can be edited using the methods toggleBotUsernameIsActive, reorderBotActiveUsernames, setBotProfilePhoto, setBotName, setBotInfoDescription, and setBotInfoShortDescription
// @param canJoinGroups True, if the bot can be invited to basic group and supergroup chats
// @param canReadAllGroupMessages True, if the bot can read all messages in basic group or supergroup chats and not just those addressed to the bot. In private and channel chats a bot can always read all messages
// @param hasMainWebApp True, if the bot has the main Web App
// @param isInline True, if the bot supports inline queries
// @param inlineQueryPlaceholder Placeholder for inline queries (displayed on the application input field)
// @param needLocation True, if the location of the user is expected to be sent with every inline query to this bot
// @param canConnectToBusiness True, if the bot supports connection to Telegram Business accounts
// @param canBeAddedToAttachmentMenu True, if the bot can be added to attachment or side menu
// @param activeUserCount The number of recently active users of the bot
func NewUserTypeBot(canBeEdited bool, canJoinGroups bool, canReadAllGroupMessages bool, hasMainWebApp bool, isInline bool, inlineQueryPlaceholder string, needLocation bool, canConnectToBusiness bool, canBeAddedToAttachmentMenu bool, activeUserCount int32) *UserTypeBot {
	userTypeBotTemp := UserTypeBot{
		tdCommon:                   tdCommon{Type: "userTypeBot"},
		CanBeEdited:                canBeEdited,
		CanJoinGroups:              canJoinGroups,
		CanReadAllGroupMessages:    canReadAllGroupMessages,
		HasMainWebApp:              hasMainWebApp,
		IsInline:                   isInline,
		InlineQueryPlaceholder:     inlineQueryPlaceholder,
		NeedLocation:               needLocation,
		CanConnectToBusiness:       canConnectToBusiness,
		CanBeAddedToAttachmentMenu: canBeAddedToAttachmentMenu,
		ActiveUserCount:            activeUserCount,
	}

	return &userTypeBotTemp
}

// UnmarshalJSON unmarshal to json
func (userTypeBot *UserTypeBot) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CanBeEdited                bool   `json:"can_be_edited"`                   // True, if the bot is owned by the current user and can be edited using the methods toggleBotUsernameIsActive, reorderBotActiveUsernames, setBotProfilePhoto, setBotName, setBotInfoDescription, and setBotInfoShortDescription
		CanJoinGroups              bool   `json:"can_join_groups"`                 // True, if the bot can be invited to basic group and supergroup chats
		CanReadAllGroupMessages    bool   `json:"can_read_all_group_messages"`     // True, if the bot can read all messages in basic group or supergroup chats and not just those addressed to the bot. In private and channel chats a bot can always read all messages
		HasMainWebApp              bool   `json:"has_main_web_app"`                // True, if the bot has the main Web App
		IsInline                   bool   `json:"is_inline"`                       // True, if the bot supports inline queries
		InlineQueryPlaceholder     string `json:"inline_query_placeholder"`        // Placeholder for inline queries (displayed on the application input field)
		NeedLocation               bool   `json:"need_location"`                   // True, if the location of the user is expected to be sent with every inline query to this bot
		CanConnectToBusiness       bool   `json:"can_connect_to_business"`         // True, if the bot supports connection to Telegram Business accounts
		CanBeAddedToAttachmentMenu bool   `json:"can_be_added_to_attachment_menu"` // True, if the bot can be added to attachment or side menu
		ActiveUserCount            int32  `json:"active_user_count"`               // The number of recently active users of the bot
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userTypeBot.tdCommon = tempObj.tdCommon
	userTypeBot.CanBeEdited = tempObj.CanBeEdited
	userTypeBot.CanJoinGroups = tempObj.CanJoinGroups
	userTypeBot.CanReadAllGroupMessages = tempObj.CanReadAllGroupMessages
	userTypeBot.HasMainWebApp = tempObj.HasMainWebApp
	userTypeBot.IsInline = tempObj.IsInline
	userTypeBot.InlineQueryPlaceholder = tempObj.InlineQueryPlaceholder
	userTypeBot.NeedLocation = tempObj.NeedLocation
	userTypeBot.CanConnectToBusiness = tempObj.CanConnectToBusiness
	userTypeBot.CanBeAddedToAttachmentMenu = tempObj.CanBeAddedToAttachmentMenu
	userTypeBot.ActiveUserCount = tempObj.ActiveUserCount

	return nil
}

// GetUserTypeEnum return the enum type of this object
func (userTypeBot *UserTypeBot) GetUserTypeEnum() UserTypeEnum {
	return UserTypeBotType
}

// UserTypeUnknown No information on the user besides the user identifier is available, yet this user has not been deleted. This object is extremely rare and must be handled like a deleted user. It is not possible to perform any actions on users of this type
type UserTypeUnknown struct {
	tdCommon
}

// MessageType return the string telegram-type of UserTypeUnknown
func (userTypeUnknown *UserTypeUnknown) MessageType() string {
	return "userTypeUnknown"
}

// NewUserTypeUnknown creates a new UserTypeUnknown
//
func NewUserTypeUnknown() *UserTypeUnknown {
	userTypeUnknownTemp := UserTypeUnknown{
		tdCommon: tdCommon{Type: "userTypeUnknown"},
	}

	return &userTypeUnknownTemp
}

// UnmarshalJSON unmarshal to json
func (userTypeUnknown *UserTypeUnknown) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userTypeUnknown.tdCommon = tempObj.tdCommon

	return nil
}

// GetUserTypeEnum return the enum type of this object
func (userTypeUnknown *UserTypeUnknown) GetUserTypeEnum() UserTypeEnum {
	return UserTypeUnknownType
}

// BotCommand Represents a command supported by a bot
type BotCommand struct {
	tdCommon
	Command     string `json:"command"`     // Text of the bot command
	Description string `json:"description"` // Description of the bot command
}

// MessageType return the string telegram-type of BotCommand
func (botCommand *BotCommand) MessageType() string {
	return "botCommand"
}

// NewBotCommand creates a new BotCommand
//
// @param command Text of the bot command
// @param description Description of the bot command
func NewBotCommand(command string, description string) *BotCommand {
	botCommandTemp := BotCommand{
		tdCommon:    tdCommon{Type: "botCommand"},
		Command:     command,
		Description: description,
	}

	return &botCommandTemp
}

// UnmarshalJSON unmarshal to json
func (botCommand *BotCommand) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Command     string `json:"command"`     // Text of the bot command
		Description string `json:"description"` // Description of the bot command
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	botCommand.tdCommon = tempObj.tdCommon
	botCommand.Command = tempObj.Command
	botCommand.Description = tempObj.Description

	return nil
}

// BotCommands Contains a list of bot commands
type BotCommands struct {
	tdCommon
	BotUserID int64        `json:"bot_user_id"` // Bot's user identifier
	Commands  []BotCommand `json:"commands"`    // List of bot commands
}

// MessageType return the string telegram-type of BotCommands
func (botCommands *BotCommands) MessageType() string {
	return "botCommands"
}

// NewBotCommands creates a new BotCommands
//
// @param botUserID Bot's user identifier
// @param commands List of bot commands
func NewBotCommands(botUserID int64, commands []BotCommand) *BotCommands {
	botCommandsTemp := BotCommands{
		tdCommon:  tdCommon{Type: "botCommands"},
		BotUserID: botUserID,
		Commands:  commands,
	}

	return &botCommandsTemp
}

// UnmarshalJSON unmarshal to json
func (botCommands *BotCommands) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BotUserID int64        `json:"bot_user_id"` // Bot's user identifier
		Commands  []BotCommand `json:"commands"`    // List of bot commands
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	botCommands.tdCommon = tempObj.tdCommon
	botCommands.BotUserID = tempObj.BotUserID
	botCommands.Commands = tempObj.Commands

	return nil
}

// BotMenuButton Describes a button to be shown instead of bot commands menu button
type BotMenuButton struct {
	tdCommon
	Text string `json:"text"` // Text of the button
	URL  string `json:"url"`  // URL of a Web App to open when the button is pressed. If the link is of the type internalLinkTypeWebApp, then it must be processed accordingly. Otherwise, the link must be passed to openWebApp
}

// MessageType return the string telegram-type of BotMenuButton
func (botMenuButton *BotMenuButton) MessageType() string {
	return "botMenuButton"
}

// NewBotMenuButton creates a new BotMenuButton
//
// @param text Text of the button
// @param uRL URL of a Web App to open when the button is pressed. If the link is of the type internalLinkTypeWebApp, then it must be processed accordingly. Otherwise, the link must be passed to openWebApp
func NewBotMenuButton(text string, uRL string) *BotMenuButton {
	botMenuButtonTemp := BotMenuButton{
		tdCommon: tdCommon{Type: "botMenuButton"},
		Text:     text,
		URL:      uRL,
	}

	return &botMenuButtonTemp
}

// UnmarshalJSON unmarshal to json
func (botMenuButton *BotMenuButton) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Text string `json:"text"` // Text of the button
		URL  string `json:"url"`  // URL of a Web App to open when the button is pressed. If the link is of the type internalLinkTypeWebApp, then it must be processed accordingly. Otherwise, the link must be passed to openWebApp
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	botMenuButton.tdCommon = tempObj.tdCommon
	botMenuButton.Text = tempObj.Text
	botMenuButton.URL = tempObj.URL

	return nil
}

// ChatLocation Represents a location to which a chat is connected
type ChatLocation struct {
	tdCommon
	Location *Location `json:"location"` // The location
	Address  string    `json:"address"`  // Location address; 1-64 characters, as defined by the chat owner
}

// MessageType return the string telegram-type of ChatLocation
func (chatLocation *ChatLocation) MessageType() string {
	return "chatLocation"
}

// NewChatLocation creates a new ChatLocation
//
// @param location The location
// @param address Location address; 1-64 characters, as defined by the chat owner
func NewChatLocation(location *Location, address string) *ChatLocation {
	chatLocationTemp := ChatLocation{
		tdCommon: tdCommon{Type: "chatLocation"},
		Location: location,
		Address:  address,
	}

	return &chatLocationTemp
}

// UnmarshalJSON unmarshal to json
func (chatLocation *ChatLocation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Location *Location `json:"location"` // The location
		Address  string    `json:"address"`  // Location address; 1-64 characters, as defined by the chat owner
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatLocation.tdCommon = tempObj.tdCommon
	chatLocation.Location = tempObj.Location
	chatLocation.Address = tempObj.Address

	return nil
}

// Birthdate Represents a birthdate of a user
type Birthdate struct {
	tdCommon
	Day   int32 `json:"day"`   // Day of the month; 1-31
	Month int32 `json:"month"` // Month of the year; 1-12
	Year  int32 `json:"year"`  // Birth year; 0 if unknown
}

// MessageType return the string telegram-type of Birthdate
func (birthdate *Birthdate) MessageType() string {
	return "birthdate"
}

// NewBirthdate creates a new Birthdate
//
// @param day Day of the month; 1-31
// @param month Month of the year; 1-12
// @param year Birth year; 0 if unknown
func NewBirthdate(day int32, month int32, year int32) *Birthdate {
	birthdateTemp := Birthdate{
		tdCommon: tdCommon{Type: "birthdate"},
		Day:      day,
		Month:    month,
		Year:     year,
	}

	return &birthdateTemp
}

// UnmarshalJSON unmarshal to json
func (birthdate *Birthdate) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Day   int32 `json:"day"`   // Day of the month; 1-31
		Month int32 `json:"month"` // Month of the year; 1-12
		Year  int32 `json:"year"`  // Birth year; 0 if unknown
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	birthdate.tdCommon = tempObj.tdCommon
	birthdate.Day = tempObj.Day
	birthdate.Month = tempObj.Month
	birthdate.Year = tempObj.Year

	return nil
}

// CloseBirthdayUser Describes a user that had or will have a birthday soon
type CloseBirthdayUser struct {
	tdCommon
	UserID    int64      `json:"user_id"`   // User identifier
	Birthdate *Birthdate `json:"birthdate"` // Birthdate of the user
}

// MessageType return the string telegram-type of CloseBirthdayUser
func (closeBirthdayUser *CloseBirthdayUser) MessageType() string {
	return "closeBirthdayUser"
}

// NewCloseBirthdayUser creates a new CloseBirthdayUser
//
// @param userID User identifier
// @param birthdate Birthdate of the user
func NewCloseBirthdayUser(userID int64, birthdate *Birthdate) *CloseBirthdayUser {
	closeBirthdayUserTemp := CloseBirthdayUser{
		tdCommon:  tdCommon{Type: "closeBirthdayUser"},
		UserID:    userID,
		Birthdate: birthdate,
	}

	return &closeBirthdayUserTemp
}

// UnmarshalJSON unmarshal to json
func (closeBirthdayUser *CloseBirthdayUser) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID    int64      `json:"user_id"`   // User identifier
		Birthdate *Birthdate `json:"birthdate"` // Birthdate of the user
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	closeBirthdayUser.tdCommon = tempObj.tdCommon
	closeBirthdayUser.UserID = tempObj.UserID
	closeBirthdayUser.Birthdate = tempObj.Birthdate

	return nil
}

// BusinessAwayMessageScheduleAlways Send away messages always
type BusinessAwayMessageScheduleAlways struct {
	tdCommon
}

// MessageType return the string telegram-type of BusinessAwayMessageScheduleAlways
func (businessAwayMessageScheduleAlways *BusinessAwayMessageScheduleAlways) MessageType() string {
	return "businessAwayMessageScheduleAlways"
}

// NewBusinessAwayMessageScheduleAlways creates a new BusinessAwayMessageScheduleAlways
//
func NewBusinessAwayMessageScheduleAlways() *BusinessAwayMessageScheduleAlways {
	businessAwayMessageScheduleAlwaysTemp := BusinessAwayMessageScheduleAlways{
		tdCommon: tdCommon{Type: "businessAwayMessageScheduleAlways"},
	}

	return &businessAwayMessageScheduleAlwaysTemp
}

// UnmarshalJSON unmarshal to json
func (businessAwayMessageScheduleAlways *BusinessAwayMessageScheduleAlways) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessAwayMessageScheduleAlways.tdCommon = tempObj.tdCommon

	return nil
}

// GetBusinessAwayMessageScheduleEnum return the enum type of this object
func (businessAwayMessageScheduleAlways *BusinessAwayMessageScheduleAlways) GetBusinessAwayMessageScheduleEnum() BusinessAwayMessageScheduleEnum {
	return BusinessAwayMessageScheduleAlwaysType
}

// BusinessAwayMessageScheduleOutsideOfOpeningHours Send away messages outside of the business opening hours
type BusinessAwayMessageScheduleOutsideOfOpeningHours struct {
	tdCommon
}

// MessageType return the string telegram-type of BusinessAwayMessageScheduleOutsideOfOpeningHours
func (businessAwayMessageScheduleOutsideOfOpeningHours *BusinessAwayMessageScheduleOutsideOfOpeningHours) MessageType() string {
	return "businessAwayMessageScheduleOutsideOfOpeningHours"
}

// NewBusinessAwayMessageScheduleOutsideOfOpeningHours creates a new BusinessAwayMessageScheduleOutsideOfOpeningHours
//
func NewBusinessAwayMessageScheduleOutsideOfOpeningHours() *BusinessAwayMessageScheduleOutsideOfOpeningHours {
	businessAwayMessageScheduleOutsideOfOpeningHoursTemp := BusinessAwayMessageScheduleOutsideOfOpeningHours{
		tdCommon: tdCommon{Type: "businessAwayMessageScheduleOutsideOfOpeningHours"},
	}

	return &businessAwayMessageScheduleOutsideOfOpeningHoursTemp
}

// UnmarshalJSON unmarshal to json
func (businessAwayMessageScheduleOutsideOfOpeningHours *BusinessAwayMessageScheduleOutsideOfOpeningHours) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessAwayMessageScheduleOutsideOfOpeningHours.tdCommon = tempObj.tdCommon

	return nil
}

// GetBusinessAwayMessageScheduleEnum return the enum type of this object
func (businessAwayMessageScheduleOutsideOfOpeningHours *BusinessAwayMessageScheduleOutsideOfOpeningHours) GetBusinessAwayMessageScheduleEnum() BusinessAwayMessageScheduleEnum {
	return BusinessAwayMessageScheduleOutsideOfOpeningHoursType
}

// BusinessAwayMessageScheduleCustom Send away messages only in the specified time span
type BusinessAwayMessageScheduleCustom struct {
	tdCommon
	StartDate int32 `json:"start_date"` // Point in time (Unix timestamp) when the away messages will start to be sent
	EndDate   int32 `json:"end_date"`   // Point in time (Unix timestamp) when the away messages will stop to be sent
}

// MessageType return the string telegram-type of BusinessAwayMessageScheduleCustom
func (businessAwayMessageScheduleCustom *BusinessAwayMessageScheduleCustom) MessageType() string {
	return "businessAwayMessageScheduleCustom"
}

// NewBusinessAwayMessageScheduleCustom creates a new BusinessAwayMessageScheduleCustom
//
// @param startDate Point in time (Unix timestamp) when the away messages will start to be sent
// @param endDate Point in time (Unix timestamp) when the away messages will stop to be sent
func NewBusinessAwayMessageScheduleCustom(startDate int32, endDate int32) *BusinessAwayMessageScheduleCustom {
	businessAwayMessageScheduleCustomTemp := BusinessAwayMessageScheduleCustom{
		tdCommon:  tdCommon{Type: "businessAwayMessageScheduleCustom"},
		StartDate: startDate,
		EndDate:   endDate,
	}

	return &businessAwayMessageScheduleCustomTemp
}

// UnmarshalJSON unmarshal to json
func (businessAwayMessageScheduleCustom *BusinessAwayMessageScheduleCustom) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StartDate int32 `json:"start_date"` // Point in time (Unix timestamp) when the away messages will start to be sent
		EndDate   int32 `json:"end_date"`   // Point in time (Unix timestamp) when the away messages will stop to be sent
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessAwayMessageScheduleCustom.tdCommon = tempObj.tdCommon
	businessAwayMessageScheduleCustom.StartDate = tempObj.StartDate
	businessAwayMessageScheduleCustom.EndDate = tempObj.EndDate

	return nil
}

// GetBusinessAwayMessageScheduleEnum return the enum type of this object
func (businessAwayMessageScheduleCustom *BusinessAwayMessageScheduleCustom) GetBusinessAwayMessageScheduleEnum() BusinessAwayMessageScheduleEnum {
	return BusinessAwayMessageScheduleCustomType
}

// BusinessLocation Represents a location of a business
type BusinessLocation struct {
	tdCommon
	Location *Location `json:"location"` // The location; may be null if not specified
	Address  string    `json:"address"`  // Location address; 1-96 characters
}

// MessageType return the string telegram-type of BusinessLocation
func (businessLocation *BusinessLocation) MessageType() string {
	return "businessLocation"
}

// NewBusinessLocation creates a new BusinessLocation
//
// @param location The location; may be null if not specified
// @param address Location address; 1-96 characters
func NewBusinessLocation(location *Location, address string) *BusinessLocation {
	businessLocationTemp := BusinessLocation{
		tdCommon: tdCommon{Type: "businessLocation"},
		Location: location,
		Address:  address,
	}

	return &businessLocationTemp
}

// UnmarshalJSON unmarshal to json
func (businessLocation *BusinessLocation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Location *Location `json:"location"` // The location; may be null if not specified
		Address  string    `json:"address"`  // Location address; 1-96 characters
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessLocation.tdCommon = tempObj.tdCommon
	businessLocation.Location = tempObj.Location
	businessLocation.Address = tempObj.Address

	return nil
}

// BusinessRecipients Describes private chats chosen for automatic interaction with a business
type BusinessRecipients struct {
	tdCommon
	ChatIDs             []int64 `json:"chat_ids"`              // Identifiers of selected private chats
	ExcludedChatIDs     []int64 `json:"excluded_chat_ids"`     // Identifiers of private chats that are always excluded; for businessConnectedBot only
	SelectExistingChats bool    `json:"select_existing_chats"` // True, if all existing private chats are selected
	SelectNewChats      bool    `json:"select_new_chats"`      // True, if all new private chats are selected
	SelectContacts      bool    `json:"select_contacts"`       // True, if all private chats with contacts are selected
	SelectNonContacts   bool    `json:"select_non_contacts"`   // True, if all private chats with non-contacts are selected
	ExcludeSelected     bool    `json:"exclude_selected"`      // If true, then all private chats except the selected are chosen. Otherwise, only the selected chats are chosen
}

// MessageType return the string telegram-type of BusinessRecipients
func (businessRecipients *BusinessRecipients) MessageType() string {
	return "businessRecipients"
}

// NewBusinessRecipients creates a new BusinessRecipients
//
// @param chatIDs Identifiers of selected private chats
// @param excludedChatIDs Identifiers of private chats that are always excluded; for businessConnectedBot only
// @param selectExistingChats True, if all existing private chats are selected
// @param selectNewChats True, if all new private chats are selected
// @param selectContacts True, if all private chats with contacts are selected
// @param selectNonContacts True, if all private chats with non-contacts are selected
// @param excludeSelected If true, then all private chats except the selected are chosen. Otherwise, only the selected chats are chosen
func NewBusinessRecipients(chatIDs []int64, excludedChatIDs []int64, selectExistingChats bool, selectNewChats bool, selectContacts bool, selectNonContacts bool, excludeSelected bool) *BusinessRecipients {
	businessRecipientsTemp := BusinessRecipients{
		tdCommon:            tdCommon{Type: "businessRecipients"},
		ChatIDs:             chatIDs,
		ExcludedChatIDs:     excludedChatIDs,
		SelectExistingChats: selectExistingChats,
		SelectNewChats:      selectNewChats,
		SelectContacts:      selectContacts,
		SelectNonContacts:   selectNonContacts,
		ExcludeSelected:     excludeSelected,
	}

	return &businessRecipientsTemp
}

// UnmarshalJSON unmarshal to json
func (businessRecipients *BusinessRecipients) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatIDs             []int64 `json:"chat_ids"`              // Identifiers of selected private chats
		ExcludedChatIDs     []int64 `json:"excluded_chat_ids"`     // Identifiers of private chats that are always excluded; for businessConnectedBot only
		SelectExistingChats bool    `json:"select_existing_chats"` // True, if all existing private chats are selected
		SelectNewChats      bool    `json:"select_new_chats"`      // True, if all new private chats are selected
		SelectContacts      bool    `json:"select_contacts"`       // True, if all private chats with contacts are selected
		SelectNonContacts   bool    `json:"select_non_contacts"`   // True, if all private chats with non-contacts are selected
		ExcludeSelected     bool    `json:"exclude_selected"`      // If true, then all private chats except the selected are chosen. Otherwise, only the selected chats are chosen
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessRecipients.tdCommon = tempObj.tdCommon
	businessRecipients.ChatIDs = tempObj.ChatIDs
	businessRecipients.ExcludedChatIDs = tempObj.ExcludedChatIDs
	businessRecipients.SelectExistingChats = tempObj.SelectExistingChats
	businessRecipients.SelectNewChats = tempObj.SelectNewChats
	businessRecipients.SelectContacts = tempObj.SelectContacts
	businessRecipients.SelectNonContacts = tempObj.SelectNonContacts
	businessRecipients.ExcludeSelected = tempObj.ExcludeSelected

	return nil
}

// BusinessAwayMessageSettings Describes settings for messages that are automatically sent by a Telegram Business account when it is away
type BusinessAwayMessageSettings struct {
	tdCommon
	ShortcutID  int32                       `json:"shortcut_id"`  // Unique quick reply shortcut identifier for the away messages
	Recipients  *BusinessRecipients         `json:"recipients"`   // Chosen recipients of the away messages
	Schedule    BusinessAwayMessageSchedule `json:"schedule"`     // Settings used to check whether the current user is away
	OfflineOnly bool                        `json:"offline_only"` // True, if the messages must not be sent if the account was online in the last 10 minutes
}

// MessageType return the string telegram-type of BusinessAwayMessageSettings
func (businessAwayMessageSettings *BusinessAwayMessageSettings) MessageType() string {
	return "businessAwayMessageSettings"
}

// NewBusinessAwayMessageSettings creates a new BusinessAwayMessageSettings
//
// @param shortcutID Unique quick reply shortcut identifier for the away messages
// @param recipients Chosen recipients of the away messages
// @param schedule Settings used to check whether the current user is away
// @param offlineOnly True, if the messages must not be sent if the account was online in the last 10 minutes
func NewBusinessAwayMessageSettings(shortcutID int32, recipients *BusinessRecipients, schedule BusinessAwayMessageSchedule, offlineOnly bool) *BusinessAwayMessageSettings {
	businessAwayMessageSettingsTemp := BusinessAwayMessageSettings{
		tdCommon:    tdCommon{Type: "businessAwayMessageSettings"},
		ShortcutID:  shortcutID,
		Recipients:  recipients,
		Schedule:    schedule,
		OfflineOnly: offlineOnly,
	}

	return &businessAwayMessageSettingsTemp
}

// UnmarshalJSON unmarshal to json
func (businessAwayMessageSettings *BusinessAwayMessageSettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ShortcutID  int32               `json:"shortcut_id"`  // Unique quick reply shortcut identifier for the away messages
		Recipients  *BusinessRecipients `json:"recipients"`   // Chosen recipients of the away messages
		OfflineOnly bool                `json:"offline_only"` // True, if the messages must not be sent if the account was online in the last 10 minutes
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessAwayMessageSettings.tdCommon = tempObj.tdCommon
	businessAwayMessageSettings.ShortcutID = tempObj.ShortcutID
	businessAwayMessageSettings.Recipients = tempObj.Recipients
	businessAwayMessageSettings.OfflineOnly = tempObj.OfflineOnly

	fieldSchedule, _ := unmarshalBusinessAwayMessageSchedule(objMap["schedule"])
	businessAwayMessageSettings.Schedule = fieldSchedule

	return nil
}

// BusinessGreetingMessageSettings Describes settings for greeting messages that are automatically sent by a Telegram Business account as response to incoming messages in an inactive private chat
type BusinessGreetingMessageSettings struct {
	tdCommon
	ShortcutID     int32               `json:"shortcut_id"`     // Unique quick reply shortcut identifier for the greeting messages
	Recipients     *BusinessRecipients `json:"recipients"`      // Chosen recipients of the greeting messages
	InactivityDays int32               `json:"inactivity_days"` // The number of days after which a chat will be considered as inactive; currently, must be on of 7, 14, 21, or 28
}

// MessageType return the string telegram-type of BusinessGreetingMessageSettings
func (businessGreetingMessageSettings *BusinessGreetingMessageSettings) MessageType() string {
	return "businessGreetingMessageSettings"
}

// NewBusinessGreetingMessageSettings creates a new BusinessGreetingMessageSettings
//
// @param shortcutID Unique quick reply shortcut identifier for the greeting messages
// @param recipients Chosen recipients of the greeting messages
// @param inactivityDays The number of days after which a chat will be considered as inactive; currently, must be on of 7, 14, 21, or 28
func NewBusinessGreetingMessageSettings(shortcutID int32, recipients *BusinessRecipients, inactivityDays int32) *BusinessGreetingMessageSettings {
	businessGreetingMessageSettingsTemp := BusinessGreetingMessageSettings{
		tdCommon:       tdCommon{Type: "businessGreetingMessageSettings"},
		ShortcutID:     shortcutID,
		Recipients:     recipients,
		InactivityDays: inactivityDays,
	}

	return &businessGreetingMessageSettingsTemp
}

// UnmarshalJSON unmarshal to json
func (businessGreetingMessageSettings *BusinessGreetingMessageSettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ShortcutID     int32               `json:"shortcut_id"`     // Unique quick reply shortcut identifier for the greeting messages
		Recipients     *BusinessRecipients `json:"recipients"`      // Chosen recipients of the greeting messages
		InactivityDays int32               `json:"inactivity_days"` // The number of days after which a chat will be considered as inactive; currently, must be on of 7, 14, 21, or 28
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessGreetingMessageSettings.tdCommon = tempObj.tdCommon
	businessGreetingMessageSettings.ShortcutID = tempObj.ShortcutID
	businessGreetingMessageSettings.Recipients = tempObj.Recipients
	businessGreetingMessageSettings.InactivityDays = tempObj.InactivityDays

	return nil
}

// BusinessConnectedBot Describes a bot connected to a business account
type BusinessConnectedBot struct {
	tdCommon
	BotUserID  int64               `json:"bot_user_id"` // User identifier of the bot
	Recipients *BusinessRecipients `json:"recipients"`  // Private chats that will be accessible to the bot
	CanReply   bool                `json:"can_reply"`   // True, if the bot can send messages to the private chats; false otherwise
}

// MessageType return the string telegram-type of BusinessConnectedBot
func (businessConnectedBot *BusinessConnectedBot) MessageType() string {
	return "businessConnectedBot"
}

// NewBusinessConnectedBot creates a new BusinessConnectedBot
//
// @param botUserID User identifier of the bot
// @param recipients Private chats that will be accessible to the bot
// @param canReply True, if the bot can send messages to the private chats; false otherwise
func NewBusinessConnectedBot(botUserID int64, recipients *BusinessRecipients, canReply bool) *BusinessConnectedBot {
	businessConnectedBotTemp := BusinessConnectedBot{
		tdCommon:   tdCommon{Type: "businessConnectedBot"},
		BotUserID:  botUserID,
		Recipients: recipients,
		CanReply:   canReply,
	}

	return &businessConnectedBotTemp
}

// UnmarshalJSON unmarshal to json
func (businessConnectedBot *BusinessConnectedBot) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BotUserID  int64               `json:"bot_user_id"` // User identifier of the bot
		Recipients *BusinessRecipients `json:"recipients"`  // Private chats that will be accessible to the bot
		CanReply   bool                `json:"can_reply"`   // True, if the bot can send messages to the private chats; false otherwise
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessConnectedBot.tdCommon = tempObj.tdCommon
	businessConnectedBot.BotUserID = tempObj.BotUserID
	businessConnectedBot.Recipients = tempObj.Recipients
	businessConnectedBot.CanReply = tempObj.CanReply

	return nil
}

// BusinessStartPage Describes settings for a business account start page
type BusinessStartPage struct {
	tdCommon
	Title   string   `json:"title"`   // Title text of the start page
	Message string   `json:"message"` // Message text of the start page
	Sticker *Sticker `json:"sticker"` // Greeting sticker of the start page; may be null if none
}

// MessageType return the string telegram-type of BusinessStartPage
func (businessStartPage *BusinessStartPage) MessageType() string {
	return "businessStartPage"
}

// NewBusinessStartPage creates a new BusinessStartPage
//
// @param title Title text of the start page
// @param message Message text of the start page
// @param sticker Greeting sticker of the start page; may be null if none
func NewBusinessStartPage(title string, message string, sticker *Sticker) *BusinessStartPage {
	businessStartPageTemp := BusinessStartPage{
		tdCommon: tdCommon{Type: "businessStartPage"},
		Title:    title,
		Message:  message,
		Sticker:  sticker,
	}

	return &businessStartPageTemp
}

// UnmarshalJSON unmarshal to json
func (businessStartPage *BusinessStartPage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Title   string `json:"title"`   // Title text of the start page
		Message string `json:"message"` // Message text of the start page

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessStartPage.tdCommon = tempObj.tdCommon
	businessStartPage.Title = tempObj.Title
	businessStartPage.Message = tempObj.Message

	var sticker Sticker
	if objMap["sticker"] != nil {
		err = sticker.UnmarshalJSON(*objMap["sticker"])
		if err != nil {
			return err
		}
	}

	businessStartPage.Sticker = &sticker

	return nil
}

// InputBusinessStartPage Describes settings for a business account start page to set
type InputBusinessStartPage struct {
	tdCommon
	Title   string    `json:"title"`   // Title text of the start page; 0-getOption("business_start_page_title_length_max") characters
	Message string    `json:"message"` // Message text of the start page; 0-getOption("business_start_page_message_length_max") characters
	Sticker InputFile `json:"sticker"` // Greeting sticker of the start page; pass null if none. The sticker must belong to a sticker set and must not be a custom emoji
}

// MessageType return the string telegram-type of InputBusinessStartPage
func (inputBusinessStartPage *InputBusinessStartPage) MessageType() string {
	return "inputBusinessStartPage"
}

// NewInputBusinessStartPage creates a new InputBusinessStartPage
//
// @param title Title text of the start page; 0-getOption("business_start_page_title_length_max") characters
// @param message Message text of the start page; 0-getOption("business_start_page_message_length_max") characters
// @param sticker Greeting sticker of the start page; pass null if none. The sticker must belong to a sticker set and must not be a custom emoji
func NewInputBusinessStartPage(title string, message string, sticker InputFile) *InputBusinessStartPage {
	inputBusinessStartPageTemp := InputBusinessStartPage{
		tdCommon: tdCommon{Type: "inputBusinessStartPage"},
		Title:    title,
		Message:  message,
		Sticker:  sticker,
	}

	return &inputBusinessStartPageTemp
}

// UnmarshalJSON unmarshal to json
func (inputBusinessStartPage *InputBusinessStartPage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Title   string `json:"title"`   // Title text of the start page; 0-getOption("business_start_page_title_length_max") characters
		Message string `json:"message"` // Message text of the start page; 0-getOption("business_start_page_message_length_max") characters

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputBusinessStartPage.tdCommon = tempObj.tdCommon
	inputBusinessStartPage.Title = tempObj.Title
	inputBusinessStartPage.Message = tempObj.Message

	fieldSticker, _ := unmarshalInputFile(objMap["sticker"])
	inputBusinessStartPage.Sticker = fieldSticker

	return nil
}

// BusinessOpeningHoursInterval Describes an interval of time when the business is open
type BusinessOpeningHoursInterval struct {
	tdCommon
	StartMinute int32 `json:"start_minute"` // The minute's sequence number in a week, starting on Monday, marking the start of the time interval during which the business is open; 0-7*24*60
	EndMinute   int32 `json:"end_minute"`   // The minute's sequence number in a week, starting on Monday, marking the end of the time interval during which the business is open; 1-8*24*60
}

// MessageType return the string telegram-type of BusinessOpeningHoursInterval
func (businessOpeningHoursInterval *BusinessOpeningHoursInterval) MessageType() string {
	return "businessOpeningHoursInterval"
}

// NewBusinessOpeningHoursInterval creates a new BusinessOpeningHoursInterval
//
// @param startMinute The minute's sequence number in a week, starting on Monday, marking the start of the time interval during which the business is open; 0-7*24*60
// @param endMinute The minute's sequence number in a week, starting on Monday, marking the end of the time interval during which the business is open; 1-8*24*60
func NewBusinessOpeningHoursInterval(startMinute int32, endMinute int32) *BusinessOpeningHoursInterval {
	businessOpeningHoursIntervalTemp := BusinessOpeningHoursInterval{
		tdCommon:    tdCommon{Type: "businessOpeningHoursInterval"},
		StartMinute: startMinute,
		EndMinute:   endMinute,
	}

	return &businessOpeningHoursIntervalTemp
}

// UnmarshalJSON unmarshal to json
func (businessOpeningHoursInterval *BusinessOpeningHoursInterval) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StartMinute int32 `json:"start_minute"` // The minute's sequence number in a week, starting on Monday, marking the start of the time interval during which the business is open; 0-7*24*60
		EndMinute   int32 `json:"end_minute"`   // The minute's sequence number in a week, starting on Monday, marking the end of the time interval during which the business is open; 1-8*24*60
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessOpeningHoursInterval.tdCommon = tempObj.tdCommon
	businessOpeningHoursInterval.StartMinute = tempObj.StartMinute
	businessOpeningHoursInterval.EndMinute = tempObj.EndMinute

	return nil
}

// BusinessOpeningHours Describes opening hours of a business
type BusinessOpeningHours struct {
	tdCommon
	TimeZoneID   string                         `json:"time_zone_id"`  // Unique time zone identifier
	OpeningHours []BusinessOpeningHoursInterval `json:"opening_hours"` // Intervals of the time when the business is open
}

// MessageType return the string telegram-type of BusinessOpeningHours
func (businessOpeningHours *BusinessOpeningHours) MessageType() string {
	return "businessOpeningHours"
}

// NewBusinessOpeningHours creates a new BusinessOpeningHours
//
// @param timeZoneID Unique time zone identifier
// @param openingHours Intervals of the time when the business is open
func NewBusinessOpeningHours(timeZoneID string, openingHours []BusinessOpeningHoursInterval) *BusinessOpeningHours {
	businessOpeningHoursTemp := BusinessOpeningHours{
		tdCommon:     tdCommon{Type: "businessOpeningHours"},
		TimeZoneID:   timeZoneID,
		OpeningHours: openingHours,
	}

	return &businessOpeningHoursTemp
}

// UnmarshalJSON unmarshal to json
func (businessOpeningHours *BusinessOpeningHours) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TimeZoneID   string                         `json:"time_zone_id"`  // Unique time zone identifier
		OpeningHours []BusinessOpeningHoursInterval `json:"opening_hours"` // Intervals of the time when the business is open
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessOpeningHours.tdCommon = tempObj.tdCommon
	businessOpeningHours.TimeZoneID = tempObj.TimeZoneID
	businessOpeningHours.OpeningHours = tempObj.OpeningHours

	return nil
}

// BusinessInfo Contains information about a Telegram Business account
type BusinessInfo struct {
	tdCommon
	Location                *BusinessLocation                `json:"location"`                  // Location of the business; may be null if none
	OpeningHours            *BusinessOpeningHours            `json:"opening_hours"`             // Opening hours of the business; may be null if none. The hours are guaranteed to be valid and has already been split by week days
	LocalOpeningHours       *BusinessOpeningHours            `json:"local_opening_hours"`       // Opening hours of the business in the local time; may be null if none. The hours are guaranteed to be valid and has already been split by week days. Local time zone identifier will be empty. An updateUserFullInfo update is not triggered when value of this field changes
	NextOpenIn              int32                            `json:"next_open_in"`              // Time left before the business will open the next time, in seconds; 0 if unknown. An updateUserFullInfo update is not triggered when value of this field changes
	NextCloseIn             int32                            `json:"next_close_in"`             // Time left before the business will close the next time, in seconds; 0 if unknown. An updateUserFullInfo update is not triggered when value of this field changes
	GreetingMessageSettings *BusinessGreetingMessageSettings `json:"greeting_message_settings"` // The greeting message; may be null if none or the Business account is not of the current user
	AwayMessageSettings     *BusinessAwayMessageSettings     `json:"away_message_settings"`     // The away message; may be null if none or the Business account is not of the current user
	StartPage               *BusinessStartPage               `json:"start_page"`                // Information about start page of the account; may be null if none
}

// MessageType return the string telegram-type of BusinessInfo
func (businessInfo *BusinessInfo) MessageType() string {
	return "businessInfo"
}

// NewBusinessInfo creates a new BusinessInfo
//
// @param location Location of the business; may be null if none
// @param openingHours Opening hours of the business; may be null if none. The hours are guaranteed to be valid and has already been split by week days
// @param localOpeningHours Opening hours of the business in the local time; may be null if none. The hours are guaranteed to be valid and has already been split by week days. Local time zone identifier will be empty. An updateUserFullInfo update is not triggered when value of this field changes
// @param nextOpenIn Time left before the business will open the next time, in seconds; 0 if unknown. An updateUserFullInfo update is not triggered when value of this field changes
// @param nextCloseIn Time left before the business will close the next time, in seconds; 0 if unknown. An updateUserFullInfo update is not triggered when value of this field changes
// @param greetingMessageSettings The greeting message; may be null if none or the Business account is not of the current user
// @param awayMessageSettings The away message; may be null if none or the Business account is not of the current user
// @param startPage Information about start page of the account; may be null if none
func NewBusinessInfo(location *BusinessLocation, openingHours *BusinessOpeningHours, localOpeningHours *BusinessOpeningHours, nextOpenIn int32, nextCloseIn int32, greetingMessageSettings *BusinessGreetingMessageSettings, awayMessageSettings *BusinessAwayMessageSettings, startPage *BusinessStartPage) *BusinessInfo {
	businessInfoTemp := BusinessInfo{
		tdCommon:                tdCommon{Type: "businessInfo"},
		Location:                location,
		OpeningHours:            openingHours,
		LocalOpeningHours:       localOpeningHours,
		NextOpenIn:              nextOpenIn,
		NextCloseIn:             nextCloseIn,
		GreetingMessageSettings: greetingMessageSettings,
		AwayMessageSettings:     awayMessageSettings,
		StartPage:               startPage,
	}

	return &businessInfoTemp
}

// UnmarshalJSON unmarshal to json
func (businessInfo *BusinessInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Location                *BusinessLocation                `json:"location"`                  // Location of the business; may be null if none
		OpeningHours            *BusinessOpeningHours            `json:"opening_hours"`             // Opening hours of the business; may be null if none. The hours are guaranteed to be valid and has already been split by week days
		LocalOpeningHours       *BusinessOpeningHours            `json:"local_opening_hours"`       // Opening hours of the business in the local time; may be null if none. The hours are guaranteed to be valid and has already been split by week days. Local time zone identifier will be empty. An updateUserFullInfo update is not triggered when value of this field changes
		NextOpenIn              int32                            `json:"next_open_in"`              // Time left before the business will open the next time, in seconds; 0 if unknown. An updateUserFullInfo update is not triggered when value of this field changes
		NextCloseIn             int32                            `json:"next_close_in"`             // Time left before the business will close the next time, in seconds; 0 if unknown. An updateUserFullInfo update is not triggered when value of this field changes
		GreetingMessageSettings *BusinessGreetingMessageSettings `json:"greeting_message_settings"` // The greeting message; may be null if none or the Business account is not of the current user
		StartPage               *BusinessStartPage               `json:"start_page"`                // Information about start page of the account; may be null if none
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessInfo.tdCommon = tempObj.tdCommon
	businessInfo.Location = tempObj.Location
	businessInfo.OpeningHours = tempObj.OpeningHours
	businessInfo.LocalOpeningHours = tempObj.LocalOpeningHours
	businessInfo.NextOpenIn = tempObj.NextOpenIn
	businessInfo.NextCloseIn = tempObj.NextCloseIn
	businessInfo.GreetingMessageSettings = tempObj.GreetingMessageSettings
	businessInfo.StartPage = tempObj.StartPage

	var awayMessageSettings BusinessAwayMessageSettings
	if objMap["away_message_settings"] != nil {
		err = awayMessageSettings.UnmarshalJSON(*objMap["away_message_settings"])
		if err != nil {
			return err
		}
	}

	businessInfo.AwayMessageSettings = &awayMessageSettings

	return nil
}

// BusinessChatLink Contains information about a business chat link
type BusinessChatLink struct {
	tdCommon
	Link      string         `json:"link"`       // The HTTPS link
	Text      *FormattedText `json:"text"`       // Message draft text that will be added to the input field
	Title     string         `json:"title"`      // Link title
	ViewCount int32          `json:"view_count"` // Number of times the link was used
}

// MessageType return the string telegram-type of BusinessChatLink
func (businessChatLink *BusinessChatLink) MessageType() string {
	return "businessChatLink"
}

// NewBusinessChatLink creates a new BusinessChatLink
//
// @param link The HTTPS link
// @param text Message draft text that will be added to the input field
// @param title Link title
// @param viewCount Number of times the link was used
func NewBusinessChatLink(link string, text *FormattedText, title string, viewCount int32) *BusinessChatLink {
	businessChatLinkTemp := BusinessChatLink{
		tdCommon:  tdCommon{Type: "businessChatLink"},
		Link:      link,
		Text:      text,
		Title:     title,
		ViewCount: viewCount,
	}

	return &businessChatLinkTemp
}

// UnmarshalJSON unmarshal to json
func (businessChatLink *BusinessChatLink) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Link      string         `json:"link"`       // The HTTPS link
		Text      *FormattedText `json:"text"`       // Message draft text that will be added to the input field
		Title     string         `json:"title"`      // Link title
		ViewCount int32          `json:"view_count"` // Number of times the link was used
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessChatLink.tdCommon = tempObj.tdCommon
	businessChatLink.Link = tempObj.Link
	businessChatLink.Text = tempObj.Text
	businessChatLink.Title = tempObj.Title
	businessChatLink.ViewCount = tempObj.ViewCount

	return nil
}

// BusinessChatLinks Contains a list of business chat links created by the user
type BusinessChatLinks struct {
	tdCommon
	Links []BusinessChatLink `json:"links"` // List of links
}

// MessageType return the string telegram-type of BusinessChatLinks
func (businessChatLinks *BusinessChatLinks) MessageType() string {
	return "businessChatLinks"
}

// NewBusinessChatLinks creates a new BusinessChatLinks
//
// @param links List of links
func NewBusinessChatLinks(links []BusinessChatLink) *BusinessChatLinks {
	businessChatLinksTemp := BusinessChatLinks{
		tdCommon: tdCommon{Type: "businessChatLinks"},
		Links:    links,
	}

	return &businessChatLinksTemp
}

// UnmarshalJSON unmarshal to json
func (businessChatLinks *BusinessChatLinks) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Links []BusinessChatLink `json:"links"` // List of links
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessChatLinks.tdCommon = tempObj.tdCommon
	businessChatLinks.Links = tempObj.Links

	return nil
}

// InputBusinessChatLink Describes a business chat link to create or edit
type InputBusinessChatLink struct {
	tdCommon
	Text  *FormattedText `json:"text"`  // Message draft text that will be added to the input field
	Title string         `json:"title"` // Link title
}

// MessageType return the string telegram-type of InputBusinessChatLink
func (inputBusinessChatLink *InputBusinessChatLink) MessageType() string {
	return "inputBusinessChatLink"
}

// NewInputBusinessChatLink creates a new InputBusinessChatLink
//
// @param text Message draft text that will be added to the input field
// @param title Link title
func NewInputBusinessChatLink(text *FormattedText, title string) *InputBusinessChatLink {
	inputBusinessChatLinkTemp := InputBusinessChatLink{
		tdCommon: tdCommon{Type: "inputBusinessChatLink"},
		Text:     text,
		Title:    title,
	}

	return &inputBusinessChatLinkTemp
}

// UnmarshalJSON unmarshal to json
func (inputBusinessChatLink *InputBusinessChatLink) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Text  *FormattedText `json:"text"`  // Message draft text that will be added to the input field
		Title string         `json:"title"` // Link title
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputBusinessChatLink.tdCommon = tempObj.tdCommon
	inputBusinessChatLink.Text = tempObj.Text
	inputBusinessChatLink.Title = tempObj.Title

	return nil
}

// BusinessChatLinkInfo Contains information about a business chat link
type BusinessChatLinkInfo struct {
	tdCommon
	ChatID int64          `json:"chat_id"` // Identifier of the private chat that created the link
	Text   *FormattedText `json:"text"`    // Message draft text that must be added to the input field
}

// MessageType return the string telegram-type of BusinessChatLinkInfo
func (businessChatLinkInfo *BusinessChatLinkInfo) MessageType() string {
	return "businessChatLinkInfo"
}

// NewBusinessChatLinkInfo creates a new BusinessChatLinkInfo
//
// @param chatID Identifier of the private chat that created the link
// @param text Message draft text that must be added to the input field
func NewBusinessChatLinkInfo(chatID int64, text *FormattedText) *BusinessChatLinkInfo {
	businessChatLinkInfoTemp := BusinessChatLinkInfo{
		tdCommon: tdCommon{Type: "businessChatLinkInfo"},
		ChatID:   chatID,
		Text:     text,
	}

	return &businessChatLinkInfoTemp
}

// UnmarshalJSON unmarshal to json
func (businessChatLinkInfo *BusinessChatLinkInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID int64          `json:"chat_id"` // Identifier of the private chat that created the link
		Text   *FormattedText `json:"text"`    // Message draft text that must be added to the input field
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessChatLinkInfo.tdCommon = tempObj.tdCommon
	businessChatLinkInfo.ChatID = tempObj.ChatID
	businessChatLinkInfo.Text = tempObj.Text

	return nil
}

// ChatPhotoStickerTypeRegularOrMask Information about the sticker, which was used to create the chat photo
type ChatPhotoStickerTypeRegularOrMask struct {
	tdCommon
	StickerSetID JSONInt64 `json:"sticker_set_id"` // Sticker set identifier
	StickerID    JSONInt64 `json:"sticker_id"`     // Identifier of the sticker in the set
}

// MessageType return the string telegram-type of ChatPhotoStickerTypeRegularOrMask
func (chatPhotoStickerTypeRegularOrMask *ChatPhotoStickerTypeRegularOrMask) MessageType() string {
	return "chatPhotoStickerTypeRegularOrMask"
}

// NewChatPhotoStickerTypeRegularOrMask creates a new ChatPhotoStickerTypeRegularOrMask
//
// @param stickerSetID Sticker set identifier
// @param stickerID Identifier of the sticker in the set
func NewChatPhotoStickerTypeRegularOrMask(stickerSetID JSONInt64, stickerID JSONInt64) *ChatPhotoStickerTypeRegularOrMask {
	chatPhotoStickerTypeRegularOrMaskTemp := ChatPhotoStickerTypeRegularOrMask{
		tdCommon:     tdCommon{Type: "chatPhotoStickerTypeRegularOrMask"},
		StickerSetID: stickerSetID,
		StickerID:    stickerID,
	}

	return &chatPhotoStickerTypeRegularOrMaskTemp
}

// UnmarshalJSON unmarshal to json
func (chatPhotoStickerTypeRegularOrMask *ChatPhotoStickerTypeRegularOrMask) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StickerSetID JSONInt64 `json:"sticker_set_id"` // Sticker set identifier
		StickerID    JSONInt64 `json:"sticker_id"`     // Identifier of the sticker in the set
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatPhotoStickerTypeRegularOrMask.tdCommon = tempObj.tdCommon
	chatPhotoStickerTypeRegularOrMask.StickerSetID = tempObj.StickerSetID
	chatPhotoStickerTypeRegularOrMask.StickerID = tempObj.StickerID

	return nil
}

// GetChatPhotoStickerTypeEnum return the enum type of this object
func (chatPhotoStickerTypeRegularOrMask *ChatPhotoStickerTypeRegularOrMask) GetChatPhotoStickerTypeEnum() ChatPhotoStickerTypeEnum {
	return ChatPhotoStickerTypeRegularOrMaskType
}

// ChatPhotoStickerTypeCustomEmoji Information about the custom emoji, which was used to create the chat photo
type ChatPhotoStickerTypeCustomEmoji struct {
	tdCommon
	CustomEmojiID JSONInt64 `json:"custom_emoji_id"` // Identifier of the custom emoji
}

// MessageType return the string telegram-type of ChatPhotoStickerTypeCustomEmoji
func (chatPhotoStickerTypeCustomEmoji *ChatPhotoStickerTypeCustomEmoji) MessageType() string {
	return "chatPhotoStickerTypeCustomEmoji"
}

// NewChatPhotoStickerTypeCustomEmoji creates a new ChatPhotoStickerTypeCustomEmoji
//
// @param customEmojiID Identifier of the custom emoji
func NewChatPhotoStickerTypeCustomEmoji(customEmojiID JSONInt64) *ChatPhotoStickerTypeCustomEmoji {
	chatPhotoStickerTypeCustomEmojiTemp := ChatPhotoStickerTypeCustomEmoji{
		tdCommon:      tdCommon{Type: "chatPhotoStickerTypeCustomEmoji"},
		CustomEmojiID: customEmojiID,
	}

	return &chatPhotoStickerTypeCustomEmojiTemp
}

// UnmarshalJSON unmarshal to json
func (chatPhotoStickerTypeCustomEmoji *ChatPhotoStickerTypeCustomEmoji) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CustomEmojiID JSONInt64 `json:"custom_emoji_id"` // Identifier of the custom emoji
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatPhotoStickerTypeCustomEmoji.tdCommon = tempObj.tdCommon
	chatPhotoStickerTypeCustomEmoji.CustomEmojiID = tempObj.CustomEmojiID

	return nil
}

// GetChatPhotoStickerTypeEnum return the enum type of this object
func (chatPhotoStickerTypeCustomEmoji *ChatPhotoStickerTypeCustomEmoji) GetChatPhotoStickerTypeEnum() ChatPhotoStickerTypeEnum {
	return ChatPhotoStickerTypeCustomEmojiType
}

// ChatPhotoSticker Information about the sticker, which was used to create the chat photo. The sticker is shown at the center of the photo and occupies at most 67% of it
type ChatPhotoSticker struct {
	tdCommon
	Type           ChatPhotoStickerType `json:"type"`            // Type of the sticker
	BackgroundFill BackgroundFill       `json:"background_fill"` // The fill to be used as background for the sticker; rotation angle in backgroundFillGradient isn't supported
}

// MessageType return the string telegram-type of ChatPhotoSticker
func (chatPhotoSticker *ChatPhotoSticker) MessageType() string {
	return "chatPhotoSticker"
}

// NewChatPhotoSticker creates a new ChatPhotoSticker
//
// @param typeParam Type of the sticker
// @param backgroundFill The fill to be used as background for the sticker; rotation angle in backgroundFillGradient isn't supported
func NewChatPhotoSticker(typeParam ChatPhotoStickerType, backgroundFill BackgroundFill) *ChatPhotoSticker {
	chatPhotoStickerTemp := ChatPhotoSticker{
		tdCommon:       tdCommon{Type: "chatPhotoSticker"},
		Type:           typeParam,
		BackgroundFill: backgroundFill,
	}

	return &chatPhotoStickerTemp
}

// UnmarshalJSON unmarshal to json
func (chatPhotoSticker *ChatPhotoSticker) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatPhotoSticker.tdCommon = tempObj.tdCommon

	fieldType, _ := unmarshalChatPhotoStickerType(objMap["type"])
	chatPhotoSticker.Type = fieldType

	fieldBackgroundFill, _ := unmarshalBackgroundFill(objMap["background_fill"])
	chatPhotoSticker.BackgroundFill = fieldBackgroundFill

	return nil
}

// AnimatedChatPhoto Animated variant of a chat photo in MPEG4 format
type AnimatedChatPhoto struct {
	tdCommon
	Length             int32   `json:"length"`               // Animation width and height
	File               *File   `json:"file"`                 // Information about the animation file
	MainFrameTimestamp float64 `json:"main_frame_timestamp"` // Timestamp of the frame, used as a static chat photo
}

// MessageType return the string telegram-type of AnimatedChatPhoto
func (animatedChatPhoto *AnimatedChatPhoto) MessageType() string {
	return "animatedChatPhoto"
}

// NewAnimatedChatPhoto creates a new AnimatedChatPhoto
//
// @param length Animation width and height
// @param file Information about the animation file
// @param mainFrameTimestamp Timestamp of the frame, used as a static chat photo
func NewAnimatedChatPhoto(length int32, file *File, mainFrameTimestamp float64) *AnimatedChatPhoto {
	animatedChatPhotoTemp := AnimatedChatPhoto{
		tdCommon:           tdCommon{Type: "animatedChatPhoto"},
		Length:             length,
		File:               file,
		MainFrameTimestamp: mainFrameTimestamp,
	}

	return &animatedChatPhotoTemp
}

// UnmarshalJSON unmarshal to json
func (animatedChatPhoto *AnimatedChatPhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Length             int32   `json:"length"`               // Animation width and height
		File               *File   `json:"file"`                 // Information about the animation file
		MainFrameTimestamp float64 `json:"main_frame_timestamp"` // Timestamp of the frame, used as a static chat photo
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	animatedChatPhoto.tdCommon = tempObj.tdCommon
	animatedChatPhoto.Length = tempObj.Length
	animatedChatPhoto.File = tempObj.File
	animatedChatPhoto.MainFrameTimestamp = tempObj.MainFrameTimestamp

	return nil
}

// ChatPhoto Describes a chat or user profile photo
type ChatPhoto struct {
	tdCommon
	ID             JSONInt64          `json:"id"`              // Unique photo identifier
	AddedDate      int32              `json:"added_date"`      // Point in time (Unix timestamp) when the photo has been added
	Minithumbnail  *Minithumbnail     `json:"minithumbnail"`   // Photo minithumbnail; may be null
	Sizes          []PhotoSize        `json:"sizes"`           // Available variants of the photo in JPEG format, in different size
	Animation      *AnimatedChatPhoto `json:"animation"`       // A big (up to 1280x1280) animated variant of the photo in MPEG4 format; may be null
	SmallAnimation *AnimatedChatPhoto `json:"small_animation"` // A small (160x160) animated variant of the photo in MPEG4 format; may be null even the big animation is available
	Sticker        *ChatPhotoSticker  `json:"sticker"`         // Sticker-based version of the chat photo; may be null
}

// MessageType return the string telegram-type of ChatPhoto
func (chatPhoto *ChatPhoto) MessageType() string {
	return "chatPhoto"
}

// NewChatPhoto creates a new ChatPhoto
//
// @param iD Unique photo identifier
// @param addedDate Point in time (Unix timestamp) when the photo has been added
// @param minithumbnail Photo minithumbnail; may be null
// @param sizes Available variants of the photo in JPEG format, in different size
// @param animation A big (up to 1280x1280) animated variant of the photo in MPEG4 format; may be null
// @param smallAnimation A small (160x160) animated variant of the photo in MPEG4 format; may be null even the big animation is available
// @param sticker Sticker-based version of the chat photo; may be null
func NewChatPhoto(iD JSONInt64, addedDate int32, minithumbnail *Minithumbnail, sizes []PhotoSize, animation *AnimatedChatPhoto, smallAnimation *AnimatedChatPhoto, sticker *ChatPhotoSticker) *ChatPhoto {
	chatPhotoTemp := ChatPhoto{
		tdCommon:       tdCommon{Type: "chatPhoto"},
		ID:             iD,
		AddedDate:      addedDate,
		Minithumbnail:  minithumbnail,
		Sizes:          sizes,
		Animation:      animation,
		SmallAnimation: smallAnimation,
		Sticker:        sticker,
	}

	return &chatPhotoTemp
}

// UnmarshalJSON unmarshal to json
func (chatPhoto *ChatPhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID             JSONInt64          `json:"id"`              // Unique photo identifier
		AddedDate      int32              `json:"added_date"`      // Point in time (Unix timestamp) when the photo has been added
		Minithumbnail  *Minithumbnail     `json:"minithumbnail"`   // Photo minithumbnail; may be null
		Sizes          []PhotoSize        `json:"sizes"`           // Available variants of the photo in JPEG format, in different size
		Animation      *AnimatedChatPhoto `json:"animation"`       // A big (up to 1280x1280) animated variant of the photo in MPEG4 format; may be null
		SmallAnimation *AnimatedChatPhoto `json:"small_animation"` // A small (160x160) animated variant of the photo in MPEG4 format; may be null even the big animation is available

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatPhoto.tdCommon = tempObj.tdCommon
	chatPhoto.ID = tempObj.ID
	chatPhoto.AddedDate = tempObj.AddedDate
	chatPhoto.Minithumbnail = tempObj.Minithumbnail
	chatPhoto.Sizes = tempObj.Sizes
	chatPhoto.Animation = tempObj.Animation
	chatPhoto.SmallAnimation = tempObj.SmallAnimation

	var sticker ChatPhotoSticker
	if objMap["sticker"] != nil {
		err = sticker.UnmarshalJSON(*objMap["sticker"])
		if err != nil {
			return err
		}
	}

	chatPhoto.Sticker = &sticker

	return nil
}

// ChatPhotos Contains a list of chat or user profile photos
type ChatPhotos struct {
	tdCommon
	TotalCount int32       `json:"total_count"` // Total number of photos
	Photos     []ChatPhoto `json:"photos"`      // List of photos
}

// MessageType return the string telegram-type of ChatPhotos
func (chatPhotos *ChatPhotos) MessageType() string {
	return "chatPhotos"
}

// NewChatPhotos creates a new ChatPhotos
//
// @param totalCount Total number of photos
// @param photos List of photos
func NewChatPhotos(totalCount int32, photos []ChatPhoto) *ChatPhotos {
	chatPhotosTemp := ChatPhotos{
		tdCommon:   tdCommon{Type: "chatPhotos"},
		TotalCount: totalCount,
		Photos:     photos,
	}

	return &chatPhotosTemp
}

// UnmarshalJSON unmarshal to json
func (chatPhotos *ChatPhotos) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32       `json:"total_count"` // Total number of photos
		Photos     []ChatPhoto `json:"photos"`      // List of photos
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatPhotos.tdCommon = tempObj.tdCommon
	chatPhotos.TotalCount = tempObj.TotalCount
	chatPhotos.Photos = tempObj.Photos

	return nil
}

// InputChatPhotoPrevious A previously used profile photo of the current user
type InputChatPhotoPrevious struct {
	tdCommon
	ChatPhotoID JSONInt64 `json:"chat_photo_id"` // Identifier of the current user's profile photo to reuse
}

// MessageType return the string telegram-type of InputChatPhotoPrevious
func (inputChatPhotoPrevious *InputChatPhotoPrevious) MessageType() string {
	return "inputChatPhotoPrevious"
}

// NewInputChatPhotoPrevious creates a new InputChatPhotoPrevious
//
// @param chatPhotoID Identifier of the current user's profile photo to reuse
func NewInputChatPhotoPrevious(chatPhotoID JSONInt64) *InputChatPhotoPrevious {
	inputChatPhotoPreviousTemp := InputChatPhotoPrevious{
		tdCommon:    tdCommon{Type: "inputChatPhotoPrevious"},
		ChatPhotoID: chatPhotoID,
	}

	return &inputChatPhotoPreviousTemp
}

// UnmarshalJSON unmarshal to json
func (inputChatPhotoPrevious *InputChatPhotoPrevious) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatPhotoID JSONInt64 `json:"chat_photo_id"` // Identifier of the current user's profile photo to reuse
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputChatPhotoPrevious.tdCommon = tempObj.tdCommon
	inputChatPhotoPrevious.ChatPhotoID = tempObj.ChatPhotoID

	return nil
}

// GetInputChatPhotoEnum return the enum type of this object
func (inputChatPhotoPrevious *InputChatPhotoPrevious) GetInputChatPhotoEnum() InputChatPhotoEnum {
	return InputChatPhotoPreviousType
}

// InputChatPhotoStatic A static photo in JPEG format
type InputChatPhotoStatic struct {
	tdCommon
	Photo InputFile `json:"photo"` // Photo to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed
}

// MessageType return the string telegram-type of InputChatPhotoStatic
func (inputChatPhotoStatic *InputChatPhotoStatic) MessageType() string {
	return "inputChatPhotoStatic"
}

// NewInputChatPhotoStatic creates a new InputChatPhotoStatic
//
// @param photo Photo to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed
func NewInputChatPhotoStatic(photo InputFile) *InputChatPhotoStatic {
	inputChatPhotoStaticTemp := InputChatPhotoStatic{
		tdCommon: tdCommon{Type: "inputChatPhotoStatic"},
		Photo:    photo,
	}

	return &inputChatPhotoStaticTemp
}

// UnmarshalJSON unmarshal to json
func (inputChatPhotoStatic *InputChatPhotoStatic) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputChatPhotoStatic.tdCommon = tempObj.tdCommon

	fieldPhoto, _ := unmarshalInputFile(objMap["photo"])
	inputChatPhotoStatic.Photo = fieldPhoto

	return nil
}

// GetInputChatPhotoEnum return the enum type of this object
func (inputChatPhotoStatic *InputChatPhotoStatic) GetInputChatPhotoEnum() InputChatPhotoEnum {
	return InputChatPhotoStaticType
}

// InputChatPhotoAnimation An animation in MPEG4 format; must be square, at most 10 seconds long, have width between 160 and 1280 and be at most 2MB in size
type InputChatPhotoAnimation struct {
	tdCommon
	Animation          InputFile `json:"animation"`            // Animation to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed
	MainFrameTimestamp float64   `json:"main_frame_timestamp"` // Timestamp of the frame, which will be used as static chat photo
}

// MessageType return the string telegram-type of InputChatPhotoAnimation
func (inputChatPhotoAnimation *InputChatPhotoAnimation) MessageType() string {
	return "inputChatPhotoAnimation"
}

// NewInputChatPhotoAnimation creates a new InputChatPhotoAnimation
//
// @param animation Animation to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed
// @param mainFrameTimestamp Timestamp of the frame, which will be used as static chat photo
func NewInputChatPhotoAnimation(animation InputFile, mainFrameTimestamp float64) *InputChatPhotoAnimation {
	inputChatPhotoAnimationTemp := InputChatPhotoAnimation{
		tdCommon:           tdCommon{Type: "inputChatPhotoAnimation"},
		Animation:          animation,
		MainFrameTimestamp: mainFrameTimestamp,
	}

	return &inputChatPhotoAnimationTemp
}

// UnmarshalJSON unmarshal to json
func (inputChatPhotoAnimation *InputChatPhotoAnimation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MainFrameTimestamp float64 `json:"main_frame_timestamp"` // Timestamp of the frame, which will be used as static chat photo
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputChatPhotoAnimation.tdCommon = tempObj.tdCommon
	inputChatPhotoAnimation.MainFrameTimestamp = tempObj.MainFrameTimestamp

	fieldAnimation, _ := unmarshalInputFile(objMap["animation"])
	inputChatPhotoAnimation.Animation = fieldAnimation

	return nil
}

// GetInputChatPhotoEnum return the enum type of this object
func (inputChatPhotoAnimation *InputChatPhotoAnimation) GetInputChatPhotoEnum() InputChatPhotoEnum {
	return InputChatPhotoAnimationType
}

// InputChatPhotoSticker A sticker on a custom background
type InputChatPhotoSticker struct {
	tdCommon
	Sticker *ChatPhotoSticker `json:"sticker"` // Information about the sticker
}

// MessageType return the string telegram-type of InputChatPhotoSticker
func (inputChatPhotoSticker *InputChatPhotoSticker) MessageType() string {
	return "inputChatPhotoSticker"
}

// NewInputChatPhotoSticker creates a new InputChatPhotoSticker
//
// @param sticker Information about the sticker
func NewInputChatPhotoSticker(sticker *ChatPhotoSticker) *InputChatPhotoSticker {
	inputChatPhotoStickerTemp := InputChatPhotoSticker{
		tdCommon: tdCommon{Type: "inputChatPhotoSticker"},
		Sticker:  sticker,
	}

	return &inputChatPhotoStickerTemp
}

// UnmarshalJSON unmarshal to json
func (inputChatPhotoSticker *InputChatPhotoSticker) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputChatPhotoSticker.tdCommon = tempObj.tdCommon

	var sticker ChatPhotoSticker
	if objMap["sticker"] != nil {
		err = sticker.UnmarshalJSON(*objMap["sticker"])
		if err != nil {
			return err
		}
	}

	inputChatPhotoSticker.Sticker = &sticker

	return nil
}

// GetInputChatPhotoEnum return the enum type of this object
func (inputChatPhotoSticker *InputChatPhotoSticker) GetInputChatPhotoEnum() InputChatPhotoEnum {
	return InputChatPhotoStickerType
}

// ChatPermissions Describes actions that a user is allowed to take in a chat
type ChatPermissions struct {
	tdCommon
	CanSendBasicMessages bool `json:"can_send_basic_messages"` // True, if the user can send text messages, contacts, giveaways, giveaway winners, invoices, locations, and venues
	CanSendAudios        bool `json:"can_send_audios"`         // True, if the user can send music files
	CanSendDocuments     bool `json:"can_send_documents"`      // True, if the user can send documents
	CanSendPhotos        bool `json:"can_send_photos"`         // True, if the user can send photos
	CanSendVideos        bool `json:"can_send_videos"`         // True, if the user can send videos
	CanSendVideoNotes    bool `json:"can_send_video_notes"`    // True, if the user can send video notes
	CanSendVoiceNotes    bool `json:"can_send_voice_notes"`    // True, if the user can send voice notes
	CanSendPolls         bool `json:"can_send_polls"`          // True, if the user can send polls
	CanSendOtherMessages bool `json:"can_send_other_messages"` // True, if the user can send animations, games, stickers, and dice and use inline bots
	CanAddLinkPreviews   bool `json:"can_add_link_previews"`   // True, if the user may add a link preview to their messages
	CanChangeInfo        bool `json:"can_change_info"`         // True, if the user can change the chat title, photo, and other settings
	CanInviteUsers       bool `json:"can_invite_users"`        // True, if the user can invite new users to the chat
	CanPinMessages       bool `json:"can_pin_messages"`        // True, if the user can pin messages
	CanCreateTopics      bool `json:"can_create_topics"`       // True, if the user can create topics
}

// MessageType return the string telegram-type of ChatPermissions
func (chatPermissions *ChatPermissions) MessageType() string {
	return "chatPermissions"
}

// NewChatPermissions creates a new ChatPermissions
//
// @param canSendBasicMessages True, if the user can send text messages, contacts, giveaways, giveaway winners, invoices, locations, and venues
// @param canSendAudios True, if the user can send music files
// @param canSendDocuments True, if the user can send documents
// @param canSendPhotos True, if the user can send photos
// @param canSendVideos True, if the user can send videos
// @param canSendVideoNotes True, if the user can send video notes
// @param canSendVoiceNotes True, if the user can send voice notes
// @param canSendPolls True, if the user can send polls
// @param canSendOtherMessages True, if the user can send animations, games, stickers, and dice and use inline bots
// @param canAddLinkPreviews True, if the user may add a link preview to their messages
// @param canChangeInfo True, if the user can change the chat title, photo, and other settings
// @param canInviteUsers True, if the user can invite new users to the chat
// @param canPinMessages True, if the user can pin messages
// @param canCreateTopics True, if the user can create topics
func NewChatPermissions(canSendBasicMessages bool, canSendAudios bool, canSendDocuments bool, canSendPhotos bool, canSendVideos bool, canSendVideoNotes bool, canSendVoiceNotes bool, canSendPolls bool, canSendOtherMessages bool, canAddLinkPreviews bool, canChangeInfo bool, canInviteUsers bool, canPinMessages bool, canCreateTopics bool) *ChatPermissions {
	chatPermissionsTemp := ChatPermissions{
		tdCommon:             tdCommon{Type: "chatPermissions"},
		CanSendBasicMessages: canSendBasicMessages,
		CanSendAudios:        canSendAudios,
		CanSendDocuments:     canSendDocuments,
		CanSendPhotos:        canSendPhotos,
		CanSendVideos:        canSendVideos,
		CanSendVideoNotes:    canSendVideoNotes,
		CanSendVoiceNotes:    canSendVoiceNotes,
		CanSendPolls:         canSendPolls,
		CanSendOtherMessages: canSendOtherMessages,
		CanAddLinkPreviews:   canAddLinkPreviews,
		CanChangeInfo:        canChangeInfo,
		CanInviteUsers:       canInviteUsers,
		CanPinMessages:       canPinMessages,
		CanCreateTopics:      canCreateTopics,
	}

	return &chatPermissionsTemp
}

// UnmarshalJSON unmarshal to json
func (chatPermissions *ChatPermissions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CanSendBasicMessages bool `json:"can_send_basic_messages"` // True, if the user can send text messages, contacts, giveaways, giveaway winners, invoices, locations, and venues
		CanSendAudios        bool `json:"can_send_audios"`         // True, if the user can send music files
		CanSendDocuments     bool `json:"can_send_documents"`      // True, if the user can send documents
		CanSendPhotos        bool `json:"can_send_photos"`         // True, if the user can send photos
		CanSendVideos        bool `json:"can_send_videos"`         // True, if the user can send videos
		CanSendVideoNotes    bool `json:"can_send_video_notes"`    // True, if the user can send video notes
		CanSendVoiceNotes    bool `json:"can_send_voice_notes"`    // True, if the user can send voice notes
		CanSendPolls         bool `json:"can_send_polls"`          // True, if the user can send polls
		CanSendOtherMessages bool `json:"can_send_other_messages"` // True, if the user can send animations, games, stickers, and dice and use inline bots
		CanAddLinkPreviews   bool `json:"can_add_link_previews"`   // True, if the user may add a link preview to their messages
		CanChangeInfo        bool `json:"can_change_info"`         // True, if the user can change the chat title, photo, and other settings
		CanInviteUsers       bool `json:"can_invite_users"`        // True, if the user can invite new users to the chat
		CanPinMessages       bool `json:"can_pin_messages"`        // True, if the user can pin messages
		CanCreateTopics      bool `json:"can_create_topics"`       // True, if the user can create topics
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatPermissions.tdCommon = tempObj.tdCommon
	chatPermissions.CanSendBasicMessages = tempObj.CanSendBasicMessages
	chatPermissions.CanSendAudios = tempObj.CanSendAudios
	chatPermissions.CanSendDocuments = tempObj.CanSendDocuments
	chatPermissions.CanSendPhotos = tempObj.CanSendPhotos
	chatPermissions.CanSendVideos = tempObj.CanSendVideos
	chatPermissions.CanSendVideoNotes = tempObj.CanSendVideoNotes
	chatPermissions.CanSendVoiceNotes = tempObj.CanSendVoiceNotes
	chatPermissions.CanSendPolls = tempObj.CanSendPolls
	chatPermissions.CanSendOtherMessages = tempObj.CanSendOtherMessages
	chatPermissions.CanAddLinkPreviews = tempObj.CanAddLinkPreviews
	chatPermissions.CanChangeInfo = tempObj.CanChangeInfo
	chatPermissions.CanInviteUsers = tempObj.CanInviteUsers
	chatPermissions.CanPinMessages = tempObj.CanPinMessages
	chatPermissions.CanCreateTopics = tempObj.CanCreateTopics

	return nil
}

// ChatAdministratorRights Describes rights of the administrator
type ChatAdministratorRights struct {
	tdCommon
	CanManageChat       bool `json:"can_manage_chat"`        // True, if the administrator can access the chat event log, get boost list, see hidden supergroup and channel members, report supergroup spam messages and ignore slow mode. Implied by any other privilege; applicable to supergroups and channels only
	CanChangeInfo       bool `json:"can_change_info"`        // True, if the administrator can change the chat title, photo, and other settings
	CanPostMessages     bool `json:"can_post_messages"`      // True, if the administrator can create channel posts or view channel statistics; applicable to channels only
	CanEditMessages     bool `json:"can_edit_messages"`      // True, if the administrator can edit messages of other users and pin messages; applicable to channels only
	CanDeleteMessages   bool `json:"can_delete_messages"`    // True, if the administrator can delete messages of other users
	CanInviteUsers      bool `json:"can_invite_users"`       // True, if the administrator can invite new users to the chat
	CanRestrictMembers  bool `json:"can_restrict_members"`   // True, if the administrator can restrict, ban, or unban chat members or view supergroup statistics; always true for channels
	CanPinMessages      bool `json:"can_pin_messages"`       // True, if the administrator can pin messages; applicable to basic groups and supergroups only
	CanManageTopics     bool `json:"can_manage_topics"`      // True, if the administrator can create, rename, close, reopen, hide, and unhide forum topics; applicable to forum supergroups only
	CanPromoteMembers   bool `json:"can_promote_members"`    // True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that were directly or indirectly promoted by them
	CanManageVideoChats bool `json:"can_manage_video_chats"` // True, if the administrator can manage video chats
	CanPostStories      bool `json:"can_post_stories"`       // True, if the administrator can create new chat stories, or edit and delete posted stories; applicable to supergroups and channels only
	CanEditStories      bool `json:"can_edit_stories"`       // True, if the administrator can edit stories posted by other users, post stories to the chat page, pin chat stories, and access story archive; applicable to supergroups and channels only
	CanDeleteStories    bool `json:"can_delete_stories"`     // True, if the administrator can delete stories posted by other users; applicable to supergroups and channels only
	IsAnonymous         bool `json:"is_anonymous"`           // True, if the administrator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only
}

// MessageType return the string telegram-type of ChatAdministratorRights
func (chatAdministratorRights *ChatAdministratorRights) MessageType() string {
	return "chatAdministratorRights"
}

// NewChatAdministratorRights creates a new ChatAdministratorRights
//
// @param canManageChat True, if the administrator can access the chat event log, get boost list, see hidden supergroup and channel members, report supergroup spam messages and ignore slow mode. Implied by any other privilege; applicable to supergroups and channels only
// @param canChangeInfo True, if the administrator can change the chat title, photo, and other settings
// @param canPostMessages True, if the administrator can create channel posts or view channel statistics; applicable to channels only
// @param canEditMessages True, if the administrator can edit messages of other users and pin messages; applicable to channels only
// @param canDeleteMessages True, if the administrator can delete messages of other users
// @param canInviteUsers True, if the administrator can invite new users to the chat
// @param canRestrictMembers True, if the administrator can restrict, ban, or unban chat members or view supergroup statistics; always true for channels
// @param canPinMessages True, if the administrator can pin messages; applicable to basic groups and supergroups only
// @param canManageTopics True, if the administrator can create, rename, close, reopen, hide, and unhide forum topics; applicable to forum supergroups only
// @param canPromoteMembers True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that were directly or indirectly promoted by them
// @param canManageVideoChats True, if the administrator can manage video chats
// @param canPostStories True, if the administrator can create new chat stories, or edit and delete posted stories; applicable to supergroups and channels only
// @param canEditStories True, if the administrator can edit stories posted by other users, post stories to the chat page, pin chat stories, and access story archive; applicable to supergroups and channels only
// @param canDeleteStories True, if the administrator can delete stories posted by other users; applicable to supergroups and channels only
// @param isAnonymous True, if the administrator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only
func NewChatAdministratorRights(canManageChat bool, canChangeInfo bool, canPostMessages bool, canEditMessages bool, canDeleteMessages bool, canInviteUsers bool, canRestrictMembers bool, canPinMessages bool, canManageTopics bool, canPromoteMembers bool, canManageVideoChats bool, canPostStories bool, canEditStories bool, canDeleteStories bool, isAnonymous bool) *ChatAdministratorRights {
	chatAdministratorRightsTemp := ChatAdministratorRights{
		tdCommon:            tdCommon{Type: "chatAdministratorRights"},
		CanManageChat:       canManageChat,
		CanChangeInfo:       canChangeInfo,
		CanPostMessages:     canPostMessages,
		CanEditMessages:     canEditMessages,
		CanDeleteMessages:   canDeleteMessages,
		CanInviteUsers:      canInviteUsers,
		CanRestrictMembers:  canRestrictMembers,
		CanPinMessages:      canPinMessages,
		CanManageTopics:     canManageTopics,
		CanPromoteMembers:   canPromoteMembers,
		CanManageVideoChats: canManageVideoChats,
		CanPostStories:      canPostStories,
		CanEditStories:      canEditStories,
		CanDeleteStories:    canDeleteStories,
		IsAnonymous:         isAnonymous,
	}

	return &chatAdministratorRightsTemp
}

// UnmarshalJSON unmarshal to json
func (chatAdministratorRights *ChatAdministratorRights) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CanManageChat       bool `json:"can_manage_chat"`        // True, if the administrator can access the chat event log, get boost list, see hidden supergroup and channel members, report supergroup spam messages and ignore slow mode. Implied by any other privilege; applicable to supergroups and channels only
		CanChangeInfo       bool `json:"can_change_info"`        // True, if the administrator can change the chat title, photo, and other settings
		CanPostMessages     bool `json:"can_post_messages"`      // True, if the administrator can create channel posts or view channel statistics; applicable to channels only
		CanEditMessages     bool `json:"can_edit_messages"`      // True, if the administrator can edit messages of other users and pin messages; applicable to channels only
		CanDeleteMessages   bool `json:"can_delete_messages"`    // True, if the administrator can delete messages of other users
		CanInviteUsers      bool `json:"can_invite_users"`       // True, if the administrator can invite new users to the chat
		CanRestrictMembers  bool `json:"can_restrict_members"`   // True, if the administrator can restrict, ban, or unban chat members or view supergroup statistics; always true for channels
		CanPinMessages      bool `json:"can_pin_messages"`       // True, if the administrator can pin messages; applicable to basic groups and supergroups only
		CanManageTopics     bool `json:"can_manage_topics"`      // True, if the administrator can create, rename, close, reopen, hide, and unhide forum topics; applicable to forum supergroups only
		CanPromoteMembers   bool `json:"can_promote_members"`    // True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that were directly or indirectly promoted by them
		CanManageVideoChats bool `json:"can_manage_video_chats"` // True, if the administrator can manage video chats
		CanPostStories      bool `json:"can_post_stories"`       // True, if the administrator can create new chat stories, or edit and delete posted stories; applicable to supergroups and channels only
		CanEditStories      bool `json:"can_edit_stories"`       // True, if the administrator can edit stories posted by other users, post stories to the chat page, pin chat stories, and access story archive; applicable to supergroups and channels only
		CanDeleteStories    bool `json:"can_delete_stories"`     // True, if the administrator can delete stories posted by other users; applicable to supergroups and channels only
		IsAnonymous         bool `json:"is_anonymous"`           // True, if the administrator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatAdministratorRights.tdCommon = tempObj.tdCommon
	chatAdministratorRights.CanManageChat = tempObj.CanManageChat
	chatAdministratorRights.CanChangeInfo = tempObj.CanChangeInfo
	chatAdministratorRights.CanPostMessages = tempObj.CanPostMessages
	chatAdministratorRights.CanEditMessages = tempObj.CanEditMessages
	chatAdministratorRights.CanDeleteMessages = tempObj.CanDeleteMessages
	chatAdministratorRights.CanInviteUsers = tempObj.CanInviteUsers
	chatAdministratorRights.CanRestrictMembers = tempObj.CanRestrictMembers
	chatAdministratorRights.CanPinMessages = tempObj.CanPinMessages
	chatAdministratorRights.CanManageTopics = tempObj.CanManageTopics
	chatAdministratorRights.CanPromoteMembers = tempObj.CanPromoteMembers
	chatAdministratorRights.CanManageVideoChats = tempObj.CanManageVideoChats
	chatAdministratorRights.CanPostStories = tempObj.CanPostStories
	chatAdministratorRights.CanEditStories = tempObj.CanEditStories
	chatAdministratorRights.CanDeleteStories = tempObj.CanDeleteStories
	chatAdministratorRights.IsAnonymous = tempObj.IsAnonymous

	return nil
}

// StarSubscriptionPricing Describes subscription plan paid in Telegram Stars
type StarSubscriptionPricing struct {
	tdCommon
	Period    int32 `json:"period"`     // The number of seconds between consecutive Telegram Star debiting
	StarCount int64 `json:"star_count"` // The amount of Telegram Stars that must be paid for each period
}

// MessageType return the string telegram-type of StarSubscriptionPricing
func (starSubscriptionPricing *StarSubscriptionPricing) MessageType() string {
	return "starSubscriptionPricing"
}

// NewStarSubscriptionPricing creates a new StarSubscriptionPricing
//
// @param period The number of seconds between consecutive Telegram Star debiting
// @param starCount The amount of Telegram Stars that must be paid for each period
func NewStarSubscriptionPricing(period int32, starCount int64) *StarSubscriptionPricing {
	starSubscriptionPricingTemp := StarSubscriptionPricing{
		tdCommon:  tdCommon{Type: "starSubscriptionPricing"},
		Period:    period,
		StarCount: starCount,
	}

	return &starSubscriptionPricingTemp
}

// UnmarshalJSON unmarshal to json
func (starSubscriptionPricing *StarSubscriptionPricing) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Period    int32 `json:"period"`     // The number of seconds between consecutive Telegram Star debiting
		StarCount int64 `json:"star_count"` // The amount of Telegram Stars that must be paid for each period
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starSubscriptionPricing.tdCommon = tempObj.tdCommon
	starSubscriptionPricing.Period = tempObj.Period
	starSubscriptionPricing.StarCount = tempObj.StarCount

	return nil
}

// StarSubscription Contains information about subscription to a channel chat paid in Telegram Stars
type StarSubscription struct {
	tdCommon
	ID             string                   `json:"id"`              // Unique identifier of the subscription
	ChatID         int64                    `json:"chat_id"`         // Identifier of the channel chat that is subscribed
	ExpirationDate int32                    `json:"expiration_date"` // Point in time (Unix timestamp) when the subscription will expire or expired
	CanReuse       bool                     `json:"can_reuse"`       // True, if the subscription is active and the user can use the method reuseStarSubscription to join the subscribed chat again
	IsCanceled     bool                     `json:"is_canceled"`     // True, if the subscription was canceled
	IsExpiring     bool                     `json:"is_expiring"`     // True, if the subscription expires soon and there are no enough Telegram Stars on the user's balance to extend it
	InviteLink     string                   `json:"invite_link"`     // The invite link that can be used to renew the subscription if it has been expired; may be empty, if the link isn't available anymore
	Pricing        *StarSubscriptionPricing `json:"pricing"`         // The subscription plan
}

// MessageType return the string telegram-type of StarSubscription
func (starSubscription *StarSubscription) MessageType() string {
	return "starSubscription"
}

// NewStarSubscription creates a new StarSubscription
//
// @param iD Unique identifier of the subscription
// @param chatID Identifier of the channel chat that is subscribed
// @param expirationDate Point in time (Unix timestamp) when the subscription will expire or expired
// @param canReuse True, if the subscription is active and the user can use the method reuseStarSubscription to join the subscribed chat again
// @param isCanceled True, if the subscription was canceled
// @param isExpiring True, if the subscription expires soon and there are no enough Telegram Stars on the user's balance to extend it
// @param inviteLink The invite link that can be used to renew the subscription if it has been expired; may be empty, if the link isn't available anymore
// @param pricing The subscription plan
func NewStarSubscription(iD string, chatID int64, expirationDate int32, canReuse bool, isCanceled bool, isExpiring bool, inviteLink string, pricing *StarSubscriptionPricing) *StarSubscription {
	starSubscriptionTemp := StarSubscription{
		tdCommon:       tdCommon{Type: "starSubscription"},
		ID:             iD,
		ChatID:         chatID,
		ExpirationDate: expirationDate,
		CanReuse:       canReuse,
		IsCanceled:     isCanceled,
		IsExpiring:     isExpiring,
		InviteLink:     inviteLink,
		Pricing:        pricing,
	}

	return &starSubscriptionTemp
}

// UnmarshalJSON unmarshal to json
func (starSubscription *StarSubscription) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID             string                   `json:"id"`              // Unique identifier of the subscription
		ChatID         int64                    `json:"chat_id"`         // Identifier of the channel chat that is subscribed
		ExpirationDate int32                    `json:"expiration_date"` // Point in time (Unix timestamp) when the subscription will expire or expired
		CanReuse       bool                     `json:"can_reuse"`       // True, if the subscription is active and the user can use the method reuseStarSubscription to join the subscribed chat again
		IsCanceled     bool                     `json:"is_canceled"`     // True, if the subscription was canceled
		IsExpiring     bool                     `json:"is_expiring"`     // True, if the subscription expires soon and there are no enough Telegram Stars on the user's balance to extend it
		InviteLink     string                   `json:"invite_link"`     // The invite link that can be used to renew the subscription if it has been expired; may be empty, if the link isn't available anymore
		Pricing        *StarSubscriptionPricing `json:"pricing"`         // The subscription plan
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starSubscription.tdCommon = tempObj.tdCommon
	starSubscription.ID = tempObj.ID
	starSubscription.ChatID = tempObj.ChatID
	starSubscription.ExpirationDate = tempObj.ExpirationDate
	starSubscription.CanReuse = tempObj.CanReuse
	starSubscription.IsCanceled = tempObj.IsCanceled
	starSubscription.IsExpiring = tempObj.IsExpiring
	starSubscription.InviteLink = tempObj.InviteLink
	starSubscription.Pricing = tempObj.Pricing

	return nil
}

// StarSubscriptions Represents a list of Telegram Star subscriptions
type StarSubscriptions struct {
	tdCommon
	StarCount         int64              `json:"star_count"`          // The amount of owned Telegram Stars
	Subscriptions     []StarSubscription `json:"subscriptions"`       // List of subbscriptions for Telegram Stars
	RequiredStarCount int64              `json:"required_star_count"` // The number of Telegram Stars required to buy to extend subscriptions expiring soon
	NextOffset        string             `json:"next_offset"`         // The offset for the next request. If empty, then there are no more results
}

// MessageType return the string telegram-type of StarSubscriptions
func (starSubscriptions *StarSubscriptions) MessageType() string {
	return "starSubscriptions"
}

// NewStarSubscriptions creates a new StarSubscriptions
//
// @param starCount The amount of owned Telegram Stars
// @param subscriptions List of subbscriptions for Telegram Stars
// @param requiredStarCount The number of Telegram Stars required to buy to extend subscriptions expiring soon
// @param nextOffset The offset for the next request. If empty, then there are no more results
func NewStarSubscriptions(starCount int64, subscriptions []StarSubscription, requiredStarCount int64, nextOffset string) *StarSubscriptions {
	starSubscriptionsTemp := StarSubscriptions{
		tdCommon:          tdCommon{Type: "starSubscriptions"},
		StarCount:         starCount,
		Subscriptions:     subscriptions,
		RequiredStarCount: requiredStarCount,
		NextOffset:        nextOffset,
	}

	return &starSubscriptionsTemp
}

// UnmarshalJSON unmarshal to json
func (starSubscriptions *StarSubscriptions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StarCount         int64              `json:"star_count"`          // The amount of owned Telegram Stars
		Subscriptions     []StarSubscription `json:"subscriptions"`       // List of subbscriptions for Telegram Stars
		RequiredStarCount int64              `json:"required_star_count"` // The number of Telegram Stars required to buy to extend subscriptions expiring soon
		NextOffset        string             `json:"next_offset"`         // The offset for the next request. If empty, then there are no more results
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starSubscriptions.tdCommon = tempObj.tdCommon
	starSubscriptions.StarCount = tempObj.StarCount
	starSubscriptions.Subscriptions = tempObj.Subscriptions
	starSubscriptions.RequiredStarCount = tempObj.RequiredStarCount
	starSubscriptions.NextOffset = tempObj.NextOffset

	return nil
}

// ProductInfo Contains information about a product that can be paid with invoice
type ProductInfo struct {
	tdCommon
	Title       string         `json:"title"`       // Product title
	Description *FormattedText `json:"description"` // Product description
	Photo       *Photo         `json:"photo"`       // Product photo; may be null
}

// MessageType return the string telegram-type of ProductInfo
func (productInfo *ProductInfo) MessageType() string {
	return "productInfo"
}

// NewProductInfo creates a new ProductInfo
//
// @param title Product title
// @param description Product description
// @param photo Product photo; may be null
func NewProductInfo(title string, description *FormattedText, photo *Photo) *ProductInfo {
	productInfoTemp := ProductInfo{
		tdCommon:    tdCommon{Type: "productInfo"},
		Title:       title,
		Description: description,
		Photo:       photo,
	}

	return &productInfoTemp
}

// UnmarshalJSON unmarshal to json
func (productInfo *ProductInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Title       string         `json:"title"`       // Product title
		Description *FormattedText `json:"description"` // Product description
		Photo       *Photo         `json:"photo"`       // Product photo; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	productInfo.tdCommon = tempObj.tdCommon
	productInfo.Title = tempObj.Title
	productInfo.Description = tempObj.Description
	productInfo.Photo = tempObj.Photo

	return nil
}

// PremiumPaymentOption Describes an option for buying Telegram Premium to a user
type PremiumPaymentOption struct {
	tdCommon
	Currency           string            `json:"currency"`            // ISO 4217 currency code for Telegram Premium subscription payment
	Amount             int64             `json:"amount"`              // The amount to pay, in the smallest units of the currency
	DiscountPercentage int32             `json:"discount_percentage"` // The discount associated with this option, as a percentage
	MonthCount         int32             `json:"month_count"`         // Number of months the Telegram Premium subscription will be active
	StoreProductID     string            `json:"store_product_id"`    // Identifier of the store product associated with the option
	PaymentLink        *InternalLinkType `json:"payment_link"`        // An internal link to be opened for buying Telegram Premium to the user if store payment isn't possible; may be null if direct payment isn't available
}

// MessageType return the string telegram-type of PremiumPaymentOption
func (premiumPaymentOption *PremiumPaymentOption) MessageType() string {
	return "premiumPaymentOption"
}

// NewPremiumPaymentOption creates a new PremiumPaymentOption
//
// @param currency ISO 4217 currency code for Telegram Premium subscription payment
// @param amount The amount to pay, in the smallest units of the currency
// @param discountPercentage The discount associated with this option, as a percentage
// @param monthCount Number of months the Telegram Premium subscription will be active
// @param storeProductID Identifier of the store product associated with the option
// @param paymentLink An internal link to be opened for buying Telegram Premium to the user if store payment isn't possible; may be null if direct payment isn't available
func NewPremiumPaymentOption(currency string, amount int64, discountPercentage int32, monthCount int32, storeProductID string, paymentLink *InternalLinkType) *PremiumPaymentOption {
	premiumPaymentOptionTemp := PremiumPaymentOption{
		tdCommon:           tdCommon{Type: "premiumPaymentOption"},
		Currency:           currency,
		Amount:             amount,
		DiscountPercentage: discountPercentage,
		MonthCount:         monthCount,
		StoreProductID:     storeProductID,
		PaymentLink:        paymentLink,
	}

	return &premiumPaymentOptionTemp
}

// UnmarshalJSON unmarshal to json
func (premiumPaymentOption *PremiumPaymentOption) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Currency           string `json:"currency"`            // ISO 4217 currency code for Telegram Premium subscription payment
		Amount             int64  `json:"amount"`              // The amount to pay, in the smallest units of the currency
		DiscountPercentage int32  `json:"discount_percentage"` // The discount associated with this option, as a percentage
		MonthCount         int32  `json:"month_count"`         // Number of months the Telegram Premium subscription will be active
		StoreProductID     string `json:"store_product_id"`    // Identifier of the store product associated with the option

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumPaymentOption.tdCommon = tempObj.tdCommon
	premiumPaymentOption.Currency = tempObj.Currency
	premiumPaymentOption.Amount = tempObj.Amount
	premiumPaymentOption.DiscountPercentage = tempObj.DiscountPercentage
	premiumPaymentOption.MonthCount = tempObj.MonthCount
	premiumPaymentOption.StoreProductID = tempObj.StoreProductID

	fieldPaymentLink, _ := unmarshalInternalLinkType(objMap["payment_link"])
	premiumPaymentOption.PaymentLink = &fieldPaymentLink

	return nil
}

// PremiumStatePaymentOption Describes an option for buying or upgrading Telegram Premium for self
type PremiumStatePaymentOption struct {
	tdCommon
	PaymentOption     *PremiumPaymentOption `json:"payment_option"`      // Information about the payment option
	IsCurrent         bool                  `json:"is_current"`          // True, if this is the currently used Telegram Premium subscription option
	IsUpgrade         bool                  `json:"is_upgrade"`          // True, if the payment option can be used to upgrade the existing Telegram Premium subscription
	LastTransactionID string                `json:"last_transaction_id"` // Identifier of the last in-store transaction for the currently used option
}

// MessageType return the string telegram-type of PremiumStatePaymentOption
func (premiumStatePaymentOption *PremiumStatePaymentOption) MessageType() string {
	return "premiumStatePaymentOption"
}

// NewPremiumStatePaymentOption creates a new PremiumStatePaymentOption
//
// @param paymentOption Information about the payment option
// @param isCurrent True, if this is the currently used Telegram Premium subscription option
// @param isUpgrade True, if the payment option can be used to upgrade the existing Telegram Premium subscription
// @param lastTransactionID Identifier of the last in-store transaction for the currently used option
func NewPremiumStatePaymentOption(paymentOption *PremiumPaymentOption, isCurrent bool, isUpgrade bool, lastTransactionID string) *PremiumStatePaymentOption {
	premiumStatePaymentOptionTemp := PremiumStatePaymentOption{
		tdCommon:          tdCommon{Type: "premiumStatePaymentOption"},
		PaymentOption:     paymentOption,
		IsCurrent:         isCurrent,
		IsUpgrade:         isUpgrade,
		LastTransactionID: lastTransactionID,
	}

	return &premiumStatePaymentOptionTemp
}

// UnmarshalJSON unmarshal to json
func (premiumStatePaymentOption *PremiumStatePaymentOption) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsCurrent         bool   `json:"is_current"`          // True, if this is the currently used Telegram Premium subscription option
		IsUpgrade         bool   `json:"is_upgrade"`          // True, if the payment option can be used to upgrade the existing Telegram Premium subscription
		LastTransactionID string `json:"last_transaction_id"` // Identifier of the last in-store transaction for the currently used option
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumStatePaymentOption.tdCommon = tempObj.tdCommon
	premiumStatePaymentOption.IsCurrent = tempObj.IsCurrent
	premiumStatePaymentOption.IsUpgrade = tempObj.IsUpgrade
	premiumStatePaymentOption.LastTransactionID = tempObj.LastTransactionID

	var paymentOption PremiumPaymentOption
	if objMap["payment_option"] != nil {
		err = paymentOption.UnmarshalJSON(*objMap["payment_option"])
		if err != nil {
			return err
		}
	}

	premiumStatePaymentOption.PaymentOption = &paymentOption

	return nil
}

// PremiumGiftCodePaymentOption Describes an option for creating Telegram Premium gift codes or Telegram Premium giveaway. Use telegramPaymentPurposePremiumGiftCodes or telegramPaymentPurposePremiumGiveaway for out-of-store payments
type PremiumGiftCodePaymentOption struct {
	tdCommon
	Currency             string `json:"currency"`               // ISO 4217 currency code for Telegram Premium gift code payment
	Amount               int64  `json:"amount"`                 // The amount to pay, in the smallest units of the currency
	WinnerCount          int32  `json:"winner_count"`           // Number of users which will be able to activate the gift codes
	MonthCount           int32  `json:"month_count"`            // Number of months the Telegram Premium subscription will be active
	StoreProductID       string `json:"store_product_id"`       // Identifier of the store product associated with the option; may be empty if none
	StoreProductQuantity int32  `json:"store_product_quantity"` // Number of times the store product must be paid
}

// MessageType return the string telegram-type of PremiumGiftCodePaymentOption
func (premiumGiftCodePaymentOption *PremiumGiftCodePaymentOption) MessageType() string {
	return "premiumGiftCodePaymentOption"
}

// NewPremiumGiftCodePaymentOption creates a new PremiumGiftCodePaymentOption
//
// @param currency ISO 4217 currency code for Telegram Premium gift code payment
// @param amount The amount to pay, in the smallest units of the currency
// @param winnerCount Number of users which will be able to activate the gift codes
// @param monthCount Number of months the Telegram Premium subscription will be active
// @param storeProductID Identifier of the store product associated with the option; may be empty if none
// @param storeProductQuantity Number of times the store product must be paid
func NewPremiumGiftCodePaymentOption(currency string, amount int64, winnerCount int32, monthCount int32, storeProductID string, storeProductQuantity int32) *PremiumGiftCodePaymentOption {
	premiumGiftCodePaymentOptionTemp := PremiumGiftCodePaymentOption{
		tdCommon:             tdCommon{Type: "premiumGiftCodePaymentOption"},
		Currency:             currency,
		Amount:               amount,
		WinnerCount:          winnerCount,
		MonthCount:           monthCount,
		StoreProductID:       storeProductID,
		StoreProductQuantity: storeProductQuantity,
	}

	return &premiumGiftCodePaymentOptionTemp
}

// UnmarshalJSON unmarshal to json
func (premiumGiftCodePaymentOption *PremiumGiftCodePaymentOption) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Currency             string `json:"currency"`               // ISO 4217 currency code for Telegram Premium gift code payment
		Amount               int64  `json:"amount"`                 // The amount to pay, in the smallest units of the currency
		WinnerCount          int32  `json:"winner_count"`           // Number of users which will be able to activate the gift codes
		MonthCount           int32  `json:"month_count"`            // Number of months the Telegram Premium subscription will be active
		StoreProductID       string `json:"store_product_id"`       // Identifier of the store product associated with the option; may be empty if none
		StoreProductQuantity int32  `json:"store_product_quantity"` // Number of times the store product must be paid
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumGiftCodePaymentOption.tdCommon = tempObj.tdCommon
	premiumGiftCodePaymentOption.Currency = tempObj.Currency
	premiumGiftCodePaymentOption.Amount = tempObj.Amount
	premiumGiftCodePaymentOption.WinnerCount = tempObj.WinnerCount
	premiumGiftCodePaymentOption.MonthCount = tempObj.MonthCount
	premiumGiftCodePaymentOption.StoreProductID = tempObj.StoreProductID
	premiumGiftCodePaymentOption.StoreProductQuantity = tempObj.StoreProductQuantity

	return nil
}

// PremiumGiftCodePaymentOptions Contains a list of options for creating Telegram Premium gift codes or Telegram Premium giveaway
type PremiumGiftCodePaymentOptions struct {
	tdCommon
	Options []PremiumGiftCodePaymentOption `json:"options"` // The list of options
}

// MessageType return the string telegram-type of PremiumGiftCodePaymentOptions
func (premiumGiftCodePaymentOptions *PremiumGiftCodePaymentOptions) MessageType() string {
	return "premiumGiftCodePaymentOptions"
}

// NewPremiumGiftCodePaymentOptions creates a new PremiumGiftCodePaymentOptions
//
// @param options The list of options
func NewPremiumGiftCodePaymentOptions(options []PremiumGiftCodePaymentOption) *PremiumGiftCodePaymentOptions {
	premiumGiftCodePaymentOptionsTemp := PremiumGiftCodePaymentOptions{
		tdCommon: tdCommon{Type: "premiumGiftCodePaymentOptions"},
		Options:  options,
	}

	return &premiumGiftCodePaymentOptionsTemp
}

// UnmarshalJSON unmarshal to json
func (premiumGiftCodePaymentOptions *PremiumGiftCodePaymentOptions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Options []PremiumGiftCodePaymentOption `json:"options"` // The list of options
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumGiftCodePaymentOptions.tdCommon = tempObj.tdCommon
	premiumGiftCodePaymentOptions.Options = tempObj.Options

	return nil
}

// PremiumGiftCodeInfo Contains information about a Telegram Premium gift code
type PremiumGiftCodeInfo struct {
	tdCommon
	CreatorID         *MessageSender `json:"creator_id"`          // Identifier of a chat or a user that created the gift code; may be null if unknown. If null and the code is from messagePremiumGiftCode message, then creator_id from the message can be used
	CreationDate      int32          `json:"creation_date"`       // Point in time (Unix timestamp) when the code was created
	IsFromGiveaway    bool           `json:"is_from_giveaway"`    // True, if the gift code was created for a giveaway
	GiveawayMessageID int64          `json:"giveaway_message_id"` // Identifier of the corresponding giveaway message in the creator_id chat; can be 0 or an identifier of a deleted message
	MonthCount        int32          `json:"month_count"`         // Number of months the Telegram Premium subscription will be active after code activation
	UserID            int64          `json:"user_id"`             // Identifier of a user for which the code was created; 0 if none
	UseDate           int32          `json:"use_date"`            // Point in time (Unix timestamp) when the code was activated; 0 if none
}

// MessageType return the string telegram-type of PremiumGiftCodeInfo
func (premiumGiftCodeInfo *PremiumGiftCodeInfo) MessageType() string {
	return "premiumGiftCodeInfo"
}

// NewPremiumGiftCodeInfo creates a new PremiumGiftCodeInfo
//
// @param creatorID Identifier of a chat or a user that created the gift code; may be null if unknown. If null and the code is from messagePremiumGiftCode message, then creator_id from the message can be used
// @param creationDate Point in time (Unix timestamp) when the code was created
// @param isFromGiveaway True, if the gift code was created for a giveaway
// @param giveawayMessageID Identifier of the corresponding giveaway message in the creator_id chat; can be 0 or an identifier of a deleted message
// @param monthCount Number of months the Telegram Premium subscription will be active after code activation
// @param userID Identifier of a user for which the code was created; 0 if none
// @param useDate Point in time (Unix timestamp) when the code was activated; 0 if none
func NewPremiumGiftCodeInfo(creatorID *MessageSender, creationDate int32, isFromGiveaway bool, giveawayMessageID int64, monthCount int32, userID int64, useDate int32) *PremiumGiftCodeInfo {
	premiumGiftCodeInfoTemp := PremiumGiftCodeInfo{
		tdCommon:          tdCommon{Type: "premiumGiftCodeInfo"},
		CreatorID:         creatorID,
		CreationDate:      creationDate,
		IsFromGiveaway:    isFromGiveaway,
		GiveawayMessageID: giveawayMessageID,
		MonthCount:        monthCount,
		UserID:            userID,
		UseDate:           useDate,
	}

	return &premiumGiftCodeInfoTemp
}

// UnmarshalJSON unmarshal to json
func (premiumGiftCodeInfo *PremiumGiftCodeInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CreationDate      int32 `json:"creation_date"`       // Point in time (Unix timestamp) when the code was created
		IsFromGiveaway    bool  `json:"is_from_giveaway"`    // True, if the gift code was created for a giveaway
		GiveawayMessageID int64 `json:"giveaway_message_id"` // Identifier of the corresponding giveaway message in the creator_id chat; can be 0 or an identifier of a deleted message
		MonthCount        int32 `json:"month_count"`         // Number of months the Telegram Premium subscription will be active after code activation
		UserID            int64 `json:"user_id"`             // Identifier of a user for which the code was created; 0 if none
		UseDate           int32 `json:"use_date"`            // Point in time (Unix timestamp) when the code was activated; 0 if none
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumGiftCodeInfo.tdCommon = tempObj.tdCommon
	premiumGiftCodeInfo.CreationDate = tempObj.CreationDate
	premiumGiftCodeInfo.IsFromGiveaway = tempObj.IsFromGiveaway
	premiumGiftCodeInfo.GiveawayMessageID = tempObj.GiveawayMessageID
	premiumGiftCodeInfo.MonthCount = tempObj.MonthCount
	premiumGiftCodeInfo.UserID = tempObj.UserID
	premiumGiftCodeInfo.UseDate = tempObj.UseDate

	fieldCreatorID, _ := unmarshalMessageSender(objMap["creator_id"])
	premiumGiftCodeInfo.CreatorID = &fieldCreatorID

	return nil
}

// StarPaymentOption Describes an option for buying Telegram Stars. Use telegramPaymentPurposeStars for out-of-store payments
type StarPaymentOption struct {
	tdCommon
	Currency       string `json:"currency"`         // ISO 4217 currency code for the payment
	Amount         int64  `json:"amount"`           // The amount to pay, in the smallest units of the currency
	StarCount      int64  `json:"star_count"`       // Number of Telegram Stars that will be purchased
	StoreProductID string `json:"store_product_id"` // Identifier of the store product associated with the option; may be empty if none
	IsAdditional   bool   `json:"is_additional"`    // True, if the option must be shown only in the full list of payment options
}

// MessageType return the string telegram-type of StarPaymentOption
func (starPaymentOption *StarPaymentOption) MessageType() string {
	return "starPaymentOption"
}

// NewStarPaymentOption creates a new StarPaymentOption
//
// @param currency ISO 4217 currency code for the payment
// @param amount The amount to pay, in the smallest units of the currency
// @param starCount Number of Telegram Stars that will be purchased
// @param storeProductID Identifier of the store product associated with the option; may be empty if none
// @param isAdditional True, if the option must be shown only in the full list of payment options
func NewStarPaymentOption(currency string, amount int64, starCount int64, storeProductID string, isAdditional bool) *StarPaymentOption {
	starPaymentOptionTemp := StarPaymentOption{
		tdCommon:       tdCommon{Type: "starPaymentOption"},
		Currency:       currency,
		Amount:         amount,
		StarCount:      starCount,
		StoreProductID: storeProductID,
		IsAdditional:   isAdditional,
	}

	return &starPaymentOptionTemp
}

// UnmarshalJSON unmarshal to json
func (starPaymentOption *StarPaymentOption) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Currency       string `json:"currency"`         // ISO 4217 currency code for the payment
		Amount         int64  `json:"amount"`           // The amount to pay, in the smallest units of the currency
		StarCount      int64  `json:"star_count"`       // Number of Telegram Stars that will be purchased
		StoreProductID string `json:"store_product_id"` // Identifier of the store product associated with the option; may be empty if none
		IsAdditional   bool   `json:"is_additional"`    // True, if the option must be shown only in the full list of payment options
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starPaymentOption.tdCommon = tempObj.tdCommon
	starPaymentOption.Currency = tempObj.Currency
	starPaymentOption.Amount = tempObj.Amount
	starPaymentOption.StarCount = tempObj.StarCount
	starPaymentOption.StoreProductID = tempObj.StoreProductID
	starPaymentOption.IsAdditional = tempObj.IsAdditional

	return nil
}

// StarPaymentOptions Contains a list of options for buying Telegram Stars
type StarPaymentOptions struct {
	tdCommon
	Options []StarPaymentOption `json:"options"` // The list of options
}

// MessageType return the string telegram-type of StarPaymentOptions
func (starPaymentOptions *StarPaymentOptions) MessageType() string {
	return "starPaymentOptions"
}

// NewStarPaymentOptions creates a new StarPaymentOptions
//
// @param options The list of options
func NewStarPaymentOptions(options []StarPaymentOption) *StarPaymentOptions {
	starPaymentOptionsTemp := StarPaymentOptions{
		tdCommon: tdCommon{Type: "starPaymentOptions"},
		Options:  options,
	}

	return &starPaymentOptionsTemp
}

// UnmarshalJSON unmarshal to json
func (starPaymentOptions *StarPaymentOptions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Options []StarPaymentOption `json:"options"` // The list of options
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starPaymentOptions.tdCommon = tempObj.tdCommon
	starPaymentOptions.Options = tempObj.Options

	return nil
}

// StarGiveawayWinnerOption Describes an option for the number of winners of a Telegram Star giveaway
type StarGiveawayWinnerOption struct {
	tdCommon
	WinnerCount  int32 `json:"winner_count"`   // The number of users that will be chosen as winners
	WonStarCount int64 `json:"won_star_count"` // The number of Telegram Stars that will be won by the winners of the giveaway
	IsDefault    bool  `json:"is_default"`     // True, if the option must be chosen by default
}

// MessageType return the string telegram-type of StarGiveawayWinnerOption
func (starGiveawayWinnerOption *StarGiveawayWinnerOption) MessageType() string {
	return "starGiveawayWinnerOption"
}

// NewStarGiveawayWinnerOption creates a new StarGiveawayWinnerOption
//
// @param winnerCount The number of users that will be chosen as winners
// @param wonStarCount The number of Telegram Stars that will be won by the winners of the giveaway
// @param isDefault True, if the option must be chosen by default
func NewStarGiveawayWinnerOption(winnerCount int32, wonStarCount int64, isDefault bool) *StarGiveawayWinnerOption {
	starGiveawayWinnerOptionTemp := StarGiveawayWinnerOption{
		tdCommon:     tdCommon{Type: "starGiveawayWinnerOption"},
		WinnerCount:  winnerCount,
		WonStarCount: wonStarCount,
		IsDefault:    isDefault,
	}

	return &starGiveawayWinnerOptionTemp
}

// UnmarshalJSON unmarshal to json
func (starGiveawayWinnerOption *StarGiveawayWinnerOption) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		WinnerCount  int32 `json:"winner_count"`   // The number of users that will be chosen as winners
		WonStarCount int64 `json:"won_star_count"` // The number of Telegram Stars that will be won by the winners of the giveaway
		IsDefault    bool  `json:"is_default"`     // True, if the option must be chosen by default
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starGiveawayWinnerOption.tdCommon = tempObj.tdCommon
	starGiveawayWinnerOption.WinnerCount = tempObj.WinnerCount
	starGiveawayWinnerOption.WonStarCount = tempObj.WonStarCount
	starGiveawayWinnerOption.IsDefault = tempObj.IsDefault

	return nil
}

// StarGiveawayPaymentOption Describes an option for creating Telegram Star giveaway. Use telegramPaymentPurposeStarGiveaway for out-of-store payments
type StarGiveawayPaymentOption struct {
	tdCommon
	Currency         string                     `json:"currency"`           // ISO 4217 currency code for the payment
	Amount           int64                      `json:"amount"`             // The amount to pay, in the smallest units of the currency
	StarCount        int64                      `json:"star_count"`         // Number of Telegram Stars that will be distributed among winners
	StoreProductID   string                     `json:"store_product_id"`   // Identifier of the store product associated with the option; may be empty if none
	YearlyBoostCount int32                      `json:"yearly_boost_count"` // Number of times the chat will be boosted for one year if the option is chosen
	WinnerOptions    []StarGiveawayWinnerOption `json:"winner_options"`     // Allowed options for the number of giveaway winners
	IsDefault        bool                       `json:"is_default"`         // True, if the option must be chosen by default
	IsAdditional     bool                       `json:"is_additional"`      // True, if the option must be shown only in the full list of payment options
}

// MessageType return the string telegram-type of StarGiveawayPaymentOption
func (starGiveawayPaymentOption *StarGiveawayPaymentOption) MessageType() string {
	return "starGiveawayPaymentOption"
}

// NewStarGiveawayPaymentOption creates a new StarGiveawayPaymentOption
//
// @param currency ISO 4217 currency code for the payment
// @param amount The amount to pay, in the smallest units of the currency
// @param starCount Number of Telegram Stars that will be distributed among winners
// @param storeProductID Identifier of the store product associated with the option; may be empty if none
// @param yearlyBoostCount Number of times the chat will be boosted for one year if the option is chosen
// @param winnerOptions Allowed options for the number of giveaway winners
// @param isDefault True, if the option must be chosen by default
// @param isAdditional True, if the option must be shown only in the full list of payment options
func NewStarGiveawayPaymentOption(currency string, amount int64, starCount int64, storeProductID string, yearlyBoostCount int32, winnerOptions []StarGiveawayWinnerOption, isDefault bool, isAdditional bool) *StarGiveawayPaymentOption {
	starGiveawayPaymentOptionTemp := StarGiveawayPaymentOption{
		tdCommon:         tdCommon{Type: "starGiveawayPaymentOption"},
		Currency:         currency,
		Amount:           amount,
		StarCount:        starCount,
		StoreProductID:   storeProductID,
		YearlyBoostCount: yearlyBoostCount,
		WinnerOptions:    winnerOptions,
		IsDefault:        isDefault,
		IsAdditional:     isAdditional,
	}

	return &starGiveawayPaymentOptionTemp
}

// UnmarshalJSON unmarshal to json
func (starGiveawayPaymentOption *StarGiveawayPaymentOption) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Currency         string                     `json:"currency"`           // ISO 4217 currency code for the payment
		Amount           int64                      `json:"amount"`             // The amount to pay, in the smallest units of the currency
		StarCount        int64                      `json:"star_count"`         // Number of Telegram Stars that will be distributed among winners
		StoreProductID   string                     `json:"store_product_id"`   // Identifier of the store product associated with the option; may be empty if none
		YearlyBoostCount int32                      `json:"yearly_boost_count"` // Number of times the chat will be boosted for one year if the option is chosen
		WinnerOptions    []StarGiveawayWinnerOption `json:"winner_options"`     // Allowed options for the number of giveaway winners
		IsDefault        bool                       `json:"is_default"`         // True, if the option must be chosen by default
		IsAdditional     bool                       `json:"is_additional"`      // True, if the option must be shown only in the full list of payment options
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starGiveawayPaymentOption.tdCommon = tempObj.tdCommon
	starGiveawayPaymentOption.Currency = tempObj.Currency
	starGiveawayPaymentOption.Amount = tempObj.Amount
	starGiveawayPaymentOption.StarCount = tempObj.StarCount
	starGiveawayPaymentOption.StoreProductID = tempObj.StoreProductID
	starGiveawayPaymentOption.YearlyBoostCount = tempObj.YearlyBoostCount
	starGiveawayPaymentOption.WinnerOptions = tempObj.WinnerOptions
	starGiveawayPaymentOption.IsDefault = tempObj.IsDefault
	starGiveawayPaymentOption.IsAdditional = tempObj.IsAdditional

	return nil
}

// StarGiveawayPaymentOptions Contains a list of options for creating Telegram Star giveaway
type StarGiveawayPaymentOptions struct {
	tdCommon
	Options []StarGiveawayPaymentOption `json:"options"` // The list of options
}

// MessageType return the string telegram-type of StarGiveawayPaymentOptions
func (starGiveawayPaymentOptions *StarGiveawayPaymentOptions) MessageType() string {
	return "starGiveawayPaymentOptions"
}

// NewStarGiveawayPaymentOptions creates a new StarGiveawayPaymentOptions
//
// @param options The list of options
func NewStarGiveawayPaymentOptions(options []StarGiveawayPaymentOption) *StarGiveawayPaymentOptions {
	starGiveawayPaymentOptionsTemp := StarGiveawayPaymentOptions{
		tdCommon: tdCommon{Type: "starGiveawayPaymentOptions"},
		Options:  options,
	}

	return &starGiveawayPaymentOptionsTemp
}

// UnmarshalJSON unmarshal to json
func (starGiveawayPaymentOptions *StarGiveawayPaymentOptions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Options []StarGiveawayPaymentOption `json:"options"` // The list of options
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starGiveawayPaymentOptions.tdCommon = tempObj.tdCommon
	starGiveawayPaymentOptions.Options = tempObj.Options

	return nil
}

// StarTransactionDirectionIncoming The transaction is incoming and increases the number of owned Telegram Stars
type StarTransactionDirectionIncoming struct {
	tdCommon
}

// MessageType return the string telegram-type of StarTransactionDirectionIncoming
func (starTransactionDirectionIncoming *StarTransactionDirectionIncoming) MessageType() string {
	return "starTransactionDirectionIncoming"
}

// NewStarTransactionDirectionIncoming creates a new StarTransactionDirectionIncoming
//
func NewStarTransactionDirectionIncoming() *StarTransactionDirectionIncoming {
	starTransactionDirectionIncomingTemp := StarTransactionDirectionIncoming{
		tdCommon: tdCommon{Type: "starTransactionDirectionIncoming"},
	}

	return &starTransactionDirectionIncomingTemp
}

// UnmarshalJSON unmarshal to json
func (starTransactionDirectionIncoming *StarTransactionDirectionIncoming) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starTransactionDirectionIncoming.tdCommon = tempObj.tdCommon

	return nil
}

// GetStarTransactionDirectionEnum return the enum type of this object
func (starTransactionDirectionIncoming *StarTransactionDirectionIncoming) GetStarTransactionDirectionEnum() StarTransactionDirectionEnum {
	return StarTransactionDirectionIncomingType
}

// StarTransactionDirectionOutgoing The transaction is outgoing and decreases the number of owned Telegram Stars
type StarTransactionDirectionOutgoing struct {
	tdCommon
}

// MessageType return the string telegram-type of StarTransactionDirectionOutgoing
func (starTransactionDirectionOutgoing *StarTransactionDirectionOutgoing) MessageType() string {
	return "starTransactionDirectionOutgoing"
}

// NewStarTransactionDirectionOutgoing creates a new StarTransactionDirectionOutgoing
//
func NewStarTransactionDirectionOutgoing() *StarTransactionDirectionOutgoing {
	starTransactionDirectionOutgoingTemp := StarTransactionDirectionOutgoing{
		tdCommon: tdCommon{Type: "starTransactionDirectionOutgoing"},
	}

	return &starTransactionDirectionOutgoingTemp
}

// UnmarshalJSON unmarshal to json
func (starTransactionDirectionOutgoing *StarTransactionDirectionOutgoing) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starTransactionDirectionOutgoing.tdCommon = tempObj.tdCommon

	return nil
}

// GetStarTransactionDirectionEnum return the enum type of this object
func (starTransactionDirectionOutgoing *StarTransactionDirectionOutgoing) GetStarTransactionDirectionEnum() StarTransactionDirectionEnum {
	return StarTransactionDirectionOutgoingType
}

// BotTransactionPurposePaidMedia Paid media were bought
type BotTransactionPurposePaidMedia struct {
	tdCommon
	Media   []PaidMedia `json:"media"`   // The bought media if the trancastion wasn't refunded
	Payload string      `json:"payload"` // Bot-provided payload; for bots only
}

// MessageType return the string telegram-type of BotTransactionPurposePaidMedia
func (botTransactionPurposePaidMedia *BotTransactionPurposePaidMedia) MessageType() string {
	return "botTransactionPurposePaidMedia"
}

// NewBotTransactionPurposePaidMedia creates a new BotTransactionPurposePaidMedia
//
// @param media The bought media if the trancastion wasn't refunded
// @param payload Bot-provided payload; for bots only
func NewBotTransactionPurposePaidMedia(media []PaidMedia, payload string) *BotTransactionPurposePaidMedia {
	botTransactionPurposePaidMediaTemp := BotTransactionPurposePaidMedia{
		tdCommon: tdCommon{Type: "botTransactionPurposePaidMedia"},
		Media:    media,
		Payload:  payload,
	}

	return &botTransactionPurposePaidMediaTemp
}

// UnmarshalJSON unmarshal to json
func (botTransactionPurposePaidMedia *BotTransactionPurposePaidMedia) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Payload string `json:"payload"` // Bot-provided payload; for bots only
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	botTransactionPurposePaidMedia.tdCommon = tempObj.tdCommon
	botTransactionPurposePaidMedia.Payload = tempObj.Payload

	fieldMedia, _ := unmarshalPaidMediaSlice(objMap["media"])
	botTransactionPurposePaidMedia.Media = fieldMedia

	return nil
}

// GetBotTransactionPurposeEnum return the enum type of this object
func (botTransactionPurposePaidMedia *BotTransactionPurposePaidMedia) GetBotTransactionPurposeEnum() BotTransactionPurposeEnum {
	return BotTransactionPurposePaidMediaType
}

// BotTransactionPurposeInvoicePayment User bought a product from the bot
type BotTransactionPurposeInvoicePayment struct {
	tdCommon
	ProductInfo    *ProductInfo `json:"product_info"`    // Information about the bought product; may be null if not applicable
	InvoicePayload []byte       `json:"invoice_payload"` // Invoice payload; for bots only
}

// MessageType return the string telegram-type of BotTransactionPurposeInvoicePayment
func (botTransactionPurposeInvoicePayment *BotTransactionPurposeInvoicePayment) MessageType() string {
	return "botTransactionPurposeInvoicePayment"
}

// NewBotTransactionPurposeInvoicePayment creates a new BotTransactionPurposeInvoicePayment
//
// @param productInfo Information about the bought product; may be null if not applicable
// @param invoicePayload Invoice payload; for bots only
func NewBotTransactionPurposeInvoicePayment(productInfo *ProductInfo, invoicePayload []byte) *BotTransactionPurposeInvoicePayment {
	botTransactionPurposeInvoicePaymentTemp := BotTransactionPurposeInvoicePayment{
		tdCommon:       tdCommon{Type: "botTransactionPurposeInvoicePayment"},
		ProductInfo:    productInfo,
		InvoicePayload: invoicePayload,
	}

	return &botTransactionPurposeInvoicePaymentTemp
}

// UnmarshalJSON unmarshal to json
func (botTransactionPurposeInvoicePayment *BotTransactionPurposeInvoicePayment) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ProductInfo    *ProductInfo `json:"product_info"`    // Information about the bought product; may be null if not applicable
		InvoicePayload []byte       `json:"invoice_payload"` // Invoice payload; for bots only
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	botTransactionPurposeInvoicePayment.tdCommon = tempObj.tdCommon
	botTransactionPurposeInvoicePayment.ProductInfo = tempObj.ProductInfo
	botTransactionPurposeInvoicePayment.InvoicePayload = tempObj.InvoicePayload

	return nil
}

// GetBotTransactionPurposeEnum return the enum type of this object
func (botTransactionPurposeInvoicePayment *BotTransactionPurposeInvoicePayment) GetBotTransactionPurposeEnum() BotTransactionPurposeEnum {
	return BotTransactionPurposeInvoicePaymentType
}

// ChatTransactionPurposePaidMedia Paid media were bought
type ChatTransactionPurposePaidMedia struct {
	tdCommon
	MessageID int64       `json:"message_id"` // Identifier of the corresponding message with paid media; can be 0 or an identifier of a deleted message
	Media     []PaidMedia `json:"media"`      // The bought media if the trancastion wasn't refunded
}

// MessageType return the string telegram-type of ChatTransactionPurposePaidMedia
func (chatTransactionPurposePaidMedia *ChatTransactionPurposePaidMedia) MessageType() string {
	return "chatTransactionPurposePaidMedia"
}

// NewChatTransactionPurposePaidMedia creates a new ChatTransactionPurposePaidMedia
//
// @param messageID Identifier of the corresponding message with paid media; can be 0 or an identifier of a deleted message
// @param media The bought media if the trancastion wasn't refunded
func NewChatTransactionPurposePaidMedia(messageID int64, media []PaidMedia) *ChatTransactionPurposePaidMedia {
	chatTransactionPurposePaidMediaTemp := ChatTransactionPurposePaidMedia{
		tdCommon:  tdCommon{Type: "chatTransactionPurposePaidMedia"},
		MessageID: messageID,
		Media:     media,
	}

	return &chatTransactionPurposePaidMediaTemp
}

// UnmarshalJSON unmarshal to json
func (chatTransactionPurposePaidMedia *ChatTransactionPurposePaidMedia) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MessageID int64 `json:"message_id"` // Identifier of the corresponding message with paid media; can be 0 or an identifier of a deleted message

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatTransactionPurposePaidMedia.tdCommon = tempObj.tdCommon
	chatTransactionPurposePaidMedia.MessageID = tempObj.MessageID

	fieldMedia, _ := unmarshalPaidMediaSlice(objMap["media"])
	chatTransactionPurposePaidMedia.Media = fieldMedia

	return nil
}

// GetChatTransactionPurposeEnum return the enum type of this object
func (chatTransactionPurposePaidMedia *ChatTransactionPurposePaidMedia) GetChatTransactionPurposeEnum() ChatTransactionPurposeEnum {
	return ChatTransactionPurposePaidMediaType
}

// ChatTransactionPurposeJoin User joined the channel and subscribed to regular payments in Telegram Stars
type ChatTransactionPurposeJoin struct {
	tdCommon
	Period int32 `json:"period"` // The number of seconds between consecutive Telegram Star debiting
}

// MessageType return the string telegram-type of ChatTransactionPurposeJoin
func (chatTransactionPurposeJoin *ChatTransactionPurposeJoin) MessageType() string {
	return "chatTransactionPurposeJoin"
}

// NewChatTransactionPurposeJoin creates a new ChatTransactionPurposeJoin
//
// @param period The number of seconds between consecutive Telegram Star debiting
func NewChatTransactionPurposeJoin(period int32) *ChatTransactionPurposeJoin {
	chatTransactionPurposeJoinTemp := ChatTransactionPurposeJoin{
		tdCommon: tdCommon{Type: "chatTransactionPurposeJoin"},
		Period:   period,
	}

	return &chatTransactionPurposeJoinTemp
}

// UnmarshalJSON unmarshal to json
func (chatTransactionPurposeJoin *ChatTransactionPurposeJoin) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Period int32 `json:"period"` // The number of seconds between consecutive Telegram Star debiting
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatTransactionPurposeJoin.tdCommon = tempObj.tdCommon
	chatTransactionPurposeJoin.Period = tempObj.Period

	return nil
}

// GetChatTransactionPurposeEnum return the enum type of this object
func (chatTransactionPurposeJoin *ChatTransactionPurposeJoin) GetChatTransactionPurposeEnum() ChatTransactionPurposeEnum {
	return ChatTransactionPurposeJoinType
}

// ChatTransactionPurposeReaction User paid for a reaction
type ChatTransactionPurposeReaction struct {
	tdCommon
	MessageID int64 `json:"message_id"` // Identifier of the reacted message; can be 0 or an identifier of a deleted message
}

// MessageType return the string telegram-type of ChatTransactionPurposeReaction
func (chatTransactionPurposeReaction *ChatTransactionPurposeReaction) MessageType() string {
	return "chatTransactionPurposeReaction"
}

// NewChatTransactionPurposeReaction creates a new ChatTransactionPurposeReaction
//
// @param messageID Identifier of the reacted message; can be 0 or an identifier of a deleted message
func NewChatTransactionPurposeReaction(messageID int64) *ChatTransactionPurposeReaction {
	chatTransactionPurposeReactionTemp := ChatTransactionPurposeReaction{
		tdCommon:  tdCommon{Type: "chatTransactionPurposeReaction"},
		MessageID: messageID,
	}

	return &chatTransactionPurposeReactionTemp
}

// UnmarshalJSON unmarshal to json
func (chatTransactionPurposeReaction *ChatTransactionPurposeReaction) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MessageID int64 `json:"message_id"` // Identifier of the reacted message; can be 0 or an identifier of a deleted message
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatTransactionPurposeReaction.tdCommon = tempObj.tdCommon
	chatTransactionPurposeReaction.MessageID = tempObj.MessageID

	return nil
}

// GetChatTransactionPurposeEnum return the enum type of this object
func (chatTransactionPurposeReaction *ChatTransactionPurposeReaction) GetChatTransactionPurposeEnum() ChatTransactionPurposeEnum {
	return ChatTransactionPurposeReactionType
}

// ChatTransactionPurposeGiveaway User received Telegram Stars from a giveaway
type ChatTransactionPurposeGiveaway struct {
	tdCommon
	GiveawayMessageID int64 `json:"giveaway_message_id"` // Identifier of the message with giveaway; can be 0 or an identifier of a deleted message
}

// MessageType return the string telegram-type of ChatTransactionPurposeGiveaway
func (chatTransactionPurposeGiveaway *ChatTransactionPurposeGiveaway) MessageType() string {
	return "chatTransactionPurposeGiveaway"
}

// NewChatTransactionPurposeGiveaway creates a new ChatTransactionPurposeGiveaway
//
// @param giveawayMessageID Identifier of the message with giveaway; can be 0 or an identifier of a deleted message
func NewChatTransactionPurposeGiveaway(giveawayMessageID int64) *ChatTransactionPurposeGiveaway {
	chatTransactionPurposeGiveawayTemp := ChatTransactionPurposeGiveaway{
		tdCommon:          tdCommon{Type: "chatTransactionPurposeGiveaway"},
		GiveawayMessageID: giveawayMessageID,
	}

	return &chatTransactionPurposeGiveawayTemp
}

// UnmarshalJSON unmarshal to json
func (chatTransactionPurposeGiveaway *ChatTransactionPurposeGiveaway) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		GiveawayMessageID int64 `json:"giveaway_message_id"` // Identifier of the message with giveaway; can be 0 or an identifier of a deleted message
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatTransactionPurposeGiveaway.tdCommon = tempObj.tdCommon
	chatTransactionPurposeGiveaway.GiveawayMessageID = tempObj.GiveawayMessageID

	return nil
}

// GetChatTransactionPurposeEnum return the enum type of this object
func (chatTransactionPurposeGiveaway *ChatTransactionPurposeGiveaway) GetChatTransactionPurposeEnum() ChatTransactionPurposeEnum {
	return ChatTransactionPurposeGiveawayType
}

// StarTransactionPartnerTelegram The transaction is a transaction with Telegram through a bot
type StarTransactionPartnerTelegram struct {
	tdCommon
}

// MessageType return the string telegram-type of StarTransactionPartnerTelegram
func (starTransactionPartnerTelegram *StarTransactionPartnerTelegram) MessageType() string {
	return "starTransactionPartnerTelegram"
}

// NewStarTransactionPartnerTelegram creates a new StarTransactionPartnerTelegram
//
func NewStarTransactionPartnerTelegram() *StarTransactionPartnerTelegram {
	starTransactionPartnerTelegramTemp := StarTransactionPartnerTelegram{
		tdCommon: tdCommon{Type: "starTransactionPartnerTelegram"},
	}

	return &starTransactionPartnerTelegramTemp
}

// UnmarshalJSON unmarshal to json
func (starTransactionPartnerTelegram *StarTransactionPartnerTelegram) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starTransactionPartnerTelegram.tdCommon = tempObj.tdCommon

	return nil
}

// GetStarTransactionPartnerEnum return the enum type of this object
func (starTransactionPartnerTelegram *StarTransactionPartnerTelegram) GetStarTransactionPartnerEnum() StarTransactionPartnerEnum {
	return StarTransactionPartnerTelegramType
}

// StarTransactionPartnerAppStore The transaction is a transaction with App Store
type StarTransactionPartnerAppStore struct {
	tdCommon
}

// MessageType return the string telegram-type of StarTransactionPartnerAppStore
func (starTransactionPartnerAppStore *StarTransactionPartnerAppStore) MessageType() string {
	return "starTransactionPartnerAppStore"
}

// NewStarTransactionPartnerAppStore creates a new StarTransactionPartnerAppStore
//
func NewStarTransactionPartnerAppStore() *StarTransactionPartnerAppStore {
	starTransactionPartnerAppStoreTemp := StarTransactionPartnerAppStore{
		tdCommon: tdCommon{Type: "starTransactionPartnerAppStore"},
	}

	return &starTransactionPartnerAppStoreTemp
}

// UnmarshalJSON unmarshal to json
func (starTransactionPartnerAppStore *StarTransactionPartnerAppStore) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starTransactionPartnerAppStore.tdCommon = tempObj.tdCommon

	return nil
}

// GetStarTransactionPartnerEnum return the enum type of this object
func (starTransactionPartnerAppStore *StarTransactionPartnerAppStore) GetStarTransactionPartnerEnum() StarTransactionPartnerEnum {
	return StarTransactionPartnerAppStoreType
}

// StarTransactionPartnerGooglePlay The transaction is a transaction with Google Play
type StarTransactionPartnerGooglePlay struct {
	tdCommon
}

// MessageType return the string telegram-type of StarTransactionPartnerGooglePlay
func (starTransactionPartnerGooglePlay *StarTransactionPartnerGooglePlay) MessageType() string {
	return "starTransactionPartnerGooglePlay"
}

// NewStarTransactionPartnerGooglePlay creates a new StarTransactionPartnerGooglePlay
//
func NewStarTransactionPartnerGooglePlay() *StarTransactionPartnerGooglePlay {
	starTransactionPartnerGooglePlayTemp := StarTransactionPartnerGooglePlay{
		tdCommon: tdCommon{Type: "starTransactionPartnerGooglePlay"},
	}

	return &starTransactionPartnerGooglePlayTemp
}

// UnmarshalJSON unmarshal to json
func (starTransactionPartnerGooglePlay *StarTransactionPartnerGooglePlay) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starTransactionPartnerGooglePlay.tdCommon = tempObj.tdCommon

	return nil
}

// GetStarTransactionPartnerEnum return the enum type of this object
func (starTransactionPartnerGooglePlay *StarTransactionPartnerGooglePlay) GetStarTransactionPartnerEnum() StarTransactionPartnerEnum {
	return StarTransactionPartnerGooglePlayType
}

// StarTransactionPartnerFragment The transaction is a transaction with Fragment
type StarTransactionPartnerFragment struct {
	tdCommon
	WithdrawalState *RevenueWithdrawalState `json:"withdrawal_state"` // State of the withdrawal; may be null for refunds from Fragment
}

// MessageType return the string telegram-type of StarTransactionPartnerFragment
func (starTransactionPartnerFragment *StarTransactionPartnerFragment) MessageType() string {
	return "starTransactionPartnerFragment"
}

// NewStarTransactionPartnerFragment creates a new StarTransactionPartnerFragment
//
// @param withdrawalState State of the withdrawal; may be null for refunds from Fragment
func NewStarTransactionPartnerFragment(withdrawalState *RevenueWithdrawalState) *StarTransactionPartnerFragment {
	starTransactionPartnerFragmentTemp := StarTransactionPartnerFragment{
		tdCommon:        tdCommon{Type: "starTransactionPartnerFragment"},
		WithdrawalState: withdrawalState,
	}

	return &starTransactionPartnerFragmentTemp
}

// UnmarshalJSON unmarshal to json
func (starTransactionPartnerFragment *StarTransactionPartnerFragment) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starTransactionPartnerFragment.tdCommon = tempObj.tdCommon

	fieldWithdrawalState, _ := unmarshalRevenueWithdrawalState(objMap["withdrawal_state"])
	starTransactionPartnerFragment.WithdrawalState = &fieldWithdrawalState

	return nil
}

// GetStarTransactionPartnerEnum return the enum type of this object
func (starTransactionPartnerFragment *StarTransactionPartnerFragment) GetStarTransactionPartnerEnum() StarTransactionPartnerEnum {
	return StarTransactionPartnerFragmentType
}

// StarTransactionPartnerTelegramAds The transaction is a transaction with Telegram Ad platform
type StarTransactionPartnerTelegramAds struct {
	tdCommon
}

// MessageType return the string telegram-type of StarTransactionPartnerTelegramAds
func (starTransactionPartnerTelegramAds *StarTransactionPartnerTelegramAds) MessageType() string {
	return "starTransactionPartnerTelegramAds"
}

// NewStarTransactionPartnerTelegramAds creates a new StarTransactionPartnerTelegramAds
//
func NewStarTransactionPartnerTelegramAds() *StarTransactionPartnerTelegramAds {
	starTransactionPartnerTelegramAdsTemp := StarTransactionPartnerTelegramAds{
		tdCommon: tdCommon{Type: "starTransactionPartnerTelegramAds"},
	}

	return &starTransactionPartnerTelegramAdsTemp
}

// UnmarshalJSON unmarshal to json
func (starTransactionPartnerTelegramAds *StarTransactionPartnerTelegramAds) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starTransactionPartnerTelegramAds.tdCommon = tempObj.tdCommon

	return nil
}

// GetStarTransactionPartnerEnum return the enum type of this object
func (starTransactionPartnerTelegramAds *StarTransactionPartnerTelegramAds) GetStarTransactionPartnerEnum() StarTransactionPartnerEnum {
	return StarTransactionPartnerTelegramAdsType
}

// StarTransactionPartnerBot The transaction is a transaction with a bot
type StarTransactionPartnerBot struct {
	tdCommon
	UserID  int64                 `json:"user_id"` // Identifier of the bot
	Purpose BotTransactionPurpose `json:"purpose"` // Purpose of the transaction
}

// MessageType return the string telegram-type of StarTransactionPartnerBot
func (starTransactionPartnerBot *StarTransactionPartnerBot) MessageType() string {
	return "starTransactionPartnerBot"
}

// NewStarTransactionPartnerBot creates a new StarTransactionPartnerBot
//
// @param userID Identifier of the bot
// @param purpose Purpose of the transaction
func NewStarTransactionPartnerBot(userID int64, purpose BotTransactionPurpose) *StarTransactionPartnerBot {
	starTransactionPartnerBotTemp := StarTransactionPartnerBot{
		tdCommon: tdCommon{Type: "starTransactionPartnerBot"},
		UserID:   userID,
		Purpose:  purpose,
	}

	return &starTransactionPartnerBotTemp
}

// UnmarshalJSON unmarshal to json
func (starTransactionPartnerBot *StarTransactionPartnerBot) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID int64 `json:"user_id"` // Identifier of the bot

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starTransactionPartnerBot.tdCommon = tempObj.tdCommon
	starTransactionPartnerBot.UserID = tempObj.UserID

	fieldPurpose, _ := unmarshalBotTransactionPurpose(objMap["purpose"])
	starTransactionPartnerBot.Purpose = fieldPurpose

	return nil
}

// GetStarTransactionPartnerEnum return the enum type of this object
func (starTransactionPartnerBot *StarTransactionPartnerBot) GetStarTransactionPartnerEnum() StarTransactionPartnerEnum {
	return StarTransactionPartnerBotType
}

// StarTransactionPartnerBusiness The transaction is a transaction with a business account
type StarTransactionPartnerBusiness struct {
	tdCommon
	UserID int64       `json:"user_id"` // Identifier of the business account user
	Media  []PaidMedia `json:"media"`   // The bought media if the trancastion wasn't refunded
}

// MessageType return the string telegram-type of StarTransactionPartnerBusiness
func (starTransactionPartnerBusiness *StarTransactionPartnerBusiness) MessageType() string {
	return "starTransactionPartnerBusiness"
}

// NewStarTransactionPartnerBusiness creates a new StarTransactionPartnerBusiness
//
// @param userID Identifier of the business account user
// @param media The bought media if the trancastion wasn't refunded
func NewStarTransactionPartnerBusiness(userID int64, media []PaidMedia) *StarTransactionPartnerBusiness {
	starTransactionPartnerBusinessTemp := StarTransactionPartnerBusiness{
		tdCommon: tdCommon{Type: "starTransactionPartnerBusiness"},
		UserID:   userID,
		Media:    media,
	}

	return &starTransactionPartnerBusinessTemp
}

// UnmarshalJSON unmarshal to json
func (starTransactionPartnerBusiness *StarTransactionPartnerBusiness) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID int64 `json:"user_id"` // Identifier of the business account user

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starTransactionPartnerBusiness.tdCommon = tempObj.tdCommon
	starTransactionPartnerBusiness.UserID = tempObj.UserID

	fieldMedia, _ := unmarshalPaidMediaSlice(objMap["media"])
	starTransactionPartnerBusiness.Media = fieldMedia

	return nil
}

// GetStarTransactionPartnerEnum return the enum type of this object
func (starTransactionPartnerBusiness *StarTransactionPartnerBusiness) GetStarTransactionPartnerEnum() StarTransactionPartnerEnum {
	return StarTransactionPartnerBusinessType
}

// StarTransactionPartnerChat The transaction is a transaction with a supergroup or a channel chat
type StarTransactionPartnerChat struct {
	tdCommon
	ChatID  int64                  `json:"chat_id"` // Identifier of the chat
	Purpose ChatTransactionPurpose `json:"purpose"` // Purpose of the transaction
}

// MessageType return the string telegram-type of StarTransactionPartnerChat
func (starTransactionPartnerChat *StarTransactionPartnerChat) MessageType() string {
	return "starTransactionPartnerChat"
}

// NewStarTransactionPartnerChat creates a new StarTransactionPartnerChat
//
// @param chatID Identifier of the chat
// @param purpose Purpose of the transaction
func NewStarTransactionPartnerChat(chatID int64, purpose ChatTransactionPurpose) *StarTransactionPartnerChat {
	starTransactionPartnerChatTemp := StarTransactionPartnerChat{
		tdCommon: tdCommon{Type: "starTransactionPartnerChat"},
		ChatID:   chatID,
		Purpose:  purpose,
	}

	return &starTransactionPartnerChatTemp
}

// UnmarshalJSON unmarshal to json
func (starTransactionPartnerChat *StarTransactionPartnerChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID int64 `json:"chat_id"` // Identifier of the chat

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starTransactionPartnerChat.tdCommon = tempObj.tdCommon
	starTransactionPartnerChat.ChatID = tempObj.ChatID

	fieldPurpose, _ := unmarshalChatTransactionPurpose(objMap["purpose"])
	starTransactionPartnerChat.Purpose = fieldPurpose

	return nil
}

// GetStarTransactionPartnerEnum return the enum type of this object
func (starTransactionPartnerChat *StarTransactionPartnerChat) GetStarTransactionPartnerEnum() StarTransactionPartnerEnum {
	return StarTransactionPartnerChatType
}

// StarTransactionPartnerUser The transaction is a gift of Telegram Stars from another user
type StarTransactionPartnerUser struct {
	tdCommon
	UserID  int64    `json:"user_id"` // Identifier of the user; 0 if the gift was anonymous
	Sticker *Sticker `json:"sticker"` // A sticker to be shown in the transaction information; may be null if unknown
}

// MessageType return the string telegram-type of StarTransactionPartnerUser
func (starTransactionPartnerUser *StarTransactionPartnerUser) MessageType() string {
	return "starTransactionPartnerUser"
}

// NewStarTransactionPartnerUser creates a new StarTransactionPartnerUser
//
// @param userID Identifier of the user; 0 if the gift was anonymous
// @param sticker A sticker to be shown in the transaction information; may be null if unknown
func NewStarTransactionPartnerUser(userID int64, sticker *Sticker) *StarTransactionPartnerUser {
	starTransactionPartnerUserTemp := StarTransactionPartnerUser{
		tdCommon: tdCommon{Type: "starTransactionPartnerUser"},
		UserID:   userID,
		Sticker:  sticker,
	}

	return &starTransactionPartnerUserTemp
}

// UnmarshalJSON unmarshal to json
func (starTransactionPartnerUser *StarTransactionPartnerUser) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID int64 `json:"user_id"` // Identifier of the user; 0 if the gift was anonymous

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starTransactionPartnerUser.tdCommon = tempObj.tdCommon
	starTransactionPartnerUser.UserID = tempObj.UserID

	var sticker Sticker
	if objMap["sticker"] != nil {
		err = sticker.UnmarshalJSON(*objMap["sticker"])
		if err != nil {
			return err
		}
	}

	starTransactionPartnerUser.Sticker = &sticker

	return nil
}

// GetStarTransactionPartnerEnum return the enum type of this object
func (starTransactionPartnerUser *StarTransactionPartnerUser) GetStarTransactionPartnerEnum() StarTransactionPartnerEnum {
	return StarTransactionPartnerUserType
}

// StarTransactionPartnerUnsupported The transaction is a transaction with unknown partner
type StarTransactionPartnerUnsupported struct {
	tdCommon
}

// MessageType return the string telegram-type of StarTransactionPartnerUnsupported
func (starTransactionPartnerUnsupported *StarTransactionPartnerUnsupported) MessageType() string {
	return "starTransactionPartnerUnsupported"
}

// NewStarTransactionPartnerUnsupported creates a new StarTransactionPartnerUnsupported
//
func NewStarTransactionPartnerUnsupported() *StarTransactionPartnerUnsupported {
	starTransactionPartnerUnsupportedTemp := StarTransactionPartnerUnsupported{
		tdCommon: tdCommon{Type: "starTransactionPartnerUnsupported"},
	}

	return &starTransactionPartnerUnsupportedTemp
}

// UnmarshalJSON unmarshal to json
func (starTransactionPartnerUnsupported *StarTransactionPartnerUnsupported) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starTransactionPartnerUnsupported.tdCommon = tempObj.tdCommon

	return nil
}

// GetStarTransactionPartnerEnum return the enum type of this object
func (starTransactionPartnerUnsupported *StarTransactionPartnerUnsupported) GetStarTransactionPartnerEnum() StarTransactionPartnerEnum {
	return StarTransactionPartnerUnsupportedType
}

// StarTransaction Represents a transaction changing the amount of owned Telegram Stars
type StarTransaction struct {
	tdCommon
	ID        string                 `json:"id"`         // Unique identifier of the transaction
	StarCount int64                  `json:"star_count"` // The amount of added owned Telegram Stars; negative for outgoing transactions
	IsRefund  bool                   `json:"is_refund"`  // True, if the transaction is a refund of a previous transaction
	Date      int32                  `json:"date"`       // Point in time (Unix timestamp) when the transaction was completed
	Partner   StarTransactionPartner `json:"partner"`    // Source of the incoming transaction, or its recipient for outgoing transactions
}

// MessageType return the string telegram-type of StarTransaction
func (starTransaction *StarTransaction) MessageType() string {
	return "starTransaction"
}

// NewStarTransaction creates a new StarTransaction
//
// @param iD Unique identifier of the transaction
// @param starCount The amount of added owned Telegram Stars; negative for outgoing transactions
// @param isRefund True, if the transaction is a refund of a previous transaction
// @param date Point in time (Unix timestamp) when the transaction was completed
// @param partner Source of the incoming transaction, or its recipient for outgoing transactions
func NewStarTransaction(iD string, starCount int64, isRefund bool, date int32, partner StarTransactionPartner) *StarTransaction {
	starTransactionTemp := StarTransaction{
		tdCommon:  tdCommon{Type: "starTransaction"},
		ID:        iD,
		StarCount: starCount,
		IsRefund:  isRefund,
		Date:      date,
		Partner:   partner,
	}

	return &starTransactionTemp
}

// UnmarshalJSON unmarshal to json
func (starTransaction *StarTransaction) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID        string `json:"id"`         // Unique identifier of the transaction
		StarCount int64  `json:"star_count"` // The amount of added owned Telegram Stars; negative for outgoing transactions
		IsRefund  bool   `json:"is_refund"`  // True, if the transaction is a refund of a previous transaction
		Date      int32  `json:"date"`       // Point in time (Unix timestamp) when the transaction was completed

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starTransaction.tdCommon = tempObj.tdCommon
	starTransaction.ID = tempObj.ID
	starTransaction.StarCount = tempObj.StarCount
	starTransaction.IsRefund = tempObj.IsRefund
	starTransaction.Date = tempObj.Date

	fieldPartner, _ := unmarshalStarTransactionPartner(objMap["partner"])
	starTransaction.Partner = fieldPartner

	return nil
}

// StarTransactions Represents a list of Telegram Star transactions
type StarTransactions struct {
	tdCommon
	StarCount    int64             `json:"star_count"`   // The amount of owned Telegram Stars
	Transactions []StarTransaction `json:"transactions"` // List of transactions with Telegram Stars
	NextOffset   string            `json:"next_offset"`  // The offset for the next request. If empty, then there are no more results
}

// MessageType return the string telegram-type of StarTransactions
func (starTransactions *StarTransactions) MessageType() string {
	return "starTransactions"
}

// NewStarTransactions creates a new StarTransactions
//
// @param starCount The amount of owned Telegram Stars
// @param transactions List of transactions with Telegram Stars
// @param nextOffset The offset for the next request. If empty, then there are no more results
func NewStarTransactions(starCount int64, transactions []StarTransaction, nextOffset string) *StarTransactions {
	starTransactionsTemp := StarTransactions{
		tdCommon:     tdCommon{Type: "starTransactions"},
		StarCount:    starCount,
		Transactions: transactions,
		NextOffset:   nextOffset,
	}

	return &starTransactionsTemp
}

// UnmarshalJSON unmarshal to json
func (starTransactions *StarTransactions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StarCount    int64             `json:"star_count"`   // The amount of owned Telegram Stars
		Transactions []StarTransaction `json:"transactions"` // List of transactions with Telegram Stars
		NextOffset   string            `json:"next_offset"`  // The offset for the next request. If empty, then there are no more results
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starTransactions.tdCommon = tempObj.tdCommon
	starTransactions.StarCount = tempObj.StarCount
	starTransactions.Transactions = tempObj.Transactions
	starTransactions.NextOffset = tempObj.NextOffset

	return nil
}

// GiveawayParticipantStatusEligible The user is eligible for the giveaway
type GiveawayParticipantStatusEligible struct {
	tdCommon
}

// MessageType return the string telegram-type of GiveawayParticipantStatusEligible
func (giveawayParticipantStatusEligible *GiveawayParticipantStatusEligible) MessageType() string {
	return "giveawayParticipantStatusEligible"
}

// NewGiveawayParticipantStatusEligible creates a new GiveawayParticipantStatusEligible
//
func NewGiveawayParticipantStatusEligible() *GiveawayParticipantStatusEligible {
	giveawayParticipantStatusEligibleTemp := GiveawayParticipantStatusEligible{
		tdCommon: tdCommon{Type: "giveawayParticipantStatusEligible"},
	}

	return &giveawayParticipantStatusEligibleTemp
}

// UnmarshalJSON unmarshal to json
func (giveawayParticipantStatusEligible *GiveawayParticipantStatusEligible) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	giveawayParticipantStatusEligible.tdCommon = tempObj.tdCommon

	return nil
}

// GetGiveawayParticipantStatusEnum return the enum type of this object
func (giveawayParticipantStatusEligible *GiveawayParticipantStatusEligible) GetGiveawayParticipantStatusEnum() GiveawayParticipantStatusEnum {
	return GiveawayParticipantStatusEligibleType
}

// GiveawayParticipantStatusParticipating The user participates in the giveaway
type GiveawayParticipantStatusParticipating struct {
	tdCommon
}

// MessageType return the string telegram-type of GiveawayParticipantStatusParticipating
func (giveawayParticipantStatusParticipating *GiveawayParticipantStatusParticipating) MessageType() string {
	return "giveawayParticipantStatusParticipating"
}

// NewGiveawayParticipantStatusParticipating creates a new GiveawayParticipantStatusParticipating
//
func NewGiveawayParticipantStatusParticipating() *GiveawayParticipantStatusParticipating {
	giveawayParticipantStatusParticipatingTemp := GiveawayParticipantStatusParticipating{
		tdCommon: tdCommon{Type: "giveawayParticipantStatusParticipating"},
	}

	return &giveawayParticipantStatusParticipatingTemp
}

// UnmarshalJSON unmarshal to json
func (giveawayParticipantStatusParticipating *GiveawayParticipantStatusParticipating) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	giveawayParticipantStatusParticipating.tdCommon = tempObj.tdCommon

	return nil
}

// GetGiveawayParticipantStatusEnum return the enum type of this object
func (giveawayParticipantStatusParticipating *GiveawayParticipantStatusParticipating) GetGiveawayParticipantStatusEnum() GiveawayParticipantStatusEnum {
	return GiveawayParticipantStatusParticipatingType
}

// GiveawayParticipantStatusAlreadyWasMember The user can't participate in the giveaway, because they have already been member of the chat
type GiveawayParticipantStatusAlreadyWasMember struct {
	tdCommon
	JoinedChatDate int32 `json:"joined_chat_date"` // Point in time (Unix timestamp) when the user joined the chat
}

// MessageType return the string telegram-type of GiveawayParticipantStatusAlreadyWasMember
func (giveawayParticipantStatusAlreadyWasMember *GiveawayParticipantStatusAlreadyWasMember) MessageType() string {
	return "giveawayParticipantStatusAlreadyWasMember"
}

// NewGiveawayParticipantStatusAlreadyWasMember creates a new GiveawayParticipantStatusAlreadyWasMember
//
// @param joinedChatDate Point in time (Unix timestamp) when the user joined the chat
func NewGiveawayParticipantStatusAlreadyWasMember(joinedChatDate int32) *GiveawayParticipantStatusAlreadyWasMember {
	giveawayParticipantStatusAlreadyWasMemberTemp := GiveawayParticipantStatusAlreadyWasMember{
		tdCommon:       tdCommon{Type: "giveawayParticipantStatusAlreadyWasMember"},
		JoinedChatDate: joinedChatDate,
	}

	return &giveawayParticipantStatusAlreadyWasMemberTemp
}

// UnmarshalJSON unmarshal to json
func (giveawayParticipantStatusAlreadyWasMember *GiveawayParticipantStatusAlreadyWasMember) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		JoinedChatDate int32 `json:"joined_chat_date"` // Point in time (Unix timestamp) when the user joined the chat
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	giveawayParticipantStatusAlreadyWasMember.tdCommon = tempObj.tdCommon
	giveawayParticipantStatusAlreadyWasMember.JoinedChatDate = tempObj.JoinedChatDate

	return nil
}

// GetGiveawayParticipantStatusEnum return the enum type of this object
func (giveawayParticipantStatusAlreadyWasMember *GiveawayParticipantStatusAlreadyWasMember) GetGiveawayParticipantStatusEnum() GiveawayParticipantStatusEnum {
	return GiveawayParticipantStatusAlreadyWasMemberType
}

// GiveawayParticipantStatusAdministrator The user can't participate in the giveaway, because they are an administrator in one of the chats that created the giveaway
type GiveawayParticipantStatusAdministrator struct {
	tdCommon
	ChatID int64 `json:"chat_id"` // Identifier of the chat administered by the user
}

// MessageType return the string telegram-type of GiveawayParticipantStatusAdministrator
func (giveawayParticipantStatusAdministrator *GiveawayParticipantStatusAdministrator) MessageType() string {
	return "giveawayParticipantStatusAdministrator"
}

// NewGiveawayParticipantStatusAdministrator creates a new GiveawayParticipantStatusAdministrator
//
// @param chatID Identifier of the chat administered by the user
func NewGiveawayParticipantStatusAdministrator(chatID int64) *GiveawayParticipantStatusAdministrator {
	giveawayParticipantStatusAdministratorTemp := GiveawayParticipantStatusAdministrator{
		tdCommon: tdCommon{Type: "giveawayParticipantStatusAdministrator"},
		ChatID:   chatID,
	}

	return &giveawayParticipantStatusAdministratorTemp
}

// UnmarshalJSON unmarshal to json
func (giveawayParticipantStatusAdministrator *GiveawayParticipantStatusAdministrator) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID int64 `json:"chat_id"` // Identifier of the chat administered by the user
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	giveawayParticipantStatusAdministrator.tdCommon = tempObj.tdCommon
	giveawayParticipantStatusAdministrator.ChatID = tempObj.ChatID

	return nil
}

// GetGiveawayParticipantStatusEnum return the enum type of this object
func (giveawayParticipantStatusAdministrator *GiveawayParticipantStatusAdministrator) GetGiveawayParticipantStatusEnum() GiveawayParticipantStatusEnum {
	return GiveawayParticipantStatusAdministratorType
}

// GiveawayParticipantStatusDisallowedCountry The user can't participate in the giveaway, because they phone number is from a disallowed country
type GiveawayParticipantStatusDisallowedCountry struct {
	tdCommon
	UserCountryCode string `json:"user_country_code"` // A two-letter ISO 3166-1 alpha-2 country code of the user's country
}

// MessageType return the string telegram-type of GiveawayParticipantStatusDisallowedCountry
func (giveawayParticipantStatusDisallowedCountry *GiveawayParticipantStatusDisallowedCountry) MessageType() string {
	return "giveawayParticipantStatusDisallowedCountry"
}

// NewGiveawayParticipantStatusDisallowedCountry creates a new GiveawayParticipantStatusDisallowedCountry
//
// @param userCountryCode A two-letter ISO 3166-1 alpha-2 country code of the user's country
func NewGiveawayParticipantStatusDisallowedCountry(userCountryCode string) *GiveawayParticipantStatusDisallowedCountry {
	giveawayParticipantStatusDisallowedCountryTemp := GiveawayParticipantStatusDisallowedCountry{
		tdCommon:        tdCommon{Type: "giveawayParticipantStatusDisallowedCountry"},
		UserCountryCode: userCountryCode,
	}

	return &giveawayParticipantStatusDisallowedCountryTemp
}

// UnmarshalJSON unmarshal to json
func (giveawayParticipantStatusDisallowedCountry *GiveawayParticipantStatusDisallowedCountry) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserCountryCode string `json:"user_country_code"` // A two-letter ISO 3166-1 alpha-2 country code of the user's country
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	giveawayParticipantStatusDisallowedCountry.tdCommon = tempObj.tdCommon
	giveawayParticipantStatusDisallowedCountry.UserCountryCode = tempObj.UserCountryCode

	return nil
}

// GetGiveawayParticipantStatusEnum return the enum type of this object
func (giveawayParticipantStatusDisallowedCountry *GiveawayParticipantStatusDisallowedCountry) GetGiveawayParticipantStatusEnum() GiveawayParticipantStatusEnum {
	return GiveawayParticipantStatusDisallowedCountryType
}

// GiveawayInfoOngoing Describes an ongoing giveaway
type GiveawayInfoOngoing struct {
	tdCommon
	CreationDate int32                     `json:"creation_date"` // Point in time (Unix timestamp) when the giveaway was created
	Status       GiveawayParticipantStatus `json:"status"`        // Status of the current user in the giveaway
	IsEnded      bool                      `json:"is_ended"`      // True, if the giveaway has ended and results are being prepared
}

// MessageType return the string telegram-type of GiveawayInfoOngoing
func (giveawayInfoOngoing *GiveawayInfoOngoing) MessageType() string {
	return "giveawayInfoOngoing"
}

// NewGiveawayInfoOngoing creates a new GiveawayInfoOngoing
//
// @param creationDate Point in time (Unix timestamp) when the giveaway was created
// @param status Status of the current user in the giveaway
// @param isEnded True, if the giveaway has ended and results are being prepared
func NewGiveawayInfoOngoing(creationDate int32, status GiveawayParticipantStatus, isEnded bool) *GiveawayInfoOngoing {
	giveawayInfoOngoingTemp := GiveawayInfoOngoing{
		tdCommon:     tdCommon{Type: "giveawayInfoOngoing"},
		CreationDate: creationDate,
		Status:       status,
		IsEnded:      isEnded,
	}

	return &giveawayInfoOngoingTemp
}

// UnmarshalJSON unmarshal to json
func (giveawayInfoOngoing *GiveawayInfoOngoing) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CreationDate int32 `json:"creation_date"` // Point in time (Unix timestamp) when the giveaway was created
		IsEnded      bool  `json:"is_ended"`      // True, if the giveaway has ended and results are being prepared
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	giveawayInfoOngoing.tdCommon = tempObj.tdCommon
	giveawayInfoOngoing.CreationDate = tempObj.CreationDate
	giveawayInfoOngoing.IsEnded = tempObj.IsEnded

	fieldStatus, _ := unmarshalGiveawayParticipantStatus(objMap["status"])
	giveawayInfoOngoing.Status = fieldStatus

	return nil
}

// GetGiveawayInfoEnum return the enum type of this object
func (giveawayInfoOngoing *GiveawayInfoOngoing) GetGiveawayInfoEnum() GiveawayInfoEnum {
	return GiveawayInfoOngoingType
}

// GiveawayInfoCompleted Describes a completed giveaway
type GiveawayInfoCompleted struct {
	tdCommon
	CreationDate               int32  `json:"creation_date"`                 // Point in time (Unix timestamp) when the giveaway was created
	ActualWinnersSelectionDate int32  `json:"actual_winners_selection_date"` // Point in time (Unix timestamp) when the winners were selected. May be bigger than winners selection date specified in parameters of the giveaway
	WasRefunded                bool   `json:"was_refunded"`                  // True, if the giveaway was canceled and was fully refunded
	IsWinner                   bool   `json:"is_winner"`                     // True, if the cuurent user is a winner of the giveaway
	WinnerCount                int32  `json:"winner_count"`                  // Number of winners in the giveaway
	ActivationCount            int32  `json:"activation_count"`              // Number of winners, which activated their gift codes; for Telegram Premium giveaways only
	GiftCode                   string `json:"gift_code"`                     // Telegram Premium gift code that was received by the current user; empty if the user isn't a winner in the giveaway or the giveaway isn't a Telegram Premium giveaway
	WonStarCount               int64  `json:"won_star_count"`                // The amount of Telegram Stars won by the current user; 0 if the user isn't a winner in the giveaway or the giveaway isn't a Telegram Star giveaway
}

// MessageType return the string telegram-type of GiveawayInfoCompleted
func (giveawayInfoCompleted *GiveawayInfoCompleted) MessageType() string {
	return "giveawayInfoCompleted"
}

// NewGiveawayInfoCompleted creates a new GiveawayInfoCompleted
//
// @param creationDate Point in time (Unix timestamp) when the giveaway was created
// @param actualWinnersSelectionDate Point in time (Unix timestamp) when the winners were selected. May be bigger than winners selection date specified in parameters of the giveaway
// @param wasRefunded True, if the giveaway was canceled and was fully refunded
// @param isWinner True, if the cuurent user is a winner of the giveaway
// @param winnerCount Number of winners in the giveaway
// @param activationCount Number of winners, which activated their gift codes; for Telegram Premium giveaways only
// @param giftCode Telegram Premium gift code that was received by the current user; empty if the user isn't a winner in the giveaway or the giveaway isn't a Telegram Premium giveaway
// @param wonStarCount The amount of Telegram Stars won by the current user; 0 if the user isn't a winner in the giveaway or the giveaway isn't a Telegram Star giveaway
func NewGiveawayInfoCompleted(creationDate int32, actualWinnersSelectionDate int32, wasRefunded bool, isWinner bool, winnerCount int32, activationCount int32, giftCode string, wonStarCount int64) *GiveawayInfoCompleted {
	giveawayInfoCompletedTemp := GiveawayInfoCompleted{
		tdCommon:                   tdCommon{Type: "giveawayInfoCompleted"},
		CreationDate:               creationDate,
		ActualWinnersSelectionDate: actualWinnersSelectionDate,
		WasRefunded:                wasRefunded,
		IsWinner:                   isWinner,
		WinnerCount:                winnerCount,
		ActivationCount:            activationCount,
		GiftCode:                   giftCode,
		WonStarCount:               wonStarCount,
	}

	return &giveawayInfoCompletedTemp
}

// UnmarshalJSON unmarshal to json
func (giveawayInfoCompleted *GiveawayInfoCompleted) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CreationDate               int32  `json:"creation_date"`                 // Point in time (Unix timestamp) when the giveaway was created
		ActualWinnersSelectionDate int32  `json:"actual_winners_selection_date"` // Point in time (Unix timestamp) when the winners were selected. May be bigger than winners selection date specified in parameters of the giveaway
		WasRefunded                bool   `json:"was_refunded"`                  // True, if the giveaway was canceled and was fully refunded
		IsWinner                   bool   `json:"is_winner"`                     // True, if the cuurent user is a winner of the giveaway
		WinnerCount                int32  `json:"winner_count"`                  // Number of winners in the giveaway
		ActivationCount            int32  `json:"activation_count"`              // Number of winners, which activated their gift codes; for Telegram Premium giveaways only
		GiftCode                   string `json:"gift_code"`                     // Telegram Premium gift code that was received by the current user; empty if the user isn't a winner in the giveaway or the giveaway isn't a Telegram Premium giveaway
		WonStarCount               int64  `json:"won_star_count"`                // The amount of Telegram Stars won by the current user; 0 if the user isn't a winner in the giveaway or the giveaway isn't a Telegram Star giveaway
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	giveawayInfoCompleted.tdCommon = tempObj.tdCommon
	giveawayInfoCompleted.CreationDate = tempObj.CreationDate
	giveawayInfoCompleted.ActualWinnersSelectionDate = tempObj.ActualWinnersSelectionDate
	giveawayInfoCompleted.WasRefunded = tempObj.WasRefunded
	giveawayInfoCompleted.IsWinner = tempObj.IsWinner
	giveawayInfoCompleted.WinnerCount = tempObj.WinnerCount
	giveawayInfoCompleted.ActivationCount = tempObj.ActivationCount
	giveawayInfoCompleted.GiftCode = tempObj.GiftCode
	giveawayInfoCompleted.WonStarCount = tempObj.WonStarCount

	return nil
}

// GetGiveawayInfoEnum return the enum type of this object
func (giveawayInfoCompleted *GiveawayInfoCompleted) GetGiveawayInfoEnum() GiveawayInfoEnum {
	return GiveawayInfoCompletedType
}

// GiveawayPrizePremium The giveaway sends Telegram Premium subscriptions to the winners
type GiveawayPrizePremium struct {
	tdCommon
	MonthCount int32 `json:"month_count"` // Number of months the Telegram Premium subscription will be active after code activation
}

// MessageType return the string telegram-type of GiveawayPrizePremium
func (giveawayPrizePremium *GiveawayPrizePremium) MessageType() string {
	return "giveawayPrizePremium"
}

// NewGiveawayPrizePremium creates a new GiveawayPrizePremium
//
// @param monthCount Number of months the Telegram Premium subscription will be active after code activation
func NewGiveawayPrizePremium(monthCount int32) *GiveawayPrizePremium {
	giveawayPrizePremiumTemp := GiveawayPrizePremium{
		tdCommon:   tdCommon{Type: "giveawayPrizePremium"},
		MonthCount: monthCount,
	}

	return &giveawayPrizePremiumTemp
}

// UnmarshalJSON unmarshal to json
func (giveawayPrizePremium *GiveawayPrizePremium) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MonthCount int32 `json:"month_count"` // Number of months the Telegram Premium subscription will be active after code activation
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	giveawayPrizePremium.tdCommon = tempObj.tdCommon
	giveawayPrizePremium.MonthCount = tempObj.MonthCount

	return nil
}

// GetGiveawayPrizeEnum return the enum type of this object
func (giveawayPrizePremium *GiveawayPrizePremium) GetGiveawayPrizeEnum() GiveawayPrizeEnum {
	return GiveawayPrizePremiumType
}

// GiveawayPrizeStars The giveaway sends Telegram Stars to the winners
type GiveawayPrizeStars struct {
	tdCommon
	StarCount int64 `json:"star_count"` // Number of Telegram Stars that will be shared by all winners
}

// MessageType return the string telegram-type of GiveawayPrizeStars
func (giveawayPrizeStars *GiveawayPrizeStars) MessageType() string {
	return "giveawayPrizeStars"
}

// NewGiveawayPrizeStars creates a new GiveawayPrizeStars
//
// @param starCount Number of Telegram Stars that will be shared by all winners
func NewGiveawayPrizeStars(starCount int64) *GiveawayPrizeStars {
	giveawayPrizeStarsTemp := GiveawayPrizeStars{
		tdCommon:  tdCommon{Type: "giveawayPrizeStars"},
		StarCount: starCount,
	}

	return &giveawayPrizeStarsTemp
}

// UnmarshalJSON unmarshal to json
func (giveawayPrizeStars *GiveawayPrizeStars) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StarCount int64 `json:"star_count"` // Number of Telegram Stars that will be shared by all winners
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	giveawayPrizeStars.tdCommon = tempObj.tdCommon
	giveawayPrizeStars.StarCount = tempObj.StarCount

	return nil
}

// GetGiveawayPrizeEnum return the enum type of this object
func (giveawayPrizeStars *GiveawayPrizeStars) GetGiveawayPrizeEnum() GiveawayPrizeEnum {
	return GiveawayPrizeStarsType
}

// AccentColor Contains information about supported accent color for user/chat name, background of empty chat photo, replies to messages and link previews
type AccentColor struct {
	tdCommon
	ID                       int32   `json:"id"`                           // Accent color identifier
	BuiltInAccentColorID     int32   `json:"built_in_accent_color_id"`     // Identifier of a built-in color to use in places, where only one color is needed; 0-6
	LightThemeColors         []int32 `json:"light_theme_colors"`           // The list of 1-3 colors in RGB format, describing the accent color, as expected to be shown in light themes
	DarkThemeColors          []int32 `json:"dark_theme_colors"`            // The list of 1-3 colors in RGB format, describing the accent color, as expected to be shown in dark themes
	MinChannelChatBoostLevel int32   `json:"min_channel_chat_boost_level"` // The minimum chat boost level required to use the color in a channel chat
}

// MessageType return the string telegram-type of AccentColor
func (accentColor *AccentColor) MessageType() string {
	return "accentColor"
}

// NewAccentColor creates a new AccentColor
//
// @param iD Accent color identifier
// @param builtInAccentColorID Identifier of a built-in color to use in places, where only one color is needed; 0-6
// @param lightThemeColors The list of 1-3 colors in RGB format, describing the accent color, as expected to be shown in light themes
// @param darkThemeColors The list of 1-3 colors in RGB format, describing the accent color, as expected to be shown in dark themes
// @param minChannelChatBoostLevel The minimum chat boost level required to use the color in a channel chat
func NewAccentColor(iD int32, builtInAccentColorID int32, lightThemeColors []int32, darkThemeColors []int32, minChannelChatBoostLevel int32) *AccentColor {
	accentColorTemp := AccentColor{
		tdCommon:                 tdCommon{Type: "accentColor"},
		ID:                       iD,
		BuiltInAccentColorID:     builtInAccentColorID,
		LightThemeColors:         lightThemeColors,
		DarkThemeColors:          darkThemeColors,
		MinChannelChatBoostLevel: minChannelChatBoostLevel,
	}

	return &accentColorTemp
}

// UnmarshalJSON unmarshal to json
func (accentColor *AccentColor) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID                       int32   `json:"id"`                           // Accent color identifier
		BuiltInAccentColorID     int32   `json:"built_in_accent_color_id"`     // Identifier of a built-in color to use in places, where only one color is needed; 0-6
		LightThemeColors         []int32 `json:"light_theme_colors"`           // The list of 1-3 colors in RGB format, describing the accent color, as expected to be shown in light themes
		DarkThemeColors          []int32 `json:"dark_theme_colors"`            // The list of 1-3 colors in RGB format, describing the accent color, as expected to be shown in dark themes
		MinChannelChatBoostLevel int32   `json:"min_channel_chat_boost_level"` // The minimum chat boost level required to use the color in a channel chat
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	accentColor.tdCommon = tempObj.tdCommon
	accentColor.ID = tempObj.ID
	accentColor.BuiltInAccentColorID = tempObj.BuiltInAccentColorID
	accentColor.LightThemeColors = tempObj.LightThemeColors
	accentColor.DarkThemeColors = tempObj.DarkThemeColors
	accentColor.MinChannelChatBoostLevel = tempObj.MinChannelChatBoostLevel

	return nil
}

// ProfileAccentColors Contains information about supported accent colors for user profile photo background in RGB format
type ProfileAccentColors struct {
	tdCommon
	PaletteColors    []int32 `json:"palette_colors"`    // The list of 1-2 colors in RGB format, describing the colors, as expected to be shown in the color palette settings
	BackgroundColors []int32 `json:"background_colors"` // The list of 1-2 colors in RGB format, describing the colors, as expected to be used for the profile photo background
	StoryColors      []int32 `json:"story_colors"`      // The list of 2 colors in RGB format, describing the colors of the gradient to be used for the unread active story indicator around profile photo
}

// MessageType return the string telegram-type of ProfileAccentColors
func (profileAccentColors *ProfileAccentColors) MessageType() string {
	return "profileAccentColors"
}

// NewProfileAccentColors creates a new ProfileAccentColors
//
// @param paletteColors The list of 1-2 colors in RGB format, describing the colors, as expected to be shown in the color palette settings
// @param backgroundColors The list of 1-2 colors in RGB format, describing the colors, as expected to be used for the profile photo background
// @param storyColors The list of 2 colors in RGB format, describing the colors of the gradient to be used for the unread active story indicator around profile photo
func NewProfileAccentColors(paletteColors []int32, backgroundColors []int32, storyColors []int32) *ProfileAccentColors {
	profileAccentColorsTemp := ProfileAccentColors{
		tdCommon:         tdCommon{Type: "profileAccentColors"},
		PaletteColors:    paletteColors,
		BackgroundColors: backgroundColors,
		StoryColors:      storyColors,
	}

	return &profileAccentColorsTemp
}

// UnmarshalJSON unmarshal to json
func (profileAccentColors *ProfileAccentColors) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PaletteColors    []int32 `json:"palette_colors"`    // The list of 1-2 colors in RGB format, describing the colors, as expected to be shown in the color palette settings
		BackgroundColors []int32 `json:"background_colors"` // The list of 1-2 colors in RGB format, describing the colors, as expected to be used for the profile photo background
		StoryColors      []int32 `json:"story_colors"`      // The list of 2 colors in RGB format, describing the colors of the gradient to be used for the unread active story indicator around profile photo
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	profileAccentColors.tdCommon = tempObj.tdCommon
	profileAccentColors.PaletteColors = tempObj.PaletteColors
	profileAccentColors.BackgroundColors = tempObj.BackgroundColors
	profileAccentColors.StoryColors = tempObj.StoryColors

	return nil
}

// ProfileAccentColor Contains information about supported accent color for user profile photo background
type ProfileAccentColor struct {
	tdCommon
	ID                          int32                `json:"id"`                              // Profile accent color identifier
	LightThemeColors            *ProfileAccentColors `json:"light_theme_colors"`              // Accent colors expected to be used in light themes
	DarkThemeColors             *ProfileAccentColors `json:"dark_theme_colors"`               // Accent colors expected to be used in dark themes
	MinSupergroupChatBoostLevel int32                `json:"min_supergroup_chat_boost_level"` // The minimum chat boost level required to use the color in a supergroup chat
	MinChannelChatBoostLevel    int32                `json:"min_channel_chat_boost_level"`    // The minimum chat boost level required to use the color in a channel chat
}

// MessageType return the string telegram-type of ProfileAccentColor
func (profileAccentColor *ProfileAccentColor) MessageType() string {
	return "profileAccentColor"
}

// NewProfileAccentColor creates a new ProfileAccentColor
//
// @param iD Profile accent color identifier
// @param lightThemeColors Accent colors expected to be used in light themes
// @param darkThemeColors Accent colors expected to be used in dark themes
// @param minSupergroupChatBoostLevel The minimum chat boost level required to use the color in a supergroup chat
// @param minChannelChatBoostLevel The minimum chat boost level required to use the color in a channel chat
func NewProfileAccentColor(iD int32, lightThemeColors *ProfileAccentColors, darkThemeColors *ProfileAccentColors, minSupergroupChatBoostLevel int32, minChannelChatBoostLevel int32) *ProfileAccentColor {
	profileAccentColorTemp := ProfileAccentColor{
		tdCommon:                    tdCommon{Type: "profileAccentColor"},
		ID:                          iD,
		LightThemeColors:            lightThemeColors,
		DarkThemeColors:             darkThemeColors,
		MinSupergroupChatBoostLevel: minSupergroupChatBoostLevel,
		MinChannelChatBoostLevel:    minChannelChatBoostLevel,
	}

	return &profileAccentColorTemp
}

// UnmarshalJSON unmarshal to json
func (profileAccentColor *ProfileAccentColor) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID                          int32                `json:"id"`                              // Profile accent color identifier
		LightThemeColors            *ProfileAccentColors `json:"light_theme_colors"`              // Accent colors expected to be used in light themes
		DarkThemeColors             *ProfileAccentColors `json:"dark_theme_colors"`               // Accent colors expected to be used in dark themes
		MinSupergroupChatBoostLevel int32                `json:"min_supergroup_chat_boost_level"` // The minimum chat boost level required to use the color in a supergroup chat
		MinChannelChatBoostLevel    int32                `json:"min_channel_chat_boost_level"`    // The minimum chat boost level required to use the color in a channel chat
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	profileAccentColor.tdCommon = tempObj.tdCommon
	profileAccentColor.ID = tempObj.ID
	profileAccentColor.LightThemeColors = tempObj.LightThemeColors
	profileAccentColor.DarkThemeColors = tempObj.DarkThemeColors
	profileAccentColor.MinSupergroupChatBoostLevel = tempObj.MinSupergroupChatBoostLevel
	profileAccentColor.MinChannelChatBoostLevel = tempObj.MinChannelChatBoostLevel

	return nil
}

// EmojiStatus Describes a custom emoji to be shown instead of the Telegram Premium badge
type EmojiStatus struct {
	tdCommon
	CustomEmojiID  JSONInt64 `json:"custom_emoji_id"` // Identifier of the custom emoji in stickerFormatTgs format
	ExpirationDate int32     `json:"expiration_date"` // Point in time (Unix timestamp) when the status will expire; 0 if never
}

// MessageType return the string telegram-type of EmojiStatus
func (emojiStatus *EmojiStatus) MessageType() string {
	return "emojiStatus"
}

// NewEmojiStatus creates a new EmojiStatus
//
// @param customEmojiID Identifier of the custom emoji in stickerFormatTgs format
// @param expirationDate Point in time (Unix timestamp) when the status will expire; 0 if never
func NewEmojiStatus(customEmojiID JSONInt64, expirationDate int32) *EmojiStatus {
	emojiStatusTemp := EmojiStatus{
		tdCommon:       tdCommon{Type: "emojiStatus"},
		CustomEmojiID:  customEmojiID,
		ExpirationDate: expirationDate,
	}

	return &emojiStatusTemp
}

// UnmarshalJSON unmarshal to json
func (emojiStatus *EmojiStatus) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CustomEmojiID  JSONInt64 `json:"custom_emoji_id"` // Identifier of the custom emoji in stickerFormatTgs format
		ExpirationDate int32     `json:"expiration_date"` // Point in time (Unix timestamp) when the status will expire; 0 if never
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	emojiStatus.tdCommon = tempObj.tdCommon
	emojiStatus.CustomEmojiID = tempObj.CustomEmojiID
	emojiStatus.ExpirationDate = tempObj.ExpirationDate

	return nil
}

// EmojiStatuses Contains a list of custom emoji identifiers for emoji statuses
type EmojiStatuses struct {
	tdCommon
	CustomEmojiIDs []JSONInt64 `json:"custom_emoji_ids"` // The list of custom emoji identifiers
}

// MessageType return the string telegram-type of EmojiStatuses
func (emojiStatuses *EmojiStatuses) MessageType() string {
	return "emojiStatuses"
}

// NewEmojiStatuses creates a new EmojiStatuses
//
// @param customEmojiIDs The list of custom emoji identifiers
func NewEmojiStatuses(customEmojiIDs []JSONInt64) *EmojiStatuses {
	emojiStatusesTemp := EmojiStatuses{
		tdCommon:       tdCommon{Type: "emojiStatuses"},
		CustomEmojiIDs: customEmojiIDs,
	}

	return &emojiStatusesTemp
}

// UnmarshalJSON unmarshal to json
func (emojiStatuses *EmojiStatuses) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CustomEmojiIDs []JSONInt64 `json:"custom_emoji_ids"` // The list of custom emoji identifiers
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	emojiStatuses.tdCommon = tempObj.tdCommon
	emojiStatuses.CustomEmojiIDs = tempObj.CustomEmojiIDs

	return nil
}

// Usernames Describes usernames assigned to a user, a supergroup, or a channel
type Usernames struct {
	tdCommon
	ActiveUsernames   []string `json:"active_usernames"`   // List of active usernames; the first one must be shown as the primary username. The order of active usernames can be changed with reorderActiveUsernames, reorderBotActiveUsernames or reorderSupergroupActiveUsernames
	DisabledUsernames []string `json:"disabled_usernames"` // List of currently disabled usernames; the username can be activated with toggleUsernameIsActive, toggleBotUsernameIsActive, or toggleSupergroupUsernameIsActive
	EditableUsername  string   `json:"editable_username"`  // The active username, which can be changed with setUsername or setSupergroupUsername. Information about other active usernames can be received using getCollectibleItemInfo
}

// MessageType return the string telegram-type of Usernames
func (usernames *Usernames) MessageType() string {
	return "usernames"
}

// NewUsernames creates a new Usernames
//
// @param activeUsernames List of active usernames; the first one must be shown as the primary username. The order of active usernames can be changed with reorderActiveUsernames, reorderBotActiveUsernames or reorderSupergroupActiveUsernames
// @param disabledUsernames List of currently disabled usernames; the username can be activated with toggleUsernameIsActive, toggleBotUsernameIsActive, or toggleSupergroupUsernameIsActive
// @param editableUsername The active username, which can be changed with setUsername or setSupergroupUsername. Information about other active usernames can be received using getCollectibleItemInfo
func NewUsernames(activeUsernames []string, disabledUsernames []string, editableUsername string) *Usernames {
	usernamesTemp := Usernames{
		tdCommon:          tdCommon{Type: "usernames"},
		ActiveUsernames:   activeUsernames,
		DisabledUsernames: disabledUsernames,
		EditableUsername:  editableUsername,
	}

	return &usernamesTemp
}

// UnmarshalJSON unmarshal to json
func (usernames *Usernames) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ActiveUsernames   []string `json:"active_usernames"`   // List of active usernames; the first one must be shown as the primary username. The order of active usernames can be changed with reorderActiveUsernames, reorderBotActiveUsernames or reorderSupergroupActiveUsernames
		DisabledUsernames []string `json:"disabled_usernames"` // List of currently disabled usernames; the username can be activated with toggleUsernameIsActive, toggleBotUsernameIsActive, or toggleSupergroupUsernameIsActive
		EditableUsername  string   `json:"editable_username"`  // The active username, which can be changed with setUsername or setSupergroupUsername. Information about other active usernames can be received using getCollectibleItemInfo
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	usernames.tdCommon = tempObj.tdCommon
	usernames.ActiveUsernames = tempObj.ActiveUsernames
	usernames.DisabledUsernames = tempObj.DisabledUsernames
	usernames.EditableUsername = tempObj.EditableUsername

	return nil
}

// User Represents a user
type User struct {
	tdCommon
	ID                             int64         `json:"id"`                                 // User identifier
	FirstName                      string        `json:"first_name"`                         // First name of the user
	LastName                       string        `json:"last_name"`                          // Last name of the user
	Usernames                      *Usernames    `json:"usernames"`                          // Usernames of the user; may be null
	PhoneNumber                    string        `json:"phone_number"`                       // Phone number of the user
	Status                         UserStatus    `json:"status"`                             // Current online status of the user
	ProfilePhoto                   *ProfilePhoto `json:"profile_photo"`                      // Profile photo of the user; may be null
	AccentColorID                  int32         `json:"accent_color_id"`                    // Identifier of the accent color for name, and backgrounds of profile photo, reply header, and link preview. For Telegram Premium users only
	BackgroundCustomEmojiID        JSONInt64     `json:"background_custom_emoji_id"`         // Identifier of a custom emoji to be shown on the reply header and link preview background; 0 if none. For Telegram Premium users only
	ProfileAccentColorID           int32         `json:"profile_accent_color_id"`            // Identifier of the accent color for the user's profile; -1 if none. For Telegram Premium users only
	ProfileBackgroundCustomEmojiID JSONInt64     `json:"profile_background_custom_emoji_id"` // Identifier of a custom emoji to be shown on the background of the user's profile; 0 if none. For Telegram Premium users only
	EmojiStatus                    *EmojiStatus  `json:"emoji_status"`                       // Emoji status to be shown instead of the default Telegram Premium badge; may be null. For Telegram Premium users only
	IsContact                      bool          `json:"is_contact"`                         // The user is a contact of the current user
	IsMutualContact                bool          `json:"is_mutual_contact"`                  // The user is a contact of the current user and the current user is a contact of the user
	IsCloseFriend                  bool          `json:"is_close_friend"`                    // The user is a close friend of the current user; implies that the user is a contact
	IsVerified                     bool          `json:"is_verified"`                        // True, if the user is verified
	IsPremium                      bool          `json:"is_premium"`                         // True, if the user is a Telegram Premium user
	IsSupport                      bool          `json:"is_support"`                         // True, if the user is Telegram support account
	RestrictionReason              string        `json:"restriction_reason"`                 // If non-empty, it contains a human-readable description of the reason why access to this user must be restricted
	IsScam                         bool          `json:"is_scam"`                            // True, if many users reported this user as a scam
	IsFake                         bool          `json:"is_fake"`                            // True, if many users reported this user as a fake account
	HasActiveStories               bool          `json:"has_active_stories"`                 // True, if the user has non-expired stories available to the current user
	HasUnreadActiveStories         bool          `json:"has_unread_active_stories"`          // True, if the user has unread non-expired stories available to the current user
	RestrictsNewChats              bool          `json:"restricts_new_chats"`                // True, if the user may restrict new chats with non-contacts. Use canSendMessageToUser to check whether the current user can message the user or try to create a chat with them
	HaveAccess                     bool          `json:"have_access"`                        // If false, the user is inaccessible, and the only information known about the user is inside this class. Identifier of the user can't be passed to any method
	Type                           UserType      `json:"type"`                               // Type of the user
	LanguageCode                   string        `json:"language_code"`                      // IETF language tag of the user's language; only available to bots
	AddedToAttachmentMenu          bool          `json:"added_to_attachment_menu"`           // True, if the user added the current bot to attachment menu; only available to bots
}

// MessageType return the string telegram-type of User
func (user *User) MessageType() string {
	return "user"
}

// NewUser creates a new User
//
// @param iD User identifier
// @param firstName First name of the user
// @param lastName Last name of the user
// @param usernames Usernames of the user; may be null
// @param phoneNumber Phone number of the user
// @param status Current online status of the user
// @param profilePhoto Profile photo of the user; may be null
// @param accentColorID Identifier of the accent color for name, and backgrounds of profile photo, reply header, and link preview. For Telegram Premium users only
// @param backgroundCustomEmojiID Identifier of a custom emoji to be shown on the reply header and link preview background; 0 if none. For Telegram Premium users only
// @param profileAccentColorID Identifier of the accent color for the user's profile; -1 if none. For Telegram Premium users only
// @param profileBackgroundCustomEmojiID Identifier of a custom emoji to be shown on the background of the user's profile; 0 if none. For Telegram Premium users only
// @param emojiStatus Emoji status to be shown instead of the default Telegram Premium badge; may be null. For Telegram Premium users only
// @param isContact The user is a contact of the current user
// @param isMutualContact The user is a contact of the current user and the current user is a contact of the user
// @param isCloseFriend The user is a close friend of the current user; implies that the user is a contact
// @param isVerified True, if the user is verified
// @param isPremium True, if the user is a Telegram Premium user
// @param isSupport True, if the user is Telegram support account
// @param restrictionReason If non-empty, it contains a human-readable description of the reason why access to this user must be restricted
// @param isScam True, if many users reported this user as a scam
// @param isFake True, if many users reported this user as a fake account
// @param hasActiveStories True, if the user has non-expired stories available to the current user
// @param hasUnreadActiveStories True, if the user has unread non-expired stories available to the current user
// @param restrictsNewChats True, if the user may restrict new chats with non-contacts. Use canSendMessageToUser to check whether the current user can message the user or try to create a chat with them
// @param haveAccess If false, the user is inaccessible, and the only information known about the user is inside this class. Identifier of the user can't be passed to any method
// @param typeParam Type of the user
// @param languageCode IETF language tag of the user's language; only available to bots
// @param addedToAttachmentMenu True, if the user added the current bot to attachment menu; only available to bots
func NewUser(iD int64, firstName string, lastName string, usernames *Usernames, phoneNumber string, status UserStatus, profilePhoto *ProfilePhoto, accentColorID int32, backgroundCustomEmojiID JSONInt64, profileAccentColorID int32, profileBackgroundCustomEmojiID JSONInt64, emojiStatus *EmojiStatus, isContact bool, isMutualContact bool, isCloseFriend bool, isVerified bool, isPremium bool, isSupport bool, restrictionReason string, isScam bool, isFake bool, hasActiveStories bool, hasUnreadActiveStories bool, restrictsNewChats bool, haveAccess bool, typeParam UserType, languageCode string, addedToAttachmentMenu bool) *User {
	userTemp := User{
		tdCommon:                       tdCommon{Type: "user"},
		ID:                             iD,
		FirstName:                      firstName,
		LastName:                       lastName,
		Usernames:                      usernames,
		PhoneNumber:                    phoneNumber,
		Status:                         status,
		ProfilePhoto:                   profilePhoto,
		AccentColorID:                  accentColorID,
		BackgroundCustomEmojiID:        backgroundCustomEmojiID,
		ProfileAccentColorID:           profileAccentColorID,
		ProfileBackgroundCustomEmojiID: profileBackgroundCustomEmojiID,
		EmojiStatus:                    emojiStatus,
		IsContact:                      isContact,
		IsMutualContact:                isMutualContact,
		IsCloseFriend:                  isCloseFriend,
		IsVerified:                     isVerified,
		IsPremium:                      isPremium,
		IsSupport:                      isSupport,
		RestrictionReason:              restrictionReason,
		IsScam:                         isScam,
		IsFake:                         isFake,
		HasActiveStories:               hasActiveStories,
		HasUnreadActiveStories:         hasUnreadActiveStories,
		RestrictsNewChats:              restrictsNewChats,
		HaveAccess:                     haveAccess,
		Type:                           typeParam,
		LanguageCode:                   languageCode,
		AddedToAttachmentMenu:          addedToAttachmentMenu,
	}

	return &userTemp
}

// UnmarshalJSON unmarshal to json
func (user *User) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID                             int64         `json:"id"`                                 // User identifier
		FirstName                      string        `json:"first_name"`                         // First name of the user
		LastName                       string        `json:"last_name"`                          // Last name of the user
		Usernames                      *Usernames    `json:"usernames"`                          // Usernames of the user; may be null
		PhoneNumber                    string        `json:"phone_number"`                       // Phone number of the user
		ProfilePhoto                   *ProfilePhoto `json:"profile_photo"`                      // Profile photo of the user; may be null
		AccentColorID                  int32         `json:"accent_color_id"`                    // Identifier of the accent color for name, and backgrounds of profile photo, reply header, and link preview. For Telegram Premium users only
		BackgroundCustomEmojiID        JSONInt64     `json:"background_custom_emoji_id"`         // Identifier of a custom emoji to be shown on the reply header and link preview background; 0 if none. For Telegram Premium users only
		ProfileAccentColorID           int32         `json:"profile_accent_color_id"`            // Identifier of the accent color for the user's profile; -1 if none. For Telegram Premium users only
		ProfileBackgroundCustomEmojiID JSONInt64     `json:"profile_background_custom_emoji_id"` // Identifier of a custom emoji to be shown on the background of the user's profile; 0 if none. For Telegram Premium users only
		EmojiStatus                    *EmojiStatus  `json:"emoji_status"`                       // Emoji status to be shown instead of the default Telegram Premium badge; may be null. For Telegram Premium users only
		IsContact                      bool          `json:"is_contact"`                         // The user is a contact of the current user
		IsMutualContact                bool          `json:"is_mutual_contact"`                  // The user is a contact of the current user and the current user is a contact of the user
		IsCloseFriend                  bool          `json:"is_close_friend"`                    // The user is a close friend of the current user; implies that the user is a contact
		IsVerified                     bool          `json:"is_verified"`                        // True, if the user is verified
		IsPremium                      bool          `json:"is_premium"`                         // True, if the user is a Telegram Premium user
		IsSupport                      bool          `json:"is_support"`                         // True, if the user is Telegram support account
		RestrictionReason              string        `json:"restriction_reason"`                 // If non-empty, it contains a human-readable description of the reason why access to this user must be restricted
		IsScam                         bool          `json:"is_scam"`                            // True, if many users reported this user as a scam
		IsFake                         bool          `json:"is_fake"`                            // True, if many users reported this user as a fake account
		HasActiveStories               bool          `json:"has_active_stories"`                 // True, if the user has non-expired stories available to the current user
		HasUnreadActiveStories         bool          `json:"has_unread_active_stories"`          // True, if the user has unread non-expired stories available to the current user
		RestrictsNewChats              bool          `json:"restricts_new_chats"`                // True, if the user may restrict new chats with non-contacts. Use canSendMessageToUser to check whether the current user can message the user or try to create a chat with them
		HaveAccess                     bool          `json:"have_access"`                        // If false, the user is inaccessible, and the only information known about the user is inside this class. Identifier of the user can't be passed to any method
		LanguageCode                   string        `json:"language_code"`                      // IETF language tag of the user's language; only available to bots
		AddedToAttachmentMenu          bool          `json:"added_to_attachment_menu"`           // True, if the user added the current bot to attachment menu; only available to bots
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	user.tdCommon = tempObj.tdCommon
	user.ID = tempObj.ID
	user.FirstName = tempObj.FirstName
	user.LastName = tempObj.LastName
	user.Usernames = tempObj.Usernames
	user.PhoneNumber = tempObj.PhoneNumber
	user.ProfilePhoto = tempObj.ProfilePhoto
	user.AccentColorID = tempObj.AccentColorID
	user.BackgroundCustomEmojiID = tempObj.BackgroundCustomEmojiID
	user.ProfileAccentColorID = tempObj.ProfileAccentColorID
	user.ProfileBackgroundCustomEmojiID = tempObj.ProfileBackgroundCustomEmojiID
	user.EmojiStatus = tempObj.EmojiStatus
	user.IsContact = tempObj.IsContact
	user.IsMutualContact = tempObj.IsMutualContact
	user.IsCloseFriend = tempObj.IsCloseFriend
	user.IsVerified = tempObj.IsVerified
	user.IsPremium = tempObj.IsPremium
	user.IsSupport = tempObj.IsSupport
	user.RestrictionReason = tempObj.RestrictionReason
	user.IsScam = tempObj.IsScam
	user.IsFake = tempObj.IsFake
	user.HasActiveStories = tempObj.HasActiveStories
	user.HasUnreadActiveStories = tempObj.HasUnreadActiveStories
	user.RestrictsNewChats = tempObj.RestrictsNewChats
	user.HaveAccess = tempObj.HaveAccess
	user.LanguageCode = tempObj.LanguageCode
	user.AddedToAttachmentMenu = tempObj.AddedToAttachmentMenu

	fieldStatus, _ := unmarshalUserStatus(objMap["status"])
	user.Status = fieldStatus

	fieldType, _ := unmarshalUserType(objMap["type"])
	user.Type = fieldType

	return nil
}

// BotInfo Contains information about a bot
type BotInfo struct {
	tdCommon
	ShortDescription                  string                   `json:"short_description"`                    // The text that is shown on the bot's profile page and is sent together with the link when users share the bot
	Description                       string                   `json:"description"`                          // The text shown in the chat with the bot if the chat is empty
	Photo                             *Photo                   `json:"photo"`                                // Photo shown in the chat with the bot if the chat is empty; may be null
	Animation                         *Animation               `json:"animation"`                            // Animation shown in the chat with the bot if the chat is empty; may be null
	MenuButton                        *BotMenuButton           `json:"menu_button"`                          // Information about a button to show instead of the bot commands menu button; may be null if ordinary bot commands menu must be shown
	Commands                          []BotCommand             `json:"commands"`                             // List of the bot commands
	PrivacyPolicyURL                  string                   `json:"privacy_policy_url"`                   // The HTTP link to the privacy policy of the bot. If empty, then /privacy command must be used if supported by the bot. If the command isn't supported, then https://telegram.org/privacy-tpa must be opened
	DefaultGroupAdministratorRights   *ChatAdministratorRights `json:"default_group_administrator_rights"`   // Default administrator rights for adding the bot to basic group and supergroup chats; may be null
	DefaultChannelAdministratorRights *ChatAdministratorRights `json:"default_channel_administrator_rights"` // Default administrator rights for adding the bot to channels; may be null
	HasMediaPreviews                  bool                     `json:"has_media_previews"`                   // True, if the bot has media previews
	EditCommandsLink                  *InternalLinkType        `json:"edit_commands_link"`                   // The internal link, which can be used to edit bot commands; may be null
	EditDescriptionLink               *InternalLinkType        `json:"edit_description_link"`                // The internal link, which can be used to edit bot description; may be null
	EditDescriptionMediaLink          *InternalLinkType        `json:"edit_description_media_link"`          // The internal link, which can be used to edit the photo or animation shown in the chat with the bot if the chat is empty; may be null
	EditSettingsLink                  *InternalLinkType        `json:"edit_settings_link"`                   // The internal link, which can be used to edit bot settings; may be null
}

// MessageType return the string telegram-type of BotInfo
func (botInfo *BotInfo) MessageType() string {
	return "botInfo"
}

// NewBotInfo creates a new BotInfo
//
// @param shortDescription The text that is shown on the bot's profile page and is sent together with the link when users share the bot
// @param description The text shown in the chat with the bot if the chat is empty
// @param photo Photo shown in the chat with the bot if the chat is empty; may be null
// @param animation Animation shown in the chat with the bot if the chat is empty; may be null
// @param menuButton Information about a button to show instead of the bot commands menu button; may be null if ordinary bot commands menu must be shown
// @param commands List of the bot commands
// @param privacyPolicyURL The HTTP link to the privacy policy of the bot. If empty, then /privacy command must be used if supported by the bot. If the command isn't supported, then https://telegram.org/privacy-tpa must be opened
// @param defaultGroupAdministratorRights Default administrator rights for adding the bot to basic group and supergroup chats; may be null
// @param defaultChannelAdministratorRights Default administrator rights for adding the bot to channels; may be null
// @param hasMediaPreviews True, if the bot has media previews
// @param editCommandsLink The internal link, which can be used to edit bot commands; may be null
// @param editDescriptionLink The internal link, which can be used to edit bot description; may be null
// @param editDescriptionMediaLink The internal link, which can be used to edit the photo or animation shown in the chat with the bot if the chat is empty; may be null
// @param editSettingsLink The internal link, which can be used to edit bot settings; may be null
func NewBotInfo(shortDescription string, description string, photo *Photo, animation *Animation, menuButton *BotMenuButton, commands []BotCommand, privacyPolicyURL string, defaultGroupAdministratorRights *ChatAdministratorRights, defaultChannelAdministratorRights *ChatAdministratorRights, hasMediaPreviews bool, editCommandsLink *InternalLinkType, editDescriptionLink *InternalLinkType, editDescriptionMediaLink *InternalLinkType, editSettingsLink *InternalLinkType) *BotInfo {
	botInfoTemp := BotInfo{
		tdCommon:                          tdCommon{Type: "botInfo"},
		ShortDescription:                  shortDescription,
		Description:                       description,
		Photo:                             photo,
		Animation:                         animation,
		MenuButton:                        menuButton,
		Commands:                          commands,
		PrivacyPolicyURL:                  privacyPolicyURL,
		DefaultGroupAdministratorRights:   defaultGroupAdministratorRights,
		DefaultChannelAdministratorRights: defaultChannelAdministratorRights,
		HasMediaPreviews:                  hasMediaPreviews,
		EditCommandsLink:                  editCommandsLink,
		EditDescriptionLink:               editDescriptionLink,
		EditDescriptionMediaLink:          editDescriptionMediaLink,
		EditSettingsLink:                  editSettingsLink,
	}

	return &botInfoTemp
}

// UnmarshalJSON unmarshal to json
func (botInfo *BotInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ShortDescription                  string                   `json:"short_description"`                    // The text that is shown on the bot's profile page and is sent together with the link when users share the bot
		Description                       string                   `json:"description"`                          // The text shown in the chat with the bot if the chat is empty
		Photo                             *Photo                   `json:"photo"`                                // Photo shown in the chat with the bot if the chat is empty; may be null
		Animation                         *Animation               `json:"animation"`                            // Animation shown in the chat with the bot if the chat is empty; may be null
		MenuButton                        *BotMenuButton           `json:"menu_button"`                          // Information about a button to show instead of the bot commands menu button; may be null if ordinary bot commands menu must be shown
		Commands                          []BotCommand             `json:"commands"`                             // List of the bot commands
		PrivacyPolicyURL                  string                   `json:"privacy_policy_url"`                   // The HTTP link to the privacy policy of the bot. If empty, then /privacy command must be used if supported by the bot. If the command isn't supported, then https://telegram.org/privacy-tpa must be opened
		DefaultGroupAdministratorRights   *ChatAdministratorRights `json:"default_group_administrator_rights"`   // Default administrator rights for adding the bot to basic group and supergroup chats; may be null
		DefaultChannelAdministratorRights *ChatAdministratorRights `json:"default_channel_administrator_rights"` // Default administrator rights for adding the bot to channels; may be null
		HasMediaPreviews                  bool                     `json:"has_media_previews"`                   // True, if the bot has media previews

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	botInfo.tdCommon = tempObj.tdCommon
	botInfo.ShortDescription = tempObj.ShortDescription
	botInfo.Description = tempObj.Description
	botInfo.Photo = tempObj.Photo
	botInfo.Animation = tempObj.Animation
	botInfo.MenuButton = tempObj.MenuButton
	botInfo.Commands = tempObj.Commands
	botInfo.PrivacyPolicyURL = tempObj.PrivacyPolicyURL
	botInfo.DefaultGroupAdministratorRights = tempObj.DefaultGroupAdministratorRights
	botInfo.DefaultChannelAdministratorRights = tempObj.DefaultChannelAdministratorRights
	botInfo.HasMediaPreviews = tempObj.HasMediaPreviews

	fieldEditCommandsLink, _ := unmarshalInternalLinkType(objMap["edit_commands_link"])
	botInfo.EditCommandsLink = &fieldEditCommandsLink

	fieldEditDescriptionLink, _ := unmarshalInternalLinkType(objMap["edit_description_link"])
	botInfo.EditDescriptionLink = &fieldEditDescriptionLink

	fieldEditDescriptionMediaLink, _ := unmarshalInternalLinkType(objMap["edit_description_media_link"])
	botInfo.EditDescriptionMediaLink = &fieldEditDescriptionMediaLink

	fieldEditSettingsLink, _ := unmarshalInternalLinkType(objMap["edit_settings_link"])
	botInfo.EditSettingsLink = &fieldEditSettingsLink

	return nil
}

// UserFullInfo Contains full information about a user
type UserFullInfo struct {
	tdCommon
	PersonalPhoto                          *ChatPhoto             `json:"personal_photo"`                               // User profile photo set by the current user for the contact; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown. If non-null, then it is the same photo as in user.profile_photo and chat.photo. This photo isn't returned in the list of user photos
	Photo                                  *ChatPhoto             `json:"photo"`                                        // User profile photo; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown. If non-null and personal_photo is null, then it is the same photo as in user.profile_photo and chat.photo
	PublicPhoto                            *ChatPhoto             `json:"public_photo"`                                 // User profile photo visible if the main photo is hidden by privacy settings; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown. If non-null and both photo and personal_photo are null, then it is the same photo as in user.profile_photo and chat.photo. This photo isn't returned in the list of user photos
	BlockList                              *BlockList             `json:"block_list"`                                   // Block list to which the user is added; may be null if none
	CanBeCalled                            bool                   `json:"can_be_called"`                                // True, if the user can be called
	SupportsVideoCalls                     bool                   `json:"supports_video_calls"`                         // True, if a video call can be created with the user
	HasPrivateCalls                        bool                   `json:"has_private_calls"`                            // True, if the user can't be called due to their privacy settings
	HasPrivateForwards                     bool                   `json:"has_private_forwards"`                         // True, if the user can't be linked in forwarded messages due to their privacy settings
	HasRestrictedVoiceAndVideoNoteMessages bool                   `json:"has_restricted_voice_and_video_note_messages"` // True, if voice and video notes can't be sent or forwarded to the user
	HasPostedToProfileStories              bool                   `json:"has_posted_to_profile_stories"`                // True, if the user has posted to profile stories
	HasSponsoredMessagesEnabled            bool                   `json:"has_sponsored_messages_enabled"`               // True, if the user always enabled sponsored messages; known only for the current user
	NeedPhoneNumberPrivacyException        bool                   `json:"need_phone_number_privacy_exception"`          // True, if the current user needs to explicitly allow to share their phone number with the user when the method addContact is used
	SetChatBackground                      bool                   `json:"set_chat_background"`                          // True, if the user set chat background for both chat users and it wasn't reverted yet
	Bio                                    *FormattedText         `json:"bio"`                                          // A short user bio; may be null for bots
	Birthdate                              *Birthdate             `json:"birthdate"`                                    // Birthdate of the user; may be null if unknown
	PersonalChatID                         int64                  `json:"personal_chat_id"`                             // Identifier of the personal chat of the user; 0 if none
	PremiumGiftOptions                     []PremiumPaymentOption `json:"premium_gift_options"`                         // The list of available options for gifting Telegram Premium to the user
	GroupInCommonCount                     int32                  `json:"group_in_common_count"`                        // Number of group chats where both the other user and the current user are a member; 0 for the current user
	BusinessInfo                           *BusinessInfo          `json:"business_info"`                                // Information about business settings for Telegram Business accounts; may be null if none
	BotInfo                                *BotInfo               `json:"bot_info"`                                     // For bots, information about the bot; may be null if the user isn't a bot
}

// MessageType return the string telegram-type of UserFullInfo
func (userFullInfo *UserFullInfo) MessageType() string {
	return "userFullInfo"
}

// NewUserFullInfo creates a new UserFullInfo
//
// @param personalPhoto User profile photo set by the current user for the contact; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown. If non-null, then it is the same photo as in user.profile_photo and chat.photo. This photo isn't returned in the list of user photos
// @param photo User profile photo; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown. If non-null and personal_photo is null, then it is the same photo as in user.profile_photo and chat.photo
// @param publicPhoto User profile photo visible if the main photo is hidden by privacy settings; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown. If non-null and both photo and personal_photo are null, then it is the same photo as in user.profile_photo and chat.photo. This photo isn't returned in the list of user photos
// @param blockList Block list to which the user is added; may be null if none
// @param canBeCalled True, if the user can be called
// @param supportsVideoCalls True, if a video call can be created with the user
// @param hasPrivateCalls True, if the user can't be called due to their privacy settings
// @param hasPrivateForwards True, if the user can't be linked in forwarded messages due to their privacy settings
// @param hasRestrictedVoiceAndVideoNoteMessages True, if voice and video notes can't be sent or forwarded to the user
// @param hasPostedToProfileStories True, if the user has posted to profile stories
// @param hasSponsoredMessagesEnabled True, if the user always enabled sponsored messages; known only for the current user
// @param needPhoneNumberPrivacyException True, if the current user needs to explicitly allow to share their phone number with the user when the method addContact is used
// @param setChatBackground True, if the user set chat background for both chat users and it wasn't reverted yet
// @param bio A short user bio; may be null for bots
// @param birthdate Birthdate of the user; may be null if unknown
// @param personalChatID Identifier of the personal chat of the user; 0 if none
// @param premiumGiftOptions The list of available options for gifting Telegram Premium to the user
// @param groupInCommonCount Number of group chats where both the other user and the current user are a member; 0 for the current user
// @param businessInfo Information about business settings for Telegram Business accounts; may be null if none
// @param botInfo For bots, information about the bot; may be null if the user isn't a bot
func NewUserFullInfo(personalPhoto *ChatPhoto, photo *ChatPhoto, publicPhoto *ChatPhoto, blockList *BlockList, canBeCalled bool, supportsVideoCalls bool, hasPrivateCalls bool, hasPrivateForwards bool, hasRestrictedVoiceAndVideoNoteMessages bool, hasPostedToProfileStories bool, hasSponsoredMessagesEnabled bool, needPhoneNumberPrivacyException bool, setChatBackground bool, bio *FormattedText, birthdate *Birthdate, personalChatID int64, premiumGiftOptions []PremiumPaymentOption, groupInCommonCount int32, businessInfo *BusinessInfo, botInfo *BotInfo) *UserFullInfo {
	userFullInfoTemp := UserFullInfo{
		tdCommon:                               tdCommon{Type: "userFullInfo"},
		PersonalPhoto:                          personalPhoto,
		Photo:                                  photo,
		PublicPhoto:                            publicPhoto,
		BlockList:                              blockList,
		CanBeCalled:                            canBeCalled,
		SupportsVideoCalls:                     supportsVideoCalls,
		HasPrivateCalls:                        hasPrivateCalls,
		HasPrivateForwards:                     hasPrivateForwards,
		HasRestrictedVoiceAndVideoNoteMessages: hasRestrictedVoiceAndVideoNoteMessages,
		HasPostedToProfileStories:              hasPostedToProfileStories,
		HasSponsoredMessagesEnabled:            hasSponsoredMessagesEnabled,
		NeedPhoneNumberPrivacyException:        needPhoneNumberPrivacyException,
		SetChatBackground:                      setChatBackground,
		Bio:                                    bio,
		Birthdate:                              birthdate,
		PersonalChatID:                         personalChatID,
		PremiumGiftOptions:                     premiumGiftOptions,
		GroupInCommonCount:                     groupInCommonCount,
		BusinessInfo:                           businessInfo,
		BotInfo:                                botInfo,
	}

	return &userFullInfoTemp
}

// UnmarshalJSON unmarshal to json
func (userFullInfo *UserFullInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PersonalPhoto                          *ChatPhoto             `json:"personal_photo"`                               // User profile photo set by the current user for the contact; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown. If non-null, then it is the same photo as in user.profile_photo and chat.photo. This photo isn't returned in the list of user photos
		Photo                                  *ChatPhoto             `json:"photo"`                                        // User profile photo; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown. If non-null and personal_photo is null, then it is the same photo as in user.profile_photo and chat.photo
		PublicPhoto                            *ChatPhoto             `json:"public_photo"`                                 // User profile photo visible if the main photo is hidden by privacy settings; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown. If non-null and both photo and personal_photo are null, then it is the same photo as in user.profile_photo and chat.photo. This photo isn't returned in the list of user photos
		CanBeCalled                            bool                   `json:"can_be_called"`                                // True, if the user can be called
		SupportsVideoCalls                     bool                   `json:"supports_video_calls"`                         // True, if a video call can be created with the user
		HasPrivateCalls                        bool                   `json:"has_private_calls"`                            // True, if the user can't be called due to their privacy settings
		HasPrivateForwards                     bool                   `json:"has_private_forwards"`                         // True, if the user can't be linked in forwarded messages due to their privacy settings
		HasRestrictedVoiceAndVideoNoteMessages bool                   `json:"has_restricted_voice_and_video_note_messages"` // True, if voice and video notes can't be sent or forwarded to the user
		HasPostedToProfileStories              bool                   `json:"has_posted_to_profile_stories"`                // True, if the user has posted to profile stories
		HasSponsoredMessagesEnabled            bool                   `json:"has_sponsored_messages_enabled"`               // True, if the user always enabled sponsored messages; known only for the current user
		NeedPhoneNumberPrivacyException        bool                   `json:"need_phone_number_privacy_exception"`          // True, if the current user needs to explicitly allow to share their phone number with the user when the method addContact is used
		SetChatBackground                      bool                   `json:"set_chat_background"`                          // True, if the user set chat background for both chat users and it wasn't reverted yet
		Bio                                    *FormattedText         `json:"bio"`                                          // A short user bio; may be null for bots
		Birthdate                              *Birthdate             `json:"birthdate"`                                    // Birthdate of the user; may be null if unknown
		PersonalChatID                         int64                  `json:"personal_chat_id"`                             // Identifier of the personal chat of the user; 0 if none
		PremiumGiftOptions                     []PremiumPaymentOption `json:"premium_gift_options"`                         // The list of available options for gifting Telegram Premium to the user
		GroupInCommonCount                     int32                  `json:"group_in_common_count"`                        // Number of group chats where both the other user and the current user are a member; 0 for the current user
		BusinessInfo                           *BusinessInfo          `json:"business_info"`                                // Information about business settings for Telegram Business accounts; may be null if none

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userFullInfo.tdCommon = tempObj.tdCommon
	userFullInfo.PersonalPhoto = tempObj.PersonalPhoto
	userFullInfo.Photo = tempObj.Photo
	userFullInfo.PublicPhoto = tempObj.PublicPhoto
	userFullInfo.CanBeCalled = tempObj.CanBeCalled
	userFullInfo.SupportsVideoCalls = tempObj.SupportsVideoCalls
	userFullInfo.HasPrivateCalls = tempObj.HasPrivateCalls
	userFullInfo.HasPrivateForwards = tempObj.HasPrivateForwards
	userFullInfo.HasRestrictedVoiceAndVideoNoteMessages = tempObj.HasRestrictedVoiceAndVideoNoteMessages
	userFullInfo.HasPostedToProfileStories = tempObj.HasPostedToProfileStories
	userFullInfo.HasSponsoredMessagesEnabled = tempObj.HasSponsoredMessagesEnabled
	userFullInfo.NeedPhoneNumberPrivacyException = tempObj.NeedPhoneNumberPrivacyException
	userFullInfo.SetChatBackground = tempObj.SetChatBackground
	userFullInfo.Bio = tempObj.Bio
	userFullInfo.Birthdate = tempObj.Birthdate
	userFullInfo.PersonalChatID = tempObj.PersonalChatID
	userFullInfo.PremiumGiftOptions = tempObj.PremiumGiftOptions
	userFullInfo.GroupInCommonCount = tempObj.GroupInCommonCount
	userFullInfo.BusinessInfo = tempObj.BusinessInfo

	fieldBlockList, _ := unmarshalBlockList(objMap["block_list"])
	userFullInfo.BlockList = &fieldBlockList

	var botInfo BotInfo
	if objMap["bot_info"] != nil {
		err = botInfo.UnmarshalJSON(*objMap["bot_info"])
		if err != nil {
			return err
		}
	}

	userFullInfo.BotInfo = &botInfo

	return nil
}

// Users Represents a list of users
type Users struct {
	tdCommon
	TotalCount int32   `json:"total_count"` // Approximate total number of users found
	UserIDs    []int64 `json:"user_ids"`    // A list of user identifiers
}

// MessageType return the string telegram-type of Users
func (users *Users) MessageType() string {
	return "users"
}

// NewUsers creates a new Users
//
// @param totalCount Approximate total number of users found
// @param userIDs A list of user identifiers
func NewUsers(totalCount int32, userIDs []int64) *Users {
	usersTemp := Users{
		tdCommon:   tdCommon{Type: "users"},
		TotalCount: totalCount,
		UserIDs:    userIDs,
	}

	return &usersTemp
}

// UnmarshalJSON unmarshal to json
func (users *Users) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32   `json:"total_count"` // Approximate total number of users found
		UserIDs    []int64 `json:"user_ids"`    // A list of user identifiers
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	users.tdCommon = tempObj.tdCommon
	users.TotalCount = tempObj.TotalCount
	users.UserIDs = tempObj.UserIDs

	return nil
}

// FoundUsers Represents a list of found users
type FoundUsers struct {
	tdCommon
	UserIDs    []int64 `json:"user_ids"`    // Identifiers of the found users
	NextOffset string  `json:"next_offset"` // The offset for the next request. If empty, then there are no more results
}

// MessageType return the string telegram-type of FoundUsers
func (foundUsers *FoundUsers) MessageType() string {
	return "foundUsers"
}

// NewFoundUsers creates a new FoundUsers
//
// @param userIDs Identifiers of the found users
// @param nextOffset The offset for the next request. If empty, then there are no more results
func NewFoundUsers(userIDs []int64, nextOffset string) *FoundUsers {
	foundUsersTemp := FoundUsers{
		tdCommon:   tdCommon{Type: "foundUsers"},
		UserIDs:    userIDs,
		NextOffset: nextOffset,
	}

	return &foundUsersTemp
}

// UnmarshalJSON unmarshal to json
func (foundUsers *FoundUsers) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserIDs    []int64 `json:"user_ids"`    // Identifiers of the found users
		NextOffset string  `json:"next_offset"` // The offset for the next request. If empty, then there are no more results
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	foundUsers.tdCommon = tempObj.tdCommon
	foundUsers.UserIDs = tempObj.UserIDs
	foundUsers.NextOffset = tempObj.NextOffset

	return nil
}

// ChatAdministrator Contains information about a chat administrator
type ChatAdministrator struct {
	tdCommon
	UserID      int64  `json:"user_id"`      // User identifier of the administrator
	CustomTitle string `json:"custom_title"` // Custom title of the administrator
	IsOwner     bool   `json:"is_owner"`     // True, if the user is the owner of the chat
}

// MessageType return the string telegram-type of ChatAdministrator
func (chatAdministrator *ChatAdministrator) MessageType() string {
	return "chatAdministrator"
}

// NewChatAdministrator creates a new ChatAdministrator
//
// @param userID User identifier of the administrator
// @param customTitle Custom title of the administrator
// @param isOwner True, if the user is the owner of the chat
func NewChatAdministrator(userID int64, customTitle string, isOwner bool) *ChatAdministrator {
	chatAdministratorTemp := ChatAdministrator{
		tdCommon:    tdCommon{Type: "chatAdministrator"},
		UserID:      userID,
		CustomTitle: customTitle,
		IsOwner:     isOwner,
	}

	return &chatAdministratorTemp
}

// UnmarshalJSON unmarshal to json
func (chatAdministrator *ChatAdministrator) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID      int64  `json:"user_id"`      // User identifier of the administrator
		CustomTitle string `json:"custom_title"` // Custom title of the administrator
		IsOwner     bool   `json:"is_owner"`     // True, if the user is the owner of the chat
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatAdministrator.tdCommon = tempObj.tdCommon
	chatAdministrator.UserID = tempObj.UserID
	chatAdministrator.CustomTitle = tempObj.CustomTitle
	chatAdministrator.IsOwner = tempObj.IsOwner

	return nil
}

// ChatAdministrators Represents a list of chat administrators
type ChatAdministrators struct {
	tdCommon
	Administrators []ChatAdministrator `json:"administrators"` // A list of chat administrators
}

// MessageType return the string telegram-type of ChatAdministrators
func (chatAdministrators *ChatAdministrators) MessageType() string {
	return "chatAdministrators"
}

// NewChatAdministrators creates a new ChatAdministrators
//
// @param administrators A list of chat administrators
func NewChatAdministrators(administrators []ChatAdministrator) *ChatAdministrators {
	chatAdministratorsTemp := ChatAdministrators{
		tdCommon:       tdCommon{Type: "chatAdministrators"},
		Administrators: administrators,
	}

	return &chatAdministratorsTemp
}

// UnmarshalJSON unmarshal to json
func (chatAdministrators *ChatAdministrators) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Administrators []ChatAdministrator `json:"administrators"` // A list of chat administrators
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatAdministrators.tdCommon = tempObj.tdCommon
	chatAdministrators.Administrators = tempObj.Administrators

	return nil
}

// ChatMemberStatusCreator The user is the owner of the chat and has all the administrator privileges
type ChatMemberStatusCreator struct {
	tdCommon
	CustomTitle string `json:"custom_title"` // A custom title of the owner; 0-16 characters without emoji; applicable to supergroups only
	IsAnonymous bool   `json:"is_anonymous"` // True, if the creator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only
	IsMember    bool   `json:"is_member"`    // True, if the user is a member of the chat
}

// MessageType return the string telegram-type of ChatMemberStatusCreator
func (chatMemberStatusCreator *ChatMemberStatusCreator) MessageType() string {
	return "chatMemberStatusCreator"
}

// NewChatMemberStatusCreator creates a new ChatMemberStatusCreator
//
// @param customTitle A custom title of the owner; 0-16 characters without emoji; applicable to supergroups only
// @param isAnonymous True, if the creator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only
// @param isMember True, if the user is a member of the chat
func NewChatMemberStatusCreator(customTitle string, isAnonymous bool, isMember bool) *ChatMemberStatusCreator {
	chatMemberStatusCreatorTemp := ChatMemberStatusCreator{
		tdCommon:    tdCommon{Type: "chatMemberStatusCreator"},
		CustomTitle: customTitle,
		IsAnonymous: isAnonymous,
		IsMember:    isMember,
	}

	return &chatMemberStatusCreatorTemp
}

// UnmarshalJSON unmarshal to json
func (chatMemberStatusCreator *ChatMemberStatusCreator) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CustomTitle string `json:"custom_title"` // A custom title of the owner; 0-16 characters without emoji; applicable to supergroups only
		IsAnonymous bool   `json:"is_anonymous"` // True, if the creator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only
		IsMember    bool   `json:"is_member"`    // True, if the user is a member of the chat
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatMemberStatusCreator.tdCommon = tempObj.tdCommon
	chatMemberStatusCreator.CustomTitle = tempObj.CustomTitle
	chatMemberStatusCreator.IsAnonymous = tempObj.IsAnonymous
	chatMemberStatusCreator.IsMember = tempObj.IsMember

	return nil
}

// GetChatMemberStatusEnum return the enum type of this object
func (chatMemberStatusCreator *ChatMemberStatusCreator) GetChatMemberStatusEnum() ChatMemberStatusEnum {
	return ChatMemberStatusCreatorType
}

// ChatMemberStatusAdministrator The user is a member of the chat and has some additional privileges. In basic groups, administrators can edit and delete messages sent by others, add new members, ban unprivileged members, and manage video chats. In supergroups and channels, there are more detailed options for administrator privileges
type ChatMemberStatusAdministrator struct {
	tdCommon
	CustomTitle string                   `json:"custom_title"`  // A custom title of the administrator; 0-16 characters without emoji; applicable to supergroups only
	CanBeEdited bool                     `json:"can_be_edited"` // True, if the current user can edit the administrator privileges for the called user
	Rights      *ChatAdministratorRights `json:"rights"`        // Rights of the administrator
}

// MessageType return the string telegram-type of ChatMemberStatusAdministrator
func (chatMemberStatusAdministrator *ChatMemberStatusAdministrator) MessageType() string {
	return "chatMemberStatusAdministrator"
}

// NewChatMemberStatusAdministrator creates a new ChatMemberStatusAdministrator
//
// @param customTitle A custom title of the administrator; 0-16 characters without emoji; applicable to supergroups only
// @param canBeEdited True, if the current user can edit the administrator privileges for the called user
// @param rights Rights of the administrator
func NewChatMemberStatusAdministrator(customTitle string, canBeEdited bool, rights *ChatAdministratorRights) *ChatMemberStatusAdministrator {
	chatMemberStatusAdministratorTemp := ChatMemberStatusAdministrator{
		tdCommon:    tdCommon{Type: "chatMemberStatusAdministrator"},
		CustomTitle: customTitle,
		CanBeEdited: canBeEdited,
		Rights:      rights,
	}

	return &chatMemberStatusAdministratorTemp
}

// UnmarshalJSON unmarshal to json
func (chatMemberStatusAdministrator *ChatMemberStatusAdministrator) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CustomTitle string                   `json:"custom_title"`  // A custom title of the administrator; 0-16 characters without emoji; applicable to supergroups only
		CanBeEdited bool                     `json:"can_be_edited"` // True, if the current user can edit the administrator privileges for the called user
		Rights      *ChatAdministratorRights `json:"rights"`        // Rights of the administrator
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatMemberStatusAdministrator.tdCommon = tempObj.tdCommon
	chatMemberStatusAdministrator.CustomTitle = tempObj.CustomTitle
	chatMemberStatusAdministrator.CanBeEdited = tempObj.CanBeEdited
	chatMemberStatusAdministrator.Rights = tempObj.Rights

	return nil
}

// GetChatMemberStatusEnum return the enum type of this object
func (chatMemberStatusAdministrator *ChatMemberStatusAdministrator) GetChatMemberStatusEnum() ChatMemberStatusEnum {
	return ChatMemberStatusAdministratorType
}

// ChatMemberStatusMember The user is a member of the chat, without any additional privileges or restrictions
type ChatMemberStatusMember struct {
	tdCommon
	MemberUntilDate int32 `json:"member_until_date"` // Point in time (Unix timestamp) when the user will be removed from the chat because of the expired subscription; 0 if never. Ignored in setChatMemberStatus
}

// MessageType return the string telegram-type of ChatMemberStatusMember
func (chatMemberStatusMember *ChatMemberStatusMember) MessageType() string {
	return "chatMemberStatusMember"
}

// NewChatMemberStatusMember creates a new ChatMemberStatusMember
//
// @param memberUntilDate Point in time (Unix timestamp) when the user will be removed from the chat because of the expired subscription; 0 if never. Ignored in setChatMemberStatus
func NewChatMemberStatusMember(memberUntilDate int32) *ChatMemberStatusMember {
	chatMemberStatusMemberTemp := ChatMemberStatusMember{
		tdCommon:        tdCommon{Type: "chatMemberStatusMember"},
		MemberUntilDate: memberUntilDate,
	}

	return &chatMemberStatusMemberTemp
}

// UnmarshalJSON unmarshal to json
func (chatMemberStatusMember *ChatMemberStatusMember) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MemberUntilDate int32 `json:"member_until_date"` // Point in time (Unix timestamp) when the user will be removed from the chat because of the expired subscription; 0 if never. Ignored in setChatMemberStatus
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatMemberStatusMember.tdCommon = tempObj.tdCommon
	chatMemberStatusMember.MemberUntilDate = tempObj.MemberUntilDate

	return nil
}

// GetChatMemberStatusEnum return the enum type of this object
func (chatMemberStatusMember *ChatMemberStatusMember) GetChatMemberStatusEnum() ChatMemberStatusEnum {
	return ChatMemberStatusMemberType
}

// ChatMemberStatusRestricted The user is under certain restrictions in the chat. Not supported in basic groups and channels
type ChatMemberStatusRestricted struct {
	tdCommon
	IsMember            bool             `json:"is_member"`             // True, if the user is a member of the chat
	RestrictedUntilDate int32            `json:"restricted_until_date"` // Point in time (Unix timestamp) when restrictions will be lifted from the user; 0 if never. If the user is restricted for more than 366 days or for less than 30 seconds from the current time, the user is considered to be restricted forever
	Permissions         *ChatPermissions `json:"permissions"`           // User permissions in the chat
}

// MessageType return the string telegram-type of ChatMemberStatusRestricted
func (chatMemberStatusRestricted *ChatMemberStatusRestricted) MessageType() string {
	return "chatMemberStatusRestricted"
}

// NewChatMemberStatusRestricted creates a new ChatMemberStatusRestricted
//
// @param isMember True, if the user is a member of the chat
// @param restrictedUntilDate Point in time (Unix timestamp) when restrictions will be lifted from the user; 0 if never. If the user is restricted for more than 366 days or for less than 30 seconds from the current time, the user is considered to be restricted forever
// @param permissions User permissions in the chat
func NewChatMemberStatusRestricted(isMember bool, restrictedUntilDate int32, permissions *ChatPermissions) *ChatMemberStatusRestricted {
	chatMemberStatusRestrictedTemp := ChatMemberStatusRestricted{
		tdCommon:            tdCommon{Type: "chatMemberStatusRestricted"},
		IsMember:            isMember,
		RestrictedUntilDate: restrictedUntilDate,
		Permissions:         permissions,
	}

	return &chatMemberStatusRestrictedTemp
}

// UnmarshalJSON unmarshal to json
func (chatMemberStatusRestricted *ChatMemberStatusRestricted) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsMember            bool             `json:"is_member"`             // True, if the user is a member of the chat
		RestrictedUntilDate int32            `json:"restricted_until_date"` // Point in time (Unix timestamp) when restrictions will be lifted from the user; 0 if never. If the user is restricted for more than 366 days or for less than 30 seconds from the current time, the user is considered to be restricted forever
		Permissions         *ChatPermissions `json:"permissions"`           // User permissions in the chat
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatMemberStatusRestricted.tdCommon = tempObj.tdCommon
	chatMemberStatusRestricted.IsMember = tempObj.IsMember
	chatMemberStatusRestricted.RestrictedUntilDate = tempObj.RestrictedUntilDate
	chatMemberStatusRestricted.Permissions = tempObj.Permissions

	return nil
}

// GetChatMemberStatusEnum return the enum type of this object
func (chatMemberStatusRestricted *ChatMemberStatusRestricted) GetChatMemberStatusEnum() ChatMemberStatusEnum {
	return ChatMemberStatusRestrictedType
}

// ChatMemberStatusLeft The user or the chat is not a chat member
type ChatMemberStatusLeft struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatMemberStatusLeft
func (chatMemberStatusLeft *ChatMemberStatusLeft) MessageType() string {
	return "chatMemberStatusLeft"
}

// NewChatMemberStatusLeft creates a new ChatMemberStatusLeft
//
func NewChatMemberStatusLeft() *ChatMemberStatusLeft {
	chatMemberStatusLeftTemp := ChatMemberStatusLeft{
		tdCommon: tdCommon{Type: "chatMemberStatusLeft"},
	}

	return &chatMemberStatusLeftTemp
}

// UnmarshalJSON unmarshal to json
func (chatMemberStatusLeft *ChatMemberStatusLeft) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatMemberStatusLeft.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatMemberStatusEnum return the enum type of this object
func (chatMemberStatusLeft *ChatMemberStatusLeft) GetChatMemberStatusEnum() ChatMemberStatusEnum {
	return ChatMemberStatusLeftType
}

// ChatMemberStatusBanned The user or the chat was banned (and hence is not a member of the chat). Implies the user can't return to the chat, view messages, or be used as a participant identifier to join a video chat of the chat
type ChatMemberStatusBanned struct {
	tdCommon
	BannedUntilDate int32 `json:"banned_until_date"` // Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever. Always 0 in basic groups
}

// MessageType return the string telegram-type of ChatMemberStatusBanned
func (chatMemberStatusBanned *ChatMemberStatusBanned) MessageType() string {
	return "chatMemberStatusBanned"
}

// NewChatMemberStatusBanned creates a new ChatMemberStatusBanned
//
// @param bannedUntilDate Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever. Always 0 in basic groups
func NewChatMemberStatusBanned(bannedUntilDate int32) *ChatMemberStatusBanned {
	chatMemberStatusBannedTemp := ChatMemberStatusBanned{
		tdCommon:        tdCommon{Type: "chatMemberStatusBanned"},
		BannedUntilDate: bannedUntilDate,
	}

	return &chatMemberStatusBannedTemp
}

// UnmarshalJSON unmarshal to json
func (chatMemberStatusBanned *ChatMemberStatusBanned) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BannedUntilDate int32 `json:"banned_until_date"` // Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever. Always 0 in basic groups
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatMemberStatusBanned.tdCommon = tempObj.tdCommon
	chatMemberStatusBanned.BannedUntilDate = tempObj.BannedUntilDate

	return nil
}

// GetChatMemberStatusEnum return the enum type of this object
func (chatMemberStatusBanned *ChatMemberStatusBanned) GetChatMemberStatusEnum() ChatMemberStatusEnum {
	return ChatMemberStatusBannedType
}

// ChatMember Describes a user or a chat as a member of another chat
type ChatMember struct {
	tdCommon
	MemberID       MessageSender    `json:"member_id"`        // Identifier of the chat member. Currently, other chats can be only Left or Banned. Only supergroups and channels can have other chats as Left or Banned members and these chats must be supergroups or channels
	InviterUserID  int64            `json:"inviter_user_id"`  // Identifier of a user that invited/promoted/banned this member in the chat; 0 if unknown
	JoinedChatDate int32            `json:"joined_chat_date"` // Point in time (Unix timestamp) when the user joined/was promoted/was banned in the chat
	Status         ChatMemberStatus `json:"status"`           // Status of the member in the chat
}

// MessageType return the string telegram-type of ChatMember
func (chatMember *ChatMember) MessageType() string {
	return "chatMember"
}

// NewChatMember creates a new ChatMember
//
// @param memberID Identifier of the chat member. Currently, other chats can be only Left or Banned. Only supergroups and channels can have other chats as Left or Banned members and these chats must be supergroups or channels
// @param inviterUserID Identifier of a user that invited/promoted/banned this member in the chat; 0 if unknown
// @param joinedChatDate Point in time (Unix timestamp) when the user joined/was promoted/was banned in the chat
// @param status Status of the member in the chat
func NewChatMember(memberID MessageSender, inviterUserID int64, joinedChatDate int32, status ChatMemberStatus) *ChatMember {
	chatMemberTemp := ChatMember{
		tdCommon:       tdCommon{Type: "chatMember"},
		MemberID:       memberID,
		InviterUserID:  inviterUserID,
		JoinedChatDate: joinedChatDate,
		Status:         status,
	}

	return &chatMemberTemp
}

// UnmarshalJSON unmarshal to json
func (chatMember *ChatMember) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		InviterUserID  int64 `json:"inviter_user_id"`  // Identifier of a user that invited/promoted/banned this member in the chat; 0 if unknown
		JoinedChatDate int32 `json:"joined_chat_date"` // Point in time (Unix timestamp) when the user joined/was promoted/was banned in the chat

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatMember.tdCommon = tempObj.tdCommon
	chatMember.InviterUserID = tempObj.InviterUserID
	chatMember.JoinedChatDate = tempObj.JoinedChatDate

	fieldMemberID, _ := unmarshalMessageSender(objMap["member_id"])
	chatMember.MemberID = fieldMemberID

	fieldStatus, _ := unmarshalChatMemberStatus(objMap["status"])
	chatMember.Status = fieldStatus

	return nil
}

// ChatMembers Contains a list of chat members
type ChatMembers struct {
	tdCommon
	TotalCount int32        `json:"total_count"` // Approximate total number of chat members found
	Members    []ChatMember `json:"members"`     // A list of chat members
}

// MessageType return the string telegram-type of ChatMembers
func (chatMembers *ChatMembers) MessageType() string {
	return "chatMembers"
}

// NewChatMembers creates a new ChatMembers
//
// @param totalCount Approximate total number of chat members found
// @param members A list of chat members
func NewChatMembers(totalCount int32, members []ChatMember) *ChatMembers {
	chatMembersTemp := ChatMembers{
		tdCommon:   tdCommon{Type: "chatMembers"},
		TotalCount: totalCount,
		Members:    members,
	}

	return &chatMembersTemp
}

// UnmarshalJSON unmarshal to json
func (chatMembers *ChatMembers) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32        `json:"total_count"` // Approximate total number of chat members found
		Members    []ChatMember `json:"members"`     // A list of chat members
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatMembers.tdCommon = tempObj.tdCommon
	chatMembers.TotalCount = tempObj.TotalCount
	chatMembers.Members = tempObj.Members

	return nil
}

// ChatMembersFilterContacts Returns contacts of the user
type ChatMembersFilterContacts struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatMembersFilterContacts
func (chatMembersFilterContacts *ChatMembersFilterContacts) MessageType() string {
	return "chatMembersFilterContacts"
}

// NewChatMembersFilterContacts creates a new ChatMembersFilterContacts
//
func NewChatMembersFilterContacts() *ChatMembersFilterContacts {
	chatMembersFilterContactsTemp := ChatMembersFilterContacts{
		tdCommon: tdCommon{Type: "chatMembersFilterContacts"},
	}

	return &chatMembersFilterContactsTemp
}

// UnmarshalJSON unmarshal to json
func (chatMembersFilterContacts *ChatMembersFilterContacts) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatMembersFilterContacts.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatMembersFilterEnum return the enum type of this object
func (chatMembersFilterContacts *ChatMembersFilterContacts) GetChatMembersFilterEnum() ChatMembersFilterEnum {
	return ChatMembersFilterContactsType
}

// ChatMembersFilterAdministrators Returns the owner and administrators
type ChatMembersFilterAdministrators struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatMembersFilterAdministrators
func (chatMembersFilterAdministrators *ChatMembersFilterAdministrators) MessageType() string {
	return "chatMembersFilterAdministrators"
}

// NewChatMembersFilterAdministrators creates a new ChatMembersFilterAdministrators
//
func NewChatMembersFilterAdministrators() *ChatMembersFilterAdministrators {
	chatMembersFilterAdministratorsTemp := ChatMembersFilterAdministrators{
		tdCommon: tdCommon{Type: "chatMembersFilterAdministrators"},
	}

	return &chatMembersFilterAdministratorsTemp
}

// UnmarshalJSON unmarshal to json
func (chatMembersFilterAdministrators *ChatMembersFilterAdministrators) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatMembersFilterAdministrators.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatMembersFilterEnum return the enum type of this object
func (chatMembersFilterAdministrators *ChatMembersFilterAdministrators) GetChatMembersFilterEnum() ChatMembersFilterEnum {
	return ChatMembersFilterAdministratorsType
}

// ChatMembersFilterMembers Returns all chat members, including restricted chat members
type ChatMembersFilterMembers struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatMembersFilterMembers
func (chatMembersFilterMembers *ChatMembersFilterMembers) MessageType() string {
	return "chatMembersFilterMembers"
}

// NewChatMembersFilterMembers creates a new ChatMembersFilterMembers
//
func NewChatMembersFilterMembers() *ChatMembersFilterMembers {
	chatMembersFilterMembersTemp := ChatMembersFilterMembers{
		tdCommon: tdCommon{Type: "chatMembersFilterMembers"},
	}

	return &chatMembersFilterMembersTemp
}

// UnmarshalJSON unmarshal to json
func (chatMembersFilterMembers *ChatMembersFilterMembers) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatMembersFilterMembers.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatMembersFilterEnum return the enum type of this object
func (chatMembersFilterMembers *ChatMembersFilterMembers) GetChatMembersFilterEnum() ChatMembersFilterEnum {
	return ChatMembersFilterMembersType
}

// ChatMembersFilterMention Returns users which can be mentioned in the chat
type ChatMembersFilterMention struct {
	tdCommon
	MessageThreadID int64 `json:"message_thread_id"` // If non-zero, the identifier of the current message thread
}

// MessageType return the string telegram-type of ChatMembersFilterMention
func (chatMembersFilterMention *ChatMembersFilterMention) MessageType() string {
	return "chatMembersFilterMention"
}

// NewChatMembersFilterMention creates a new ChatMembersFilterMention
//
// @param messageThreadID If non-zero, the identifier of the current message thread
func NewChatMembersFilterMention(messageThreadID int64) *ChatMembersFilterMention {
	chatMembersFilterMentionTemp := ChatMembersFilterMention{
		tdCommon:        tdCommon{Type: "chatMembersFilterMention"},
		MessageThreadID: messageThreadID,
	}

	return &chatMembersFilterMentionTemp
}

// UnmarshalJSON unmarshal to json
func (chatMembersFilterMention *ChatMembersFilterMention) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MessageThreadID int64 `json:"message_thread_id"` // If non-zero, the identifier of the current message thread
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatMembersFilterMention.tdCommon = tempObj.tdCommon
	chatMembersFilterMention.MessageThreadID = tempObj.MessageThreadID

	return nil
}

// GetChatMembersFilterEnum return the enum type of this object
func (chatMembersFilterMention *ChatMembersFilterMention) GetChatMembersFilterEnum() ChatMembersFilterEnum {
	return ChatMembersFilterMentionType
}

// ChatMembersFilterRestricted Returns users under certain restrictions in the chat; can be used only by administrators in a supergroup
type ChatMembersFilterRestricted struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatMembersFilterRestricted
func (chatMembersFilterRestricted *ChatMembersFilterRestricted) MessageType() string {
	return "chatMembersFilterRestricted"
}

// NewChatMembersFilterRestricted creates a new ChatMembersFilterRestricted
//
func NewChatMembersFilterRestricted() *ChatMembersFilterRestricted {
	chatMembersFilterRestrictedTemp := ChatMembersFilterRestricted{
		tdCommon: tdCommon{Type: "chatMembersFilterRestricted"},
	}

	return &chatMembersFilterRestrictedTemp
}

// UnmarshalJSON unmarshal to json
func (chatMembersFilterRestricted *ChatMembersFilterRestricted) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatMembersFilterRestricted.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatMembersFilterEnum return the enum type of this object
func (chatMembersFilterRestricted *ChatMembersFilterRestricted) GetChatMembersFilterEnum() ChatMembersFilterEnum {
	return ChatMembersFilterRestrictedType
}

// ChatMembersFilterBanned Returns users banned from the chat; can be used only by administrators in a supergroup or in a channel
type ChatMembersFilterBanned struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatMembersFilterBanned
func (chatMembersFilterBanned *ChatMembersFilterBanned) MessageType() string {
	return "chatMembersFilterBanned"
}

// NewChatMembersFilterBanned creates a new ChatMembersFilterBanned
//
func NewChatMembersFilterBanned() *ChatMembersFilterBanned {
	chatMembersFilterBannedTemp := ChatMembersFilterBanned{
		tdCommon: tdCommon{Type: "chatMembersFilterBanned"},
	}

	return &chatMembersFilterBannedTemp
}

// UnmarshalJSON unmarshal to json
func (chatMembersFilterBanned *ChatMembersFilterBanned) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatMembersFilterBanned.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatMembersFilterEnum return the enum type of this object
func (chatMembersFilterBanned *ChatMembersFilterBanned) GetChatMembersFilterEnum() ChatMembersFilterEnum {
	return ChatMembersFilterBannedType
}

// ChatMembersFilterBots Returns bot members of the chat
type ChatMembersFilterBots struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatMembersFilterBots
func (chatMembersFilterBots *ChatMembersFilterBots) MessageType() string {
	return "chatMembersFilterBots"
}

// NewChatMembersFilterBots creates a new ChatMembersFilterBots
//
func NewChatMembersFilterBots() *ChatMembersFilterBots {
	chatMembersFilterBotsTemp := ChatMembersFilterBots{
		tdCommon: tdCommon{Type: "chatMembersFilterBots"},
	}

	return &chatMembersFilterBotsTemp
}

// UnmarshalJSON unmarshal to json
func (chatMembersFilterBots *ChatMembersFilterBots) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatMembersFilterBots.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatMembersFilterEnum return the enum type of this object
func (chatMembersFilterBots *ChatMembersFilterBots) GetChatMembersFilterEnum() ChatMembersFilterEnum {
	return ChatMembersFilterBotsType
}

// SupergroupMembersFilterRecent Returns recently active users in reverse chronological order
type SupergroupMembersFilterRecent struct {
	tdCommon
}

// MessageType return the string telegram-type of SupergroupMembersFilterRecent
func (supergroupMembersFilterRecent *SupergroupMembersFilterRecent) MessageType() string {
	return "supergroupMembersFilterRecent"
}

// NewSupergroupMembersFilterRecent creates a new SupergroupMembersFilterRecent
//
func NewSupergroupMembersFilterRecent() *SupergroupMembersFilterRecent {
	supergroupMembersFilterRecentTemp := SupergroupMembersFilterRecent{
		tdCommon: tdCommon{Type: "supergroupMembersFilterRecent"},
	}

	return &supergroupMembersFilterRecentTemp
}

// UnmarshalJSON unmarshal to json
func (supergroupMembersFilterRecent *SupergroupMembersFilterRecent) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	supergroupMembersFilterRecent.tdCommon = tempObj.tdCommon

	return nil
}

// GetSupergroupMembersFilterEnum return the enum type of this object
func (supergroupMembersFilterRecent *SupergroupMembersFilterRecent) GetSupergroupMembersFilterEnum() SupergroupMembersFilterEnum {
	return SupergroupMembersFilterRecentType
}

// SupergroupMembersFilterContacts Returns contacts of the user, which are members of the supergroup or channel
type SupergroupMembersFilterContacts struct {
	tdCommon
	Query string `json:"query"` // Query to search for
}

// MessageType return the string telegram-type of SupergroupMembersFilterContacts
func (supergroupMembersFilterContacts *SupergroupMembersFilterContacts) MessageType() string {
	return "supergroupMembersFilterContacts"
}

// NewSupergroupMembersFilterContacts creates a new SupergroupMembersFilterContacts
//
// @param query Query to search for
func NewSupergroupMembersFilterContacts(query string) *SupergroupMembersFilterContacts {
	supergroupMembersFilterContactsTemp := SupergroupMembersFilterContacts{
		tdCommon: tdCommon{Type: "supergroupMembersFilterContacts"},
		Query:    query,
	}

	return &supergroupMembersFilterContactsTemp
}

// UnmarshalJSON unmarshal to json
func (supergroupMembersFilterContacts *SupergroupMembersFilterContacts) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Query string `json:"query"` // Query to search for
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	supergroupMembersFilterContacts.tdCommon = tempObj.tdCommon
	supergroupMembersFilterContacts.Query = tempObj.Query

	return nil
}

// GetSupergroupMembersFilterEnum return the enum type of this object
func (supergroupMembersFilterContacts *SupergroupMembersFilterContacts) GetSupergroupMembersFilterEnum() SupergroupMembersFilterEnum {
	return SupergroupMembersFilterContactsType
}

// SupergroupMembersFilterAdministrators Returns the owner and administrators
type SupergroupMembersFilterAdministrators struct {
	tdCommon
}

// MessageType return the string telegram-type of SupergroupMembersFilterAdministrators
func (supergroupMembersFilterAdministrators *SupergroupMembersFilterAdministrators) MessageType() string {
	return "supergroupMembersFilterAdministrators"
}

// NewSupergroupMembersFilterAdministrators creates a new SupergroupMembersFilterAdministrators
//
func NewSupergroupMembersFilterAdministrators() *SupergroupMembersFilterAdministrators {
	supergroupMembersFilterAdministratorsTemp := SupergroupMembersFilterAdministrators{
		tdCommon: tdCommon{Type: "supergroupMembersFilterAdministrators"},
	}

	return &supergroupMembersFilterAdministratorsTemp
}

// UnmarshalJSON unmarshal to json
func (supergroupMembersFilterAdministrators *SupergroupMembersFilterAdministrators) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	supergroupMembersFilterAdministrators.tdCommon = tempObj.tdCommon

	return nil
}

// GetSupergroupMembersFilterEnum return the enum type of this object
func (supergroupMembersFilterAdministrators *SupergroupMembersFilterAdministrators) GetSupergroupMembersFilterEnum() SupergroupMembersFilterEnum {
	return SupergroupMembersFilterAdministratorsType
}

// SupergroupMembersFilterSearch Used to search for supergroup or channel members via a (string) query
type SupergroupMembersFilterSearch struct {
	tdCommon
	Query string `json:"query"` // Query to search for
}

// MessageType return the string telegram-type of SupergroupMembersFilterSearch
func (supergroupMembersFilterSearch *SupergroupMembersFilterSearch) MessageType() string {
	return "supergroupMembersFilterSearch"
}

// NewSupergroupMembersFilterSearch creates a new SupergroupMembersFilterSearch
//
// @param query Query to search for
func NewSupergroupMembersFilterSearch(query string) *SupergroupMembersFilterSearch {
	supergroupMembersFilterSearchTemp := SupergroupMembersFilterSearch{
		tdCommon: tdCommon{Type: "supergroupMembersFilterSearch"},
		Query:    query,
	}

	return &supergroupMembersFilterSearchTemp
}

// UnmarshalJSON unmarshal to json
func (supergroupMembersFilterSearch *SupergroupMembersFilterSearch) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Query string `json:"query"` // Query to search for
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	supergroupMembersFilterSearch.tdCommon = tempObj.tdCommon
	supergroupMembersFilterSearch.Query = tempObj.Query

	return nil
}

// GetSupergroupMembersFilterEnum return the enum type of this object
func (supergroupMembersFilterSearch *SupergroupMembersFilterSearch) GetSupergroupMembersFilterEnum() SupergroupMembersFilterEnum {
	return SupergroupMembersFilterSearchType
}

// SupergroupMembersFilterRestricted Returns restricted supergroup members; can be used only by administrators
type SupergroupMembersFilterRestricted struct {
	tdCommon
	Query string `json:"query"` // Query to search for
}

// MessageType return the string telegram-type of SupergroupMembersFilterRestricted
func (supergroupMembersFilterRestricted *SupergroupMembersFilterRestricted) MessageType() string {
	return "supergroupMembersFilterRestricted"
}

// NewSupergroupMembersFilterRestricted creates a new SupergroupMembersFilterRestricted
//
// @param query Query to search for
func NewSupergroupMembersFilterRestricted(query string) *SupergroupMembersFilterRestricted {
	supergroupMembersFilterRestrictedTemp := SupergroupMembersFilterRestricted{
		tdCommon: tdCommon{Type: "supergroupMembersFilterRestricted"},
		Query:    query,
	}

	return &supergroupMembersFilterRestrictedTemp
}

// UnmarshalJSON unmarshal to json
func (supergroupMembersFilterRestricted *SupergroupMembersFilterRestricted) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Query string `json:"query"` // Query to search for
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	supergroupMembersFilterRestricted.tdCommon = tempObj.tdCommon
	supergroupMembersFilterRestricted.Query = tempObj.Query

	return nil
}

// GetSupergroupMembersFilterEnum return the enum type of this object
func (supergroupMembersFilterRestricted *SupergroupMembersFilterRestricted) GetSupergroupMembersFilterEnum() SupergroupMembersFilterEnum {
	return SupergroupMembersFilterRestrictedType
}

// SupergroupMembersFilterBanned Returns users banned from the supergroup or channel; can be used only by administrators
type SupergroupMembersFilterBanned struct {
	tdCommon
	Query string `json:"query"` // Query to search for
}

// MessageType return the string telegram-type of SupergroupMembersFilterBanned
func (supergroupMembersFilterBanned *SupergroupMembersFilterBanned) MessageType() string {
	return "supergroupMembersFilterBanned"
}

// NewSupergroupMembersFilterBanned creates a new SupergroupMembersFilterBanned
//
// @param query Query to search for
func NewSupergroupMembersFilterBanned(query string) *SupergroupMembersFilterBanned {
	supergroupMembersFilterBannedTemp := SupergroupMembersFilterBanned{
		tdCommon: tdCommon{Type: "supergroupMembersFilterBanned"},
		Query:    query,
	}

	return &supergroupMembersFilterBannedTemp
}

// UnmarshalJSON unmarshal to json
func (supergroupMembersFilterBanned *SupergroupMembersFilterBanned) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Query string `json:"query"` // Query to search for
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	supergroupMembersFilterBanned.tdCommon = tempObj.tdCommon
	supergroupMembersFilterBanned.Query = tempObj.Query

	return nil
}

// GetSupergroupMembersFilterEnum return the enum type of this object
func (supergroupMembersFilterBanned *SupergroupMembersFilterBanned) GetSupergroupMembersFilterEnum() SupergroupMembersFilterEnum {
	return SupergroupMembersFilterBannedType
}

// SupergroupMembersFilterMention Returns users which can be mentioned in the supergroup
type SupergroupMembersFilterMention struct {
	tdCommon
	Query           string `json:"query"`             // Query to search for
	MessageThreadID int64  `json:"message_thread_id"` // If non-zero, the identifier of the current message thread
}

// MessageType return the string telegram-type of SupergroupMembersFilterMention
func (supergroupMembersFilterMention *SupergroupMembersFilterMention) MessageType() string {
	return "supergroupMembersFilterMention"
}

// NewSupergroupMembersFilterMention creates a new SupergroupMembersFilterMention
//
// @param query Query to search for
// @param messageThreadID If non-zero, the identifier of the current message thread
func NewSupergroupMembersFilterMention(query string, messageThreadID int64) *SupergroupMembersFilterMention {
	supergroupMembersFilterMentionTemp := SupergroupMembersFilterMention{
		tdCommon:        tdCommon{Type: "supergroupMembersFilterMention"},
		Query:           query,
		MessageThreadID: messageThreadID,
	}

	return &supergroupMembersFilterMentionTemp
}

// UnmarshalJSON unmarshal to json
func (supergroupMembersFilterMention *SupergroupMembersFilterMention) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Query           string `json:"query"`             // Query to search for
		MessageThreadID int64  `json:"message_thread_id"` // If non-zero, the identifier of the current message thread
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	supergroupMembersFilterMention.tdCommon = tempObj.tdCommon
	supergroupMembersFilterMention.Query = tempObj.Query
	supergroupMembersFilterMention.MessageThreadID = tempObj.MessageThreadID

	return nil
}

// GetSupergroupMembersFilterEnum return the enum type of this object
func (supergroupMembersFilterMention *SupergroupMembersFilterMention) GetSupergroupMembersFilterEnum() SupergroupMembersFilterEnum {
	return SupergroupMembersFilterMentionType
}

// SupergroupMembersFilterBots Returns bot members of the supergroup or channel
type SupergroupMembersFilterBots struct {
	tdCommon
}

// MessageType return the string telegram-type of SupergroupMembersFilterBots
func (supergroupMembersFilterBots *SupergroupMembersFilterBots) MessageType() string {
	return "supergroupMembersFilterBots"
}

// NewSupergroupMembersFilterBots creates a new SupergroupMembersFilterBots
//
func NewSupergroupMembersFilterBots() *SupergroupMembersFilterBots {
	supergroupMembersFilterBotsTemp := SupergroupMembersFilterBots{
		tdCommon: tdCommon{Type: "supergroupMembersFilterBots"},
	}

	return &supergroupMembersFilterBotsTemp
}

// UnmarshalJSON unmarshal to json
func (supergroupMembersFilterBots *SupergroupMembersFilterBots) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	supergroupMembersFilterBots.tdCommon = tempObj.tdCommon

	return nil
}

// GetSupergroupMembersFilterEnum return the enum type of this object
func (supergroupMembersFilterBots *SupergroupMembersFilterBots) GetSupergroupMembersFilterEnum() SupergroupMembersFilterEnum {
	return SupergroupMembersFilterBotsType
}

// ChatInviteLink Contains a chat invite link
type ChatInviteLink struct {
	tdCommon
	InviteLink              string                   `json:"invite_link"`                // Chat invite link
	Name                    string                   `json:"name"`                       // Name of the link
	CreatorUserID           int64                    `json:"creator_user_id"`            // User identifier of an administrator created the link
	Date                    int32                    `json:"date"`                       // Point in time (Unix timestamp) when the link was created
	EditDate                int32                    `json:"edit_date"`                  // Point in time (Unix timestamp) when the link was last edited; 0 if never or unknown
	ExpirationDate          int32                    `json:"expiration_date"`            // Point in time (Unix timestamp) when the link will expire; 0 if never
	SubscriptionPricing     *StarSubscriptionPricing `json:"subscription_pricing"`       // Information about subscription plan that is applied to the users joining the chat by the link; may be null if the link doesn't require subscription
	MemberLimit             int32                    `json:"member_limit"`               // The maximum number of members, which can join the chat using the link simultaneously; 0 if not limited. Always 0 if the link requires approval
	MemberCount             int32                    `json:"member_count"`               // Number of chat members, which joined the chat using the link
	ExpiredMemberCount      int32                    `json:"expired_member_count"`       // Number of chat members, which joined the chat using the link, but have already left because of expired subscription; for subscription links only
	PendingJoinRequestCount int32                    `json:"pending_join_request_count"` // Number of pending join requests created using this link
	CreatesJoinRequest      bool                     `json:"creates_join_request"`       // True, if the link only creates join request. If true, total number of joining members will be unlimited
	IsPrimary               bool                     `json:"is_primary"`                 // True, if the link is primary. Primary invite link can't have name, expiration date, or usage limit. There is exactly one primary invite link for each administrator with can_invite_users right at a given time
	IsRevoked               bool                     `json:"is_revoked"`                 // True, if the link was revoked
}

// MessageType return the string telegram-type of ChatInviteLink
func (chatInviteLink *ChatInviteLink) MessageType() string {
	return "chatInviteLink"
}

// NewChatInviteLink creates a new ChatInviteLink
//
// @param inviteLink Chat invite link
// @param name Name of the link
// @param creatorUserID User identifier of an administrator created the link
// @param date Point in time (Unix timestamp) when the link was created
// @param editDate Point in time (Unix timestamp) when the link was last edited; 0 if never or unknown
// @param expirationDate Point in time (Unix timestamp) when the link will expire; 0 if never
// @param subscriptionPricing Information about subscription plan that is applied to the users joining the chat by the link; may be null if the link doesn't require subscription
// @param memberLimit The maximum number of members, which can join the chat using the link simultaneously; 0 if not limited. Always 0 if the link requires approval
// @param memberCount Number of chat members, which joined the chat using the link
// @param expiredMemberCount Number of chat members, which joined the chat using the link, but have already left because of expired subscription; for subscription links only
// @param pendingJoinRequestCount Number of pending join requests created using this link
// @param createsJoinRequest True, if the link only creates join request. If true, total number of joining members will be unlimited
// @param isPrimary True, if the link is primary. Primary invite link can't have name, expiration date, or usage limit. There is exactly one primary invite link for each administrator with can_invite_users right at a given time
// @param isRevoked True, if the link was revoked
func NewChatInviteLink(inviteLink string, name string, creatorUserID int64, date int32, editDate int32, expirationDate int32, subscriptionPricing *StarSubscriptionPricing, memberLimit int32, memberCount int32, expiredMemberCount int32, pendingJoinRequestCount int32, createsJoinRequest bool, isPrimary bool, isRevoked bool) *ChatInviteLink {
	chatInviteLinkTemp := ChatInviteLink{
		tdCommon:                tdCommon{Type: "chatInviteLink"},
		InviteLink:              inviteLink,
		Name:                    name,
		CreatorUserID:           creatorUserID,
		Date:                    date,
		EditDate:                editDate,
		ExpirationDate:          expirationDate,
		SubscriptionPricing:     subscriptionPricing,
		MemberLimit:             memberLimit,
		MemberCount:             memberCount,
		ExpiredMemberCount:      expiredMemberCount,
		PendingJoinRequestCount: pendingJoinRequestCount,
		CreatesJoinRequest:      createsJoinRequest,
		IsPrimary:               isPrimary,
		IsRevoked:               isRevoked,
	}

	return &chatInviteLinkTemp
}

// UnmarshalJSON unmarshal to json
func (chatInviteLink *ChatInviteLink) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		InviteLink              string                   `json:"invite_link"`                // Chat invite link
		Name                    string                   `json:"name"`                       // Name of the link
		CreatorUserID           int64                    `json:"creator_user_id"`            // User identifier of an administrator created the link
		Date                    int32                    `json:"date"`                       // Point in time (Unix timestamp) when the link was created
		EditDate                int32                    `json:"edit_date"`                  // Point in time (Unix timestamp) when the link was last edited; 0 if never or unknown
		ExpirationDate          int32                    `json:"expiration_date"`            // Point in time (Unix timestamp) when the link will expire; 0 if never
		SubscriptionPricing     *StarSubscriptionPricing `json:"subscription_pricing"`       // Information about subscription plan that is applied to the users joining the chat by the link; may be null if the link doesn't require subscription
		MemberLimit             int32                    `json:"member_limit"`               // The maximum number of members, which can join the chat using the link simultaneously; 0 if not limited. Always 0 if the link requires approval
		MemberCount             int32                    `json:"member_count"`               // Number of chat members, which joined the chat using the link
		ExpiredMemberCount      int32                    `json:"expired_member_count"`       // Number of chat members, which joined the chat using the link, but have already left because of expired subscription; for subscription links only
		PendingJoinRequestCount int32                    `json:"pending_join_request_count"` // Number of pending join requests created using this link
		CreatesJoinRequest      bool                     `json:"creates_join_request"`       // True, if the link only creates join request. If true, total number of joining members will be unlimited
		IsPrimary               bool                     `json:"is_primary"`                 // True, if the link is primary. Primary invite link can't have name, expiration date, or usage limit. There is exactly one primary invite link for each administrator with can_invite_users right at a given time
		IsRevoked               bool                     `json:"is_revoked"`                 // True, if the link was revoked
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatInviteLink.tdCommon = tempObj.tdCommon
	chatInviteLink.InviteLink = tempObj.InviteLink
	chatInviteLink.Name = tempObj.Name
	chatInviteLink.CreatorUserID = tempObj.CreatorUserID
	chatInviteLink.Date = tempObj.Date
	chatInviteLink.EditDate = tempObj.EditDate
	chatInviteLink.ExpirationDate = tempObj.ExpirationDate
	chatInviteLink.SubscriptionPricing = tempObj.SubscriptionPricing
	chatInviteLink.MemberLimit = tempObj.MemberLimit
	chatInviteLink.MemberCount = tempObj.MemberCount
	chatInviteLink.ExpiredMemberCount = tempObj.ExpiredMemberCount
	chatInviteLink.PendingJoinRequestCount = tempObj.PendingJoinRequestCount
	chatInviteLink.CreatesJoinRequest = tempObj.CreatesJoinRequest
	chatInviteLink.IsPrimary = tempObj.IsPrimary
	chatInviteLink.IsRevoked = tempObj.IsRevoked

	return nil
}

// ChatInviteLinks Contains a list of chat invite links
type ChatInviteLinks struct {
	tdCommon
	TotalCount  int32            `json:"total_count"`  // Approximate total number of chat invite links found
	InviteLinks []ChatInviteLink `json:"invite_links"` // List of invite links
}

// MessageType return the string telegram-type of ChatInviteLinks
func (chatInviteLinks *ChatInviteLinks) MessageType() string {
	return "chatInviteLinks"
}

// NewChatInviteLinks creates a new ChatInviteLinks
//
// @param totalCount Approximate total number of chat invite links found
// @param inviteLinks List of invite links
func NewChatInviteLinks(totalCount int32, inviteLinks []ChatInviteLink) *ChatInviteLinks {
	chatInviteLinksTemp := ChatInviteLinks{
		tdCommon:    tdCommon{Type: "chatInviteLinks"},
		TotalCount:  totalCount,
		InviteLinks: inviteLinks,
	}

	return &chatInviteLinksTemp
}

// UnmarshalJSON unmarshal to json
func (chatInviteLinks *ChatInviteLinks) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount  int32            `json:"total_count"`  // Approximate total number of chat invite links found
		InviteLinks []ChatInviteLink `json:"invite_links"` // List of invite links
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatInviteLinks.tdCommon = tempObj.tdCommon
	chatInviteLinks.TotalCount = tempObj.TotalCount
	chatInviteLinks.InviteLinks = tempObj.InviteLinks

	return nil
}

// ChatInviteLinkCount Describes a chat administrator with a number of active and revoked chat invite links
type ChatInviteLinkCount struct {
	tdCommon
	UserID                 int64 `json:"user_id"`                   // Administrator's user identifier
	InviteLinkCount        int32 `json:"invite_link_count"`         // Number of active invite links
	RevokedInviteLinkCount int32 `json:"revoked_invite_link_count"` // Number of revoked invite links
}

// MessageType return the string telegram-type of ChatInviteLinkCount
func (chatInviteLinkCount *ChatInviteLinkCount) MessageType() string {
	return "chatInviteLinkCount"
}

// NewChatInviteLinkCount creates a new ChatInviteLinkCount
//
// @param userID Administrator's user identifier
// @param inviteLinkCount Number of active invite links
// @param revokedInviteLinkCount Number of revoked invite links
func NewChatInviteLinkCount(userID int64, inviteLinkCount int32, revokedInviteLinkCount int32) *ChatInviteLinkCount {
	chatInviteLinkCountTemp := ChatInviteLinkCount{
		tdCommon:               tdCommon{Type: "chatInviteLinkCount"},
		UserID:                 userID,
		InviteLinkCount:        inviteLinkCount,
		RevokedInviteLinkCount: revokedInviteLinkCount,
	}

	return &chatInviteLinkCountTemp
}

// UnmarshalJSON unmarshal to json
func (chatInviteLinkCount *ChatInviteLinkCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID                 int64 `json:"user_id"`                   // Administrator's user identifier
		InviteLinkCount        int32 `json:"invite_link_count"`         // Number of active invite links
		RevokedInviteLinkCount int32 `json:"revoked_invite_link_count"` // Number of revoked invite links
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatInviteLinkCount.tdCommon = tempObj.tdCommon
	chatInviteLinkCount.UserID = tempObj.UserID
	chatInviteLinkCount.InviteLinkCount = tempObj.InviteLinkCount
	chatInviteLinkCount.RevokedInviteLinkCount = tempObj.RevokedInviteLinkCount

	return nil
}

// ChatInviteLinkCounts Contains a list of chat invite link counts
type ChatInviteLinkCounts struct {
	tdCommon
	InviteLinkCounts []ChatInviteLinkCount `json:"invite_link_counts"` // List of invite link counts
}

// MessageType return the string telegram-type of ChatInviteLinkCounts
func (chatInviteLinkCounts *ChatInviteLinkCounts) MessageType() string {
	return "chatInviteLinkCounts"
}

// NewChatInviteLinkCounts creates a new ChatInviteLinkCounts
//
// @param inviteLinkCounts List of invite link counts
func NewChatInviteLinkCounts(inviteLinkCounts []ChatInviteLinkCount) *ChatInviteLinkCounts {
	chatInviteLinkCountsTemp := ChatInviteLinkCounts{
		tdCommon:         tdCommon{Type: "chatInviteLinkCounts"},
		InviteLinkCounts: inviteLinkCounts,
	}

	return &chatInviteLinkCountsTemp
}

// UnmarshalJSON unmarshal to json
func (chatInviteLinkCounts *ChatInviteLinkCounts) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		InviteLinkCounts []ChatInviteLinkCount `json:"invite_link_counts"` // List of invite link counts
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatInviteLinkCounts.tdCommon = tempObj.tdCommon
	chatInviteLinkCounts.InviteLinkCounts = tempObj.InviteLinkCounts

	return nil
}

// ChatInviteLinkMember Describes a chat member joined a chat via an invite link
type ChatInviteLinkMember struct {
	tdCommon
	UserID                  int64 `json:"user_id"`                     // User identifier
	JoinedChatDate          int32 `json:"joined_chat_date"`            // Point in time (Unix timestamp) when the user joined the chat
	ViaChatFolderInviteLink bool  `json:"via_chat_folder_invite_link"` // True, if the user has joined the chat using an invite link for a chat folder
	ApproverUserID          int64 `json:"approver_user_id"`            // User identifier of the chat administrator, approved user join request
}

// MessageType return the string telegram-type of ChatInviteLinkMember
func (chatInviteLinkMember *ChatInviteLinkMember) MessageType() string {
	return "chatInviteLinkMember"
}

// NewChatInviteLinkMember creates a new ChatInviteLinkMember
//
// @param userID User identifier
// @param joinedChatDate Point in time (Unix timestamp) when the user joined the chat
// @param viaChatFolderInviteLink True, if the user has joined the chat using an invite link for a chat folder
// @param approverUserID User identifier of the chat administrator, approved user join request
func NewChatInviteLinkMember(userID int64, joinedChatDate int32, viaChatFolderInviteLink bool, approverUserID int64) *ChatInviteLinkMember {
	chatInviteLinkMemberTemp := ChatInviteLinkMember{
		tdCommon:                tdCommon{Type: "chatInviteLinkMember"},
		UserID:                  userID,
		JoinedChatDate:          joinedChatDate,
		ViaChatFolderInviteLink: viaChatFolderInviteLink,
		ApproverUserID:          approverUserID,
	}

	return &chatInviteLinkMemberTemp
}

// UnmarshalJSON unmarshal to json
func (chatInviteLinkMember *ChatInviteLinkMember) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID                  int64 `json:"user_id"`                     // User identifier
		JoinedChatDate          int32 `json:"joined_chat_date"`            // Point in time (Unix timestamp) when the user joined the chat
		ViaChatFolderInviteLink bool  `json:"via_chat_folder_invite_link"` // True, if the user has joined the chat using an invite link for a chat folder
		ApproverUserID          int64 `json:"approver_user_id"`            // User identifier of the chat administrator, approved user join request
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatInviteLinkMember.tdCommon = tempObj.tdCommon
	chatInviteLinkMember.UserID = tempObj.UserID
	chatInviteLinkMember.JoinedChatDate = tempObj.JoinedChatDate
	chatInviteLinkMember.ViaChatFolderInviteLink = tempObj.ViaChatFolderInviteLink
	chatInviteLinkMember.ApproverUserID = tempObj.ApproverUserID

	return nil
}

// ChatInviteLinkMembers Contains a list of chat members joined a chat via an invite link
type ChatInviteLinkMembers struct {
	tdCommon
	TotalCount int32                  `json:"total_count"` // Approximate total number of chat members found
	Members    []ChatInviteLinkMember `json:"members"`     // List of chat members, joined a chat via an invite link
}

// MessageType return the string telegram-type of ChatInviteLinkMembers
func (chatInviteLinkMembers *ChatInviteLinkMembers) MessageType() string {
	return "chatInviteLinkMembers"
}

// NewChatInviteLinkMembers creates a new ChatInviteLinkMembers
//
// @param totalCount Approximate total number of chat members found
// @param members List of chat members, joined a chat via an invite link
func NewChatInviteLinkMembers(totalCount int32, members []ChatInviteLinkMember) *ChatInviteLinkMembers {
	chatInviteLinkMembersTemp := ChatInviteLinkMembers{
		tdCommon:   tdCommon{Type: "chatInviteLinkMembers"},
		TotalCount: totalCount,
		Members:    members,
	}

	return &chatInviteLinkMembersTemp
}

// UnmarshalJSON unmarshal to json
func (chatInviteLinkMembers *ChatInviteLinkMembers) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32                  `json:"total_count"` // Approximate total number of chat members found
		Members    []ChatInviteLinkMember `json:"members"`     // List of chat members, joined a chat via an invite link
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatInviteLinkMembers.tdCommon = tempObj.tdCommon
	chatInviteLinkMembers.TotalCount = tempObj.TotalCount
	chatInviteLinkMembers.Members = tempObj.Members

	return nil
}

// InviteLinkChatTypeBasicGroup The link is an invite link for a basic group
type InviteLinkChatTypeBasicGroup struct {
	tdCommon
}

// MessageType return the string telegram-type of InviteLinkChatTypeBasicGroup
func (inviteLinkChatTypeBasicGroup *InviteLinkChatTypeBasicGroup) MessageType() string {
	return "inviteLinkChatTypeBasicGroup"
}

// NewInviteLinkChatTypeBasicGroup creates a new InviteLinkChatTypeBasicGroup
//
func NewInviteLinkChatTypeBasicGroup() *InviteLinkChatTypeBasicGroup {
	inviteLinkChatTypeBasicGroupTemp := InviteLinkChatTypeBasicGroup{
		tdCommon: tdCommon{Type: "inviteLinkChatTypeBasicGroup"},
	}

	return &inviteLinkChatTypeBasicGroupTemp
}

// UnmarshalJSON unmarshal to json
func (inviteLinkChatTypeBasicGroup *InviteLinkChatTypeBasicGroup) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inviteLinkChatTypeBasicGroup.tdCommon = tempObj.tdCommon

	return nil
}

// GetInviteLinkChatTypeEnum return the enum type of this object
func (inviteLinkChatTypeBasicGroup *InviteLinkChatTypeBasicGroup) GetInviteLinkChatTypeEnum() InviteLinkChatTypeEnum {
	return InviteLinkChatTypeBasicGroupType
}

// InviteLinkChatTypeSupergroup The link is an invite link for a supergroup
type InviteLinkChatTypeSupergroup struct {
	tdCommon
}

// MessageType return the string telegram-type of InviteLinkChatTypeSupergroup
func (inviteLinkChatTypeSupergroup *InviteLinkChatTypeSupergroup) MessageType() string {
	return "inviteLinkChatTypeSupergroup"
}

// NewInviteLinkChatTypeSupergroup creates a new InviteLinkChatTypeSupergroup
//
func NewInviteLinkChatTypeSupergroup() *InviteLinkChatTypeSupergroup {
	inviteLinkChatTypeSupergroupTemp := InviteLinkChatTypeSupergroup{
		tdCommon: tdCommon{Type: "inviteLinkChatTypeSupergroup"},
	}

	return &inviteLinkChatTypeSupergroupTemp
}

// UnmarshalJSON unmarshal to json
func (inviteLinkChatTypeSupergroup *InviteLinkChatTypeSupergroup) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inviteLinkChatTypeSupergroup.tdCommon = tempObj.tdCommon

	return nil
}

// GetInviteLinkChatTypeEnum return the enum type of this object
func (inviteLinkChatTypeSupergroup *InviteLinkChatTypeSupergroup) GetInviteLinkChatTypeEnum() InviteLinkChatTypeEnum {
	return InviteLinkChatTypeSupergroupType
}

// InviteLinkChatTypeChannel The link is an invite link for a channel
type InviteLinkChatTypeChannel struct {
	tdCommon
}

// MessageType return the string telegram-type of InviteLinkChatTypeChannel
func (inviteLinkChatTypeChannel *InviteLinkChatTypeChannel) MessageType() string {
	return "inviteLinkChatTypeChannel"
}

// NewInviteLinkChatTypeChannel creates a new InviteLinkChatTypeChannel
//
func NewInviteLinkChatTypeChannel() *InviteLinkChatTypeChannel {
	inviteLinkChatTypeChannelTemp := InviteLinkChatTypeChannel{
		tdCommon: tdCommon{Type: "inviteLinkChatTypeChannel"},
	}

	return &inviteLinkChatTypeChannelTemp
}

// UnmarshalJSON unmarshal to json
func (inviteLinkChatTypeChannel *InviteLinkChatTypeChannel) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inviteLinkChatTypeChannel.tdCommon = tempObj.tdCommon

	return nil
}

// GetInviteLinkChatTypeEnum return the enum type of this object
func (inviteLinkChatTypeChannel *InviteLinkChatTypeChannel) GetInviteLinkChatTypeEnum() InviteLinkChatTypeEnum {
	return InviteLinkChatTypeChannelType
}

// ChatInviteLinkSubscriptionInfo Contains information about subscription plan that must be paid by the user to use a chat invite link
type ChatInviteLinkSubscriptionInfo struct {
	tdCommon
	Pricing  *StarSubscriptionPricing `json:"pricing"`   // Information about subscription plan that must be paid by the user to use the link
	CanReuse bool                     `json:"can_reuse"` // True, if the user has already paid for the subscription and can use joinChatByInviteLink to join the subscribed chat again
	FormID   JSONInt64                `json:"form_id"`   // Identifier of the payment form to use for subscription payment; 0 if the subscription can't be paid
}

// MessageType return the string telegram-type of ChatInviteLinkSubscriptionInfo
func (chatInviteLinkSubscriptionInfo *ChatInviteLinkSubscriptionInfo) MessageType() string {
	return "chatInviteLinkSubscriptionInfo"
}

// NewChatInviteLinkSubscriptionInfo creates a new ChatInviteLinkSubscriptionInfo
//
// @param pricing Information about subscription plan that must be paid by the user to use the link
// @param canReuse True, if the user has already paid for the subscription and can use joinChatByInviteLink to join the subscribed chat again
// @param formID Identifier of the payment form to use for subscription payment; 0 if the subscription can't be paid
func NewChatInviteLinkSubscriptionInfo(pricing *StarSubscriptionPricing, canReuse bool, formID JSONInt64) *ChatInviteLinkSubscriptionInfo {
	chatInviteLinkSubscriptionInfoTemp := ChatInviteLinkSubscriptionInfo{
		tdCommon: tdCommon{Type: "chatInviteLinkSubscriptionInfo"},
		Pricing:  pricing,
		CanReuse: canReuse,
		FormID:   formID,
	}

	return &chatInviteLinkSubscriptionInfoTemp
}

// UnmarshalJSON unmarshal to json
func (chatInviteLinkSubscriptionInfo *ChatInviteLinkSubscriptionInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Pricing  *StarSubscriptionPricing `json:"pricing"`   // Information about subscription plan that must be paid by the user to use the link
		CanReuse bool                     `json:"can_reuse"` // True, if the user has already paid for the subscription and can use joinChatByInviteLink to join the subscribed chat again
		FormID   JSONInt64                `json:"form_id"`   // Identifier of the payment form to use for subscription payment; 0 if the subscription can't be paid
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatInviteLinkSubscriptionInfo.tdCommon = tempObj.tdCommon
	chatInviteLinkSubscriptionInfo.Pricing = tempObj.Pricing
	chatInviteLinkSubscriptionInfo.CanReuse = tempObj.CanReuse
	chatInviteLinkSubscriptionInfo.FormID = tempObj.FormID

	return nil
}

// ChatInviteLinkInfo Contains information about a chat invite link
type ChatInviteLinkInfo struct {
	tdCommon
	ChatID             int64                           `json:"chat_id"`              // Chat identifier of the invite link; 0 if the user has no access to the chat before joining
	AccessibleFor      int32                           `json:"accessible_for"`       // If non-zero, the amount of time for which read access to the chat will remain available, in seconds
	Type               InviteLinkChatType              `json:"type"`                 // Type of the chat
	Title              string                          `json:"title"`                // Title of the chat
	Photo              *ChatPhotoInfo                  `json:"photo"`                // Chat photo; may be null
	AccentColorID      int32                           `json:"accent_color_id"`      // Identifier of the accent color for chat title and background of chat photo
	Description        string                          `json:"description"`          // Chat description
	MemberCount        int32                           `json:"member_count"`         // Number of members in the chat
	MemberUserIDs      []int64                         `json:"member_user_ids"`      // User identifiers of some chat members that may be known to the current user
	SubscriptionInfo   *ChatInviteLinkSubscriptionInfo `json:"subscription_info"`    // Information about subscription plan that must be paid by the user to use the link; may be null if the link doesn't require subscription
	CreatesJoinRequest bool                            `json:"creates_join_request"` // True, if the link only creates join request
	IsPublic           bool                            `json:"is_public"`            // True, if the chat is a public supergroup or channel, i.e. it has a username or it is a location-based supergroup
	IsVerified         bool                            `json:"is_verified"`          // True, if the chat is verified
	IsScam             bool                            `json:"is_scam"`              // True, if many users reported this chat as a scam
	IsFake             bool                            `json:"is_fake"`              // True, if many users reported this chat as a fake account
}

// MessageType return the string telegram-type of ChatInviteLinkInfo
func (chatInviteLinkInfo *ChatInviteLinkInfo) MessageType() string {
	return "chatInviteLinkInfo"
}

// NewChatInviteLinkInfo creates a new ChatInviteLinkInfo
//
// @param chatID Chat identifier of the invite link; 0 if the user has no access to the chat before joining
// @param accessibleFor If non-zero, the amount of time for which read access to the chat will remain available, in seconds
// @param typeParam Type of the chat
// @param title Title of the chat
// @param photo Chat photo; may be null
// @param accentColorID Identifier of the accent color for chat title and background of chat photo
// @param description Chat description
// @param memberCount Number of members in the chat
// @param memberUserIDs User identifiers of some chat members that may be known to the current user
// @param subscriptionInfo Information about subscription plan that must be paid by the user to use the link; may be null if the link doesn't require subscription
// @param createsJoinRequest True, if the link only creates join request
// @param isPublic True, if the chat is a public supergroup or channel, i.e. it has a username or it is a location-based supergroup
// @param isVerified True, if the chat is verified
// @param isScam True, if many users reported this chat as a scam
// @param isFake True, if many users reported this chat as a fake account
func NewChatInviteLinkInfo(chatID int64, accessibleFor int32, typeParam InviteLinkChatType, title string, photo *ChatPhotoInfo, accentColorID int32, description string, memberCount int32, memberUserIDs []int64, subscriptionInfo *ChatInviteLinkSubscriptionInfo, createsJoinRequest bool, isPublic bool, isVerified bool, isScam bool, isFake bool) *ChatInviteLinkInfo {
	chatInviteLinkInfoTemp := ChatInviteLinkInfo{
		tdCommon:           tdCommon{Type: "chatInviteLinkInfo"},
		ChatID:             chatID,
		AccessibleFor:      accessibleFor,
		Type:               typeParam,
		Title:              title,
		Photo:              photo,
		AccentColorID:      accentColorID,
		Description:        description,
		MemberCount:        memberCount,
		MemberUserIDs:      memberUserIDs,
		SubscriptionInfo:   subscriptionInfo,
		CreatesJoinRequest: createsJoinRequest,
		IsPublic:           isPublic,
		IsVerified:         isVerified,
		IsScam:             isScam,
		IsFake:             isFake,
	}

	return &chatInviteLinkInfoTemp
}

// UnmarshalJSON unmarshal to json
func (chatInviteLinkInfo *ChatInviteLinkInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID             int64                           `json:"chat_id"`              // Chat identifier of the invite link; 0 if the user has no access to the chat before joining
		AccessibleFor      int32                           `json:"accessible_for"`       // If non-zero, the amount of time for which read access to the chat will remain available, in seconds
		Title              string                          `json:"title"`                // Title of the chat
		Photo              *ChatPhotoInfo                  `json:"photo"`                // Chat photo; may be null
		AccentColorID      int32                           `json:"accent_color_id"`      // Identifier of the accent color for chat title and background of chat photo
		Description        string                          `json:"description"`          // Chat description
		MemberCount        int32                           `json:"member_count"`         // Number of members in the chat
		MemberUserIDs      []int64                         `json:"member_user_ids"`      // User identifiers of some chat members that may be known to the current user
		SubscriptionInfo   *ChatInviteLinkSubscriptionInfo `json:"subscription_info"`    // Information about subscription plan that must be paid by the user to use the link; may be null if the link doesn't require subscription
		CreatesJoinRequest bool                            `json:"creates_join_request"` // True, if the link only creates join request
		IsPublic           bool                            `json:"is_public"`            // True, if the chat is a public supergroup or channel, i.e. it has a username or it is a location-based supergroup
		IsVerified         bool                            `json:"is_verified"`          // True, if the chat is verified
		IsScam             bool                            `json:"is_scam"`              // True, if many users reported this chat as a scam
		IsFake             bool                            `json:"is_fake"`              // True, if many users reported this chat as a fake account
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatInviteLinkInfo.tdCommon = tempObj.tdCommon
	chatInviteLinkInfo.ChatID = tempObj.ChatID
	chatInviteLinkInfo.AccessibleFor = tempObj.AccessibleFor
	chatInviteLinkInfo.Title = tempObj.Title
	chatInviteLinkInfo.Photo = tempObj.Photo
	chatInviteLinkInfo.AccentColorID = tempObj.AccentColorID
	chatInviteLinkInfo.Description = tempObj.Description
	chatInviteLinkInfo.MemberCount = tempObj.MemberCount
	chatInviteLinkInfo.MemberUserIDs = tempObj.MemberUserIDs
	chatInviteLinkInfo.SubscriptionInfo = tempObj.SubscriptionInfo
	chatInviteLinkInfo.CreatesJoinRequest = tempObj.CreatesJoinRequest
	chatInviteLinkInfo.IsPublic = tempObj.IsPublic
	chatInviteLinkInfo.IsVerified = tempObj.IsVerified
	chatInviteLinkInfo.IsScam = tempObj.IsScam
	chatInviteLinkInfo.IsFake = tempObj.IsFake

	fieldType, _ := unmarshalInviteLinkChatType(objMap["type"])
	chatInviteLinkInfo.Type = fieldType

	return nil
}

// ChatJoinRequest Describes a user that sent a join request and waits for administrator approval
type ChatJoinRequest struct {
	tdCommon
	UserID int64  `json:"user_id"` // User identifier
	Date   int32  `json:"date"`    // Point in time (Unix timestamp) when the user sent the join request
	Bio    string `json:"bio"`     // A short bio of the user
}

// MessageType return the string telegram-type of ChatJoinRequest
func (chatJoinRequest *ChatJoinRequest) MessageType() string {
	return "chatJoinRequest"
}

// NewChatJoinRequest creates a new ChatJoinRequest
//
// @param userID User identifier
// @param date Point in time (Unix timestamp) when the user sent the join request
// @param bio A short bio of the user
func NewChatJoinRequest(userID int64, date int32, bio string) *ChatJoinRequest {
	chatJoinRequestTemp := ChatJoinRequest{
		tdCommon: tdCommon{Type: "chatJoinRequest"},
		UserID:   userID,
		Date:     date,
		Bio:      bio,
	}

	return &chatJoinRequestTemp
}

// UnmarshalJSON unmarshal to json
func (chatJoinRequest *ChatJoinRequest) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID int64  `json:"user_id"` // User identifier
		Date   int32  `json:"date"`    // Point in time (Unix timestamp) when the user sent the join request
		Bio    string `json:"bio"`     // A short bio of the user
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatJoinRequest.tdCommon = tempObj.tdCommon
	chatJoinRequest.UserID = tempObj.UserID
	chatJoinRequest.Date = tempObj.Date
	chatJoinRequest.Bio = tempObj.Bio

	return nil
}

// ChatJoinRequests Contains a list of requests to join a chat
type ChatJoinRequests struct {
	tdCommon
	TotalCount int32             `json:"total_count"` // Approximate total number of requests found
	Requests   []ChatJoinRequest `json:"requests"`    // List of the requests
}

// MessageType return the string telegram-type of ChatJoinRequests
func (chatJoinRequests *ChatJoinRequests) MessageType() string {
	return "chatJoinRequests"
}

// NewChatJoinRequests creates a new ChatJoinRequests
//
// @param totalCount Approximate total number of requests found
// @param requests List of the requests
func NewChatJoinRequests(totalCount int32, requests []ChatJoinRequest) *ChatJoinRequests {
	chatJoinRequestsTemp := ChatJoinRequests{
		tdCommon:   tdCommon{Type: "chatJoinRequests"},
		TotalCount: totalCount,
		Requests:   requests,
	}

	return &chatJoinRequestsTemp
}

// UnmarshalJSON unmarshal to json
func (chatJoinRequests *ChatJoinRequests) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32             `json:"total_count"` // Approximate total number of requests found
		Requests   []ChatJoinRequest `json:"requests"`    // List of the requests
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatJoinRequests.tdCommon = tempObj.tdCommon
	chatJoinRequests.TotalCount = tempObj.TotalCount
	chatJoinRequests.Requests = tempObj.Requests

	return nil
}

// ChatJoinRequestsInfo Contains information about pending join requests for a chat
type ChatJoinRequestsInfo struct {
	tdCommon
	TotalCount int32   `json:"total_count"` // Total number of pending join requests
	UserIDs    []int64 `json:"user_ids"`    // Identifiers of at most 3 users sent the newest pending join requests
}

// MessageType return the string telegram-type of ChatJoinRequestsInfo
func (chatJoinRequestsInfo *ChatJoinRequestsInfo) MessageType() string {
	return "chatJoinRequestsInfo"
}

// NewChatJoinRequestsInfo creates a new ChatJoinRequestsInfo
//
// @param totalCount Total number of pending join requests
// @param userIDs Identifiers of at most 3 users sent the newest pending join requests
func NewChatJoinRequestsInfo(totalCount int32, userIDs []int64) *ChatJoinRequestsInfo {
	chatJoinRequestsInfoTemp := ChatJoinRequestsInfo{
		tdCommon:   tdCommon{Type: "chatJoinRequestsInfo"},
		TotalCount: totalCount,
		UserIDs:    userIDs,
	}

	return &chatJoinRequestsInfoTemp
}

// UnmarshalJSON unmarshal to json
func (chatJoinRequestsInfo *ChatJoinRequestsInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32   `json:"total_count"` // Total number of pending join requests
		UserIDs    []int64 `json:"user_ids"`    // Identifiers of at most 3 users sent the newest pending join requests
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatJoinRequestsInfo.tdCommon = tempObj.tdCommon
	chatJoinRequestsInfo.TotalCount = tempObj.TotalCount
	chatJoinRequestsInfo.UserIDs = tempObj.UserIDs

	return nil
}

// BasicGroup Represents a basic group of 0-200 users (must be upgraded to a supergroup to accommodate more than 200 users)
type BasicGroup struct {
	tdCommon
	ID                     int64            `json:"id"`                        // Group identifier
	MemberCount            int32            `json:"member_count"`              // Number of members in the group
	Status                 ChatMemberStatus `json:"status"`                    // Status of the current user in the group
	IsActive               bool             `json:"is_active"`                 // True, if the group is active
	UpgradedToSupergroupID int64            `json:"upgraded_to_supergroup_id"` // Identifier of the supergroup to which this group was upgraded; 0 if none
}

// MessageType return the string telegram-type of BasicGroup
func (basicGroup *BasicGroup) MessageType() string {
	return "basicGroup"
}

// NewBasicGroup creates a new BasicGroup
//
// @param iD Group identifier
// @param memberCount Number of members in the group
// @param status Status of the current user in the group
// @param isActive True, if the group is active
// @param upgradedToSupergroupID Identifier of the supergroup to which this group was upgraded; 0 if none
func NewBasicGroup(iD int64, memberCount int32, status ChatMemberStatus, isActive bool, upgradedToSupergroupID int64) *BasicGroup {
	basicGroupTemp := BasicGroup{
		tdCommon:               tdCommon{Type: "basicGroup"},
		ID:                     iD,
		MemberCount:            memberCount,
		Status:                 status,
		IsActive:               isActive,
		UpgradedToSupergroupID: upgradedToSupergroupID,
	}

	return &basicGroupTemp
}

// UnmarshalJSON unmarshal to json
func (basicGroup *BasicGroup) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID                     int64 `json:"id"`                        // Group identifier
		MemberCount            int32 `json:"member_count"`              // Number of members in the group
		IsActive               bool  `json:"is_active"`                 // True, if the group is active
		UpgradedToSupergroupID int64 `json:"upgraded_to_supergroup_id"` // Identifier of the supergroup to which this group was upgraded; 0 if none
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	basicGroup.tdCommon = tempObj.tdCommon
	basicGroup.ID = tempObj.ID
	basicGroup.MemberCount = tempObj.MemberCount
	basicGroup.IsActive = tempObj.IsActive
	basicGroup.UpgradedToSupergroupID = tempObj.UpgradedToSupergroupID

	fieldStatus, _ := unmarshalChatMemberStatus(objMap["status"])
	basicGroup.Status = fieldStatus

	return nil
}

// BasicGroupFullInfo Contains full information about a basic group
type BasicGroupFullInfo struct {
	tdCommon
	Photo                       *ChatPhoto      `json:"photo"`                           // Chat photo; may be null if empty or unknown. If non-null, then it is the same photo as in chat.photo
	Description                 string          `json:"description"`                     // Group description. Updated only after the basic group is opened
	CreatorUserID               int64           `json:"creator_user_id"`                 // User identifier of the creator of the group; 0 if unknown
	Members                     []ChatMember    `json:"members"`                         // Group members
	CanHideMembers              bool            `json:"can_hide_members"`                // True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers and searchChatMembers for non-administrators after upgrading the basic group to a supergroup
	CanToggleAggressiveAntiSpam bool            `json:"can_toggle_aggressive_anti_spam"` // True, if aggressive anti-spam checks can be enabled or disabled in the supergroup after upgrading the basic group to a supergroup
	InviteLink                  *ChatInviteLink `json:"invite_link"`                     // Primary invite link for this group; may be null. For chat administrators with can_invite_users right only. Updated only after the basic group is opened
	BotCommands                 []BotCommands   `json:"bot_commands"`                    // List of commands of bots in the group
}

// MessageType return the string telegram-type of BasicGroupFullInfo
func (basicGroupFullInfo *BasicGroupFullInfo) MessageType() string {
	return "basicGroupFullInfo"
}

// NewBasicGroupFullInfo creates a new BasicGroupFullInfo
//
// @param photo Chat photo; may be null if empty or unknown. If non-null, then it is the same photo as in chat.photo
// @param description Group description. Updated only after the basic group is opened
// @param creatorUserID User identifier of the creator of the group; 0 if unknown
// @param members Group members
// @param canHideMembers True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers and searchChatMembers for non-administrators after upgrading the basic group to a supergroup
// @param canToggleAggressiveAntiSpam True, if aggressive anti-spam checks can be enabled or disabled in the supergroup after upgrading the basic group to a supergroup
// @param inviteLink Primary invite link for this group; may be null. For chat administrators with can_invite_users right only. Updated only after the basic group is opened
// @param botCommands List of commands of bots in the group
func NewBasicGroupFullInfo(photo *ChatPhoto, description string, creatorUserID int64, members []ChatMember, canHideMembers bool, canToggleAggressiveAntiSpam bool, inviteLink *ChatInviteLink, botCommands []BotCommands) *BasicGroupFullInfo {
	basicGroupFullInfoTemp := BasicGroupFullInfo{
		tdCommon:                    tdCommon{Type: "basicGroupFullInfo"},
		Photo:                       photo,
		Description:                 description,
		CreatorUserID:               creatorUserID,
		Members:                     members,
		CanHideMembers:              canHideMembers,
		CanToggleAggressiveAntiSpam: canToggleAggressiveAntiSpam,
		InviteLink:                  inviteLink,
		BotCommands:                 botCommands,
	}

	return &basicGroupFullInfoTemp
}

// UnmarshalJSON unmarshal to json
func (basicGroupFullInfo *BasicGroupFullInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Photo                       *ChatPhoto      `json:"photo"`                           // Chat photo; may be null if empty or unknown. If non-null, then it is the same photo as in chat.photo
		Description                 string          `json:"description"`                     // Group description. Updated only after the basic group is opened
		CreatorUserID               int64           `json:"creator_user_id"`                 // User identifier of the creator of the group; 0 if unknown
		Members                     []ChatMember    `json:"members"`                         // Group members
		CanHideMembers              bool            `json:"can_hide_members"`                // True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers and searchChatMembers for non-administrators after upgrading the basic group to a supergroup
		CanToggleAggressiveAntiSpam bool            `json:"can_toggle_aggressive_anti_spam"` // True, if aggressive anti-spam checks can be enabled or disabled in the supergroup after upgrading the basic group to a supergroup
		InviteLink                  *ChatInviteLink `json:"invite_link"`                     // Primary invite link for this group; may be null. For chat administrators with can_invite_users right only. Updated only after the basic group is opened
		BotCommands                 []BotCommands   `json:"bot_commands"`                    // List of commands of bots in the group
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	basicGroupFullInfo.tdCommon = tempObj.tdCommon
	basicGroupFullInfo.Photo = tempObj.Photo
	basicGroupFullInfo.Description = tempObj.Description
	basicGroupFullInfo.CreatorUserID = tempObj.CreatorUserID
	basicGroupFullInfo.Members = tempObj.Members
	basicGroupFullInfo.CanHideMembers = tempObj.CanHideMembers
	basicGroupFullInfo.CanToggleAggressiveAntiSpam = tempObj.CanToggleAggressiveAntiSpam
	basicGroupFullInfo.InviteLink = tempObj.InviteLink
	basicGroupFullInfo.BotCommands = tempObj.BotCommands

	return nil
}

// Supergroup Represents a supergroup or channel with zero or more members (subscribers in the case of channels). From the point of view of the system, a channel is a special kind of a supergroup: only administrators can post and see the list of members, and posts from all administrators use the name and photo of the channel instead of individual names and profile photos. Unlike supergroups, channels can have an unlimited number of subscribers
type Supergroup struct {
	tdCommon
	ID                     int64            `json:"id"`                        // Supergroup or channel identifier
	Usernames              *Usernames       `json:"usernames"`                 // Usernames of the supergroup or channel; may be null
	Date                   int32            `json:"date"`                      // Point in time (Unix timestamp) when the current user joined, or the point in time when the supergroup or channel was created, in case the user is not a member
	Status                 ChatMemberStatus `json:"status"`                    // Status of the current user in the supergroup or channel; custom title will always be empty
	MemberCount            int32            `json:"member_count"`              // Number of members in the supergroup or channel; 0 if unknown. Currently, it is guaranteed to be known only if the supergroup or channel was received through getChatSimilarChats, getChatsToSendStories, getCreatedPublicChats, getGroupsInCommon, getInactiveSupergroupChats, getRecommendedChats, getSuitableDiscussionChats, getUserPrivacySettingRules, getVideoChatAvailableParticipants, searchChatsNearby, searchPublicChats, or in chatFolderInviteLinkInfo.missing_chat_ids, or in userFullInfo.personal_chat_id, or for chats with messages or stories from publicForwards and foundStories
	BoostLevel             int32            `json:"boost_level"`               // Approximate boost level for the chat
	HasLinkedChat          bool             `json:"has_linked_chat"`           // True, if the channel has a discussion group, or the supergroup is the designated discussion group for a channel
	HasLocation            bool             `json:"has_location"`              // True, if the supergroup is connected to a location, i.e. the supergroup is a location-based supergroup
	SignMessages           bool             `json:"sign_messages"`             // True, if messages sent to the channel contains name of the sender. This field is only applicable to channels
	ShowMessageSender      bool             `json:"show_message_sender"`       // True, if messages sent to the channel have information about the sender user. This field is only applicable to channels
	JoinToSendMessages     bool             `json:"join_to_send_messages"`     // True, if users need to join the supergroup before they can send messages. Always true for channels and non-discussion supergroups
	JoinByRequest          bool             `json:"join_by_request"`           // True, if all users directly joining the supergroup need to be approved by supergroup administrators. Always false for channels and supergroups without username, location, or a linked chat
	IsSlowModeEnabled      bool             `json:"is_slow_mode_enabled"`      // True, if the slow mode is enabled in the supergroup
	IsChannel              bool             `json:"is_channel"`                // True, if the supergroup is a channel
	IsBroadcastGroup       bool             `json:"is_broadcast_group"`        // True, if the supergroup is a broadcast group, i.e. only administrators can send messages and there is no limit on the number of members
	IsForum                bool             `json:"is_forum"`                  // True, if the supergroup is a forum with topics
	IsVerified             bool             `json:"is_verified"`               // True, if the supergroup or channel is verified
	HasSensitiveContent    bool             `json:"has_sensitive_content"`     // True, if content of media messages in the supergroup or channel chat must be hidden with 18+ spoiler
	RestrictionReason      string           `json:"restriction_reason"`        // If non-empty, contains a human-readable description of the reason why access to this supergroup or channel must be restricted
	IsScam                 bool             `json:"is_scam"`                   // True, if many users reported this supergroup or channel as a scam
	IsFake                 bool             `json:"is_fake"`                   // True, if many users reported this supergroup or channel as a fake account
	HasActiveStories       bool             `json:"has_active_stories"`        // True, if the supergroup or channel has non-expired stories available to the current user
	HasUnreadActiveStories bool             `json:"has_unread_active_stories"` // True, if the supergroup or channel has unread non-expired stories available to the current user
}

// MessageType return the string telegram-type of Supergroup
func (supergroup *Supergroup) MessageType() string {
	return "supergroup"
}

// NewSupergroup creates a new Supergroup
//
// @param iD Supergroup or channel identifier
// @param usernames Usernames of the supergroup or channel; may be null
// @param date Point in time (Unix timestamp) when the current user joined, or the point in time when the supergroup or channel was created, in case the user is not a member
// @param status Status of the current user in the supergroup or channel; custom title will always be empty
// @param memberCount Number of members in the supergroup or channel; 0 if unknown. Currently, it is guaranteed to be known only if the supergroup or channel was received through getChatSimilarChats, getChatsToSendStories, getCreatedPublicChats, getGroupsInCommon, getInactiveSupergroupChats, getRecommendedChats, getSuitableDiscussionChats, getUserPrivacySettingRules, getVideoChatAvailableParticipants, searchChatsNearby, searchPublicChats, or in chatFolderInviteLinkInfo.missing_chat_ids, or in userFullInfo.personal_chat_id, or for chats with messages or stories from publicForwards and foundStories
// @param boostLevel Approximate boost level for the chat
// @param hasLinkedChat True, if the channel has a discussion group, or the supergroup is the designated discussion group for a channel
// @param hasLocation True, if the supergroup is connected to a location, i.e. the supergroup is a location-based supergroup
// @param signMessages True, if messages sent to the channel contains name of the sender. This field is only applicable to channels
// @param showMessageSender True, if messages sent to the channel have information about the sender user. This field is only applicable to channels
// @param joinToSendMessages True, if users need to join the supergroup before they can send messages. Always true for channels and non-discussion supergroups
// @param joinByRequest True, if all users directly joining the supergroup need to be approved by supergroup administrators. Always false for channels and supergroups without username, location, or a linked chat
// @param isSlowModeEnabled True, if the slow mode is enabled in the supergroup
// @param isChannel True, if the supergroup is a channel
// @param isBroadcastGroup True, if the supergroup is a broadcast group, i.e. only administrators can send messages and there is no limit on the number of members
// @param isForum True, if the supergroup is a forum with topics
// @param isVerified True, if the supergroup or channel is verified
// @param hasSensitiveContent True, if content of media messages in the supergroup or channel chat must be hidden with 18+ spoiler
// @param restrictionReason If non-empty, contains a human-readable description of the reason why access to this supergroup or channel must be restricted
// @param isScam True, if many users reported this supergroup or channel as a scam
// @param isFake True, if many users reported this supergroup or channel as a fake account
// @param hasActiveStories True, if the supergroup or channel has non-expired stories available to the current user
// @param hasUnreadActiveStories True, if the supergroup or channel has unread non-expired stories available to the current user
func NewSupergroup(iD int64, usernames *Usernames, date int32, status ChatMemberStatus, memberCount int32, boostLevel int32, hasLinkedChat bool, hasLocation bool, signMessages bool, showMessageSender bool, joinToSendMessages bool, joinByRequest bool, isSlowModeEnabled bool, isChannel bool, isBroadcastGroup bool, isForum bool, isVerified bool, hasSensitiveContent bool, restrictionReason string, isScam bool, isFake bool, hasActiveStories bool, hasUnreadActiveStories bool) *Supergroup {
	supergroupTemp := Supergroup{
		tdCommon:               tdCommon{Type: "supergroup"},
		ID:                     iD,
		Usernames:              usernames,
		Date:                   date,
		Status:                 status,
		MemberCount:            memberCount,
		BoostLevel:             boostLevel,
		HasLinkedChat:          hasLinkedChat,
		HasLocation:            hasLocation,
		SignMessages:           signMessages,
		ShowMessageSender:      showMessageSender,
		JoinToSendMessages:     joinToSendMessages,
		JoinByRequest:          joinByRequest,
		IsSlowModeEnabled:      isSlowModeEnabled,
		IsChannel:              isChannel,
		IsBroadcastGroup:       isBroadcastGroup,
		IsForum:                isForum,
		IsVerified:             isVerified,
		HasSensitiveContent:    hasSensitiveContent,
		RestrictionReason:      restrictionReason,
		IsScam:                 isScam,
		IsFake:                 isFake,
		HasActiveStories:       hasActiveStories,
		HasUnreadActiveStories: hasUnreadActiveStories,
	}

	return &supergroupTemp
}

// UnmarshalJSON unmarshal to json
func (supergroup *Supergroup) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID                     int64      `json:"id"`                        // Supergroup or channel identifier
		Usernames              *Usernames `json:"usernames"`                 // Usernames of the supergroup or channel; may be null
		Date                   int32      `json:"date"`                      // Point in time (Unix timestamp) when the current user joined, or the point in time when the supergroup or channel was created, in case the user is not a member
		MemberCount            int32      `json:"member_count"`              // Number of members in the supergroup or channel; 0 if unknown. Currently, it is guaranteed to be known only if the supergroup or channel was received through getChatSimilarChats, getChatsToSendStories, getCreatedPublicChats, getGroupsInCommon, getInactiveSupergroupChats, getRecommendedChats, getSuitableDiscussionChats, getUserPrivacySettingRules, getVideoChatAvailableParticipants, searchChatsNearby, searchPublicChats, or in chatFolderInviteLinkInfo.missing_chat_ids, or in userFullInfo.personal_chat_id, or for chats with messages or stories from publicForwards and foundStories
		BoostLevel             int32      `json:"boost_level"`               // Approximate boost level for the chat
		HasLinkedChat          bool       `json:"has_linked_chat"`           // True, if the channel has a discussion group, or the supergroup is the designated discussion group for a channel
		HasLocation            bool       `json:"has_location"`              // True, if the supergroup is connected to a location, i.e. the supergroup is a location-based supergroup
		SignMessages           bool       `json:"sign_messages"`             // True, if messages sent to the channel contains name of the sender. This field is only applicable to channels
		ShowMessageSender      bool       `json:"show_message_sender"`       // True, if messages sent to the channel have information about the sender user. This field is only applicable to channels
		JoinToSendMessages     bool       `json:"join_to_send_messages"`     // True, if users need to join the supergroup before they can send messages. Always true for channels and non-discussion supergroups
		JoinByRequest          bool       `json:"join_by_request"`           // True, if all users directly joining the supergroup need to be approved by supergroup administrators. Always false for channels and supergroups without username, location, or a linked chat
		IsSlowModeEnabled      bool       `json:"is_slow_mode_enabled"`      // True, if the slow mode is enabled in the supergroup
		IsChannel              bool       `json:"is_channel"`                // True, if the supergroup is a channel
		IsBroadcastGroup       bool       `json:"is_broadcast_group"`        // True, if the supergroup is a broadcast group, i.e. only administrators can send messages and there is no limit on the number of members
		IsForum                bool       `json:"is_forum"`                  // True, if the supergroup is a forum with topics
		IsVerified             bool       `json:"is_verified"`               // True, if the supergroup or channel is verified
		HasSensitiveContent    bool       `json:"has_sensitive_content"`     // True, if content of media messages in the supergroup or channel chat must be hidden with 18+ spoiler
		RestrictionReason      string     `json:"restriction_reason"`        // If non-empty, contains a human-readable description of the reason why access to this supergroup or channel must be restricted
		IsScam                 bool       `json:"is_scam"`                   // True, if many users reported this supergroup or channel as a scam
		IsFake                 bool       `json:"is_fake"`                   // True, if many users reported this supergroup or channel as a fake account
		HasActiveStories       bool       `json:"has_active_stories"`        // True, if the supergroup or channel has non-expired stories available to the current user
		HasUnreadActiveStories bool       `json:"has_unread_active_stories"` // True, if the supergroup or channel has unread non-expired stories available to the current user
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	supergroup.tdCommon = tempObj.tdCommon
	supergroup.ID = tempObj.ID
	supergroup.Usernames = tempObj.Usernames
	supergroup.Date = tempObj.Date
	supergroup.MemberCount = tempObj.MemberCount
	supergroup.BoostLevel = tempObj.BoostLevel
	supergroup.HasLinkedChat = tempObj.HasLinkedChat
	supergroup.HasLocation = tempObj.HasLocation
	supergroup.SignMessages = tempObj.SignMessages
	supergroup.ShowMessageSender = tempObj.ShowMessageSender
	supergroup.JoinToSendMessages = tempObj.JoinToSendMessages
	supergroup.JoinByRequest = tempObj.JoinByRequest
	supergroup.IsSlowModeEnabled = tempObj.IsSlowModeEnabled
	supergroup.IsChannel = tempObj.IsChannel
	supergroup.IsBroadcastGroup = tempObj.IsBroadcastGroup
	supergroup.IsForum = tempObj.IsForum
	supergroup.IsVerified = tempObj.IsVerified
	supergroup.HasSensitiveContent = tempObj.HasSensitiveContent
	supergroup.RestrictionReason = tempObj.RestrictionReason
	supergroup.IsScam = tempObj.IsScam
	supergroup.IsFake = tempObj.IsFake
	supergroup.HasActiveStories = tempObj.HasActiveStories
	supergroup.HasUnreadActiveStories = tempObj.HasUnreadActiveStories

	fieldStatus, _ := unmarshalChatMemberStatus(objMap["status"])
	supergroup.Status = fieldStatus

	return nil
}

// SupergroupFullInfo Contains full information about a supergroup or channel
type SupergroupFullInfo struct {
	tdCommon
	Photo                        *ChatPhoto      `json:"photo"`                            // Chat photo; may be null if empty or unknown. If non-null, then it is the same photo as in chat.photo
	Description                  string          `json:"description"`                      // Supergroup or channel description
	MemberCount                  int32           `json:"member_count"`                     // Number of members in the supergroup or channel; 0 if unknown
	AdministratorCount           int32           `json:"administrator_count"`              // Number of privileged users in the supergroup or channel; 0 if unknown
	RestrictedCount              int32           `json:"restricted_count"`                 // Number of restricted users in the supergroup; 0 if unknown
	BannedCount                  int32           `json:"banned_count"`                     // Number of users banned from chat; 0 if unknown
	LinkedChatID                 int64           `json:"linked_chat_id"`                   // Chat identifier of a discussion group for the channel, or a channel, for which the supergroup is the designated discussion group; 0 if none or unknown
	SlowModeDelay                int32           `json:"slow_mode_delay"`                  // Delay between consecutive sent messages for non-administrator supergroup members, in seconds
	SlowModeDelayExpiresIn       float64         `json:"slow_mode_delay_expires_in"`       // Time left before next message can be sent in the supergroup, in seconds. An updateSupergroupFullInfo update is not triggered when value of this field changes, but both new and old values are non-zero
	CanEnablePaidReaction        bool            `json:"can_enable_paid_reaction"`         // True, if paid reaction can be enabled in the channel chat; for channels only
	CanGetMembers                bool            `json:"can_get_members"`                  // True, if members of the chat can be retrieved via getSupergroupMembers or searchChatMembers
	HasHiddenMembers             bool            `json:"has_hidden_members"`               // True, if non-administrators can receive only administrators and bots using getSupergroupMembers or searchChatMembers
	CanHideMembers               bool            `json:"can_hide_members"`                 // True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers and searchChatMembers for non-administrators
	CanSetStickerSet             bool            `json:"can_set_sticker_set"`              // True, if the supergroup sticker set can be changed
	CanSetLocation               bool            `json:"can_set_location"`                 // True, if the supergroup location can be changed
	CanGetStatistics             bool            `json:"can_get_statistics"`               // True, if the supergroup or channel statistics are available
	CanGetRevenueStatistics      bool            `json:"can_get_revenue_statistics"`       // True, if the supergroup or channel revenue statistics are available
	CanGetStarRevenueStatistics  bool            `json:"can_get_star_revenue_statistics"`  // True, if the supergroup or channel Telegram Star revenue statistics are available
	CanToggleAggressiveAntiSpam  bool            `json:"can_toggle_aggressive_anti_spam"`  // True, if aggressive anti-spam checks can be enabled or disabled in the supergroup
	IsAllHistoryAvailable        bool            `json:"is_all_history_available"`         // True, if new chat members will have access to old messages. In public, discussion, of forum groups and all channels, old messages are always available, so this option affects only private non-forum supergroups without a linked chat. The value of this field is only available to chat administrators
	CanHaveSponsoredMessages     bool            `json:"can_have_sponsored_messages"`      // True, if the chat can have sponsored messages. The value of this field is only available to the owner of the chat
	HasAggressiveAntiSpamEnabled bool            `json:"has_aggressive_anti_spam_enabled"` // True, if aggressive anti-spam checks are enabled in the supergroup. The value of this field is only available to chat administrators
	HasPaidMediaAllowed          bool            `json:"has_paid_media_allowed"`           // True, if paid media can be sent and forwarded to the channel chat; for channels only
	HasPinnedStories             bool            `json:"has_pinned_stories"`               // True, if the supergroup or channel has pinned stories
	MyBoostCount                 int32           `json:"my_boost_count"`                   // Number of times the current user boosted the supergroup or channel
	UnrestrictBoostCount         int32           `json:"unrestrict_boost_count"`           // Number of times the supergroup must be boosted by a user to ignore slow mode and chat permission restrictions; 0 if unspecified
	StickerSetID                 JSONInt64       `json:"sticker_set_id"`                   // Identifier of the supergroup sticker set that must be shown before user sticker sets; 0 if none
	CustomEmojiStickerSetID      JSONInt64       `json:"custom_emoji_sticker_set_id"`      // Identifier of the custom emoji sticker set that can be used in the supergroup without Telegram Premium subscription; 0 if none
	Location                     *ChatLocation   `json:"location"`                         // Location to which the supergroup is connected; may be null if none
	InviteLink                   *ChatInviteLink `json:"invite_link"`                      // Primary invite link for the chat; may be null. For chat administrators with can_invite_users right only
	BotCommands                  []BotCommands   `json:"bot_commands"`                     // List of commands of bots in the group
	UpgradedFromBasicGroupID     int64           `json:"upgraded_from_basic_group_id"`     // Identifier of the basic group from which supergroup was upgraded; 0 if none
	UpgradedFromMaxMessageID     int64           `json:"upgraded_from_max_message_id"`     // Identifier of the last message in the basic group from which supergroup was upgraded; 0 if none
}

// MessageType return the string telegram-type of SupergroupFullInfo
func (supergroupFullInfo *SupergroupFullInfo) MessageType() string {
	return "supergroupFullInfo"
}

// NewSupergroupFullInfo creates a new SupergroupFullInfo
//
// @param photo Chat photo; may be null if empty or unknown. If non-null, then it is the same photo as in chat.photo
// @param description Supergroup or channel description
// @param memberCount Number of members in the supergroup or channel; 0 if unknown
// @param administratorCount Number of privileged users in the supergroup or channel; 0 if unknown
// @param restrictedCount Number of restricted users in the supergroup; 0 if unknown
// @param bannedCount Number of users banned from chat; 0 if unknown
// @param linkedChatID Chat identifier of a discussion group for the channel, or a channel, for which the supergroup is the designated discussion group; 0 if none or unknown
// @param slowModeDelay Delay between consecutive sent messages for non-administrator supergroup members, in seconds
// @param slowModeDelayExpiresIn Time left before next message can be sent in the supergroup, in seconds. An updateSupergroupFullInfo update is not triggered when value of this field changes, but both new and old values are non-zero
// @param canEnablePaidReaction True, if paid reaction can be enabled in the channel chat; for channels only
// @param canGetMembers True, if members of the chat can be retrieved via getSupergroupMembers or searchChatMembers
// @param hasHiddenMembers True, if non-administrators can receive only administrators and bots using getSupergroupMembers or searchChatMembers
// @param canHideMembers True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers and searchChatMembers for non-administrators
// @param canSetStickerSet True, if the supergroup sticker set can be changed
// @param canSetLocation True, if the supergroup location can be changed
// @param canGetStatistics True, if the supergroup or channel statistics are available
// @param canGetRevenueStatistics True, if the supergroup or channel revenue statistics are available
// @param canGetStarRevenueStatistics True, if the supergroup or channel Telegram Star revenue statistics are available
// @param canToggleAggressiveAntiSpam True, if aggressive anti-spam checks can be enabled or disabled in the supergroup
// @param isAllHistoryAvailable True, if new chat members will have access to old messages. In public, discussion, of forum groups and all channels, old messages are always available, so this option affects only private non-forum supergroups without a linked chat. The value of this field is only available to chat administrators
// @param canHaveSponsoredMessages True, if the chat can have sponsored messages. The value of this field is only available to the owner of the chat
// @param hasAggressiveAntiSpamEnabled True, if aggressive anti-spam checks are enabled in the supergroup. The value of this field is only available to chat administrators
// @param hasPaidMediaAllowed True, if paid media can be sent and forwarded to the channel chat; for channels only
// @param hasPinnedStories True, if the supergroup or channel has pinned stories
// @param myBoostCount Number of times the current user boosted the supergroup or channel
// @param unrestrictBoostCount Number of times the supergroup must be boosted by a user to ignore slow mode and chat permission restrictions; 0 if unspecified
// @param stickerSetID Identifier of the supergroup sticker set that must be shown before user sticker sets; 0 if none
// @param customEmojiStickerSetID Identifier of the custom emoji sticker set that can be used in the supergroup without Telegram Premium subscription; 0 if none
// @param location Location to which the supergroup is connected; may be null if none
// @param inviteLink Primary invite link for the chat; may be null. For chat administrators with can_invite_users right only
// @param botCommands List of commands of bots in the group
// @param upgradedFromBasicGroupID Identifier of the basic group from which supergroup was upgraded; 0 if none
// @param upgradedFromMaxMessageID Identifier of the last message in the basic group from which supergroup was upgraded; 0 if none
func NewSupergroupFullInfo(photo *ChatPhoto, description string, memberCount int32, administratorCount int32, restrictedCount int32, bannedCount int32, linkedChatID int64, slowModeDelay int32, slowModeDelayExpiresIn float64, canEnablePaidReaction bool, canGetMembers bool, hasHiddenMembers bool, canHideMembers bool, canSetStickerSet bool, canSetLocation bool, canGetStatistics bool, canGetRevenueStatistics bool, canGetStarRevenueStatistics bool, canToggleAggressiveAntiSpam bool, isAllHistoryAvailable bool, canHaveSponsoredMessages bool, hasAggressiveAntiSpamEnabled bool, hasPaidMediaAllowed bool, hasPinnedStories bool, myBoostCount int32, unrestrictBoostCount int32, stickerSetID JSONInt64, customEmojiStickerSetID JSONInt64, location *ChatLocation, inviteLink *ChatInviteLink, botCommands []BotCommands, upgradedFromBasicGroupID int64, upgradedFromMaxMessageID int64) *SupergroupFullInfo {
	supergroupFullInfoTemp := SupergroupFullInfo{
		tdCommon:                     tdCommon{Type: "supergroupFullInfo"},
		Photo:                        photo,
		Description:                  description,
		MemberCount:                  memberCount,
		AdministratorCount:           administratorCount,
		RestrictedCount:              restrictedCount,
		BannedCount:                  bannedCount,
		LinkedChatID:                 linkedChatID,
		SlowModeDelay:                slowModeDelay,
		SlowModeDelayExpiresIn:       slowModeDelayExpiresIn,
		CanEnablePaidReaction:        canEnablePaidReaction,
		CanGetMembers:                canGetMembers,
		HasHiddenMembers:             hasHiddenMembers,
		CanHideMembers:               canHideMembers,
		CanSetStickerSet:             canSetStickerSet,
		CanSetLocation:               canSetLocation,
		CanGetStatistics:             canGetStatistics,
		CanGetRevenueStatistics:      canGetRevenueStatistics,
		CanGetStarRevenueStatistics:  canGetStarRevenueStatistics,
		CanToggleAggressiveAntiSpam:  canToggleAggressiveAntiSpam,
		IsAllHistoryAvailable:        isAllHistoryAvailable,
		CanHaveSponsoredMessages:     canHaveSponsoredMessages,
		HasAggressiveAntiSpamEnabled: hasAggressiveAntiSpamEnabled,
		HasPaidMediaAllowed:          hasPaidMediaAllowed,
		HasPinnedStories:             hasPinnedStories,
		MyBoostCount:                 myBoostCount,
		UnrestrictBoostCount:         unrestrictBoostCount,
		StickerSetID:                 stickerSetID,
		CustomEmojiStickerSetID:      customEmojiStickerSetID,
		Location:                     location,
		InviteLink:                   inviteLink,
		BotCommands:                  botCommands,
		UpgradedFromBasicGroupID:     upgradedFromBasicGroupID,
		UpgradedFromMaxMessageID:     upgradedFromMaxMessageID,
	}

	return &supergroupFullInfoTemp
}

// UnmarshalJSON unmarshal to json
func (supergroupFullInfo *SupergroupFullInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Photo                        *ChatPhoto      `json:"photo"`                            // Chat photo; may be null if empty or unknown. If non-null, then it is the same photo as in chat.photo
		Description                  string          `json:"description"`                      // Supergroup or channel description
		MemberCount                  int32           `json:"member_count"`                     // Number of members in the supergroup or channel; 0 if unknown
		AdministratorCount           int32           `json:"administrator_count"`              // Number of privileged users in the supergroup or channel; 0 if unknown
		RestrictedCount              int32           `json:"restricted_count"`                 // Number of restricted users in the supergroup; 0 if unknown
		BannedCount                  int32           `json:"banned_count"`                     // Number of users banned from chat; 0 if unknown
		LinkedChatID                 int64           `json:"linked_chat_id"`                   // Chat identifier of a discussion group for the channel, or a channel, for which the supergroup is the designated discussion group; 0 if none or unknown
		SlowModeDelay                int32           `json:"slow_mode_delay"`                  // Delay between consecutive sent messages for non-administrator supergroup members, in seconds
		SlowModeDelayExpiresIn       float64         `json:"slow_mode_delay_expires_in"`       // Time left before next message can be sent in the supergroup, in seconds. An updateSupergroupFullInfo update is not triggered when value of this field changes, but both new and old values are non-zero
		CanEnablePaidReaction        bool            `json:"can_enable_paid_reaction"`         // True, if paid reaction can be enabled in the channel chat; for channels only
		CanGetMembers                bool            `json:"can_get_members"`                  // True, if members of the chat can be retrieved via getSupergroupMembers or searchChatMembers
		HasHiddenMembers             bool            `json:"has_hidden_members"`               // True, if non-administrators can receive only administrators and bots using getSupergroupMembers or searchChatMembers
		CanHideMembers               bool            `json:"can_hide_members"`                 // True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers and searchChatMembers for non-administrators
		CanSetStickerSet             bool            `json:"can_set_sticker_set"`              // True, if the supergroup sticker set can be changed
		CanSetLocation               bool            `json:"can_set_location"`                 // True, if the supergroup location can be changed
		CanGetStatistics             bool            `json:"can_get_statistics"`               // True, if the supergroup or channel statistics are available
		CanGetRevenueStatistics      bool            `json:"can_get_revenue_statistics"`       // True, if the supergroup or channel revenue statistics are available
		CanGetStarRevenueStatistics  bool            `json:"can_get_star_revenue_statistics"`  // True, if the supergroup or channel Telegram Star revenue statistics are available
		CanToggleAggressiveAntiSpam  bool            `json:"can_toggle_aggressive_anti_spam"`  // True, if aggressive anti-spam checks can be enabled or disabled in the supergroup
		IsAllHistoryAvailable        bool            `json:"is_all_history_available"`         // True, if new chat members will have access to old messages. In public, discussion, of forum groups and all channels, old messages are always available, so this option affects only private non-forum supergroups without a linked chat. The value of this field is only available to chat administrators
		CanHaveSponsoredMessages     bool            `json:"can_have_sponsored_messages"`      // True, if the chat can have sponsored messages. The value of this field is only available to the owner of the chat
		HasAggressiveAntiSpamEnabled bool            `json:"has_aggressive_anti_spam_enabled"` // True, if aggressive anti-spam checks are enabled in the supergroup. The value of this field is only available to chat administrators
		HasPaidMediaAllowed          bool            `json:"has_paid_media_allowed"`           // True, if paid media can be sent and forwarded to the channel chat; for channels only
		HasPinnedStories             bool            `json:"has_pinned_stories"`               // True, if the supergroup or channel has pinned stories
		MyBoostCount                 int32           `json:"my_boost_count"`                   // Number of times the current user boosted the supergroup or channel
		UnrestrictBoostCount         int32           `json:"unrestrict_boost_count"`           // Number of times the supergroup must be boosted by a user to ignore slow mode and chat permission restrictions; 0 if unspecified
		StickerSetID                 JSONInt64       `json:"sticker_set_id"`                   // Identifier of the supergroup sticker set that must be shown before user sticker sets; 0 if none
		CustomEmojiStickerSetID      JSONInt64       `json:"custom_emoji_sticker_set_id"`      // Identifier of the custom emoji sticker set that can be used in the supergroup without Telegram Premium subscription; 0 if none
		Location                     *ChatLocation   `json:"location"`                         // Location to which the supergroup is connected; may be null if none
		InviteLink                   *ChatInviteLink `json:"invite_link"`                      // Primary invite link for the chat; may be null. For chat administrators with can_invite_users right only
		BotCommands                  []BotCommands   `json:"bot_commands"`                     // List of commands of bots in the group
		UpgradedFromBasicGroupID     int64           `json:"upgraded_from_basic_group_id"`     // Identifier of the basic group from which supergroup was upgraded; 0 if none
		UpgradedFromMaxMessageID     int64           `json:"upgraded_from_max_message_id"`     // Identifier of the last message in the basic group from which supergroup was upgraded; 0 if none
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	supergroupFullInfo.tdCommon = tempObj.tdCommon
	supergroupFullInfo.Photo = tempObj.Photo
	supergroupFullInfo.Description = tempObj.Description
	supergroupFullInfo.MemberCount = tempObj.MemberCount
	supergroupFullInfo.AdministratorCount = tempObj.AdministratorCount
	supergroupFullInfo.RestrictedCount = tempObj.RestrictedCount
	supergroupFullInfo.BannedCount = tempObj.BannedCount
	supergroupFullInfo.LinkedChatID = tempObj.LinkedChatID
	supergroupFullInfo.SlowModeDelay = tempObj.SlowModeDelay
	supergroupFullInfo.SlowModeDelayExpiresIn = tempObj.SlowModeDelayExpiresIn
	supergroupFullInfo.CanEnablePaidReaction = tempObj.CanEnablePaidReaction
	supergroupFullInfo.CanGetMembers = tempObj.CanGetMembers
	supergroupFullInfo.HasHiddenMembers = tempObj.HasHiddenMembers
	supergroupFullInfo.CanHideMembers = tempObj.CanHideMembers
	supergroupFullInfo.CanSetStickerSet = tempObj.CanSetStickerSet
	supergroupFullInfo.CanSetLocation = tempObj.CanSetLocation
	supergroupFullInfo.CanGetStatistics = tempObj.CanGetStatistics
	supergroupFullInfo.CanGetRevenueStatistics = tempObj.CanGetRevenueStatistics
	supergroupFullInfo.CanGetStarRevenueStatistics = tempObj.CanGetStarRevenueStatistics
	supergroupFullInfo.CanToggleAggressiveAntiSpam = tempObj.CanToggleAggressiveAntiSpam
	supergroupFullInfo.IsAllHistoryAvailable = tempObj.IsAllHistoryAvailable
	supergroupFullInfo.CanHaveSponsoredMessages = tempObj.CanHaveSponsoredMessages
	supergroupFullInfo.HasAggressiveAntiSpamEnabled = tempObj.HasAggressiveAntiSpamEnabled
	supergroupFullInfo.HasPaidMediaAllowed = tempObj.HasPaidMediaAllowed
	supergroupFullInfo.HasPinnedStories = tempObj.HasPinnedStories
	supergroupFullInfo.MyBoostCount = tempObj.MyBoostCount
	supergroupFullInfo.UnrestrictBoostCount = tempObj.UnrestrictBoostCount
	supergroupFullInfo.StickerSetID = tempObj.StickerSetID
	supergroupFullInfo.CustomEmojiStickerSetID = tempObj.CustomEmojiStickerSetID
	supergroupFullInfo.Location = tempObj.Location
	supergroupFullInfo.InviteLink = tempObj.InviteLink
	supergroupFullInfo.BotCommands = tempObj.BotCommands
	supergroupFullInfo.UpgradedFromBasicGroupID = tempObj.UpgradedFromBasicGroupID
	supergroupFullInfo.UpgradedFromMaxMessageID = tempObj.UpgradedFromMaxMessageID

	return nil
}

// SecretChatStatePending The secret chat is not yet created; waiting for the other user to get online
type SecretChatStatePending struct {
	tdCommon
}

// MessageType return the string telegram-type of SecretChatStatePending
func (secretChatStatePending *SecretChatStatePending) MessageType() string {
	return "secretChatStatePending"
}

// NewSecretChatStatePending creates a new SecretChatStatePending
//
func NewSecretChatStatePending() *SecretChatStatePending {
	secretChatStatePendingTemp := SecretChatStatePending{
		tdCommon: tdCommon{Type: "secretChatStatePending"},
	}

	return &secretChatStatePendingTemp
}

// UnmarshalJSON unmarshal to json
func (secretChatStatePending *SecretChatStatePending) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	secretChatStatePending.tdCommon = tempObj.tdCommon

	return nil
}

// GetSecretChatStateEnum return the enum type of this object
func (secretChatStatePending *SecretChatStatePending) GetSecretChatStateEnum() SecretChatStateEnum {
	return SecretChatStatePendingType
}

// SecretChatStateReady The secret chat is ready to use
type SecretChatStateReady struct {
	tdCommon
}

// MessageType return the string telegram-type of SecretChatStateReady
func (secretChatStateReady *SecretChatStateReady) MessageType() string {
	return "secretChatStateReady"
}

// NewSecretChatStateReady creates a new SecretChatStateReady
//
func NewSecretChatStateReady() *SecretChatStateReady {
	secretChatStateReadyTemp := SecretChatStateReady{
		tdCommon: tdCommon{Type: "secretChatStateReady"},
	}

	return &secretChatStateReadyTemp
}

// UnmarshalJSON unmarshal to json
func (secretChatStateReady *SecretChatStateReady) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	secretChatStateReady.tdCommon = tempObj.tdCommon

	return nil
}

// GetSecretChatStateEnum return the enum type of this object
func (secretChatStateReady *SecretChatStateReady) GetSecretChatStateEnum() SecretChatStateEnum {
	return SecretChatStateReadyType
}

// SecretChatStateClosed The secret chat is closed
type SecretChatStateClosed struct {
	tdCommon
}

// MessageType return the string telegram-type of SecretChatStateClosed
func (secretChatStateClosed *SecretChatStateClosed) MessageType() string {
	return "secretChatStateClosed"
}

// NewSecretChatStateClosed creates a new SecretChatStateClosed
//
func NewSecretChatStateClosed() *SecretChatStateClosed {
	secretChatStateClosedTemp := SecretChatStateClosed{
		tdCommon: tdCommon{Type: "secretChatStateClosed"},
	}

	return &secretChatStateClosedTemp
}

// UnmarshalJSON unmarshal to json
func (secretChatStateClosed *SecretChatStateClosed) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	secretChatStateClosed.tdCommon = tempObj.tdCommon

	return nil
}

// GetSecretChatStateEnum return the enum type of this object
func (secretChatStateClosed *SecretChatStateClosed) GetSecretChatStateEnum() SecretChatStateEnum {
	return SecretChatStateClosedType
}

// SecretChat Represents a secret chat
type SecretChat struct {
	tdCommon
	ID         int32           `json:"id"`          // Secret chat identifier
	UserID     int64           `json:"user_id"`     // Identifier of the chat partner
	State      SecretChatState `json:"state"`       // State of the secret chat
	IsOutbound bool            `json:"is_outbound"` // True, if the chat was created by the current user; false otherwise
	KeyHash    []byte          `json:"key_hash"`    // Hash of the currently used key for comparison with the hash of the chat partner's key. This is a string of 36 little-endian bytes, which must be split into groups of 2 bits, each denoting a pixel of one of 4 colors FFFFFF, D5E6F3, 2D5775, and 2F99C9. The pixels must be used to make a 12x12 square image filled from left to right, top to bottom. Alternatively, the first 32 bytes of the hash can be converted to the hexadecimal format and printed as 32 2-digit hex numbers
	Layer      int32           `json:"layer"`       // Secret chat layer; determines features supported by the chat partner's application. Nested text entities and underline and strikethrough entities are supported if the layer >= 101, files bigger than 2000MB are supported if the layer >= 143, spoiler and custom emoji text entities are supported if the layer >= 144
}

// MessageType return the string telegram-type of SecretChat
func (secretChat *SecretChat) MessageType() string {
	return "secretChat"
}

// NewSecretChat creates a new SecretChat
//
// @param iD Secret chat identifier
// @param userID Identifier of the chat partner
// @param state State of the secret chat
// @param isOutbound True, if the chat was created by the current user; false otherwise
// @param keyHash Hash of the currently used key for comparison with the hash of the chat partner's key. This is a string of 36 little-endian bytes, which must be split into groups of 2 bits, each denoting a pixel of one of 4 colors FFFFFF, D5E6F3, 2D5775, and 2F99C9. The pixels must be used to make a 12x12 square image filled from left to right, top to bottom. Alternatively, the first 32 bytes of the hash can be converted to the hexadecimal format and printed as 32 2-digit hex numbers
// @param layer Secret chat layer; determines features supported by the chat partner's application. Nested text entities and underline and strikethrough entities are supported if the layer >= 101, files bigger than 2000MB are supported if the layer >= 143, spoiler and custom emoji text entities are supported if the layer >= 144
func NewSecretChat(iD int32, userID int64, state SecretChatState, isOutbound bool, keyHash []byte, layer int32) *SecretChat {
	secretChatTemp := SecretChat{
		tdCommon:   tdCommon{Type: "secretChat"},
		ID:         iD,
		UserID:     userID,
		State:      state,
		IsOutbound: isOutbound,
		KeyHash:    keyHash,
		Layer:      layer,
	}

	return &secretChatTemp
}

// UnmarshalJSON unmarshal to json
func (secretChat *SecretChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID         int32  `json:"id"`          // Secret chat identifier
		UserID     int64  `json:"user_id"`     // Identifier of the chat partner
		IsOutbound bool   `json:"is_outbound"` // True, if the chat was created by the current user; false otherwise
		KeyHash    []byte `json:"key_hash"`    // Hash of the currently used key for comparison with the hash of the chat partner's key. This is a string of 36 little-endian bytes, which must be split into groups of 2 bits, each denoting a pixel of one of 4 colors FFFFFF, D5E6F3, 2D5775, and 2F99C9. The pixels must be used to make a 12x12 square image filled from left to right, top to bottom. Alternatively, the first 32 bytes of the hash can be converted to the hexadecimal format and printed as 32 2-digit hex numbers
		Layer      int32  `json:"layer"`       // Secret chat layer; determines features supported by the chat partner's application. Nested text entities and underline and strikethrough entities are supported if the layer >= 101, files bigger than 2000MB are supported if the layer >= 143, spoiler and custom emoji text entities are supported if the layer >= 144
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	secretChat.tdCommon = tempObj.tdCommon
	secretChat.ID = tempObj.ID
	secretChat.UserID = tempObj.UserID
	secretChat.IsOutbound = tempObj.IsOutbound
	secretChat.KeyHash = tempObj.KeyHash
	secretChat.Layer = tempObj.Layer

	fieldState, _ := unmarshalSecretChatState(objMap["state"])
	secretChat.State = fieldState

	return nil
}

// MessageSenderUser The message was sent by a known user
type MessageSenderUser struct {
	tdCommon
	UserID int64 `json:"user_id"` // Identifier of the user that sent the message
}

// MessageType return the string telegram-type of MessageSenderUser
func (messageSenderUser *MessageSenderUser) MessageType() string {
	return "messageSenderUser"
}

// NewMessageSenderUser creates a new MessageSenderUser
//
// @param userID Identifier of the user that sent the message
func NewMessageSenderUser(userID int64) *MessageSenderUser {
	messageSenderUserTemp := MessageSenderUser{
		tdCommon: tdCommon{Type: "messageSenderUser"},
		UserID:   userID,
	}

	return &messageSenderUserTemp
}

// UnmarshalJSON unmarshal to json
func (messageSenderUser *MessageSenderUser) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID int64 `json:"user_id"` // Identifier of the user that sent the message
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSenderUser.tdCommon = tempObj.tdCommon
	messageSenderUser.UserID = tempObj.UserID

	return nil
}

// GetMessageSenderEnum return the enum type of this object
func (messageSenderUser *MessageSenderUser) GetMessageSenderEnum() MessageSenderEnum {
	return MessageSenderUserType
}

// MessageSenderChat The message was sent on behalf of a chat
type MessageSenderChat struct {
	tdCommon
	ChatID int64 `json:"chat_id"` // Identifier of the chat that sent the message
}

// MessageType return the string telegram-type of MessageSenderChat
func (messageSenderChat *MessageSenderChat) MessageType() string {
	return "messageSenderChat"
}

// NewMessageSenderChat creates a new MessageSenderChat
//
// @param chatID Identifier of the chat that sent the message
func NewMessageSenderChat(chatID int64) *MessageSenderChat {
	messageSenderChatTemp := MessageSenderChat{
		tdCommon: tdCommon{Type: "messageSenderChat"},
		ChatID:   chatID,
	}

	return &messageSenderChatTemp
}

// UnmarshalJSON unmarshal to json
func (messageSenderChat *MessageSenderChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID int64 `json:"chat_id"` // Identifier of the chat that sent the message
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSenderChat.tdCommon = tempObj.tdCommon
	messageSenderChat.ChatID = tempObj.ChatID

	return nil
}

// GetMessageSenderEnum return the enum type of this object
func (messageSenderChat *MessageSenderChat) GetMessageSenderEnum() MessageSenderEnum {
	return MessageSenderChatType
}

// MessageSenders Represents a list of message senders
type MessageSenders struct {
	tdCommon
	TotalCount int32           `json:"total_count"` // Approximate total number of messages senders found
	Senders    []MessageSender `json:"senders"`     // List of message senders
}

// MessageType return the string telegram-type of MessageSenders
func (messageSenders *MessageSenders) MessageType() string {
	return "messageSenders"
}

// NewMessageSenders creates a new MessageSenders
//
// @param totalCount Approximate total number of messages senders found
// @param senders List of message senders
func NewMessageSenders(totalCount int32, senders []MessageSender) *MessageSenders {
	messageSendersTemp := MessageSenders{
		tdCommon:   tdCommon{Type: "messageSenders"},
		TotalCount: totalCount,
		Senders:    senders,
	}

	return &messageSendersTemp
}

// UnmarshalJSON unmarshal to json
func (messageSenders *MessageSenders) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32 `json:"total_count"` // Approximate total number of messages senders found

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSenders.tdCommon = tempObj.tdCommon
	messageSenders.TotalCount = tempObj.TotalCount

	fieldSenders, _ := unmarshalMessageSenderSlice(objMap["senders"])
	messageSenders.Senders = fieldSenders

	return nil
}

// ChatMessageSender Represents a message sender, which can be used to send messages in a chat
type ChatMessageSender struct {
	tdCommon
	Sender       MessageSender `json:"sender"`        // The message sender
	NeedsPremium bool          `json:"needs_premium"` // True, if Telegram Premium is needed to use the message sender
}

// MessageType return the string telegram-type of ChatMessageSender
func (chatMessageSender *ChatMessageSender) MessageType() string {
	return "chatMessageSender"
}

// NewChatMessageSender creates a new ChatMessageSender
//
// @param sender The message sender
// @param needsPremium True, if Telegram Premium is needed to use the message sender
func NewChatMessageSender(sender MessageSender, needsPremium bool) *ChatMessageSender {
	chatMessageSenderTemp := ChatMessageSender{
		tdCommon:     tdCommon{Type: "chatMessageSender"},
		Sender:       sender,
		NeedsPremium: needsPremium,
	}

	return &chatMessageSenderTemp
}

// UnmarshalJSON unmarshal to json
func (chatMessageSender *ChatMessageSender) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		NeedsPremium bool `json:"needs_premium"` // True, if Telegram Premium is needed to use the message sender
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatMessageSender.tdCommon = tempObj.tdCommon
	chatMessageSender.NeedsPremium = tempObj.NeedsPremium

	fieldSender, _ := unmarshalMessageSender(objMap["sender"])
	chatMessageSender.Sender = fieldSender

	return nil
}

// ChatMessageSenders Represents a list of message senders, which can be used to send messages in a chat
type ChatMessageSenders struct {
	tdCommon
	Senders []ChatMessageSender `json:"senders"` // List of available message senders
}

// MessageType return the string telegram-type of ChatMessageSenders
func (chatMessageSenders *ChatMessageSenders) MessageType() string {
	return "chatMessageSenders"
}

// NewChatMessageSenders creates a new ChatMessageSenders
//
// @param senders List of available message senders
func NewChatMessageSenders(senders []ChatMessageSender) *ChatMessageSenders {
	chatMessageSendersTemp := ChatMessageSenders{
		tdCommon: tdCommon{Type: "chatMessageSenders"},
		Senders:  senders,
	}

	return &chatMessageSendersTemp
}

// UnmarshalJSON unmarshal to json
func (chatMessageSenders *ChatMessageSenders) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Senders []ChatMessageSender `json:"senders"` // List of available message senders
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatMessageSenders.tdCommon = tempObj.tdCommon
	chatMessageSenders.Senders = tempObj.Senders

	return nil
}

// MessageReadDateRead Contains read date of the message
type MessageReadDateRead struct {
	tdCommon
	ReadDate int32 `json:"read_date"` // Point in time (Unix timestamp) when the message was read by the other user
}

// MessageType return the string telegram-type of MessageReadDateRead
func (messageReadDateRead *MessageReadDateRead) MessageType() string {
	return "messageReadDateRead"
}

// NewMessageReadDateRead creates a new MessageReadDateRead
//
// @param readDate Point in time (Unix timestamp) when the message was read by the other user
func NewMessageReadDateRead(readDate int32) *MessageReadDateRead {
	messageReadDateReadTemp := MessageReadDateRead{
		tdCommon: tdCommon{Type: "messageReadDateRead"},
		ReadDate: readDate,
	}

	return &messageReadDateReadTemp
}

// UnmarshalJSON unmarshal to json
func (messageReadDateRead *MessageReadDateRead) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ReadDate int32 `json:"read_date"` // Point in time (Unix timestamp) when the message was read by the other user
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageReadDateRead.tdCommon = tempObj.tdCommon
	messageReadDateRead.ReadDate = tempObj.ReadDate

	return nil
}

// GetMessageReadDateEnum return the enum type of this object
func (messageReadDateRead *MessageReadDateRead) GetMessageReadDateEnum() MessageReadDateEnum {
	return MessageReadDateReadType
}

// MessageReadDateUnread The message is unread yet
type MessageReadDateUnread struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageReadDateUnread
func (messageReadDateUnread *MessageReadDateUnread) MessageType() string {
	return "messageReadDateUnread"
}

// NewMessageReadDateUnread creates a new MessageReadDateUnread
//
func NewMessageReadDateUnread() *MessageReadDateUnread {
	messageReadDateUnreadTemp := MessageReadDateUnread{
		tdCommon: tdCommon{Type: "messageReadDateUnread"},
	}

	return &messageReadDateUnreadTemp
}

// UnmarshalJSON unmarshal to json
func (messageReadDateUnread *MessageReadDateUnread) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageReadDateUnread.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageReadDateEnum return the enum type of this object
func (messageReadDateUnread *MessageReadDateUnread) GetMessageReadDateEnum() MessageReadDateEnum {
	return MessageReadDateUnreadType
}

// MessageReadDateTooOld The message is too old to get read date
type MessageReadDateTooOld struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageReadDateTooOld
func (messageReadDateTooOld *MessageReadDateTooOld) MessageType() string {
	return "messageReadDateTooOld"
}

// NewMessageReadDateTooOld creates a new MessageReadDateTooOld
//
func NewMessageReadDateTooOld() *MessageReadDateTooOld {
	messageReadDateTooOldTemp := MessageReadDateTooOld{
		tdCommon: tdCommon{Type: "messageReadDateTooOld"},
	}

	return &messageReadDateTooOldTemp
}

// UnmarshalJSON unmarshal to json
func (messageReadDateTooOld *MessageReadDateTooOld) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageReadDateTooOld.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageReadDateEnum return the enum type of this object
func (messageReadDateTooOld *MessageReadDateTooOld) GetMessageReadDateEnum() MessageReadDateEnum {
	return MessageReadDateTooOldType
}

// MessageReadDateUserPrivacyRestricted The read date is unknown due to privacy settings of the other user
type MessageReadDateUserPrivacyRestricted struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageReadDateUserPrivacyRestricted
func (messageReadDateUserPrivacyRestricted *MessageReadDateUserPrivacyRestricted) MessageType() string {
	return "messageReadDateUserPrivacyRestricted"
}

// NewMessageReadDateUserPrivacyRestricted creates a new MessageReadDateUserPrivacyRestricted
//
func NewMessageReadDateUserPrivacyRestricted() *MessageReadDateUserPrivacyRestricted {
	messageReadDateUserPrivacyRestrictedTemp := MessageReadDateUserPrivacyRestricted{
		tdCommon: tdCommon{Type: "messageReadDateUserPrivacyRestricted"},
	}

	return &messageReadDateUserPrivacyRestrictedTemp
}

// UnmarshalJSON unmarshal to json
func (messageReadDateUserPrivacyRestricted *MessageReadDateUserPrivacyRestricted) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageReadDateUserPrivacyRestricted.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageReadDateEnum return the enum type of this object
func (messageReadDateUserPrivacyRestricted *MessageReadDateUserPrivacyRestricted) GetMessageReadDateEnum() MessageReadDateEnum {
	return MessageReadDateUserPrivacyRestrictedType
}

// MessageReadDateMyPrivacyRestricted The read date is unknown due to privacy settings of the current user, but will be known if the user subscribes to Telegram Premium
type MessageReadDateMyPrivacyRestricted struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageReadDateMyPrivacyRestricted
func (messageReadDateMyPrivacyRestricted *MessageReadDateMyPrivacyRestricted) MessageType() string {
	return "messageReadDateMyPrivacyRestricted"
}

// NewMessageReadDateMyPrivacyRestricted creates a new MessageReadDateMyPrivacyRestricted
//
func NewMessageReadDateMyPrivacyRestricted() *MessageReadDateMyPrivacyRestricted {
	messageReadDateMyPrivacyRestrictedTemp := MessageReadDateMyPrivacyRestricted{
		tdCommon: tdCommon{Type: "messageReadDateMyPrivacyRestricted"},
	}

	return &messageReadDateMyPrivacyRestrictedTemp
}

// UnmarshalJSON unmarshal to json
func (messageReadDateMyPrivacyRestricted *MessageReadDateMyPrivacyRestricted) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageReadDateMyPrivacyRestricted.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageReadDateEnum return the enum type of this object
func (messageReadDateMyPrivacyRestricted *MessageReadDateMyPrivacyRestricted) GetMessageReadDateEnum() MessageReadDateEnum {
	return MessageReadDateMyPrivacyRestrictedType
}

// MessageViewer Represents a viewer of a message
type MessageViewer struct {
	tdCommon
	UserID   int64 `json:"user_id"`   // User identifier of the viewer
	ViewDate int32 `json:"view_date"` // Approximate point in time (Unix timestamp) when the message was viewed
}

// MessageType return the string telegram-type of MessageViewer
func (messageViewer *MessageViewer) MessageType() string {
	return "messageViewer"
}

// NewMessageViewer creates a new MessageViewer
//
// @param userID User identifier of the viewer
// @param viewDate Approximate point in time (Unix timestamp) when the message was viewed
func NewMessageViewer(userID int64, viewDate int32) *MessageViewer {
	messageViewerTemp := MessageViewer{
		tdCommon: tdCommon{Type: "messageViewer"},
		UserID:   userID,
		ViewDate: viewDate,
	}

	return &messageViewerTemp
}

// UnmarshalJSON unmarshal to json
func (messageViewer *MessageViewer) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID   int64 `json:"user_id"`   // User identifier of the viewer
		ViewDate int32 `json:"view_date"` // Approximate point in time (Unix timestamp) when the message was viewed
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageViewer.tdCommon = tempObj.tdCommon
	messageViewer.UserID = tempObj.UserID
	messageViewer.ViewDate = tempObj.ViewDate

	return nil
}

// MessageViewers Represents a list of message viewers
type MessageViewers struct {
	tdCommon
	Viewers []MessageViewer `json:"viewers"` // List of message viewers
}

// MessageType return the string telegram-type of MessageViewers
func (messageViewers *MessageViewers) MessageType() string {
	return "messageViewers"
}

// NewMessageViewers creates a new MessageViewers
//
// @param viewers List of message viewers
func NewMessageViewers(viewers []MessageViewer) *MessageViewers {
	messageViewersTemp := MessageViewers{
		tdCommon: tdCommon{Type: "messageViewers"},
		Viewers:  viewers,
	}

	return &messageViewersTemp
}

// UnmarshalJSON unmarshal to json
func (messageViewers *MessageViewers) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Viewers []MessageViewer `json:"viewers"` // List of message viewers
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageViewers.tdCommon = tempObj.tdCommon
	messageViewers.Viewers = tempObj.Viewers

	return nil
}

// MessageOriginUser The message was originally sent by a known user
type MessageOriginUser struct {
	tdCommon
	SenderUserID int64 `json:"sender_user_id"` // Identifier of the user that originally sent the message
}

// MessageType return the string telegram-type of MessageOriginUser
func (messageOriginUser *MessageOriginUser) MessageType() string {
	return "messageOriginUser"
}

// NewMessageOriginUser creates a new MessageOriginUser
//
// @param senderUserID Identifier of the user that originally sent the message
func NewMessageOriginUser(senderUserID int64) *MessageOriginUser {
	messageOriginUserTemp := MessageOriginUser{
		tdCommon:     tdCommon{Type: "messageOriginUser"},
		SenderUserID: senderUserID,
	}

	return &messageOriginUserTemp
}

// UnmarshalJSON unmarshal to json
func (messageOriginUser *MessageOriginUser) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SenderUserID int64 `json:"sender_user_id"` // Identifier of the user that originally sent the message
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageOriginUser.tdCommon = tempObj.tdCommon
	messageOriginUser.SenderUserID = tempObj.SenderUserID

	return nil
}

// GetMessageOriginEnum return the enum type of this object
func (messageOriginUser *MessageOriginUser) GetMessageOriginEnum() MessageOriginEnum {
	return MessageOriginUserType
}

// MessageOriginHiddenUser The message was originally sent by a user, which is hidden by their privacy settings
type MessageOriginHiddenUser struct {
	tdCommon
	SenderName string `json:"sender_name"` // Name of the sender
}

// MessageType return the string telegram-type of MessageOriginHiddenUser
func (messageOriginHiddenUser *MessageOriginHiddenUser) MessageType() string {
	return "messageOriginHiddenUser"
}

// NewMessageOriginHiddenUser creates a new MessageOriginHiddenUser
//
// @param senderName Name of the sender
func NewMessageOriginHiddenUser(senderName string) *MessageOriginHiddenUser {
	messageOriginHiddenUserTemp := MessageOriginHiddenUser{
		tdCommon:   tdCommon{Type: "messageOriginHiddenUser"},
		SenderName: senderName,
	}

	return &messageOriginHiddenUserTemp
}

// UnmarshalJSON unmarshal to json
func (messageOriginHiddenUser *MessageOriginHiddenUser) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SenderName string `json:"sender_name"` // Name of the sender
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageOriginHiddenUser.tdCommon = tempObj.tdCommon
	messageOriginHiddenUser.SenderName = tempObj.SenderName

	return nil
}

// GetMessageOriginEnum return the enum type of this object
func (messageOriginHiddenUser *MessageOriginHiddenUser) GetMessageOriginEnum() MessageOriginEnum {
	return MessageOriginHiddenUserType
}

// MessageOriginChat The message was originally sent on behalf of a chat
type MessageOriginChat struct {
	tdCommon
	SenderChatID    int64  `json:"sender_chat_id"`   // Identifier of the chat that originally sent the message
	AuthorSignature string `json:"author_signature"` // For messages originally sent by an anonymous chat administrator, original message author signature
}

// MessageType return the string telegram-type of MessageOriginChat
func (messageOriginChat *MessageOriginChat) MessageType() string {
	return "messageOriginChat"
}

// NewMessageOriginChat creates a new MessageOriginChat
//
// @param senderChatID Identifier of the chat that originally sent the message
// @param authorSignature For messages originally sent by an anonymous chat administrator, original message author signature
func NewMessageOriginChat(senderChatID int64, authorSignature string) *MessageOriginChat {
	messageOriginChatTemp := MessageOriginChat{
		tdCommon:        tdCommon{Type: "messageOriginChat"},
		SenderChatID:    senderChatID,
		AuthorSignature: authorSignature,
	}

	return &messageOriginChatTemp
}

// UnmarshalJSON unmarshal to json
func (messageOriginChat *MessageOriginChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SenderChatID    int64  `json:"sender_chat_id"`   // Identifier of the chat that originally sent the message
		AuthorSignature string `json:"author_signature"` // For messages originally sent by an anonymous chat administrator, original message author signature
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageOriginChat.tdCommon = tempObj.tdCommon
	messageOriginChat.SenderChatID = tempObj.SenderChatID
	messageOriginChat.AuthorSignature = tempObj.AuthorSignature

	return nil
}

// GetMessageOriginEnum return the enum type of this object
func (messageOriginChat *MessageOriginChat) GetMessageOriginEnum() MessageOriginEnum {
	return MessageOriginChatType
}

// MessageOriginChannel The message was originally a post in a channel
type MessageOriginChannel struct {
	tdCommon
	ChatID          int64  `json:"chat_id"`          // Identifier of the channel chat to which the message was originally sent
	MessageID       int64  `json:"message_id"`       // Message identifier of the original message
	AuthorSignature string `json:"author_signature"` // Original post author signature
}

// MessageType return the string telegram-type of MessageOriginChannel
func (messageOriginChannel *MessageOriginChannel) MessageType() string {
	return "messageOriginChannel"
}

// NewMessageOriginChannel creates a new MessageOriginChannel
//
// @param chatID Identifier of the channel chat to which the message was originally sent
// @param messageID Message identifier of the original message
// @param authorSignature Original post author signature
func NewMessageOriginChannel(chatID int64, messageID int64, authorSignature string) *MessageOriginChannel {
	messageOriginChannelTemp := MessageOriginChannel{
		tdCommon:        tdCommon{Type: "messageOriginChannel"},
		ChatID:          chatID,
		MessageID:       messageID,
		AuthorSignature: authorSignature,
	}

	return &messageOriginChannelTemp
}

// UnmarshalJSON unmarshal to json
func (messageOriginChannel *MessageOriginChannel) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID          int64  `json:"chat_id"`          // Identifier of the channel chat to which the message was originally sent
		MessageID       int64  `json:"message_id"`       // Message identifier of the original message
		AuthorSignature string `json:"author_signature"` // Original post author signature
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageOriginChannel.tdCommon = tempObj.tdCommon
	messageOriginChannel.ChatID = tempObj.ChatID
	messageOriginChannel.MessageID = tempObj.MessageID
	messageOriginChannel.AuthorSignature = tempObj.AuthorSignature

	return nil
}

// GetMessageOriginEnum return the enum type of this object
func (messageOriginChannel *MessageOriginChannel) GetMessageOriginEnum() MessageOriginEnum {
	return MessageOriginChannelType
}

// ForwardSource Contains information about the last message from which a new message was forwarded last time
type ForwardSource struct {
	tdCommon
	ChatID     int64          `json:"chat_id"`     // Identifier of the chat to which the message that was forwarded belonged; may be 0 if unknown
	MessageID  int64          `json:"message_id"`  // Identifier of the message; may be 0 if unknown
	SenderID   *MessageSender `json:"sender_id"`   // Identifier of the sender of the message; may be null if unknown or the new message was forwarded not to Saved Messages
	SenderName string         `json:"sender_name"` // Name of the sender of the message if the sender is hidden by their privacy settings
	Date       int32          `json:"date"`        // Point in time (Unix timestamp) when the message is sent; 0 if unknown
	IsOutgoing bool           `json:"is_outgoing"` // True, if the message that was forwarded is outgoing; always false if sender is unknown
}

// MessageType return the string telegram-type of ForwardSource
func (forwardSource *ForwardSource) MessageType() string {
	return "forwardSource"
}

// NewForwardSource creates a new ForwardSource
//
// @param chatID Identifier of the chat to which the message that was forwarded belonged; may be 0 if unknown
// @param messageID Identifier of the message; may be 0 if unknown
// @param senderID Identifier of the sender of the message; may be null if unknown or the new message was forwarded not to Saved Messages
// @param senderName Name of the sender of the message if the sender is hidden by their privacy settings
// @param date Point in time (Unix timestamp) when the message is sent; 0 if unknown
// @param isOutgoing True, if the message that was forwarded is outgoing; always false if sender is unknown
func NewForwardSource(chatID int64, messageID int64, senderID *MessageSender, senderName string, date int32, isOutgoing bool) *ForwardSource {
	forwardSourceTemp := ForwardSource{
		tdCommon:   tdCommon{Type: "forwardSource"},
		ChatID:     chatID,
		MessageID:  messageID,
		SenderID:   senderID,
		SenderName: senderName,
		Date:       date,
		IsOutgoing: isOutgoing,
	}

	return &forwardSourceTemp
}

// UnmarshalJSON unmarshal to json
func (forwardSource *ForwardSource) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID     int64  `json:"chat_id"`     // Identifier of the chat to which the message that was forwarded belonged; may be 0 if unknown
		MessageID  int64  `json:"message_id"`  // Identifier of the message; may be 0 if unknown
		SenderName string `json:"sender_name"` // Name of the sender of the message if the sender is hidden by their privacy settings
		Date       int32  `json:"date"`        // Point in time (Unix timestamp) when the message is sent; 0 if unknown
		IsOutgoing bool   `json:"is_outgoing"` // True, if the message that was forwarded is outgoing; always false if sender is unknown
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	forwardSource.tdCommon = tempObj.tdCommon
	forwardSource.ChatID = tempObj.ChatID
	forwardSource.MessageID = tempObj.MessageID
	forwardSource.SenderName = tempObj.SenderName
	forwardSource.Date = tempObj.Date
	forwardSource.IsOutgoing = tempObj.IsOutgoing

	fieldSenderID, _ := unmarshalMessageSender(objMap["sender_id"])
	forwardSource.SenderID = &fieldSenderID

	return nil
}

// ReactionTypeEmoji A reaction with an emoji
type ReactionTypeEmoji struct {
	tdCommon
	Emoji string `json:"emoji"` // Text representation of the reaction
}

// MessageType return the string telegram-type of ReactionTypeEmoji
func (reactionTypeEmoji *ReactionTypeEmoji) MessageType() string {
	return "reactionTypeEmoji"
}

// NewReactionTypeEmoji creates a new ReactionTypeEmoji
//
// @param emoji Text representation of the reaction
func NewReactionTypeEmoji(emoji string) *ReactionTypeEmoji {
	reactionTypeEmojiTemp := ReactionTypeEmoji{
		tdCommon: tdCommon{Type: "reactionTypeEmoji"},
		Emoji:    emoji,
	}

	return &reactionTypeEmojiTemp
}

// UnmarshalJSON unmarshal to json
func (reactionTypeEmoji *ReactionTypeEmoji) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Emoji string `json:"emoji"` // Text representation of the reaction
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reactionTypeEmoji.tdCommon = tempObj.tdCommon
	reactionTypeEmoji.Emoji = tempObj.Emoji

	return nil
}

// GetReactionTypeEnum return the enum type of this object
func (reactionTypeEmoji *ReactionTypeEmoji) GetReactionTypeEnum() ReactionTypeEnum {
	return ReactionTypeEmojiType
}

// ReactionTypeCustomEmoji A reaction with a custom emoji
type ReactionTypeCustomEmoji struct {
	tdCommon
	CustomEmojiID JSONInt64 `json:"custom_emoji_id"` // Unique identifier of the custom emoji
}

// MessageType return the string telegram-type of ReactionTypeCustomEmoji
func (reactionTypeCustomEmoji *ReactionTypeCustomEmoji) MessageType() string {
	return "reactionTypeCustomEmoji"
}

// NewReactionTypeCustomEmoji creates a new ReactionTypeCustomEmoji
//
// @param customEmojiID Unique identifier of the custom emoji
func NewReactionTypeCustomEmoji(customEmojiID JSONInt64) *ReactionTypeCustomEmoji {
	reactionTypeCustomEmojiTemp := ReactionTypeCustomEmoji{
		tdCommon:      tdCommon{Type: "reactionTypeCustomEmoji"},
		CustomEmojiID: customEmojiID,
	}

	return &reactionTypeCustomEmojiTemp
}

// UnmarshalJSON unmarshal to json
func (reactionTypeCustomEmoji *ReactionTypeCustomEmoji) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CustomEmojiID JSONInt64 `json:"custom_emoji_id"` // Unique identifier of the custom emoji
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reactionTypeCustomEmoji.tdCommon = tempObj.tdCommon
	reactionTypeCustomEmoji.CustomEmojiID = tempObj.CustomEmojiID

	return nil
}

// GetReactionTypeEnum return the enum type of this object
func (reactionTypeCustomEmoji *ReactionTypeCustomEmoji) GetReactionTypeEnum() ReactionTypeEnum {
	return ReactionTypeCustomEmojiType
}

// ReactionTypePaid The paid reaction in a channel chat
type ReactionTypePaid struct {
	tdCommon
}

// MessageType return the string telegram-type of ReactionTypePaid
func (reactionTypePaid *ReactionTypePaid) MessageType() string {
	return "reactionTypePaid"
}

// NewReactionTypePaid creates a new ReactionTypePaid
//
func NewReactionTypePaid() *ReactionTypePaid {
	reactionTypePaidTemp := ReactionTypePaid{
		tdCommon: tdCommon{Type: "reactionTypePaid"},
	}

	return &reactionTypePaidTemp
}

// UnmarshalJSON unmarshal to json
func (reactionTypePaid *ReactionTypePaid) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reactionTypePaid.tdCommon = tempObj.tdCommon

	return nil
}

// GetReactionTypeEnum return the enum type of this object
func (reactionTypePaid *ReactionTypePaid) GetReactionTypeEnum() ReactionTypeEnum {
	return ReactionTypePaidType
}

// PaidReactor Contains information about a user that added paid reactions
type PaidReactor struct {
	tdCommon
	SenderID    *MessageSender `json:"sender_id"`    // Identifier of the user or chat that added the reactions; may be null for anonymous reactors that aren't the current user
	StarCount   int32          `json:"star_count"`   // Number of Telegram Stars added
	IsTop       bool           `json:"is_top"`       // True, if the reactor is one of the most active reactors; can be false if the reactor is the current user
	IsMe        bool           `json:"is_me"`        // True, if the paid reaction was added by the current user
	IsAnonymous bool           `json:"is_anonymous"` // True, if the reactor is anonymous
}

// MessageType return the string telegram-type of PaidReactor
func (paidReactor *PaidReactor) MessageType() string {
	return "paidReactor"
}

// NewPaidReactor creates a new PaidReactor
//
// @param senderID Identifier of the user or chat that added the reactions; may be null for anonymous reactors that aren't the current user
// @param starCount Number of Telegram Stars added
// @param isTop True, if the reactor is one of the most active reactors; can be false if the reactor is the current user
// @param isMe True, if the paid reaction was added by the current user
// @param isAnonymous True, if the reactor is anonymous
func NewPaidReactor(senderID *MessageSender, starCount int32, isTop bool, isMe bool, isAnonymous bool) *PaidReactor {
	paidReactorTemp := PaidReactor{
		tdCommon:    tdCommon{Type: "paidReactor"},
		SenderID:    senderID,
		StarCount:   starCount,
		IsTop:       isTop,
		IsMe:        isMe,
		IsAnonymous: isAnonymous,
	}

	return &paidReactorTemp
}

// UnmarshalJSON unmarshal to json
func (paidReactor *PaidReactor) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StarCount   int32 `json:"star_count"`   // Number of Telegram Stars added
		IsTop       bool  `json:"is_top"`       // True, if the reactor is one of the most active reactors; can be false if the reactor is the current user
		IsMe        bool  `json:"is_me"`        // True, if the paid reaction was added by the current user
		IsAnonymous bool  `json:"is_anonymous"` // True, if the reactor is anonymous
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	paidReactor.tdCommon = tempObj.tdCommon
	paidReactor.StarCount = tempObj.StarCount
	paidReactor.IsTop = tempObj.IsTop
	paidReactor.IsMe = tempObj.IsMe
	paidReactor.IsAnonymous = tempObj.IsAnonymous

	fieldSenderID, _ := unmarshalMessageSender(objMap["sender_id"])
	paidReactor.SenderID = &fieldSenderID

	return nil
}

// MessageForwardInfo Contains information about a forwarded message
type MessageForwardInfo struct {
	tdCommon
	Origin                        MessageOrigin  `json:"origin"`                           // Origin of the forwarded message
	Date                          int32          `json:"date"`                             // Point in time (Unix timestamp) when the message was originally sent
	Source                        *ForwardSource `json:"source"`                           // For messages forwarded to the chat with the current user (Saved Messages), to the Replies bot chat, or to the channel's discussion group, information about the source message from which the message was forwarded last time; may be null for other forwards or if unknown
	PublicServiceAnnouncementType string         `json:"public_service_announcement_type"` // The type of public service announcement for the forwarded message
}

// MessageType return the string telegram-type of MessageForwardInfo
func (messageForwardInfo *MessageForwardInfo) MessageType() string {
	return "messageForwardInfo"
}

// NewMessageForwardInfo creates a new MessageForwardInfo
//
// @param origin Origin of the forwarded message
// @param date Point in time (Unix timestamp) when the message was originally sent
// @param source For messages forwarded to the chat with the current user (Saved Messages), to the Replies bot chat, or to the channel's discussion group, information about the source message from which the message was forwarded last time; may be null for other forwards or if unknown
// @param publicServiceAnnouncementType The type of public service announcement for the forwarded message
func NewMessageForwardInfo(origin MessageOrigin, date int32, source *ForwardSource, publicServiceAnnouncementType string) *MessageForwardInfo {
	messageForwardInfoTemp := MessageForwardInfo{
		tdCommon:                      tdCommon{Type: "messageForwardInfo"},
		Origin:                        origin,
		Date:                          date,
		Source:                        source,
		PublicServiceAnnouncementType: publicServiceAnnouncementType,
	}

	return &messageForwardInfoTemp
}

// UnmarshalJSON unmarshal to json
func (messageForwardInfo *MessageForwardInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Date                          int32  `json:"date"`                             // Point in time (Unix timestamp) when the message was originally sent
		PublicServiceAnnouncementType string `json:"public_service_announcement_type"` // The type of public service announcement for the forwarded message
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageForwardInfo.tdCommon = tempObj.tdCommon
	messageForwardInfo.Date = tempObj.Date
	messageForwardInfo.PublicServiceAnnouncementType = tempObj.PublicServiceAnnouncementType

	fieldOrigin, _ := unmarshalMessageOrigin(objMap["origin"])
	messageForwardInfo.Origin = fieldOrigin

	var source ForwardSource
	if objMap["source"] != nil {
		err = source.UnmarshalJSON(*objMap["source"])
		if err != nil {
			return err
		}
	}

	messageForwardInfo.Source = &source

	return nil
}

// MessageImportInfo Contains information about a message created with importMessages
type MessageImportInfo struct {
	tdCommon
	SenderName string `json:"sender_name"` // Name of the original sender
	Date       int32  `json:"date"`        // Point in time (Unix timestamp) when the message was originally sent
}

// MessageType return the string telegram-type of MessageImportInfo
func (messageImportInfo *MessageImportInfo) MessageType() string {
	return "messageImportInfo"
}

// NewMessageImportInfo creates a new MessageImportInfo
//
// @param senderName Name of the original sender
// @param date Point in time (Unix timestamp) when the message was originally sent
func NewMessageImportInfo(senderName string, date int32) *MessageImportInfo {
	messageImportInfoTemp := MessageImportInfo{
		tdCommon:   tdCommon{Type: "messageImportInfo"},
		SenderName: senderName,
		Date:       date,
	}

	return &messageImportInfoTemp
}

// UnmarshalJSON unmarshal to json
func (messageImportInfo *MessageImportInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SenderName string `json:"sender_name"` // Name of the original sender
		Date       int32  `json:"date"`        // Point in time (Unix timestamp) when the message was originally sent
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageImportInfo.tdCommon = tempObj.tdCommon
	messageImportInfo.SenderName = tempObj.SenderName
	messageImportInfo.Date = tempObj.Date

	return nil
}

// MessageReplyInfo Contains information about replies to a message
type MessageReplyInfo struct {
	tdCommon
	ReplyCount              int32           `json:"reply_count"`                 // Number of times the message was directly or indirectly replied
	RecentReplierIDs        []MessageSender `json:"recent_replier_ids"`          // Identifiers of at most 3 recent repliers to the message; available in channels with a discussion supergroup. The users and chats are expected to be inaccessible: only their photo and name will be available
	LastReadInboxMessageID  int64           `json:"last_read_inbox_message_id"`  // Identifier of the last read incoming reply to the message
	LastReadOutboxMessageID int64           `json:"last_read_outbox_message_id"` // Identifier of the last read outgoing reply to the message
	LastMessageID           int64           `json:"last_message_id"`             // Identifier of the last reply to the message
}

// MessageType return the string telegram-type of MessageReplyInfo
func (messageReplyInfo *MessageReplyInfo) MessageType() string {
	return "messageReplyInfo"
}

// NewMessageReplyInfo creates a new MessageReplyInfo
//
// @param replyCount Number of times the message was directly or indirectly replied
// @param recentReplierIDs Identifiers of at most 3 recent repliers to the message; available in channels with a discussion supergroup. The users and chats are expected to be inaccessible: only their photo and name will be available
// @param lastReadInboxMessageID Identifier of the last read incoming reply to the message
// @param lastReadOutboxMessageID Identifier of the last read outgoing reply to the message
// @param lastMessageID Identifier of the last reply to the message
func NewMessageReplyInfo(replyCount int32, recentReplierIDs []MessageSender, lastReadInboxMessageID int64, lastReadOutboxMessageID int64, lastMessageID int64) *MessageReplyInfo {
	messageReplyInfoTemp := MessageReplyInfo{
		tdCommon:                tdCommon{Type: "messageReplyInfo"},
		ReplyCount:              replyCount,
		RecentReplierIDs:        recentReplierIDs,
		LastReadInboxMessageID:  lastReadInboxMessageID,
		LastReadOutboxMessageID: lastReadOutboxMessageID,
		LastMessageID:           lastMessageID,
	}

	return &messageReplyInfoTemp
}

// UnmarshalJSON unmarshal to json
func (messageReplyInfo *MessageReplyInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ReplyCount              int32 `json:"reply_count"`                 // Number of times the message was directly or indirectly replied
		LastReadInboxMessageID  int64 `json:"last_read_inbox_message_id"`  // Identifier of the last read incoming reply to the message
		LastReadOutboxMessageID int64 `json:"last_read_outbox_message_id"` // Identifier of the last read outgoing reply to the message
		LastMessageID           int64 `json:"last_message_id"`             // Identifier of the last reply to the message
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageReplyInfo.tdCommon = tempObj.tdCommon
	messageReplyInfo.ReplyCount = tempObj.ReplyCount
	messageReplyInfo.LastReadInboxMessageID = tempObj.LastReadInboxMessageID
	messageReplyInfo.LastReadOutboxMessageID = tempObj.LastReadOutboxMessageID
	messageReplyInfo.LastMessageID = tempObj.LastMessageID

	fieldRecentReplierIDs, _ := unmarshalMessageSenderSlice(objMap["recent_replier_ids"])
	messageReplyInfo.RecentReplierIDs = fieldRecentReplierIDs

	return nil
}

// MessageReaction Contains information about a reaction to a message
type MessageReaction struct {
	tdCommon
	Type            ReactionType    `json:"type"`              // Type of the reaction
	TotalCount      int32           `json:"total_count"`       // Number of times the reaction was added
	IsChosen        bool            `json:"is_chosen"`         // True, if the reaction is chosen by the current user
	UsedSenderID    *MessageSender  `json:"used_sender_id"`    // Identifier of the message sender used by the current user to add the reaction; may be null if unknown or the reaction isn't chosen
	RecentSenderIDs []MessageSender `json:"recent_sender_ids"` // Identifiers of at most 3 recent message senders, added the reaction; available in private, basic group and supergroup chats
}

// MessageType return the string telegram-type of MessageReaction
func (messageReaction *MessageReaction) MessageType() string {
	return "messageReaction"
}

// NewMessageReaction creates a new MessageReaction
//
// @param typeParam Type of the reaction
// @param totalCount Number of times the reaction was added
// @param isChosen True, if the reaction is chosen by the current user
// @param usedSenderID Identifier of the message sender used by the current user to add the reaction; may be null if unknown or the reaction isn't chosen
// @param recentSenderIDs Identifiers of at most 3 recent message senders, added the reaction; available in private, basic group and supergroup chats
func NewMessageReaction(typeParam ReactionType, totalCount int32, isChosen bool, usedSenderID *MessageSender, recentSenderIDs []MessageSender) *MessageReaction {
	messageReactionTemp := MessageReaction{
		tdCommon:        tdCommon{Type: "messageReaction"},
		Type:            typeParam,
		TotalCount:      totalCount,
		IsChosen:        isChosen,
		UsedSenderID:    usedSenderID,
		RecentSenderIDs: recentSenderIDs,
	}

	return &messageReactionTemp
}

// UnmarshalJSON unmarshal to json
func (messageReaction *MessageReaction) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32 `json:"total_count"` // Number of times the reaction was added
		IsChosen   bool  `json:"is_chosen"`   // True, if the reaction is chosen by the current user

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageReaction.tdCommon = tempObj.tdCommon
	messageReaction.TotalCount = tempObj.TotalCount
	messageReaction.IsChosen = tempObj.IsChosen

	fieldType, _ := unmarshalReactionType(objMap["type"])
	messageReaction.Type = fieldType

	fieldUsedSenderID, _ := unmarshalMessageSender(objMap["used_sender_id"])
	messageReaction.UsedSenderID = &fieldUsedSenderID

	fieldRecentSenderIDs, _ := unmarshalMessageSenderSlice(objMap["recent_sender_ids"])
	messageReaction.RecentSenderIDs = fieldRecentSenderIDs

	return nil
}

// MessageReactions Contains a list of reactions added to a message
type MessageReactions struct {
	tdCommon
	Reactions            []MessageReaction `json:"reactions"`               // List of added reactions
	AreTags              bool              `json:"are_tags"`                // True, if the reactions are tags and Telegram Premium users can filter messages by them
	PaidReactors         []PaidReactor     `json:"paid_reactors"`           // Information about top users that added the paid reaction
	CanGetAddedReactions bool              `json:"can_get_added_reactions"` // True, if the list of added reactions is available using getMessageAddedReactions
}

// MessageType return the string telegram-type of MessageReactions
func (messageReactions *MessageReactions) MessageType() string {
	return "messageReactions"
}

// NewMessageReactions creates a new MessageReactions
//
// @param reactions List of added reactions
// @param areTags True, if the reactions are tags and Telegram Premium users can filter messages by them
// @param paidReactors Information about top users that added the paid reaction
// @param canGetAddedReactions True, if the list of added reactions is available using getMessageAddedReactions
func NewMessageReactions(reactions []MessageReaction, areTags bool, paidReactors []PaidReactor, canGetAddedReactions bool) *MessageReactions {
	messageReactionsTemp := MessageReactions{
		tdCommon:             tdCommon{Type: "messageReactions"},
		Reactions:            reactions,
		AreTags:              areTags,
		PaidReactors:         paidReactors,
		CanGetAddedReactions: canGetAddedReactions,
	}

	return &messageReactionsTemp
}

// UnmarshalJSON unmarshal to json
func (messageReactions *MessageReactions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Reactions            []MessageReaction `json:"reactions"`               // List of added reactions
		AreTags              bool              `json:"are_tags"`                // True, if the reactions are tags and Telegram Premium users can filter messages by them
		PaidReactors         []PaidReactor     `json:"paid_reactors"`           // Information about top users that added the paid reaction
		CanGetAddedReactions bool              `json:"can_get_added_reactions"` // True, if the list of added reactions is available using getMessageAddedReactions
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageReactions.tdCommon = tempObj.tdCommon
	messageReactions.Reactions = tempObj.Reactions
	messageReactions.AreTags = tempObj.AreTags
	messageReactions.PaidReactors = tempObj.PaidReactors
	messageReactions.CanGetAddedReactions = tempObj.CanGetAddedReactions

	return nil
}

// MessageInteractionInfo Contains information about interactions with a message
type MessageInteractionInfo struct {
	tdCommon
	ViewCount    int32             `json:"view_count"`    // Number of times the message was viewed
	ForwardCount int32             `json:"forward_count"` // Number of times the message was forwarded
	ReplyInfo    *MessageReplyInfo `json:"reply_info"`    // Information about direct or indirect replies to the message; may be null. Currently, available only in channels with a discussion supergroup and discussion supergroups for messages, which are not replies itself
	Reactions    *MessageReactions `json:"reactions"`     // The list of reactions or tags added to the message; may be null
}

// MessageType return the string telegram-type of MessageInteractionInfo
func (messageInteractionInfo *MessageInteractionInfo) MessageType() string {
	return "messageInteractionInfo"
}

// NewMessageInteractionInfo creates a new MessageInteractionInfo
//
// @param viewCount Number of times the message was viewed
// @param forwardCount Number of times the message was forwarded
// @param replyInfo Information about direct or indirect replies to the message; may be null. Currently, available only in channels with a discussion supergroup and discussion supergroups for messages, which are not replies itself
// @param reactions The list of reactions or tags added to the message; may be null
func NewMessageInteractionInfo(viewCount int32, forwardCount int32, replyInfo *MessageReplyInfo, reactions *MessageReactions) *MessageInteractionInfo {
	messageInteractionInfoTemp := MessageInteractionInfo{
		tdCommon:     tdCommon{Type: "messageInteractionInfo"},
		ViewCount:    viewCount,
		ForwardCount: forwardCount,
		ReplyInfo:    replyInfo,
		Reactions:    reactions,
	}

	return &messageInteractionInfoTemp
}

// UnmarshalJSON unmarshal to json
func (messageInteractionInfo *MessageInteractionInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ViewCount    int32             `json:"view_count"`    // Number of times the message was viewed
		ForwardCount int32             `json:"forward_count"` // Number of times the message was forwarded
		Reactions    *MessageReactions `json:"reactions"`     // The list of reactions or tags added to the message; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageInteractionInfo.tdCommon = tempObj.tdCommon
	messageInteractionInfo.ViewCount = tempObj.ViewCount
	messageInteractionInfo.ForwardCount = tempObj.ForwardCount
	messageInteractionInfo.Reactions = tempObj.Reactions

	var replyInfo MessageReplyInfo
	if objMap["reply_info"] != nil {
		err = replyInfo.UnmarshalJSON(*objMap["reply_info"])
		if err != nil {
			return err
		}
	}

	messageInteractionInfo.ReplyInfo = &replyInfo

	return nil
}

// UnreadReaction Contains information about an unread reaction to a message
type UnreadReaction struct {
	tdCommon
	Type     ReactionType  `json:"type"`      // Type of the reaction
	SenderID MessageSender `json:"sender_id"` // Identifier of the sender, added the reaction
	IsBig    bool          `json:"is_big"`    // True, if the reaction was added with a big animation
}

// MessageType return the string telegram-type of UnreadReaction
func (unreadReaction *UnreadReaction) MessageType() string {
	return "unreadReaction"
}

// NewUnreadReaction creates a new UnreadReaction
//
// @param typeParam Type of the reaction
// @param senderID Identifier of the sender, added the reaction
// @param isBig True, if the reaction was added with a big animation
func NewUnreadReaction(typeParam ReactionType, senderID MessageSender, isBig bool) *UnreadReaction {
	unreadReactionTemp := UnreadReaction{
		tdCommon: tdCommon{Type: "unreadReaction"},
		Type:     typeParam,
		SenderID: senderID,
		IsBig:    isBig,
	}

	return &unreadReactionTemp
}

// UnmarshalJSON unmarshal to json
func (unreadReaction *UnreadReaction) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsBig bool `json:"is_big"` // True, if the reaction was added with a big animation
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	unreadReaction.tdCommon = tempObj.tdCommon
	unreadReaction.IsBig = tempObj.IsBig

	fieldType, _ := unmarshalReactionType(objMap["type"])
	unreadReaction.Type = fieldType

	fieldSenderID, _ := unmarshalMessageSender(objMap["sender_id"])
	unreadReaction.SenderID = fieldSenderID

	return nil
}

// MessageEffectTypeEmojiReaction An effect from an emoji reaction
type MessageEffectTypeEmojiReaction struct {
	tdCommon
	SelectAnimation *Sticker `json:"select_animation"` // Select animation for the effect in TGS format
	EffectAnimation *Sticker `json:"effect_animation"` // Effect animation for the effect in TGS format
}

// MessageType return the string telegram-type of MessageEffectTypeEmojiReaction
func (messageEffectTypeEmojiReaction *MessageEffectTypeEmojiReaction) MessageType() string {
	return "messageEffectTypeEmojiReaction"
}

// NewMessageEffectTypeEmojiReaction creates a new MessageEffectTypeEmojiReaction
//
// @param selectAnimation Select animation for the effect in TGS format
// @param effectAnimation Effect animation for the effect in TGS format
func NewMessageEffectTypeEmojiReaction(selectAnimation *Sticker, effectAnimation *Sticker) *MessageEffectTypeEmojiReaction {
	messageEffectTypeEmojiReactionTemp := MessageEffectTypeEmojiReaction{
		tdCommon:        tdCommon{Type: "messageEffectTypeEmojiReaction"},
		SelectAnimation: selectAnimation,
		EffectAnimation: effectAnimation,
	}

	return &messageEffectTypeEmojiReactionTemp
}

// UnmarshalJSON unmarshal to json
func (messageEffectTypeEmojiReaction *MessageEffectTypeEmojiReaction) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageEffectTypeEmojiReaction.tdCommon = tempObj.tdCommon

	var selectAnimation Sticker
	if objMap["select_animation"] != nil {
		err = selectAnimation.UnmarshalJSON(*objMap["select_animation"])
		if err != nil {
			return err
		}
	}

	messageEffectTypeEmojiReaction.SelectAnimation = &selectAnimation

	var effectAnimation Sticker
	if objMap["effect_animation"] != nil {
		err = effectAnimation.UnmarshalJSON(*objMap["effect_animation"])
		if err != nil {
			return err
		}
	}

	messageEffectTypeEmojiReaction.EffectAnimation = &effectAnimation

	return nil
}

// GetMessageEffectTypeEnum return the enum type of this object
func (messageEffectTypeEmojiReaction *MessageEffectTypeEmojiReaction) GetMessageEffectTypeEnum() MessageEffectTypeEnum {
	return MessageEffectTypeEmojiReactionType
}

// MessageEffectTypePremiumSticker An effect from a premium sticker
type MessageEffectTypePremiumSticker struct {
	tdCommon
	Sticker *Sticker `json:"sticker"` // The premium sticker. The effect can be found at sticker.full_type.premium_animation
}

// MessageType return the string telegram-type of MessageEffectTypePremiumSticker
func (messageEffectTypePremiumSticker *MessageEffectTypePremiumSticker) MessageType() string {
	return "messageEffectTypePremiumSticker"
}

// NewMessageEffectTypePremiumSticker creates a new MessageEffectTypePremiumSticker
//
// @param sticker The premium sticker. The effect can be found at sticker.full_type.premium_animation
func NewMessageEffectTypePremiumSticker(sticker *Sticker) *MessageEffectTypePremiumSticker {
	messageEffectTypePremiumStickerTemp := MessageEffectTypePremiumSticker{
		tdCommon: tdCommon{Type: "messageEffectTypePremiumSticker"},
		Sticker:  sticker,
	}

	return &messageEffectTypePremiumStickerTemp
}

// UnmarshalJSON unmarshal to json
func (messageEffectTypePremiumSticker *MessageEffectTypePremiumSticker) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageEffectTypePremiumSticker.tdCommon = tempObj.tdCommon

	var sticker Sticker
	if objMap["sticker"] != nil {
		err = sticker.UnmarshalJSON(*objMap["sticker"])
		if err != nil {
			return err
		}
	}

	messageEffectTypePremiumSticker.Sticker = &sticker

	return nil
}

// GetMessageEffectTypeEnum return the enum type of this object
func (messageEffectTypePremiumSticker *MessageEffectTypePremiumSticker) GetMessageEffectTypeEnum() MessageEffectTypeEnum {
	return MessageEffectTypePremiumStickerType
}

// MessageEffect Contains information about an effect added to a message
type MessageEffect struct {
	tdCommon
	ID         JSONInt64         `json:"id"`          // Unique identifier of the effect
	StaticIcon *Sticker          `json:"static_icon"` // Static icon for the effect in WEBP format; may be null if none
	Emoji      string            `json:"emoji"`       // Emoji corresponding to the effect that can be used if static icon isn't available
	IsPremium  bool              `json:"is_premium"`  // True, if Telegram Premium subscription is required to use the effect
	Type       MessageEffectType `json:"type"`        // Type of the effect
}

// MessageType return the string telegram-type of MessageEffect
func (messageEffect *MessageEffect) MessageType() string {
	return "messageEffect"
}

// NewMessageEffect creates a new MessageEffect
//
// @param iD Unique identifier of the effect
// @param staticIcon Static icon for the effect in WEBP format; may be null if none
// @param emoji Emoji corresponding to the effect that can be used if static icon isn't available
// @param isPremium True, if Telegram Premium subscription is required to use the effect
// @param typeParam Type of the effect
func NewMessageEffect(iD JSONInt64, staticIcon *Sticker, emoji string, isPremium bool, typeParam MessageEffectType) *MessageEffect {
	messageEffectTemp := MessageEffect{
		tdCommon:   tdCommon{Type: "messageEffect"},
		ID:         iD,
		StaticIcon: staticIcon,
		Emoji:      emoji,
		IsPremium:  isPremium,
		Type:       typeParam,
	}

	return &messageEffectTemp
}

// UnmarshalJSON unmarshal to json
func (messageEffect *MessageEffect) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID        JSONInt64 `json:"id"`         // Unique identifier of the effect
		Emoji     string    `json:"emoji"`      // Emoji corresponding to the effect that can be used if static icon isn't available
		IsPremium bool      `json:"is_premium"` // True, if Telegram Premium subscription is required to use the effect

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageEffect.tdCommon = tempObj.tdCommon
	messageEffect.ID = tempObj.ID
	messageEffect.Emoji = tempObj.Emoji
	messageEffect.IsPremium = tempObj.IsPremium

	fieldType, _ := unmarshalMessageEffectType(objMap["type"])
	messageEffect.Type = fieldType

	var staticIcon Sticker
	if objMap["static_icon"] != nil {
		err = staticIcon.UnmarshalJSON(*objMap["static_icon"])
		if err != nil {
			return err
		}
	}

	messageEffect.StaticIcon = &staticIcon

	return nil
}

// MessageSendingStatePending The message is being sent now, but has not yet been delivered to the server
type MessageSendingStatePending struct {
	tdCommon
	SendingID int32 `json:"sending_id"` // Non-persistent message sending identifier, specified by the application
}

// MessageType return the string telegram-type of MessageSendingStatePending
func (messageSendingStatePending *MessageSendingStatePending) MessageType() string {
	return "messageSendingStatePending"
}

// NewMessageSendingStatePending creates a new MessageSendingStatePending
//
// @param sendingID Non-persistent message sending identifier, specified by the application
func NewMessageSendingStatePending(sendingID int32) *MessageSendingStatePending {
	messageSendingStatePendingTemp := MessageSendingStatePending{
		tdCommon:  tdCommon{Type: "messageSendingStatePending"},
		SendingID: sendingID,
	}

	return &messageSendingStatePendingTemp
}

// UnmarshalJSON unmarshal to json
func (messageSendingStatePending *MessageSendingStatePending) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SendingID int32 `json:"sending_id"` // Non-persistent message sending identifier, specified by the application
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSendingStatePending.tdCommon = tempObj.tdCommon
	messageSendingStatePending.SendingID = tempObj.SendingID

	return nil
}

// GetMessageSendingStateEnum return the enum type of this object
func (messageSendingStatePending *MessageSendingStatePending) GetMessageSendingStateEnum() MessageSendingStateEnum {
	return MessageSendingStatePendingType
}

// MessageSendingStateFailed The message failed to be sent
type MessageSendingStateFailed struct {
	tdCommon
	Error                 *Error  `json:"error"`                    // The cause of the message sending failure
	CanRetry              bool    `json:"can_retry"`                // True, if the message can be re-sent using resendMessages or readdQuickReplyShortcutMessages
	NeedAnotherSender     bool    `json:"need_another_sender"`      // True, if the message can be re-sent only on behalf of a different sender
	NeedAnotherReplyQuote bool    `json:"need_another_reply_quote"` // True, if the message can be re-sent only if another quote is chosen in the message that is replied by the given message
	NeedDropReply         bool    `json:"need_drop_reply"`          // True, if the message can be re-sent only if the message to be replied is removed. This will be done automatically by resendMessages
	RetryAfter            float64 `json:"retry_after"`              // Time left before the message can be re-sent, in seconds. No update is sent when this field changes
}

// MessageType return the string telegram-type of MessageSendingStateFailed
func (messageSendingStateFailed *MessageSendingStateFailed) MessageType() string {
	return "messageSendingStateFailed"
}

// NewMessageSendingStateFailed creates a new MessageSendingStateFailed
//
// @param errParam The cause of the message sending failure
// @param canRetry True, if the message can be re-sent using resendMessages or readdQuickReplyShortcutMessages
// @param needAnotherSender True, if the message can be re-sent only on behalf of a different sender
// @param needAnotherReplyQuote True, if the message can be re-sent only if another quote is chosen in the message that is replied by the given message
// @param needDropReply True, if the message can be re-sent only if the message to be replied is removed. This will be done automatically by resendMessages
// @param retryAfter Time left before the message can be re-sent, in seconds. No update is sent when this field changes
func NewMessageSendingStateFailed(errParam *Error, canRetry bool, needAnotherSender bool, needAnotherReplyQuote bool, needDropReply bool, retryAfter float64) *MessageSendingStateFailed {
	messageSendingStateFailedTemp := MessageSendingStateFailed{
		tdCommon:              tdCommon{Type: "messageSendingStateFailed"},
		Error:                 errParam,
		CanRetry:              canRetry,
		NeedAnotherSender:     needAnotherSender,
		NeedAnotherReplyQuote: needAnotherReplyQuote,
		NeedDropReply:         needDropReply,
		RetryAfter:            retryAfter,
	}

	return &messageSendingStateFailedTemp
}

// UnmarshalJSON unmarshal to json
func (messageSendingStateFailed *MessageSendingStateFailed) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Error                 *Error  `json:"error"`                    // The cause of the message sending failure
		CanRetry              bool    `json:"can_retry"`                // True, if the message can be re-sent using resendMessages or readdQuickReplyShortcutMessages
		NeedAnotherSender     bool    `json:"need_another_sender"`      // True, if the message can be re-sent only on behalf of a different sender
		NeedAnotherReplyQuote bool    `json:"need_another_reply_quote"` // True, if the message can be re-sent only if another quote is chosen in the message that is replied by the given message
		NeedDropReply         bool    `json:"need_drop_reply"`          // True, if the message can be re-sent only if the message to be replied is removed. This will be done automatically by resendMessages
		RetryAfter            float64 `json:"retry_after"`              // Time left before the message can be re-sent, in seconds. No update is sent when this field changes
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSendingStateFailed.tdCommon = tempObj.tdCommon
	messageSendingStateFailed.Error = tempObj.Error
	messageSendingStateFailed.CanRetry = tempObj.CanRetry
	messageSendingStateFailed.NeedAnotherSender = tempObj.NeedAnotherSender
	messageSendingStateFailed.NeedAnotherReplyQuote = tempObj.NeedAnotherReplyQuote
	messageSendingStateFailed.NeedDropReply = tempObj.NeedDropReply
	messageSendingStateFailed.RetryAfter = tempObj.RetryAfter

	return nil
}

// GetMessageSendingStateEnum return the enum type of this object
func (messageSendingStateFailed *MessageSendingStateFailed) GetMessageSendingStateEnum() MessageSendingStateEnum {
	return MessageSendingStateFailedType
}

// TextQuote Describes manually or automatically chosen quote from another message
type TextQuote struct {
	tdCommon
	Text     *FormattedText `json:"text"`      // Text of the quote. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities can be present in the text
	Position int32          `json:"position"`  // Approximate quote position in the original message in UTF-16 code units as specified by the message sender
	IsManual bool           `json:"is_manual"` // True, if the quote was manually chosen by the message sender
}

// MessageType return the string telegram-type of TextQuote
func (textQuote *TextQuote) MessageType() string {
	return "textQuote"
}

// NewTextQuote creates a new TextQuote
//
// @param text Text of the quote. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities can be present in the text
// @param position Approximate quote position in the original message in UTF-16 code units as specified by the message sender
// @param isManual True, if the quote was manually chosen by the message sender
func NewTextQuote(text *FormattedText, position int32, isManual bool) *TextQuote {
	textQuoteTemp := TextQuote{
		tdCommon: tdCommon{Type: "textQuote"},
		Text:     text,
		Position: position,
		IsManual: isManual,
	}

	return &textQuoteTemp
}

// UnmarshalJSON unmarshal to json
func (textQuote *TextQuote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Text     *FormattedText `json:"text"`      // Text of the quote. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities can be present in the text
		Position int32          `json:"position"`  // Approximate quote position in the original message in UTF-16 code units as specified by the message sender
		IsManual bool           `json:"is_manual"` // True, if the quote was manually chosen by the message sender
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textQuote.tdCommon = tempObj.tdCommon
	textQuote.Text = tempObj.Text
	textQuote.Position = tempObj.Position
	textQuote.IsManual = tempObj.IsManual

	return nil
}

// InputTextQuote Describes manually chosen quote from another message
type InputTextQuote struct {
	tdCommon
	Text     *FormattedText `json:"text"`     // Text of the quote; 0-getOption("message_reply_quote_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities are allowed to be kept and must be kept in the quote
	Position int32          `json:"position"` // Quote position in the original message in UTF-16 code units
}

// MessageType return the string telegram-type of InputTextQuote
func (inputTextQuote *InputTextQuote) MessageType() string {
	return "inputTextQuote"
}

// NewInputTextQuote creates a new InputTextQuote
//
// @param text Text of the quote; 0-getOption("message_reply_quote_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities are allowed to be kept and must be kept in the quote
// @param position Quote position in the original message in UTF-16 code units
func NewInputTextQuote(text *FormattedText, position int32) *InputTextQuote {
	inputTextQuoteTemp := InputTextQuote{
		tdCommon: tdCommon{Type: "inputTextQuote"},
		Text:     text,
		Position: position,
	}

	return &inputTextQuoteTemp
}

// UnmarshalJSON unmarshal to json
func (inputTextQuote *InputTextQuote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Text     *FormattedText `json:"text"`     // Text of the quote; 0-getOption("message_reply_quote_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities are allowed to be kept and must be kept in the quote
		Position int32          `json:"position"` // Quote position in the original message in UTF-16 code units
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputTextQuote.tdCommon = tempObj.tdCommon
	inputTextQuote.Text = tempObj.Text
	inputTextQuote.Position = tempObj.Position

	return nil
}

// MessageReplyToMessage Describes a message replied by a given message
type MessageReplyToMessage struct {
	tdCommon
	ChatID         int64           `json:"chat_id"`          // The identifier of the chat to which the message belongs; may be 0 if the replied message is in unknown chat
	MessageID      int64           `json:"message_id"`       // The identifier of the message; may be 0 if the replied message is in unknown chat
	Quote          *TextQuote      `json:"quote"`            // Chosen quote from the replied message; may be null if none
	Origin         *MessageOrigin  `json:"origin"`           // Information about origin of the message if the message was from another chat or topic; may be null for messages from the same chat
	OriginSendDate int32           `json:"origin_send_date"` // Point in time (Unix timestamp) when the message was sent if the message was from another chat or topic; 0 for messages from the same chat
	Content        *MessageContent `json:"content"`          // Media content of the message if the message was from another chat or topic; may be null for messages from the same chat and messages without media. Can be only one of the following types: messageAnimation, messageAudio, messageContact, messageDice, messageDocument, messageGame, messageGiveaway, messageGiveawayWinners, messageInvoice, messageLocation, messagePaidMedia, messagePhoto, messagePoll, messageSticker, messageStory, messageText (for link preview), messageVenue, messageVideo, messageVideoNote, or messageVoiceNote
}

// MessageType return the string telegram-type of MessageReplyToMessage
func (messageReplyToMessage *MessageReplyToMessage) MessageType() string {
	return "messageReplyToMessage"
}

// NewMessageReplyToMessage creates a new MessageReplyToMessage
//
// @param chatID The identifier of the chat to which the message belongs; may be 0 if the replied message is in unknown chat
// @param messageID The identifier of the message; may be 0 if the replied message is in unknown chat
// @param quote Chosen quote from the replied message; may be null if none
// @param origin Information about origin of the message if the message was from another chat or topic; may be null for messages from the same chat
// @param originSendDate Point in time (Unix timestamp) when the message was sent if the message was from another chat or topic; 0 for messages from the same chat
// @param content Media content of the message if the message was from another chat or topic; may be null for messages from the same chat and messages without media. Can be only one of the following types: messageAnimation, messageAudio, messageContact, messageDice, messageDocument, messageGame, messageGiveaway, messageGiveawayWinners, messageInvoice, messageLocation, messagePaidMedia, messagePhoto, messagePoll, messageSticker, messageStory, messageText (for link preview), messageVenue, messageVideo, messageVideoNote, or messageVoiceNote
func NewMessageReplyToMessage(chatID int64, messageID int64, quote *TextQuote, origin *MessageOrigin, originSendDate int32, content *MessageContent) *MessageReplyToMessage {
	messageReplyToMessageTemp := MessageReplyToMessage{
		tdCommon:       tdCommon{Type: "messageReplyToMessage"},
		ChatID:         chatID,
		MessageID:      messageID,
		Quote:          quote,
		Origin:         origin,
		OriginSendDate: originSendDate,
		Content:        content,
	}

	return &messageReplyToMessageTemp
}

// UnmarshalJSON unmarshal to json
func (messageReplyToMessage *MessageReplyToMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID         int64      `json:"chat_id"`          // The identifier of the chat to which the message belongs; may be 0 if the replied message is in unknown chat
		MessageID      int64      `json:"message_id"`       // The identifier of the message; may be 0 if the replied message is in unknown chat
		Quote          *TextQuote `json:"quote"`            // Chosen quote from the replied message; may be null if none
		OriginSendDate int32      `json:"origin_send_date"` // Point in time (Unix timestamp) when the message was sent if the message was from another chat or topic; 0 for messages from the same chat

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageReplyToMessage.tdCommon = tempObj.tdCommon
	messageReplyToMessage.ChatID = tempObj.ChatID
	messageReplyToMessage.MessageID = tempObj.MessageID
	messageReplyToMessage.Quote = tempObj.Quote
	messageReplyToMessage.OriginSendDate = tempObj.OriginSendDate

	fieldOrigin, _ := unmarshalMessageOrigin(objMap["origin"])
	messageReplyToMessage.Origin = &fieldOrigin

	fieldContent, _ := unmarshalMessageContent(objMap["content"])
	messageReplyToMessage.Content = &fieldContent

	return nil
}

// GetMessageReplyToEnum return the enum type of this object
func (messageReplyToMessage *MessageReplyToMessage) GetMessageReplyToEnum() MessageReplyToEnum {
	return MessageReplyToMessageType
}

// MessageReplyToStory Describes a story replied by a given message
type MessageReplyToStory struct {
	tdCommon
	StorySenderChatID int64 `json:"story_sender_chat_id"` // The identifier of the sender of the story
	StoryID           int32 `json:"story_id"`             // The identifier of the story
}

// MessageType return the string telegram-type of MessageReplyToStory
func (messageReplyToStory *MessageReplyToStory) MessageType() string {
	return "messageReplyToStory"
}

// NewMessageReplyToStory creates a new MessageReplyToStory
//
// @param storySenderChatID The identifier of the sender of the story
// @param storyID The identifier of the story
func NewMessageReplyToStory(storySenderChatID int64, storyID int32) *MessageReplyToStory {
	messageReplyToStoryTemp := MessageReplyToStory{
		tdCommon:          tdCommon{Type: "messageReplyToStory"},
		StorySenderChatID: storySenderChatID,
		StoryID:           storyID,
	}

	return &messageReplyToStoryTemp
}

// UnmarshalJSON unmarshal to json
func (messageReplyToStory *MessageReplyToStory) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StorySenderChatID int64 `json:"story_sender_chat_id"` // The identifier of the sender of the story
		StoryID           int32 `json:"story_id"`             // The identifier of the story
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageReplyToStory.tdCommon = tempObj.tdCommon
	messageReplyToStory.StorySenderChatID = tempObj.StorySenderChatID
	messageReplyToStory.StoryID = tempObj.StoryID

	return nil
}

// GetMessageReplyToEnum return the enum type of this object
func (messageReplyToStory *MessageReplyToStory) GetMessageReplyToEnum() MessageReplyToEnum {
	return MessageReplyToStoryType
}

// InputMessageReplyToMessage Describes a message to be replied in the same chat and forum topic
type InputMessageReplyToMessage struct {
	tdCommon
	MessageID int64           `json:"message_id"` // The identifier of the message to be replied in the same chat and forum topic. A message can be replied in the same chat and forum topic only if messageProperties.can_be_replied
	Quote     *InputTextQuote `json:"quote"`      // Quote from the message to be replied; pass null if none. Must always be null for replies in secret chats
}

// MessageType return the string telegram-type of InputMessageReplyToMessage
func (inputMessageReplyToMessage *InputMessageReplyToMessage) MessageType() string {
	return "inputMessageReplyToMessage"
}

// NewInputMessageReplyToMessage creates a new InputMessageReplyToMessage
//
// @param messageID The identifier of the message to be replied in the same chat and forum topic. A message can be replied in the same chat and forum topic only if messageProperties.can_be_replied
// @param quote Quote from the message to be replied; pass null if none. Must always be null for replies in secret chats
func NewInputMessageReplyToMessage(messageID int64, quote *InputTextQuote) *InputMessageReplyToMessage {
	inputMessageReplyToMessageTemp := InputMessageReplyToMessage{
		tdCommon:  tdCommon{Type: "inputMessageReplyToMessage"},
		MessageID: messageID,
		Quote:     quote,
	}

	return &inputMessageReplyToMessageTemp
}

// UnmarshalJSON unmarshal to json
func (inputMessageReplyToMessage *InputMessageReplyToMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MessageID int64           `json:"message_id"` // The identifier of the message to be replied in the same chat and forum topic. A message can be replied in the same chat and forum topic only if messageProperties.can_be_replied
		Quote     *InputTextQuote `json:"quote"`      // Quote from the message to be replied; pass null if none. Must always be null for replies in secret chats
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputMessageReplyToMessage.tdCommon = tempObj.tdCommon
	inputMessageReplyToMessage.MessageID = tempObj.MessageID
	inputMessageReplyToMessage.Quote = tempObj.Quote

	return nil
}

// GetInputMessageReplyToEnum return the enum type of this object
func (inputMessageReplyToMessage *InputMessageReplyToMessage) GetInputMessageReplyToEnum() InputMessageReplyToEnum {
	return InputMessageReplyToMessageType
}

// InputMessageReplyToExternalMessage Describes a message to be replied that is from a different chat or a forum topic; not supported in secret chats
type InputMessageReplyToExternalMessage struct {
	tdCommon
	ChatID    int64           `json:"chat_id"`    // The identifier of the chat to which the message to be replied belongs
	MessageID int64           `json:"message_id"` // The identifier of the message to be replied in the specified chat. A message can be replied in another chat or forum topic only if messageProperties.can_be_replied_in_another_chat
	Quote     *InputTextQuote `json:"quote"`      // Quote from the message to be replied; pass null if none
}

// MessageType return the string telegram-type of InputMessageReplyToExternalMessage
func (inputMessageReplyToExternalMessage *InputMessageReplyToExternalMessage) MessageType() string {
	return "inputMessageReplyToExternalMessage"
}

// NewInputMessageReplyToExternalMessage creates a new InputMessageReplyToExternalMessage
//
// @param chatID The identifier of the chat to which the message to be replied belongs
// @param messageID The identifier of the message to be replied in the specified chat. A message can be replied in another chat or forum topic only if messageProperties.can_be_replied_in_another_chat
// @param quote Quote from the message to be replied; pass null if none
func NewInputMessageReplyToExternalMessage(chatID int64, messageID int64, quote *InputTextQuote) *InputMessageReplyToExternalMessage {
	inputMessageReplyToExternalMessageTemp := InputMessageReplyToExternalMessage{
		tdCommon:  tdCommon{Type: "inputMessageReplyToExternalMessage"},
		ChatID:    chatID,
		MessageID: messageID,
		Quote:     quote,
	}

	return &inputMessageReplyToExternalMessageTemp
}

// UnmarshalJSON unmarshal to json
func (inputMessageReplyToExternalMessage *InputMessageReplyToExternalMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID    int64           `json:"chat_id"`    // The identifier of the chat to which the message to be replied belongs
		MessageID int64           `json:"message_id"` // The identifier of the message to be replied in the specified chat. A message can be replied in another chat or forum topic only if messageProperties.can_be_replied_in_another_chat
		Quote     *InputTextQuote `json:"quote"`      // Quote from the message to be replied; pass null if none
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputMessageReplyToExternalMessage.tdCommon = tempObj.tdCommon
	inputMessageReplyToExternalMessage.ChatID = tempObj.ChatID
	inputMessageReplyToExternalMessage.MessageID = tempObj.MessageID
	inputMessageReplyToExternalMessage.Quote = tempObj.Quote

	return nil
}

// GetInputMessageReplyToEnum return the enum type of this object
func (inputMessageReplyToExternalMessage *InputMessageReplyToExternalMessage) GetInputMessageReplyToEnum() InputMessageReplyToEnum {
	return InputMessageReplyToExternalMessageType
}

// InputMessageReplyToStory Describes a story to be replied
type InputMessageReplyToStory struct {
	tdCommon
	StorySenderChatID int64 `json:"story_sender_chat_id"` // The identifier of the sender of the story. Currently, stories can be replied only in the sender's chat and channel stories can't be replied
	StoryID           int32 `json:"story_id"`             // The identifier of the story
}

// MessageType return the string telegram-type of InputMessageReplyToStory
func (inputMessageReplyToStory *InputMessageReplyToStory) MessageType() string {
	return "inputMessageReplyToStory"
}

// NewInputMessageReplyToStory creates a new InputMessageReplyToStory
//
// @param storySenderChatID The identifier of the sender of the story. Currently, stories can be replied only in the sender's chat and channel stories can't be replied
// @param storyID The identifier of the story
func NewInputMessageReplyToStory(storySenderChatID int64, storyID int32) *InputMessageReplyToStory {
	inputMessageReplyToStoryTemp := InputMessageReplyToStory{
		tdCommon:          tdCommon{Type: "inputMessageReplyToStory"},
		StorySenderChatID: storySenderChatID,
		StoryID:           storyID,
	}

	return &inputMessageReplyToStoryTemp
}

// UnmarshalJSON unmarshal to json
func (inputMessageReplyToStory *InputMessageReplyToStory) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StorySenderChatID int64 `json:"story_sender_chat_id"` // The identifier of the sender of the story. Currently, stories can be replied only in the sender's chat and channel stories can't be replied
		StoryID           int32 `json:"story_id"`             // The identifier of the story
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputMessageReplyToStory.tdCommon = tempObj.tdCommon
	inputMessageReplyToStory.StorySenderChatID = tempObj.StorySenderChatID
	inputMessageReplyToStory.StoryID = tempObj.StoryID

	return nil
}

// GetInputMessageReplyToEnum return the enum type of this object
func (inputMessageReplyToStory *InputMessageReplyToStory) GetInputMessageReplyToEnum() InputMessageReplyToEnum {
	return InputMessageReplyToStoryType
}

// FactCheck Describes a fact-check added to the message by an independent checker
type FactCheck struct {
	tdCommon
	Text        *FormattedText `json:"text"`         // Text of the fact-check
	CountryCode string         `json:"country_code"` // A two-letter ISO 3166-1 alpha-2 country code of the country for which the fact-check is shown
}

// MessageType return the string telegram-type of FactCheck
func (factCheck *FactCheck) MessageType() string {
	return "factCheck"
}

// NewFactCheck creates a new FactCheck
//
// @param text Text of the fact-check
// @param countryCode A two-letter ISO 3166-1 alpha-2 country code of the country for which the fact-check is shown
func NewFactCheck(text *FormattedText, countryCode string) *FactCheck {
	factCheckTemp := FactCheck{
		tdCommon:    tdCommon{Type: "factCheck"},
		Text:        text,
		CountryCode: countryCode,
	}

	return &factCheckTemp
}

// UnmarshalJSON unmarshal to json
func (factCheck *FactCheck) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Text        *FormattedText `json:"text"`         // Text of the fact-check
		CountryCode string         `json:"country_code"` // A two-letter ISO 3166-1 alpha-2 country code of the country for which the fact-check is shown
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	factCheck.tdCommon = tempObj.tdCommon
	factCheck.Text = tempObj.Text
	factCheck.CountryCode = tempObj.CountryCode

	return nil
}

// Message Describes a message
type Message struct {
	tdCommon
	ID                      int64                    `json:"id"`                          // Message identifier; unique for the chat to which the message belongs
	SenderID                MessageSender            `json:"sender_id"`                   // Identifier of the sender of the message
	ChatID                  int64                    `json:"chat_id"`                     // Chat identifier
	SendingState            *MessageSendingState     `json:"sending_state"`               // The sending state of the message; may be null if the message isn't being sent and didn't fail to be sent
	SchedulingState         *MessageSchedulingState  `json:"scheduling_state"`            // The scheduling state of the message; may be null if the message isn't scheduled
	IsOutgoing              bool                     `json:"is_outgoing"`                 // True, if the message is outgoing
	IsPinned                bool                     `json:"is_pinned"`                   // True, if the message is pinned
	IsFromOffline           bool                     `json:"is_from_offline"`             // True, if the message was sent because of a scheduled action by the message sender, for example, as away, or greeting service message
	CanBeSaved              bool                     `json:"can_be_saved"`                // True, if content of the message can be saved locally or copied
	HasTimestampedMedia     bool                     `json:"has_timestamped_media"`       // True, if media timestamp entities refers to a media in this message as opposed to a media in the replied message
	IsChannelPost           bool                     `json:"is_channel_post"`             // True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts
	IsTopicMessage          bool                     `json:"is_topic_message"`            // True, if the message is a forum topic message
	ContainsUnreadMention   bool                     `json:"contains_unread_mention"`     // True, if the message contains an unread mention for the current user
	Date                    int32                    `json:"date"`                        // Point in time (Unix timestamp) when the message was sent
	EditDate                int32                    `json:"edit_date"`                   // Point in time (Unix timestamp) when the message was last edited
	ForwardInfo             *MessageForwardInfo      `json:"forward_info"`                // Information about the initial message sender; may be null if none or unknown
	ImportInfo              *MessageImportInfo       `json:"import_info"`                 // Information about the initial message for messages created with importMessages; may be null if the message isn't imported
	InteractionInfo         *MessageInteractionInfo  `json:"interaction_info"`            // Information about interactions with the message; may be null if none
	UnreadReactions         []UnreadReaction         `json:"unread_reactions"`            // Information about unread reactions added to the message
	FactCheck               *FactCheck               `json:"fact_check"`                  // Information about fact-check added to the message; may be null if none
	ReplyTo                 *MessageReplyTo          `json:"reply_to"`                    // Information about the message or the story this message is replying to; may be null if none
	MessageThreadID         int64                    `json:"message_thread_id"`           // If non-zero, the identifier of the message thread the message belongs to; unique within the chat to which the message belongs
	SavedMessagesTopicID    int64                    `json:"saved_messages_topic_id"`     // Identifier of the Saved Messages topic for the message; 0 for messages not from Saved Messages
	SelfDestructType        *MessageSelfDestructType `json:"self_destruct_type"`          // The message's self-destruct type; may be null if none
	SelfDestructIn          float64                  `json:"self_destruct_in"`            // Time left before the message self-destruct timer expires, in seconds; 0 if self-destruction isn't scheduled yet
	AutoDeleteIn            float64                  `json:"auto_delete_in"`              // Time left before the message will be automatically deleted by message_auto_delete_time setting of the chat, in seconds; 0 if never
	ViaBotUserID            int64                    `json:"via_bot_user_id"`             // If non-zero, the user identifier of the inline bot through which this message was sent
	SenderBusinessBotUserID int64                    `json:"sender_business_bot_user_id"` // If non-zero, the user identifier of the business bot that sent this message
	SenderBoostCount        int32                    `json:"sender_boost_count"`          // Number of times the sender of the message boosted the supergroup at the time the message was sent; 0 if none or unknown. For messages sent by the current user, supergroupFullInfo.my_boost_count must be used instead
	AuthorSignature         string                   `json:"author_signature"`            // For channel posts and anonymous group messages, optional author signature
	MediaAlbumID            JSONInt64                `json:"media_album_id"`              // Unique identifier of an album this message belongs to; 0 if none. Only audios, documents, photos and videos can be grouped together in albums
	EffectID                JSONInt64                `json:"effect_id"`                   // Unique identifier of the effect added to the message; 0 if none
	HasSensitiveContent     bool                     `json:"has_sensitive_content"`       // True, if media content of the message must be hidden with 18+ spoiler
	RestrictionReason       string                   `json:"restriction_reason"`          // If non-empty, contains a human-readable description of the reason why access to this message must be restricted
	Content                 MessageContent           `json:"content"`                     // Content of the message
	ReplyMarkup             *ReplyMarkup             `json:"reply_markup"`                // Reply markup for the message; may be null if none
}

// MessageType return the string telegram-type of Message
func (message *Message) MessageType() string {
	return "message"
}

// NewMessage creates a new Message
//
// @param iD Message identifier; unique for the chat to which the message belongs
// @param senderID Identifier of the sender of the message
// @param chatID Chat identifier
// @param sendingState The sending state of the message; may be null if the message isn't being sent and didn't fail to be sent
// @param schedulingState The scheduling state of the message; may be null if the message isn't scheduled
// @param isOutgoing True, if the message is outgoing
// @param isPinned True, if the message is pinned
// @param isFromOffline True, if the message was sent because of a scheduled action by the message sender, for example, as away, or greeting service message
// @param canBeSaved True, if content of the message can be saved locally or copied
// @param hasTimestampedMedia True, if media timestamp entities refers to a media in this message as opposed to a media in the replied message
// @param isChannelPost True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts
// @param isTopicMessage True, if the message is a forum topic message
// @param containsUnreadMention True, if the message contains an unread mention for the current user
// @param date Point in time (Unix timestamp) when the message was sent
// @param editDate Point in time (Unix timestamp) when the message was last edited
// @param forwardInfo Information about the initial message sender; may be null if none or unknown
// @param importInfo Information about the initial message for messages created with importMessages; may be null if the message isn't imported
// @param interactionInfo Information about interactions with the message; may be null if none
// @param unreadReactions Information about unread reactions added to the message
// @param factCheck Information about fact-check added to the message; may be null if none
// @param replyTo Information about the message or the story this message is replying to; may be null if none
// @param messageThreadID If non-zero, the identifier of the message thread the message belongs to; unique within the chat to which the message belongs
// @param savedMessagesTopicID Identifier of the Saved Messages topic for the message; 0 for messages not from Saved Messages
// @param selfDestructType The message's self-destruct type; may be null if none
// @param selfDestructIn Time left before the message self-destruct timer expires, in seconds; 0 if self-destruction isn't scheduled yet
// @param autoDeleteIn Time left before the message will be automatically deleted by message_auto_delete_time setting of the chat, in seconds; 0 if never
// @param viaBotUserID If non-zero, the user identifier of the inline bot through which this message was sent
// @param senderBusinessBotUserID If non-zero, the user identifier of the business bot that sent this message
// @param senderBoostCount Number of times the sender of the message boosted the supergroup at the time the message was sent; 0 if none or unknown. For messages sent by the current user, supergroupFullInfo.my_boost_count must be used instead
// @param authorSignature For channel posts and anonymous group messages, optional author signature
// @param mediaAlbumID Unique identifier of an album this message belongs to; 0 if none. Only audios, documents, photos and videos can be grouped together in albums
// @param effectID Unique identifier of the effect added to the message; 0 if none
// @param hasSensitiveContent True, if media content of the message must be hidden with 18+ spoiler
// @param restrictionReason If non-empty, contains a human-readable description of the reason why access to this message must be restricted
// @param content Content of the message
// @param replyMarkup Reply markup for the message; may be null if none
func NewMessage(iD int64, senderID MessageSender, chatID int64, sendingState *MessageSendingState, schedulingState *MessageSchedulingState, isOutgoing bool, isPinned bool, isFromOffline bool, canBeSaved bool, hasTimestampedMedia bool, isChannelPost bool, isTopicMessage bool, containsUnreadMention bool, date int32, editDate int32, forwardInfo *MessageForwardInfo, importInfo *MessageImportInfo, interactionInfo *MessageInteractionInfo, unreadReactions []UnreadReaction, factCheck *FactCheck, replyTo *MessageReplyTo, messageThreadID int64, savedMessagesTopicID int64, selfDestructType *MessageSelfDestructType, selfDestructIn float64, autoDeleteIn float64, viaBotUserID int64, senderBusinessBotUserID int64, senderBoostCount int32, authorSignature string, mediaAlbumID JSONInt64, effectID JSONInt64, hasSensitiveContent bool, restrictionReason string, content MessageContent, replyMarkup *ReplyMarkup) *Message {
	messageTemp := Message{
		tdCommon:                tdCommon{Type: "message"},
		ID:                      iD,
		SenderID:                senderID,
		ChatID:                  chatID,
		SendingState:            sendingState,
		SchedulingState:         schedulingState,
		IsOutgoing:              isOutgoing,
		IsPinned:                isPinned,
		IsFromOffline:           isFromOffline,
		CanBeSaved:              canBeSaved,
		HasTimestampedMedia:     hasTimestampedMedia,
		IsChannelPost:           isChannelPost,
		IsTopicMessage:          isTopicMessage,
		ContainsUnreadMention:   containsUnreadMention,
		Date:                    date,
		EditDate:                editDate,
		ForwardInfo:             forwardInfo,
		ImportInfo:              importInfo,
		InteractionInfo:         interactionInfo,
		UnreadReactions:         unreadReactions,
		FactCheck:               factCheck,
		ReplyTo:                 replyTo,
		MessageThreadID:         messageThreadID,
		SavedMessagesTopicID:    savedMessagesTopicID,
		SelfDestructType:        selfDestructType,
		SelfDestructIn:          selfDestructIn,
		AutoDeleteIn:            autoDeleteIn,
		ViaBotUserID:            viaBotUserID,
		SenderBusinessBotUserID: senderBusinessBotUserID,
		SenderBoostCount:        senderBoostCount,
		AuthorSignature:         authorSignature,
		MediaAlbumID:            mediaAlbumID,
		EffectID:                effectID,
		HasSensitiveContent:     hasSensitiveContent,
		RestrictionReason:       restrictionReason,
		Content:                 content,
		ReplyMarkup:             replyMarkup,
	}

	return &messageTemp
}

// UnmarshalJSON unmarshal to json
func (message *Message) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID                      int64                   `json:"id"`                          // Message identifier; unique for the chat to which the message belongs
		ChatID                  int64                   `json:"chat_id"`                     // Chat identifier
		IsOutgoing              bool                    `json:"is_outgoing"`                 // True, if the message is outgoing
		IsPinned                bool                    `json:"is_pinned"`                   // True, if the message is pinned
		IsFromOffline           bool                    `json:"is_from_offline"`             // True, if the message was sent because of a scheduled action by the message sender, for example, as away, or greeting service message
		CanBeSaved              bool                    `json:"can_be_saved"`                // True, if content of the message can be saved locally or copied
		HasTimestampedMedia     bool                    `json:"has_timestamped_media"`       // True, if media timestamp entities refers to a media in this message as opposed to a media in the replied message
		IsChannelPost           bool                    `json:"is_channel_post"`             // True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts
		IsTopicMessage          bool                    `json:"is_topic_message"`            // True, if the message is a forum topic message
		ContainsUnreadMention   bool                    `json:"contains_unread_mention"`     // True, if the message contains an unread mention for the current user
		Date                    int32                   `json:"date"`                        // Point in time (Unix timestamp) when the message was sent
		EditDate                int32                   `json:"edit_date"`                   // Point in time (Unix timestamp) when the message was last edited
		ImportInfo              *MessageImportInfo      `json:"import_info"`                 // Information about the initial message for messages created with importMessages; may be null if the message isn't imported
		InteractionInfo         *MessageInteractionInfo `json:"interaction_info"`            // Information about interactions with the message; may be null if none
		UnreadReactions         []UnreadReaction        `json:"unread_reactions"`            // Information about unread reactions added to the message
		FactCheck               *FactCheck              `json:"fact_check"`                  // Information about fact-check added to the message; may be null if none
		MessageThreadID         int64                   `json:"message_thread_id"`           // If non-zero, the identifier of the message thread the message belongs to; unique within the chat to which the message belongs
		SavedMessagesTopicID    int64                   `json:"saved_messages_topic_id"`     // Identifier of the Saved Messages topic for the message; 0 for messages not from Saved Messages
		SelfDestructIn          float64                 `json:"self_destruct_in"`            // Time left before the message self-destruct timer expires, in seconds; 0 if self-destruction isn't scheduled yet
		AutoDeleteIn            float64                 `json:"auto_delete_in"`              // Time left before the message will be automatically deleted by message_auto_delete_time setting of the chat, in seconds; 0 if never
		ViaBotUserID            int64                   `json:"via_bot_user_id"`             // If non-zero, the user identifier of the inline bot through which this message was sent
		SenderBusinessBotUserID int64                   `json:"sender_business_bot_user_id"` // If non-zero, the user identifier of the business bot that sent this message
		SenderBoostCount        int32                   `json:"sender_boost_count"`          // Number of times the sender of the message boosted the supergroup at the time the message was sent; 0 if none or unknown. For messages sent by the current user, supergroupFullInfo.my_boost_count must be used instead
		AuthorSignature         string                  `json:"author_signature"`            // For channel posts and anonymous group messages, optional author signature
		MediaAlbumID            JSONInt64               `json:"media_album_id"`              // Unique identifier of an album this message belongs to; 0 if none. Only audios, documents, photos and videos can be grouped together in albums
		EffectID                JSONInt64               `json:"effect_id"`                   // Unique identifier of the effect added to the message; 0 if none
		HasSensitiveContent     bool                    `json:"has_sensitive_content"`       // True, if media content of the message must be hidden with 18+ spoiler
		RestrictionReason       string                  `json:"restriction_reason"`          // If non-empty, contains a human-readable description of the reason why access to this message must be restricted

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	message.tdCommon = tempObj.tdCommon
	message.ID = tempObj.ID
	message.ChatID = tempObj.ChatID
	message.IsOutgoing = tempObj.IsOutgoing
	message.IsPinned = tempObj.IsPinned
	message.IsFromOffline = tempObj.IsFromOffline
	message.CanBeSaved = tempObj.CanBeSaved
	message.HasTimestampedMedia = tempObj.HasTimestampedMedia
	message.IsChannelPost = tempObj.IsChannelPost
	message.IsTopicMessage = tempObj.IsTopicMessage
	message.ContainsUnreadMention = tempObj.ContainsUnreadMention
	message.Date = tempObj.Date
	message.EditDate = tempObj.EditDate
	message.ImportInfo = tempObj.ImportInfo
	message.InteractionInfo = tempObj.InteractionInfo
	message.UnreadReactions = tempObj.UnreadReactions
	message.FactCheck = tempObj.FactCheck
	message.MessageThreadID = tempObj.MessageThreadID
	message.SavedMessagesTopicID = tempObj.SavedMessagesTopicID
	message.SelfDestructIn = tempObj.SelfDestructIn
	message.AutoDeleteIn = tempObj.AutoDeleteIn
	message.ViaBotUserID = tempObj.ViaBotUserID
	message.SenderBusinessBotUserID = tempObj.SenderBusinessBotUserID
	message.SenderBoostCount = tempObj.SenderBoostCount
	message.AuthorSignature = tempObj.AuthorSignature
	message.MediaAlbumID = tempObj.MediaAlbumID
	message.EffectID = tempObj.EffectID
	message.HasSensitiveContent = tempObj.HasSensitiveContent
	message.RestrictionReason = tempObj.RestrictionReason

	fieldSenderID, _ := unmarshalMessageSender(objMap["sender_id"])
	message.SenderID = fieldSenderID

	fieldSendingState, _ := unmarshalMessageSendingState(objMap["sending_state"])
	message.SendingState = &fieldSendingState

	fieldSchedulingState, _ := unmarshalMessageSchedulingState(objMap["scheduling_state"])
	message.SchedulingState = &fieldSchedulingState

	fieldReplyTo, _ := unmarshalMessageReplyTo(objMap["reply_to"])
	message.ReplyTo = &fieldReplyTo

	fieldSelfDestructType, _ := unmarshalMessageSelfDestructType(objMap["self_destruct_type"])
	message.SelfDestructType = &fieldSelfDestructType

	fieldContent, _ := unmarshalMessageContent(objMap["content"])
	message.Content = fieldContent

	fieldReplyMarkup, _ := unmarshalReplyMarkup(objMap["reply_markup"])
	message.ReplyMarkup = &fieldReplyMarkup

	var forwardInfo MessageForwardInfo
	if objMap["forward_info"] != nil {
		err = forwardInfo.UnmarshalJSON(*objMap["forward_info"])
		if err != nil {
			return err
		}
	}

	message.ForwardInfo = &forwardInfo

	return nil
}

// Messages Contains a list of messages
type Messages struct {
	tdCommon
	TotalCount int32     `json:"total_count"` // Approximate total number of messages found
	Messages   []Message `json:"messages"`    // List of messages; messages may be null
}

// MessageType return the string telegram-type of Messages
func (messages *Messages) MessageType() string {
	return "messages"
}

// NewMessages creates a new Messages
//
// @param totalCount Approximate total number of messages found
// @param messages List of messages; messages may be null
func NewMessages(totalCount int32, messages []Message) *Messages {
	messagesTemp := Messages{
		tdCommon:   tdCommon{Type: "messages"},
		TotalCount: totalCount,
		Messages:   messages,
	}

	return &messagesTemp
}

// UnmarshalJSON unmarshal to json
func (messages *Messages) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32     `json:"total_count"` // Approximate total number of messages found
		Messages   []Message `json:"messages"`    // List of messages; messages may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messages.tdCommon = tempObj.tdCommon
	messages.TotalCount = tempObj.TotalCount
	messages.Messages = tempObj.Messages

	return nil
}

// FoundMessages Contains a list of messages found by a search
type FoundMessages struct {
	tdCommon
	TotalCount int32     `json:"total_count"` // Approximate total number of messages found; -1 if unknown
	Messages   []Message `json:"messages"`    // List of messages
	NextOffset string    `json:"next_offset"` // The offset for the next request. If empty, then there are no more results
}

// MessageType return the string telegram-type of FoundMessages
func (foundMessages *FoundMessages) MessageType() string {
	return "foundMessages"
}

// NewFoundMessages creates a new FoundMessages
//
// @param totalCount Approximate total number of messages found; -1 if unknown
// @param messages List of messages
// @param nextOffset The offset for the next request. If empty, then there are no more results
func NewFoundMessages(totalCount int32, messages []Message, nextOffset string) *FoundMessages {
	foundMessagesTemp := FoundMessages{
		tdCommon:   tdCommon{Type: "foundMessages"},
		TotalCount: totalCount,
		Messages:   messages,
		NextOffset: nextOffset,
	}

	return &foundMessagesTemp
}

// UnmarshalJSON unmarshal to json
func (foundMessages *FoundMessages) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32     `json:"total_count"` // Approximate total number of messages found; -1 if unknown
		Messages   []Message `json:"messages"`    // List of messages
		NextOffset string    `json:"next_offset"` // The offset for the next request. If empty, then there are no more results
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	foundMessages.tdCommon = tempObj.tdCommon
	foundMessages.TotalCount = tempObj.TotalCount
	foundMessages.Messages = tempObj.Messages
	foundMessages.NextOffset = tempObj.NextOffset

	return nil
}

// FoundChatMessages Contains a list of messages found by a search in a given chat
type FoundChatMessages struct {
	tdCommon
	TotalCount        int32     `json:"total_count"`          // Approximate total number of messages found; -1 if unknown
	Messages          []Message `json:"messages"`             // List of messages
	NextFromMessageID int64     `json:"next_from_message_id"` // The offset for the next request. If 0, there are no more results
}

// MessageType return the string telegram-type of FoundChatMessages
func (foundChatMessages *FoundChatMessages) MessageType() string {
	return "foundChatMessages"
}

// NewFoundChatMessages creates a new FoundChatMessages
//
// @param totalCount Approximate total number of messages found; -1 if unknown
// @param messages List of messages
// @param nextFromMessageID The offset for the next request. If 0, there are no more results
func NewFoundChatMessages(totalCount int32, messages []Message, nextFromMessageID int64) *FoundChatMessages {
	foundChatMessagesTemp := FoundChatMessages{
		tdCommon:          tdCommon{Type: "foundChatMessages"},
		TotalCount:        totalCount,
		Messages:          messages,
		NextFromMessageID: nextFromMessageID,
	}

	return &foundChatMessagesTemp
}

// UnmarshalJSON unmarshal to json
func (foundChatMessages *FoundChatMessages) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount        int32     `json:"total_count"`          // Approximate total number of messages found; -1 if unknown
		Messages          []Message `json:"messages"`             // List of messages
		NextFromMessageID int64     `json:"next_from_message_id"` // The offset for the next request. If 0, there are no more results
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	foundChatMessages.tdCommon = tempObj.tdCommon
	foundChatMessages.TotalCount = tempObj.TotalCount
	foundChatMessages.Messages = tempObj.Messages
	foundChatMessages.NextFromMessageID = tempObj.NextFromMessageID

	return nil
}

// MessagePosition Contains information about a message in a specific position
type MessagePosition struct {
	tdCommon
	Position  int32 `json:"position"`   // 0-based message position in the full list of suitable messages
	MessageID int64 `json:"message_id"` // Message identifier
	Date      int32 `json:"date"`       // Point in time (Unix timestamp) when the message was sent
}

// MessageType return the string telegram-type of MessagePosition
func (messagePosition *MessagePosition) MessageType() string {
	return "messagePosition"
}

// NewMessagePosition creates a new MessagePosition
//
// @param position 0-based message position in the full list of suitable messages
// @param messageID Message identifier
// @param date Point in time (Unix timestamp) when the message was sent
func NewMessagePosition(position int32, messageID int64, date int32) *MessagePosition {
	messagePositionTemp := MessagePosition{
		tdCommon:  tdCommon{Type: "messagePosition"},
		Position:  position,
		MessageID: messageID,
		Date:      date,
	}

	return &messagePositionTemp
}

// UnmarshalJSON unmarshal to json
func (messagePosition *MessagePosition) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Position  int32 `json:"position"`   // 0-based message position in the full list of suitable messages
		MessageID int64 `json:"message_id"` // Message identifier
		Date      int32 `json:"date"`       // Point in time (Unix timestamp) when the message was sent
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messagePosition.tdCommon = tempObj.tdCommon
	messagePosition.Position = tempObj.Position
	messagePosition.MessageID = tempObj.MessageID
	messagePosition.Date = tempObj.Date

	return nil
}

// MessagePositions Contains a list of message positions
type MessagePositions struct {
	tdCommon
	TotalCount int32             `json:"total_count"` // Total number of messages found
	Positions  []MessagePosition `json:"positions"`   // List of message positions
}

// MessageType return the string telegram-type of MessagePositions
func (messagePositions *MessagePositions) MessageType() string {
	return "messagePositions"
}

// NewMessagePositions creates a new MessagePositions
//
// @param totalCount Total number of messages found
// @param positions List of message positions
func NewMessagePositions(totalCount int32, positions []MessagePosition) *MessagePositions {
	messagePositionsTemp := MessagePositions{
		tdCommon:   tdCommon{Type: "messagePositions"},
		TotalCount: totalCount,
		Positions:  positions,
	}

	return &messagePositionsTemp
}

// UnmarshalJSON unmarshal to json
func (messagePositions *MessagePositions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32             `json:"total_count"` // Total number of messages found
		Positions  []MessagePosition `json:"positions"`   // List of message positions
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messagePositions.tdCommon = tempObj.tdCommon
	messagePositions.TotalCount = tempObj.TotalCount
	messagePositions.Positions = tempObj.Positions

	return nil
}

// MessageCalendarDay Contains information about found messages sent on a specific day
type MessageCalendarDay struct {
	tdCommon
	TotalCount int32    `json:"total_count"` // Total number of found messages sent on the day
	Message    *Message `json:"message"`     // First message sent on the day
}

// MessageType return the string telegram-type of MessageCalendarDay
func (messageCalendarDay *MessageCalendarDay) MessageType() string {
	return "messageCalendarDay"
}

// NewMessageCalendarDay creates a new MessageCalendarDay
//
// @param totalCount Total number of found messages sent on the day
// @param message First message sent on the day
func NewMessageCalendarDay(totalCount int32, message *Message) *MessageCalendarDay {
	messageCalendarDayTemp := MessageCalendarDay{
		tdCommon:   tdCommon{Type: "messageCalendarDay"},
		TotalCount: totalCount,
		Message:    message,
	}

	return &messageCalendarDayTemp
}

// UnmarshalJSON unmarshal to json
func (messageCalendarDay *MessageCalendarDay) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32 `json:"total_count"` // Total number of found messages sent on the day

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageCalendarDay.tdCommon = tempObj.tdCommon
	messageCalendarDay.TotalCount = tempObj.TotalCount

	var message Message
	if objMap["message"] != nil {
		err = message.UnmarshalJSON(*objMap["message"])
		if err != nil {
			return err
		}
	}

	messageCalendarDay.Message = &message

	return nil
}

// MessageCalendar Contains information about found messages, split by days according to the option "utc_time_offset"
type MessageCalendar struct {
	tdCommon
	TotalCount int32                `json:"total_count"` // Total number of found messages
	Days       []MessageCalendarDay `json:"days"`        // Information about messages sent
}

// MessageType return the string telegram-type of MessageCalendar
func (messageCalendar *MessageCalendar) MessageType() string {
	return "messageCalendar"
}

// NewMessageCalendar creates a new MessageCalendar
//
// @param totalCount Total number of found messages
// @param days Information about messages sent
func NewMessageCalendar(totalCount int32, days []MessageCalendarDay) *MessageCalendar {
	messageCalendarTemp := MessageCalendar{
		tdCommon:   tdCommon{Type: "messageCalendar"},
		TotalCount: totalCount,
		Days:       days,
	}

	return &messageCalendarTemp
}

// UnmarshalJSON unmarshal to json
func (messageCalendar *MessageCalendar) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32                `json:"total_count"` // Total number of found messages
		Days       []MessageCalendarDay `json:"days"`        // Information about messages sent
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageCalendar.tdCommon = tempObj.tdCommon
	messageCalendar.TotalCount = tempObj.TotalCount
	messageCalendar.Days = tempObj.Days

	return nil
}

// BusinessMessage Describes a message from a business account as received by a bot
type BusinessMessage struct {
	tdCommon
	Message        *Message `json:"message"`          // The message
	ReplyToMessage *Message `json:"reply_to_message"` // Message that is replied by the message in the same chat; may be null if none
}

// MessageType return the string telegram-type of BusinessMessage
func (businessMessage *BusinessMessage) MessageType() string {
	return "businessMessage"
}

// NewBusinessMessage creates a new BusinessMessage
//
// @param message The message
// @param replyToMessage Message that is replied by the message in the same chat; may be null if none
func NewBusinessMessage(message *Message, replyToMessage *Message) *BusinessMessage {
	businessMessageTemp := BusinessMessage{
		tdCommon:       tdCommon{Type: "businessMessage"},
		Message:        message,
		ReplyToMessage: replyToMessage,
	}

	return &businessMessageTemp
}

// UnmarshalJSON unmarshal to json
func (businessMessage *BusinessMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessMessage.tdCommon = tempObj.tdCommon

	var message Message
	if objMap["message"] != nil {
		err = message.UnmarshalJSON(*objMap["message"])
		if err != nil {
			return err
		}
	}

	businessMessage.Message = &message

	var replyToMessage Message
	if objMap["reply_to_message"] != nil {
		err = replyToMessage.UnmarshalJSON(*objMap["reply_to_message"])
		if err != nil {
			return err
		}
	}

	businessMessage.ReplyToMessage = &replyToMessage

	return nil
}

// BusinessMessages Contains a list of messages from a business account as received by a bot
type BusinessMessages struct {
	tdCommon
	Messages []BusinessMessage `json:"messages"` // List of business messages
}

// MessageType return the string telegram-type of BusinessMessages
func (businessMessages *BusinessMessages) MessageType() string {
	return "businessMessages"
}

// NewBusinessMessages creates a new BusinessMessages
//
// @param messages List of business messages
func NewBusinessMessages(messages []BusinessMessage) *BusinessMessages {
	businessMessagesTemp := BusinessMessages{
		tdCommon: tdCommon{Type: "businessMessages"},
		Messages: messages,
	}

	return &businessMessagesTemp
}

// UnmarshalJSON unmarshal to json
func (businessMessages *BusinessMessages) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Messages []BusinessMessage `json:"messages"` // List of business messages
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessMessages.tdCommon = tempObj.tdCommon
	businessMessages.Messages = tempObj.Messages

	return nil
}

// MessageSourceChatHistory The message is from a chat history
type MessageSourceChatHistory struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageSourceChatHistory
func (messageSourceChatHistory *MessageSourceChatHistory) MessageType() string {
	return "messageSourceChatHistory"
}

// NewMessageSourceChatHistory creates a new MessageSourceChatHistory
//
func NewMessageSourceChatHistory() *MessageSourceChatHistory {
	messageSourceChatHistoryTemp := MessageSourceChatHistory{
		tdCommon: tdCommon{Type: "messageSourceChatHistory"},
	}

	return &messageSourceChatHistoryTemp
}

// UnmarshalJSON unmarshal to json
func (messageSourceChatHistory *MessageSourceChatHistory) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSourceChatHistory.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageSourceEnum return the enum type of this object
func (messageSourceChatHistory *MessageSourceChatHistory) GetMessageSourceEnum() MessageSourceEnum {
	return MessageSourceChatHistoryType
}

// MessageSourceMessageThreadHistory The message is from a message thread history
type MessageSourceMessageThreadHistory struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageSourceMessageThreadHistory
func (messageSourceMessageThreadHistory *MessageSourceMessageThreadHistory) MessageType() string {
	return "messageSourceMessageThreadHistory"
}

// NewMessageSourceMessageThreadHistory creates a new MessageSourceMessageThreadHistory
//
func NewMessageSourceMessageThreadHistory() *MessageSourceMessageThreadHistory {
	messageSourceMessageThreadHistoryTemp := MessageSourceMessageThreadHistory{
		tdCommon: tdCommon{Type: "messageSourceMessageThreadHistory"},
	}

	return &messageSourceMessageThreadHistoryTemp
}

// UnmarshalJSON unmarshal to json
func (messageSourceMessageThreadHistory *MessageSourceMessageThreadHistory) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSourceMessageThreadHistory.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageSourceEnum return the enum type of this object
func (messageSourceMessageThreadHistory *MessageSourceMessageThreadHistory) GetMessageSourceEnum() MessageSourceEnum {
	return MessageSourceMessageThreadHistoryType
}

// MessageSourceForumTopicHistory The message is from a forum topic history
type MessageSourceForumTopicHistory struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageSourceForumTopicHistory
func (messageSourceForumTopicHistory *MessageSourceForumTopicHistory) MessageType() string {
	return "messageSourceForumTopicHistory"
}

// NewMessageSourceForumTopicHistory creates a new MessageSourceForumTopicHistory
//
func NewMessageSourceForumTopicHistory() *MessageSourceForumTopicHistory {
	messageSourceForumTopicHistoryTemp := MessageSourceForumTopicHistory{
		tdCommon: tdCommon{Type: "messageSourceForumTopicHistory"},
	}

	return &messageSourceForumTopicHistoryTemp
}

// UnmarshalJSON unmarshal to json
func (messageSourceForumTopicHistory *MessageSourceForumTopicHistory) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSourceForumTopicHistory.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageSourceEnum return the enum type of this object
func (messageSourceForumTopicHistory *MessageSourceForumTopicHistory) GetMessageSourceEnum() MessageSourceEnum {
	return MessageSourceForumTopicHistoryType
}

// MessageSourceHistoryPreview The message is from chat, message thread or forum topic history preview
type MessageSourceHistoryPreview struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageSourceHistoryPreview
func (messageSourceHistoryPreview *MessageSourceHistoryPreview) MessageType() string {
	return "messageSourceHistoryPreview"
}

// NewMessageSourceHistoryPreview creates a new MessageSourceHistoryPreview
//
func NewMessageSourceHistoryPreview() *MessageSourceHistoryPreview {
	messageSourceHistoryPreviewTemp := MessageSourceHistoryPreview{
		tdCommon: tdCommon{Type: "messageSourceHistoryPreview"},
	}

	return &messageSourceHistoryPreviewTemp
}

// UnmarshalJSON unmarshal to json
func (messageSourceHistoryPreview *MessageSourceHistoryPreview) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSourceHistoryPreview.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageSourceEnum return the enum type of this object
func (messageSourceHistoryPreview *MessageSourceHistoryPreview) GetMessageSourceEnum() MessageSourceEnum {
	return MessageSourceHistoryPreviewType
}

// MessageSourceChatList The message is from a chat list or a forum topic list
type MessageSourceChatList struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageSourceChatList
func (messageSourceChatList *MessageSourceChatList) MessageType() string {
	return "messageSourceChatList"
}

// NewMessageSourceChatList creates a new MessageSourceChatList
//
func NewMessageSourceChatList() *MessageSourceChatList {
	messageSourceChatListTemp := MessageSourceChatList{
		tdCommon: tdCommon{Type: "messageSourceChatList"},
	}

	return &messageSourceChatListTemp
}

// UnmarshalJSON unmarshal to json
func (messageSourceChatList *MessageSourceChatList) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSourceChatList.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageSourceEnum return the enum type of this object
func (messageSourceChatList *MessageSourceChatList) GetMessageSourceEnum() MessageSourceEnum {
	return MessageSourceChatListType
}

// MessageSourceSearch The message is from search results, including file downloads, local file list, outgoing document messages, calendar
type MessageSourceSearch struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageSourceSearch
func (messageSourceSearch *MessageSourceSearch) MessageType() string {
	return "messageSourceSearch"
}

// NewMessageSourceSearch creates a new MessageSourceSearch
//
func NewMessageSourceSearch() *MessageSourceSearch {
	messageSourceSearchTemp := MessageSourceSearch{
		tdCommon: tdCommon{Type: "messageSourceSearch"},
	}

	return &messageSourceSearchTemp
}

// UnmarshalJSON unmarshal to json
func (messageSourceSearch *MessageSourceSearch) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSourceSearch.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageSourceEnum return the enum type of this object
func (messageSourceSearch *MessageSourceSearch) GetMessageSourceEnum() MessageSourceEnum {
	return MessageSourceSearchType
}

// MessageSourceChatEventLog The message is from a chat event log
type MessageSourceChatEventLog struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageSourceChatEventLog
func (messageSourceChatEventLog *MessageSourceChatEventLog) MessageType() string {
	return "messageSourceChatEventLog"
}

// NewMessageSourceChatEventLog creates a new MessageSourceChatEventLog
//
func NewMessageSourceChatEventLog() *MessageSourceChatEventLog {
	messageSourceChatEventLogTemp := MessageSourceChatEventLog{
		tdCommon: tdCommon{Type: "messageSourceChatEventLog"},
	}

	return &messageSourceChatEventLogTemp
}

// UnmarshalJSON unmarshal to json
func (messageSourceChatEventLog *MessageSourceChatEventLog) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSourceChatEventLog.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageSourceEnum return the enum type of this object
func (messageSourceChatEventLog *MessageSourceChatEventLog) GetMessageSourceEnum() MessageSourceEnum {
	return MessageSourceChatEventLogType
}

// MessageSourceNotification The message is from a notification
type MessageSourceNotification struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageSourceNotification
func (messageSourceNotification *MessageSourceNotification) MessageType() string {
	return "messageSourceNotification"
}

// NewMessageSourceNotification creates a new MessageSourceNotification
//
func NewMessageSourceNotification() *MessageSourceNotification {
	messageSourceNotificationTemp := MessageSourceNotification{
		tdCommon: tdCommon{Type: "messageSourceNotification"},
	}

	return &messageSourceNotificationTemp
}

// UnmarshalJSON unmarshal to json
func (messageSourceNotification *MessageSourceNotification) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSourceNotification.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageSourceEnum return the enum type of this object
func (messageSourceNotification *MessageSourceNotification) GetMessageSourceEnum() MessageSourceEnum {
	return MessageSourceNotificationType
}

// MessageSourceScreenshot The message was screenshotted; the source must be used only if the message content was visible during the screenshot
type MessageSourceScreenshot struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageSourceScreenshot
func (messageSourceScreenshot *MessageSourceScreenshot) MessageType() string {
	return "messageSourceScreenshot"
}

// NewMessageSourceScreenshot creates a new MessageSourceScreenshot
//
func NewMessageSourceScreenshot() *MessageSourceScreenshot {
	messageSourceScreenshotTemp := MessageSourceScreenshot{
		tdCommon: tdCommon{Type: "messageSourceScreenshot"},
	}

	return &messageSourceScreenshotTemp
}

// UnmarshalJSON unmarshal to json
func (messageSourceScreenshot *MessageSourceScreenshot) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSourceScreenshot.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageSourceEnum return the enum type of this object
func (messageSourceScreenshot *MessageSourceScreenshot) GetMessageSourceEnum() MessageSourceEnum {
	return MessageSourceScreenshotType
}

// MessageSourceOther The message is from some other source
type MessageSourceOther struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageSourceOther
func (messageSourceOther *MessageSourceOther) MessageType() string {
	return "messageSourceOther"
}

// NewMessageSourceOther creates a new MessageSourceOther
//
func NewMessageSourceOther() *MessageSourceOther {
	messageSourceOtherTemp := MessageSourceOther{
		tdCommon: tdCommon{Type: "messageSourceOther"},
	}

	return &messageSourceOtherTemp
}

// UnmarshalJSON unmarshal to json
func (messageSourceOther *MessageSourceOther) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSourceOther.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageSourceEnum return the enum type of this object
func (messageSourceOther *MessageSourceOther) GetMessageSourceEnum() MessageSourceEnum {
	return MessageSourceOtherType
}

// MessageSponsor Information about the sponsor of a message
type MessageSponsor struct {
	tdCommon
	URL   string `json:"url"`   // URL of the sponsor to be opened when the message is clicked
	Photo *Photo `json:"photo"` // Photo of the sponsor; may be null if must not be shown
	Info  string `json:"info"`  // Additional optional information about the sponsor to be shown along with the message
}

// MessageType return the string telegram-type of MessageSponsor
func (messageSponsor *MessageSponsor) MessageType() string {
	return "messageSponsor"
}

// NewMessageSponsor creates a new MessageSponsor
//
// @param uRL URL of the sponsor to be opened when the message is clicked
// @param photo Photo of the sponsor; may be null if must not be shown
// @param info Additional optional information about the sponsor to be shown along with the message
func NewMessageSponsor(uRL string, photo *Photo, info string) *MessageSponsor {
	messageSponsorTemp := MessageSponsor{
		tdCommon: tdCommon{Type: "messageSponsor"},
		URL:      uRL,
		Photo:    photo,
		Info:     info,
	}

	return &messageSponsorTemp
}

// UnmarshalJSON unmarshal to json
func (messageSponsor *MessageSponsor) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL   string `json:"url"`   // URL of the sponsor to be opened when the message is clicked
		Photo *Photo `json:"photo"` // Photo of the sponsor; may be null if must not be shown
		Info  string `json:"info"`  // Additional optional information about the sponsor to be shown along with the message
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSponsor.tdCommon = tempObj.tdCommon
	messageSponsor.URL = tempObj.URL
	messageSponsor.Photo = tempObj.Photo
	messageSponsor.Info = tempObj.Info

	return nil
}

// SponsoredMessage Describes a sponsored message
type SponsoredMessage struct {
	tdCommon
	MessageID               int64           `json:"message_id"`                 // Message identifier; unique for the chat to which the sponsored message belongs among both ordinary and sponsored messages
	IsRecommended           bool            `json:"is_recommended"`             // True, if the message needs to be labeled as "recommended" instead of "sponsored"
	CanBeReported           bool            `json:"can_be_reported"`            // True, if the message can be reported to Telegram moderators through reportChatSponsoredMessage
	Content                 MessageContent  `json:"content"`                    // Content of the message. Currently, can be only of the types messageText, messageAnimation, messagePhoto, or messageVideo
	Sponsor                 *MessageSponsor `json:"sponsor"`                    // Information about the sponsor of the message
	Title                   string          `json:"title"`                      // Title of the sponsored message
	ButtonText              string          `json:"button_text"`                // Text for the message action button
	AccentColorID           int32           `json:"accent_color_id"`            // Identifier of the accent color for title, button text and message background
	BackgroundCustomEmojiID JSONInt64       `json:"background_custom_emoji_id"` // Identifier of a custom emoji to be shown on the message background; 0 if none
	AdditionalInfo          string          `json:"additional_info"`            // If non-empty, additional information about the sponsored message to be shown along with the message
}

// MessageType return the string telegram-type of SponsoredMessage
func (sponsoredMessage *SponsoredMessage) MessageType() string {
	return "sponsoredMessage"
}

// NewSponsoredMessage creates a new SponsoredMessage
//
// @param messageID Message identifier; unique for the chat to which the sponsored message belongs among both ordinary and sponsored messages
// @param isRecommended True, if the message needs to be labeled as "recommended" instead of "sponsored"
// @param canBeReported True, if the message can be reported to Telegram moderators through reportChatSponsoredMessage
// @param content Content of the message. Currently, can be only of the types messageText, messageAnimation, messagePhoto, or messageVideo
// @param sponsor Information about the sponsor of the message
// @param title Title of the sponsored message
// @param buttonText Text for the message action button
// @param accentColorID Identifier of the accent color for title, button text and message background
// @param backgroundCustomEmojiID Identifier of a custom emoji to be shown on the message background; 0 if none
// @param additionalInfo If non-empty, additional information about the sponsored message to be shown along with the message
func NewSponsoredMessage(messageID int64, isRecommended bool, canBeReported bool, content MessageContent, sponsor *MessageSponsor, title string, buttonText string, accentColorID int32, backgroundCustomEmojiID JSONInt64, additionalInfo string) *SponsoredMessage {
	sponsoredMessageTemp := SponsoredMessage{
		tdCommon:                tdCommon{Type: "sponsoredMessage"},
		MessageID:               messageID,
		IsRecommended:           isRecommended,
		CanBeReported:           canBeReported,
		Content:                 content,
		Sponsor:                 sponsor,
		Title:                   title,
		ButtonText:              buttonText,
		AccentColorID:           accentColorID,
		BackgroundCustomEmojiID: backgroundCustomEmojiID,
		AdditionalInfo:          additionalInfo,
	}

	return &sponsoredMessageTemp
}

// UnmarshalJSON unmarshal to json
func (sponsoredMessage *SponsoredMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MessageID               int64           `json:"message_id"`                 // Message identifier; unique for the chat to which the sponsored message belongs among both ordinary and sponsored messages
		IsRecommended           bool            `json:"is_recommended"`             // True, if the message needs to be labeled as "recommended" instead of "sponsored"
		CanBeReported           bool            `json:"can_be_reported"`            // True, if the message can be reported to Telegram moderators through reportChatSponsoredMessage
		Sponsor                 *MessageSponsor `json:"sponsor"`                    // Information about the sponsor of the message
		Title                   string          `json:"title"`                      // Title of the sponsored message
		ButtonText              string          `json:"button_text"`                // Text for the message action button
		AccentColorID           int32           `json:"accent_color_id"`            // Identifier of the accent color for title, button text and message background
		BackgroundCustomEmojiID JSONInt64       `json:"background_custom_emoji_id"` // Identifier of a custom emoji to be shown on the message background; 0 if none
		AdditionalInfo          string          `json:"additional_info"`            // If non-empty, additional information about the sponsored message to be shown along with the message
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sponsoredMessage.tdCommon = tempObj.tdCommon
	sponsoredMessage.MessageID = tempObj.MessageID
	sponsoredMessage.IsRecommended = tempObj.IsRecommended
	sponsoredMessage.CanBeReported = tempObj.CanBeReported
	sponsoredMessage.Sponsor = tempObj.Sponsor
	sponsoredMessage.Title = tempObj.Title
	sponsoredMessage.ButtonText = tempObj.ButtonText
	sponsoredMessage.AccentColorID = tempObj.AccentColorID
	sponsoredMessage.BackgroundCustomEmojiID = tempObj.BackgroundCustomEmojiID
	sponsoredMessage.AdditionalInfo = tempObj.AdditionalInfo

	fieldContent, _ := unmarshalMessageContent(objMap["content"])
	sponsoredMessage.Content = fieldContent

	return nil
}

// SponsoredMessages Contains a list of sponsored messages
type SponsoredMessages struct {
	tdCommon
	Messages        []SponsoredMessage `json:"messages"`         // List of sponsored messages
	MessagesBetween int32              `json:"messages_between"` // The minimum number of messages between shown sponsored messages, or 0 if only one sponsored message must be shown after all ordinary messages
}

// MessageType return the string telegram-type of SponsoredMessages
func (sponsoredMessages *SponsoredMessages) MessageType() string {
	return "sponsoredMessages"
}

// NewSponsoredMessages creates a new SponsoredMessages
//
// @param messages List of sponsored messages
// @param messagesBetween The minimum number of messages between shown sponsored messages, or 0 if only one sponsored message must be shown after all ordinary messages
func NewSponsoredMessages(messages []SponsoredMessage, messagesBetween int32) *SponsoredMessages {
	sponsoredMessagesTemp := SponsoredMessages{
		tdCommon:        tdCommon{Type: "sponsoredMessages"},
		Messages:        messages,
		MessagesBetween: messagesBetween,
	}

	return &sponsoredMessagesTemp
}

// UnmarshalJSON unmarshal to json
func (sponsoredMessages *SponsoredMessages) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Messages        []SponsoredMessage `json:"messages"`         // List of sponsored messages
		MessagesBetween int32              `json:"messages_between"` // The minimum number of messages between shown sponsored messages, or 0 if only one sponsored message must be shown after all ordinary messages
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sponsoredMessages.tdCommon = tempObj.tdCommon
	sponsoredMessages.Messages = tempObj.Messages
	sponsoredMessages.MessagesBetween = tempObj.MessagesBetween

	return nil
}

// ReportChatSponsoredMessageOption Describes an option to report a sponsored message
type ReportChatSponsoredMessageOption struct {
	tdCommon
	ID   []byte `json:"id"`   // Unique identifier of the option
	Text string `json:"text"` // Text of the option
}

// MessageType return the string telegram-type of ReportChatSponsoredMessageOption
func (reportChatSponsoredMessageOption *ReportChatSponsoredMessageOption) MessageType() string {
	return "reportChatSponsoredMessageOption"
}

// NewReportChatSponsoredMessageOption creates a new ReportChatSponsoredMessageOption
//
// @param iD Unique identifier of the option
// @param text Text of the option
func NewReportChatSponsoredMessageOption(iD []byte, text string) *ReportChatSponsoredMessageOption {
	reportChatSponsoredMessageOptionTemp := ReportChatSponsoredMessageOption{
		tdCommon: tdCommon{Type: "reportChatSponsoredMessageOption"},
		ID:       iD,
		Text:     text,
	}

	return &reportChatSponsoredMessageOptionTemp
}

// UnmarshalJSON unmarshal to json
func (reportChatSponsoredMessageOption *ReportChatSponsoredMessageOption) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID   []byte `json:"id"`   // Unique identifier of the option
		Text string `json:"text"` // Text of the option
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reportChatSponsoredMessageOption.tdCommon = tempObj.tdCommon
	reportChatSponsoredMessageOption.ID = tempObj.ID
	reportChatSponsoredMessageOption.Text = tempObj.Text

	return nil
}

// ReportChatSponsoredMessageResultOk The message was reported successfully
type ReportChatSponsoredMessageResultOk struct {
	tdCommon
}

// MessageType return the string telegram-type of ReportChatSponsoredMessageResultOk
func (reportChatSponsoredMessageResultOk *ReportChatSponsoredMessageResultOk) MessageType() string {
	return "reportChatSponsoredMessageResultOk"
}

// NewReportChatSponsoredMessageResultOk creates a new ReportChatSponsoredMessageResultOk
//
func NewReportChatSponsoredMessageResultOk() *ReportChatSponsoredMessageResultOk {
	reportChatSponsoredMessageResultOkTemp := ReportChatSponsoredMessageResultOk{
		tdCommon: tdCommon{Type: "reportChatSponsoredMessageResultOk"},
	}

	return &reportChatSponsoredMessageResultOkTemp
}

// UnmarshalJSON unmarshal to json
func (reportChatSponsoredMessageResultOk *ReportChatSponsoredMessageResultOk) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reportChatSponsoredMessageResultOk.tdCommon = tempObj.tdCommon

	return nil
}

// GetReportChatSponsoredMessageResultEnum return the enum type of this object
func (reportChatSponsoredMessageResultOk *ReportChatSponsoredMessageResultOk) GetReportChatSponsoredMessageResultEnum() ReportChatSponsoredMessageResultEnum {
	return ReportChatSponsoredMessageResultOkType
}

// ReportChatSponsoredMessageResultFailed The sponsored message is too old or not found
type ReportChatSponsoredMessageResultFailed struct {
	tdCommon
}

// MessageType return the string telegram-type of ReportChatSponsoredMessageResultFailed
func (reportChatSponsoredMessageResultFailed *ReportChatSponsoredMessageResultFailed) MessageType() string {
	return "reportChatSponsoredMessageResultFailed"
}

// NewReportChatSponsoredMessageResultFailed creates a new ReportChatSponsoredMessageResultFailed
//
func NewReportChatSponsoredMessageResultFailed() *ReportChatSponsoredMessageResultFailed {
	reportChatSponsoredMessageResultFailedTemp := ReportChatSponsoredMessageResultFailed{
		tdCommon: tdCommon{Type: "reportChatSponsoredMessageResultFailed"},
	}

	return &reportChatSponsoredMessageResultFailedTemp
}

// UnmarshalJSON unmarshal to json
func (reportChatSponsoredMessageResultFailed *ReportChatSponsoredMessageResultFailed) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reportChatSponsoredMessageResultFailed.tdCommon = tempObj.tdCommon

	return nil
}

// GetReportChatSponsoredMessageResultEnum return the enum type of this object
func (reportChatSponsoredMessageResultFailed *ReportChatSponsoredMessageResultFailed) GetReportChatSponsoredMessageResultEnum() ReportChatSponsoredMessageResultEnum {
	return ReportChatSponsoredMessageResultFailedType
}

// ReportChatSponsoredMessageResultOptionRequired The user must choose an option to report the message and repeat request with the chosen option
type ReportChatSponsoredMessageResultOptionRequired struct {
	tdCommon
	Title   string                             `json:"title"`   // Title for the option choice
	Options []ReportChatSponsoredMessageOption `json:"options"` // List of available options
}

// MessageType return the string telegram-type of ReportChatSponsoredMessageResultOptionRequired
func (reportChatSponsoredMessageResultOptionRequired *ReportChatSponsoredMessageResultOptionRequired) MessageType() string {
	return "reportChatSponsoredMessageResultOptionRequired"
}

// NewReportChatSponsoredMessageResultOptionRequired creates a new ReportChatSponsoredMessageResultOptionRequired
//
// @param title Title for the option choice
// @param options List of available options
func NewReportChatSponsoredMessageResultOptionRequired(title string, options []ReportChatSponsoredMessageOption) *ReportChatSponsoredMessageResultOptionRequired {
	reportChatSponsoredMessageResultOptionRequiredTemp := ReportChatSponsoredMessageResultOptionRequired{
		tdCommon: tdCommon{Type: "reportChatSponsoredMessageResultOptionRequired"},
		Title:    title,
		Options:  options,
	}

	return &reportChatSponsoredMessageResultOptionRequiredTemp
}

// UnmarshalJSON unmarshal to json
func (reportChatSponsoredMessageResultOptionRequired *ReportChatSponsoredMessageResultOptionRequired) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Title   string                             `json:"title"`   // Title for the option choice
		Options []ReportChatSponsoredMessageOption `json:"options"` // List of available options
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reportChatSponsoredMessageResultOptionRequired.tdCommon = tempObj.tdCommon
	reportChatSponsoredMessageResultOptionRequired.Title = tempObj.Title
	reportChatSponsoredMessageResultOptionRequired.Options = tempObj.Options

	return nil
}

// GetReportChatSponsoredMessageResultEnum return the enum type of this object
func (reportChatSponsoredMessageResultOptionRequired *ReportChatSponsoredMessageResultOptionRequired) GetReportChatSponsoredMessageResultEnum() ReportChatSponsoredMessageResultEnum {
	return ReportChatSponsoredMessageResultOptionRequiredType
}

// ReportChatSponsoredMessageResultAdsHidden Sponsored messages were hidden for the user in all chats
type ReportChatSponsoredMessageResultAdsHidden struct {
	tdCommon
}

// MessageType return the string telegram-type of ReportChatSponsoredMessageResultAdsHidden
func (reportChatSponsoredMessageResultAdsHidden *ReportChatSponsoredMessageResultAdsHidden) MessageType() string {
	return "reportChatSponsoredMessageResultAdsHidden"
}

// NewReportChatSponsoredMessageResultAdsHidden creates a new ReportChatSponsoredMessageResultAdsHidden
//
func NewReportChatSponsoredMessageResultAdsHidden() *ReportChatSponsoredMessageResultAdsHidden {
	reportChatSponsoredMessageResultAdsHiddenTemp := ReportChatSponsoredMessageResultAdsHidden{
		tdCommon: tdCommon{Type: "reportChatSponsoredMessageResultAdsHidden"},
	}

	return &reportChatSponsoredMessageResultAdsHiddenTemp
}

// UnmarshalJSON unmarshal to json
func (reportChatSponsoredMessageResultAdsHidden *ReportChatSponsoredMessageResultAdsHidden) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reportChatSponsoredMessageResultAdsHidden.tdCommon = tempObj.tdCommon

	return nil
}

// GetReportChatSponsoredMessageResultEnum return the enum type of this object
func (reportChatSponsoredMessageResultAdsHidden *ReportChatSponsoredMessageResultAdsHidden) GetReportChatSponsoredMessageResultEnum() ReportChatSponsoredMessageResultEnum {
	return ReportChatSponsoredMessageResultAdsHiddenType
}

// ReportChatSponsoredMessageResultPremiumRequired The user asked to hide sponsored messages, but Telegram Premium is required for this
type ReportChatSponsoredMessageResultPremiumRequired struct {
	tdCommon
}

// MessageType return the string telegram-type of ReportChatSponsoredMessageResultPremiumRequired
func (reportChatSponsoredMessageResultPremiumRequired *ReportChatSponsoredMessageResultPremiumRequired) MessageType() string {
	return "reportChatSponsoredMessageResultPremiumRequired"
}

// NewReportChatSponsoredMessageResultPremiumRequired creates a new ReportChatSponsoredMessageResultPremiumRequired
//
func NewReportChatSponsoredMessageResultPremiumRequired() *ReportChatSponsoredMessageResultPremiumRequired {
	reportChatSponsoredMessageResultPremiumRequiredTemp := ReportChatSponsoredMessageResultPremiumRequired{
		tdCommon: tdCommon{Type: "reportChatSponsoredMessageResultPremiumRequired"},
	}

	return &reportChatSponsoredMessageResultPremiumRequiredTemp
}

// UnmarshalJSON unmarshal to json
func (reportChatSponsoredMessageResultPremiumRequired *ReportChatSponsoredMessageResultPremiumRequired) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reportChatSponsoredMessageResultPremiumRequired.tdCommon = tempObj.tdCommon

	return nil
}

// GetReportChatSponsoredMessageResultEnum return the enum type of this object
func (reportChatSponsoredMessageResultPremiumRequired *ReportChatSponsoredMessageResultPremiumRequired) GetReportChatSponsoredMessageResultEnum() ReportChatSponsoredMessageResultEnum {
	return ReportChatSponsoredMessageResultPremiumRequiredType
}

// FileDownload Describes a file added to file download list
type FileDownload struct {
	tdCommon
	FileID       int32    `json:"file_id"`       // File identifier
	Message      *Message `json:"message"`       // The message with the file
	AddDate      int32    `json:"add_date"`      // Point in time (Unix timestamp) when the file was added to the download list
	CompleteDate int32    `json:"complete_date"` // Point in time (Unix timestamp) when the file downloading was completed; 0 if the file downloading isn't completed
	IsPaused     bool     `json:"is_paused"`     // True, if downloading of the file is paused
}

// MessageType return the string telegram-type of FileDownload
func (fileDownload *FileDownload) MessageType() string {
	return "fileDownload"
}

// NewFileDownload creates a new FileDownload
//
// @param fileID File identifier
// @param message The message with the file
// @param addDate Point in time (Unix timestamp) when the file was added to the download list
// @param completeDate Point in time (Unix timestamp) when the file downloading was completed; 0 if the file downloading isn't completed
// @param isPaused True, if downloading of the file is paused
func NewFileDownload(fileID int32, message *Message, addDate int32, completeDate int32, isPaused bool) *FileDownload {
	fileDownloadTemp := FileDownload{
		tdCommon:     tdCommon{Type: "fileDownload"},
		FileID:       fileID,
		Message:      message,
		AddDate:      addDate,
		CompleteDate: completeDate,
		IsPaused:     isPaused,
	}

	return &fileDownloadTemp
}

// UnmarshalJSON unmarshal to json
func (fileDownload *FileDownload) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		FileID       int32 `json:"file_id"`       // File identifier
		AddDate      int32 `json:"add_date"`      // Point in time (Unix timestamp) when the file was added to the download list
		CompleteDate int32 `json:"complete_date"` // Point in time (Unix timestamp) when the file downloading was completed; 0 if the file downloading isn't completed
		IsPaused     bool  `json:"is_paused"`     // True, if downloading of the file is paused
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	fileDownload.tdCommon = tempObj.tdCommon
	fileDownload.FileID = tempObj.FileID
	fileDownload.AddDate = tempObj.AddDate
	fileDownload.CompleteDate = tempObj.CompleteDate
	fileDownload.IsPaused = tempObj.IsPaused

	var message Message
	if objMap["message"] != nil {
		err = message.UnmarshalJSON(*objMap["message"])
		if err != nil {
			return err
		}
	}

	fileDownload.Message = &message

	return nil
}

// DownloadedFileCounts Contains number of being downloaded and recently downloaded files found
type DownloadedFileCounts struct {
	tdCommon
	ActiveCount    int32 `json:"active_count"`    // Number of active file downloads found, including paused
	PausedCount    int32 `json:"paused_count"`    // Number of paused file downloads found
	CompletedCount int32 `json:"completed_count"` // Number of completed file downloads found
}

// MessageType return the string telegram-type of DownloadedFileCounts
func (downloadedFileCounts *DownloadedFileCounts) MessageType() string {
	return "downloadedFileCounts"
}

// NewDownloadedFileCounts creates a new DownloadedFileCounts
//
// @param activeCount Number of active file downloads found, including paused
// @param pausedCount Number of paused file downloads found
// @param completedCount Number of completed file downloads found
func NewDownloadedFileCounts(activeCount int32, pausedCount int32, completedCount int32) *DownloadedFileCounts {
	downloadedFileCountsTemp := DownloadedFileCounts{
		tdCommon:       tdCommon{Type: "downloadedFileCounts"},
		ActiveCount:    activeCount,
		PausedCount:    pausedCount,
		CompletedCount: completedCount,
	}

	return &downloadedFileCountsTemp
}

// UnmarshalJSON unmarshal to json
func (downloadedFileCounts *DownloadedFileCounts) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ActiveCount    int32 `json:"active_count"`    // Number of active file downloads found, including paused
		PausedCount    int32 `json:"paused_count"`    // Number of paused file downloads found
		CompletedCount int32 `json:"completed_count"` // Number of completed file downloads found
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	downloadedFileCounts.tdCommon = tempObj.tdCommon
	downloadedFileCounts.ActiveCount = tempObj.ActiveCount
	downloadedFileCounts.PausedCount = tempObj.PausedCount
	downloadedFileCounts.CompletedCount = tempObj.CompletedCount

	return nil
}

// FoundFileDownloads Contains a list of downloaded files, found by a search
type FoundFileDownloads struct {
	tdCommon
	TotalCounts *DownloadedFileCounts `json:"total_counts"` // Total number of suitable files, ignoring offset
	Files       []FileDownload        `json:"files"`        // The list of files
	NextOffset  string                `json:"next_offset"`  // The offset for the next request. If empty, then there are no more results
}

// MessageType return the string telegram-type of FoundFileDownloads
func (foundFileDownloads *FoundFileDownloads) MessageType() string {
	return "foundFileDownloads"
}

// NewFoundFileDownloads creates a new FoundFileDownloads
//
// @param totalCounts Total number of suitable files, ignoring offset
// @param files The list of files
// @param nextOffset The offset for the next request. If empty, then there are no more results
func NewFoundFileDownloads(totalCounts *DownloadedFileCounts, files []FileDownload, nextOffset string) *FoundFileDownloads {
	foundFileDownloadsTemp := FoundFileDownloads{
		tdCommon:    tdCommon{Type: "foundFileDownloads"},
		TotalCounts: totalCounts,
		Files:       files,
		NextOffset:  nextOffset,
	}

	return &foundFileDownloadsTemp
}

// UnmarshalJSON unmarshal to json
func (foundFileDownloads *FoundFileDownloads) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCounts *DownloadedFileCounts `json:"total_counts"` // Total number of suitable files, ignoring offset
		Files       []FileDownload        `json:"files"`        // The list of files
		NextOffset  string                `json:"next_offset"`  // The offset for the next request. If empty, then there are no more results
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	foundFileDownloads.tdCommon = tempObj.tdCommon
	foundFileDownloads.TotalCounts = tempObj.TotalCounts
	foundFileDownloads.Files = tempObj.Files
	foundFileDownloads.NextOffset = tempObj.NextOffset

	return nil
}

// NotificationSettingsScopePrivateChats Notification settings applied to all private and secret chats when the corresponding chat setting has a default value
type NotificationSettingsScopePrivateChats struct {
	tdCommon
}

// MessageType return the string telegram-type of NotificationSettingsScopePrivateChats
func (notificationSettingsScopePrivateChats *NotificationSettingsScopePrivateChats) MessageType() string {
	return "notificationSettingsScopePrivateChats"
}

// NewNotificationSettingsScopePrivateChats creates a new NotificationSettingsScopePrivateChats
//
func NewNotificationSettingsScopePrivateChats() *NotificationSettingsScopePrivateChats {
	notificationSettingsScopePrivateChatsTemp := NotificationSettingsScopePrivateChats{
		tdCommon: tdCommon{Type: "notificationSettingsScopePrivateChats"},
	}

	return &notificationSettingsScopePrivateChatsTemp
}

// UnmarshalJSON unmarshal to json
func (notificationSettingsScopePrivateChats *NotificationSettingsScopePrivateChats) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	notificationSettingsScopePrivateChats.tdCommon = tempObj.tdCommon

	return nil
}

// GetNotificationSettingsScopeEnum return the enum type of this object
func (notificationSettingsScopePrivateChats *NotificationSettingsScopePrivateChats) GetNotificationSettingsScopeEnum() NotificationSettingsScopeEnum {
	return NotificationSettingsScopePrivateChatsType
}

// NotificationSettingsScopeGroupChats Notification settings applied to all basic group and supergroup chats when the corresponding chat setting has a default value
type NotificationSettingsScopeGroupChats struct {
	tdCommon
}

// MessageType return the string telegram-type of NotificationSettingsScopeGroupChats
func (notificationSettingsScopeGroupChats *NotificationSettingsScopeGroupChats) MessageType() string {
	return "notificationSettingsScopeGroupChats"
}

// NewNotificationSettingsScopeGroupChats creates a new NotificationSettingsScopeGroupChats
//
func NewNotificationSettingsScopeGroupChats() *NotificationSettingsScopeGroupChats {
	notificationSettingsScopeGroupChatsTemp := NotificationSettingsScopeGroupChats{
		tdCommon: tdCommon{Type: "notificationSettingsScopeGroupChats"},
	}

	return &notificationSettingsScopeGroupChatsTemp
}

// UnmarshalJSON unmarshal to json
func (notificationSettingsScopeGroupChats *NotificationSettingsScopeGroupChats) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	notificationSettingsScopeGroupChats.tdCommon = tempObj.tdCommon

	return nil
}

// GetNotificationSettingsScopeEnum return the enum type of this object
func (notificationSettingsScopeGroupChats *NotificationSettingsScopeGroupChats) GetNotificationSettingsScopeEnum() NotificationSettingsScopeEnum {
	return NotificationSettingsScopeGroupChatsType
}

// NotificationSettingsScopeChannelChats Notification settings applied to all channel chats when the corresponding chat setting has a default value
type NotificationSettingsScopeChannelChats struct {
	tdCommon
}

// MessageType return the string telegram-type of NotificationSettingsScopeChannelChats
func (notificationSettingsScopeChannelChats *NotificationSettingsScopeChannelChats) MessageType() string {
	return "notificationSettingsScopeChannelChats"
}

// NewNotificationSettingsScopeChannelChats creates a new NotificationSettingsScopeChannelChats
//
func NewNotificationSettingsScopeChannelChats() *NotificationSettingsScopeChannelChats {
	notificationSettingsScopeChannelChatsTemp := NotificationSettingsScopeChannelChats{
		tdCommon: tdCommon{Type: "notificationSettingsScopeChannelChats"},
	}

	return &notificationSettingsScopeChannelChatsTemp
}

// UnmarshalJSON unmarshal to json
func (notificationSettingsScopeChannelChats *NotificationSettingsScopeChannelChats) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	notificationSettingsScopeChannelChats.tdCommon = tempObj.tdCommon

	return nil
}

// GetNotificationSettingsScopeEnum return the enum type of this object
func (notificationSettingsScopeChannelChats *NotificationSettingsScopeChannelChats) GetNotificationSettingsScopeEnum() NotificationSettingsScopeEnum {
	return NotificationSettingsScopeChannelChatsType
}

// ChatNotificationSettings Contains information about notification settings for a chat or a forum topic
type ChatNotificationSettings struct {
	tdCommon
	UseDefaultMuteFor                           bool      `json:"use_default_mute_for"`                             // If true, the value for the relevant type of chat or the forum chat is used instead of mute_for
	MuteFor                                     int32     `json:"mute_for"`                                         // Time left before notifications will be unmuted, in seconds
	UseDefaultSound                             bool      `json:"use_default_sound"`                                // If true, the value for the relevant type of chat or the forum chat is used instead of sound_id
	SoundID                                     JSONInt64 `json:"sound_id"`                                         // Identifier of the notification sound to be played for messages; 0 if sound is disabled
	UseDefaultShowPreview                       bool      `json:"use_default_show_preview"`                         // If true, the value for the relevant type of chat or the forum chat is used instead of show_preview
	ShowPreview                                 bool      `json:"show_preview"`                                     // True, if message content must be displayed in notifications
	UseDefaultMuteStories                       bool      `json:"use_default_mute_stories"`                         // If true, the value for the relevant type of chat is used instead of mute_stories
	MuteStories                                 bool      `json:"mute_stories"`                                     // True, if story notifications are disabled for the chat
	UseDefaultStorySound                        bool      `json:"use_default_story_sound"`                          // If true, the value for the relevant type of chat is used instead of story_sound_id
	StorySoundID                                JSONInt64 `json:"story_sound_id"`                                   // Identifier of the notification sound to be played for stories; 0 if sound is disabled
	UseDefaultShowStorySender                   bool      `json:"use_default_show_story_sender"`                    // If true, the value for the relevant type of chat is used instead of show_story_sender
	ShowStorySender                             bool      `json:"show_story_sender"`                                // True, if the sender of stories must be displayed in notifications
	UseDefaultDisablePinnedMessageNotifications bool      `json:"use_default_disable_pinned_message_notifications"` // If true, the value for the relevant type of chat or the forum chat is used instead of disable_pinned_message_notifications
	DisablePinnedMessageNotifications           bool      `json:"disable_pinned_message_notifications"`             // If true, notifications for incoming pinned messages will be created as for an ordinary unread message
	UseDefaultDisableMentionNotifications       bool      `json:"use_default_disable_mention_notifications"`        // If true, the value for the relevant type of chat or the forum chat is used instead of disable_mention_notifications
	DisableMentionNotifications                 bool      `json:"disable_mention_notifications"`                    // If true, notifications for messages with mentions will be created as for an ordinary unread message
}

// MessageType return the string telegram-type of ChatNotificationSettings
func (chatNotificationSettings *ChatNotificationSettings) MessageType() string {
	return "chatNotificationSettings"
}

// NewChatNotificationSettings creates a new ChatNotificationSettings
//
// @param useDefaultMuteFor If true, the value for the relevant type of chat or the forum chat is used instead of mute_for
// @param muteFor Time left before notifications will be unmuted, in seconds
// @param useDefaultSound If true, the value for the relevant type of chat or the forum chat is used instead of sound_id
// @param soundID Identifier of the notification sound to be played for messages; 0 if sound is disabled
// @param useDefaultShowPreview If true, the value for the relevant type of chat or the forum chat is used instead of show_preview
// @param showPreview True, if message content must be displayed in notifications
// @param useDefaultMuteStories If true, the value for the relevant type of chat is used instead of mute_stories
// @param muteStories True, if story notifications are disabled for the chat
// @param useDefaultStorySound If true, the value for the relevant type of chat is used instead of story_sound_id
// @param storySoundID Identifier of the notification sound to be played for stories; 0 if sound is disabled
// @param useDefaultShowStorySender If true, the value for the relevant type of chat is used instead of show_story_sender
// @param showStorySender True, if the sender of stories must be displayed in notifications
// @param useDefaultDisablePinnedMessageNotifications If true, the value for the relevant type of chat or the forum chat is used instead of disable_pinned_message_notifications
// @param disablePinnedMessageNotifications If true, notifications for incoming pinned messages will be created as for an ordinary unread message
// @param useDefaultDisableMentionNotifications If true, the value for the relevant type of chat or the forum chat is used instead of disable_mention_notifications
// @param disableMentionNotifications If true, notifications for messages with mentions will be created as for an ordinary unread message
func NewChatNotificationSettings(useDefaultMuteFor bool, muteFor int32, useDefaultSound bool, soundID JSONInt64, useDefaultShowPreview bool, showPreview bool, useDefaultMuteStories bool, muteStories bool, useDefaultStorySound bool, storySoundID JSONInt64, useDefaultShowStorySender bool, showStorySender bool, useDefaultDisablePinnedMessageNotifications bool, disablePinnedMessageNotifications bool, useDefaultDisableMentionNotifications bool, disableMentionNotifications bool) *ChatNotificationSettings {
	chatNotificationSettingsTemp := ChatNotificationSettings{
		tdCommon:                  tdCommon{Type: "chatNotificationSettings"},
		UseDefaultMuteFor:         useDefaultMuteFor,
		MuteFor:                   muteFor,
		UseDefaultSound:           useDefaultSound,
		SoundID:                   soundID,
		UseDefaultShowPreview:     useDefaultShowPreview,
		ShowPreview:               showPreview,
		UseDefaultMuteStories:     useDefaultMuteStories,
		MuteStories:               muteStories,
		UseDefaultStorySound:      useDefaultStorySound,
		StorySoundID:              storySoundID,
		UseDefaultShowStorySender: useDefaultShowStorySender,
		ShowStorySender:           showStorySender,
		UseDefaultDisablePinnedMessageNotifications: useDefaultDisablePinnedMessageNotifications,
		DisablePinnedMessageNotifications:           disablePinnedMessageNotifications,
		UseDefaultDisableMentionNotifications:       useDefaultDisableMentionNotifications,
		DisableMentionNotifications:                 disableMentionNotifications,
	}

	return &chatNotificationSettingsTemp
}

// UnmarshalJSON unmarshal to json
func (chatNotificationSettings *ChatNotificationSettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UseDefaultMuteFor                           bool      `json:"use_default_mute_for"`                             // If true, the value for the relevant type of chat or the forum chat is used instead of mute_for
		MuteFor                                     int32     `json:"mute_for"`                                         // Time left before notifications will be unmuted, in seconds
		UseDefaultSound                             bool      `json:"use_default_sound"`                                // If true, the value for the relevant type of chat or the forum chat is used instead of sound_id
		SoundID                                     JSONInt64 `json:"sound_id"`                                         // Identifier of the notification sound to be played for messages; 0 if sound is disabled
		UseDefaultShowPreview                       bool      `json:"use_default_show_preview"`                         // If true, the value for the relevant type of chat or the forum chat is used instead of show_preview
		ShowPreview                                 bool      `json:"show_preview"`                                     // True, if message content must be displayed in notifications
		UseDefaultMuteStories                       bool      `json:"use_default_mute_stories"`                         // If true, the value for the relevant type of chat is used instead of mute_stories
		MuteStories                                 bool      `json:"mute_stories"`                                     // True, if story notifications are disabled for the chat
		UseDefaultStorySound                        bool      `json:"use_default_story_sound"`                          // If true, the value for the relevant type of chat is used instead of story_sound_id
		StorySoundID                                JSONInt64 `json:"story_sound_id"`                                   // Identifier of the notification sound to be played for stories; 0 if sound is disabled
		UseDefaultShowStorySender                   bool      `json:"use_default_show_story_sender"`                    // If true, the value for the relevant type of chat is used instead of show_story_sender
		ShowStorySender                             bool      `json:"show_story_sender"`                                // True, if the sender of stories must be displayed in notifications
		UseDefaultDisablePinnedMessageNotifications bool      `json:"use_default_disable_pinned_message_notifications"` // If true, the value for the relevant type of chat or the forum chat is used instead of disable_pinned_message_notifications
		DisablePinnedMessageNotifications           bool      `json:"disable_pinned_message_notifications"`             // If true, notifications for incoming pinned messages will be created as for an ordinary unread message
		UseDefaultDisableMentionNotifications       bool      `json:"use_default_disable_mention_notifications"`        // If true, the value for the relevant type of chat or the forum chat is used instead of disable_mention_notifications
		DisableMentionNotifications                 bool      `json:"disable_mention_notifications"`                    // If true, notifications for messages with mentions will be created as for an ordinary unread message
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatNotificationSettings.tdCommon = tempObj.tdCommon
	chatNotificationSettings.UseDefaultMuteFor = tempObj.UseDefaultMuteFor
	chatNotificationSettings.MuteFor = tempObj.MuteFor
	chatNotificationSettings.UseDefaultSound = tempObj.UseDefaultSound
	chatNotificationSettings.SoundID = tempObj.SoundID
	chatNotificationSettings.UseDefaultShowPreview = tempObj.UseDefaultShowPreview
	chatNotificationSettings.ShowPreview = tempObj.ShowPreview
	chatNotificationSettings.UseDefaultMuteStories = tempObj.UseDefaultMuteStories
	chatNotificationSettings.MuteStories = tempObj.MuteStories
	chatNotificationSettings.UseDefaultStorySound = tempObj.UseDefaultStorySound
	chatNotificationSettings.StorySoundID = tempObj.StorySoundID
	chatNotificationSettings.UseDefaultShowStorySender = tempObj.UseDefaultShowStorySender
	chatNotificationSettings.ShowStorySender = tempObj.ShowStorySender
	chatNotificationSettings.UseDefaultDisablePinnedMessageNotifications = tempObj.UseDefaultDisablePinnedMessageNotifications
	chatNotificationSettings.DisablePinnedMessageNotifications = tempObj.DisablePinnedMessageNotifications
	chatNotificationSettings.UseDefaultDisableMentionNotifications = tempObj.UseDefaultDisableMentionNotifications
	chatNotificationSettings.DisableMentionNotifications = tempObj.DisableMentionNotifications

	return nil
}

// ScopeNotificationSettings Contains information about notification settings for several chats
type ScopeNotificationSettings struct {
	tdCommon
	MuteFor                           int32     `json:"mute_for"`                             // Time left before notifications will be unmuted, in seconds
	SoundID                           JSONInt64 `json:"sound_id"`                             // Identifier of the notification sound to be played; 0 if sound is disabled
	ShowPreview                       bool      `json:"show_preview"`                         // True, if message content must be displayed in notifications
	UseDefaultMuteStories             bool      `json:"use_default_mute_stories"`             // If true, story notifications are received only for the first 5 chats from topChatCategoryUsers regardless of the value of mute_stories
	MuteStories                       bool      `json:"mute_stories"`                         // True, if story notifications are disabled
	StorySoundID                      JSONInt64 `json:"story_sound_id"`                       // Identifier of the notification sound to be played for stories; 0 if sound is disabled
	ShowStorySender                   bool      `json:"show_story_sender"`                    // True, if the sender of stories must be displayed in notifications
	DisablePinnedMessageNotifications bool      `json:"disable_pinned_message_notifications"` // True, if notifications for incoming pinned messages will be created as for an ordinary unread message
	DisableMentionNotifications       bool      `json:"disable_mention_notifications"`        // True, if notifications for messages with mentions will be created as for an ordinary unread message
}

// MessageType return the string telegram-type of ScopeNotificationSettings
func (scopeNotificationSettings *ScopeNotificationSettings) MessageType() string {
	return "scopeNotificationSettings"
}

// NewScopeNotificationSettings creates a new ScopeNotificationSettings
//
// @param muteFor Time left before notifications will be unmuted, in seconds
// @param soundID Identifier of the notification sound to be played; 0 if sound is disabled
// @param showPreview True, if message content must be displayed in notifications
// @param useDefaultMuteStories If true, story notifications are received only for the first 5 chats from topChatCategoryUsers regardless of the value of mute_stories
// @param muteStories True, if story notifications are disabled
// @param storySoundID Identifier of the notification sound to be played for stories; 0 if sound is disabled
// @param showStorySender True, if the sender of stories must be displayed in notifications
// @param disablePinnedMessageNotifications True, if notifications for incoming pinned messages will be created as for an ordinary unread message
// @param disableMentionNotifications True, if notifications for messages with mentions will be created as for an ordinary unread message
func NewScopeNotificationSettings(muteFor int32, soundID JSONInt64, showPreview bool, useDefaultMuteStories bool, muteStories bool, storySoundID JSONInt64, showStorySender bool, disablePinnedMessageNotifications bool, disableMentionNotifications bool) *ScopeNotificationSettings {
	scopeNotificationSettingsTemp := ScopeNotificationSettings{
		tdCommon:                          tdCommon{Type: "scopeNotificationSettings"},
		MuteFor:                           muteFor,
		SoundID:                           soundID,
		ShowPreview:                       showPreview,
		UseDefaultMuteStories:             useDefaultMuteStories,
		MuteStories:                       muteStories,
		StorySoundID:                      storySoundID,
		ShowStorySender:                   showStorySender,
		DisablePinnedMessageNotifications: disablePinnedMessageNotifications,
		DisableMentionNotifications:       disableMentionNotifications,
	}

	return &scopeNotificationSettingsTemp
}

// UnmarshalJSON unmarshal to json
func (scopeNotificationSettings *ScopeNotificationSettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MuteFor                           int32     `json:"mute_for"`                             // Time left before notifications will be unmuted, in seconds
		SoundID                           JSONInt64 `json:"sound_id"`                             // Identifier of the notification sound to be played; 0 if sound is disabled
		ShowPreview                       bool      `json:"show_preview"`                         // True, if message content must be displayed in notifications
		UseDefaultMuteStories             bool      `json:"use_default_mute_stories"`             // If true, story notifications are received only for the first 5 chats from topChatCategoryUsers regardless of the value of mute_stories
		MuteStories                       bool      `json:"mute_stories"`                         // True, if story notifications are disabled
		StorySoundID                      JSONInt64 `json:"story_sound_id"`                       // Identifier of the notification sound to be played for stories; 0 if sound is disabled
		ShowStorySender                   bool      `json:"show_story_sender"`                    // True, if the sender of stories must be displayed in notifications
		DisablePinnedMessageNotifications bool      `json:"disable_pinned_message_notifications"` // True, if notifications for incoming pinned messages will be created as for an ordinary unread message
		DisableMentionNotifications       bool      `json:"disable_mention_notifications"`        // True, if notifications for messages with mentions will be created as for an ordinary unread message
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	scopeNotificationSettings.tdCommon = tempObj.tdCommon
	scopeNotificationSettings.MuteFor = tempObj.MuteFor
	scopeNotificationSettings.SoundID = tempObj.SoundID
	scopeNotificationSettings.ShowPreview = tempObj.ShowPreview
	scopeNotificationSettings.UseDefaultMuteStories = tempObj.UseDefaultMuteStories
	scopeNotificationSettings.MuteStories = tempObj.MuteStories
	scopeNotificationSettings.StorySoundID = tempObj.StorySoundID
	scopeNotificationSettings.ShowStorySender = tempObj.ShowStorySender
	scopeNotificationSettings.DisablePinnedMessageNotifications = tempObj.DisablePinnedMessageNotifications
	scopeNotificationSettings.DisableMentionNotifications = tempObj.DisableMentionNotifications

	return nil
}

// ReactionNotificationSourceNone Notifications for reactions are disabled
type ReactionNotificationSourceNone struct {
	tdCommon
}

// MessageType return the string telegram-type of ReactionNotificationSourceNone
func (reactionNotificationSourceNone *ReactionNotificationSourceNone) MessageType() string {
	return "reactionNotificationSourceNone"
}

// NewReactionNotificationSourceNone creates a new ReactionNotificationSourceNone
//
func NewReactionNotificationSourceNone() *ReactionNotificationSourceNone {
	reactionNotificationSourceNoneTemp := ReactionNotificationSourceNone{
		tdCommon: tdCommon{Type: "reactionNotificationSourceNone"},
	}

	return &reactionNotificationSourceNoneTemp
}

// UnmarshalJSON unmarshal to json
func (reactionNotificationSourceNone *ReactionNotificationSourceNone) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reactionNotificationSourceNone.tdCommon = tempObj.tdCommon

	return nil
}

// GetReactionNotificationSourceEnum return the enum type of this object
func (reactionNotificationSourceNone *ReactionNotificationSourceNone) GetReactionNotificationSourceEnum() ReactionNotificationSourceEnum {
	return ReactionNotificationSourceNoneType
}

// ReactionNotificationSourceContacts Notifications for reactions are shown only for reactions from contacts
type ReactionNotificationSourceContacts struct {
	tdCommon
}

// MessageType return the string telegram-type of ReactionNotificationSourceContacts
func (reactionNotificationSourceContacts *ReactionNotificationSourceContacts) MessageType() string {
	return "reactionNotificationSourceContacts"
}

// NewReactionNotificationSourceContacts creates a new ReactionNotificationSourceContacts
//
func NewReactionNotificationSourceContacts() *ReactionNotificationSourceContacts {
	reactionNotificationSourceContactsTemp := ReactionNotificationSourceContacts{
		tdCommon: tdCommon{Type: "reactionNotificationSourceContacts"},
	}

	return &reactionNotificationSourceContactsTemp
}

// UnmarshalJSON unmarshal to json
func (reactionNotificationSourceContacts *ReactionNotificationSourceContacts) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reactionNotificationSourceContacts.tdCommon = tempObj.tdCommon

	return nil
}

// GetReactionNotificationSourceEnum return the enum type of this object
func (reactionNotificationSourceContacts *ReactionNotificationSourceContacts) GetReactionNotificationSourceEnum() ReactionNotificationSourceEnum {
	return ReactionNotificationSourceContactsType
}

// ReactionNotificationSourceAll Notifications for reactions are shown for all reactions
type ReactionNotificationSourceAll struct {
	tdCommon
}

// MessageType return the string telegram-type of ReactionNotificationSourceAll
func (reactionNotificationSourceAll *ReactionNotificationSourceAll) MessageType() string {
	return "reactionNotificationSourceAll"
}

// NewReactionNotificationSourceAll creates a new ReactionNotificationSourceAll
//
func NewReactionNotificationSourceAll() *ReactionNotificationSourceAll {
	reactionNotificationSourceAllTemp := ReactionNotificationSourceAll{
		tdCommon: tdCommon{Type: "reactionNotificationSourceAll"},
	}

	return &reactionNotificationSourceAllTemp
}

// UnmarshalJSON unmarshal to json
func (reactionNotificationSourceAll *ReactionNotificationSourceAll) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reactionNotificationSourceAll.tdCommon = tempObj.tdCommon

	return nil
}

// GetReactionNotificationSourceEnum return the enum type of this object
func (reactionNotificationSourceAll *ReactionNotificationSourceAll) GetReactionNotificationSourceEnum() ReactionNotificationSourceEnum {
	return ReactionNotificationSourceAllType
}

// ReactionNotificationSettings Contains information about notification settings for reactions
type ReactionNotificationSettings struct {
	tdCommon
	MessageReactionSource ReactionNotificationSource `json:"message_reaction_source"` // Source of message reactions for which notifications are shown
	StoryReactionSource   ReactionNotificationSource `json:"story_reaction_source"`   // Source of story reactions for which notifications are shown
	SoundID               JSONInt64                  `json:"sound_id"`                // Identifier of the notification sound to be played; 0 if sound is disabled
	ShowPreview           bool                       `json:"show_preview"`            // True, if reaction sender and emoji must be displayed in notifications
}

// MessageType return the string telegram-type of ReactionNotificationSettings
func (reactionNotificationSettings *ReactionNotificationSettings) MessageType() string {
	return "reactionNotificationSettings"
}

// NewReactionNotificationSettings creates a new ReactionNotificationSettings
//
// @param messageReactionSource Source of message reactions for which notifications are shown
// @param storyReactionSource Source of story reactions for which notifications are shown
// @param soundID Identifier of the notification sound to be played; 0 if sound is disabled
// @param showPreview True, if reaction sender and emoji must be displayed in notifications
func NewReactionNotificationSettings(messageReactionSource ReactionNotificationSource, storyReactionSource ReactionNotificationSource, soundID JSONInt64, showPreview bool) *ReactionNotificationSettings {
	reactionNotificationSettingsTemp := ReactionNotificationSettings{
		tdCommon:              tdCommon{Type: "reactionNotificationSettings"},
		MessageReactionSource: messageReactionSource,
		StoryReactionSource:   storyReactionSource,
		SoundID:               soundID,
		ShowPreview:           showPreview,
	}

	return &reactionNotificationSettingsTemp
}

// UnmarshalJSON unmarshal to json
func (reactionNotificationSettings *ReactionNotificationSettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SoundID     JSONInt64 `json:"sound_id"`     // Identifier of the notification sound to be played; 0 if sound is disabled
		ShowPreview bool      `json:"show_preview"` // True, if reaction sender and emoji must be displayed in notifications
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reactionNotificationSettings.tdCommon = tempObj.tdCommon
	reactionNotificationSettings.SoundID = tempObj.SoundID
	reactionNotificationSettings.ShowPreview = tempObj.ShowPreview

	fieldMessageReactionSource, _ := unmarshalReactionNotificationSource(objMap["message_reaction_source"])
	reactionNotificationSettings.MessageReactionSource = fieldMessageReactionSource

	fieldStoryReactionSource, _ := unmarshalReactionNotificationSource(objMap["story_reaction_source"])
	reactionNotificationSettings.StoryReactionSource = fieldStoryReactionSource

	return nil
}

// DraftMessage Contains information about a message draft
type DraftMessage struct {
	tdCommon
	ReplyTo          *InputMessageReplyTo `json:"reply_to"`           // Information about the message to be replied; must be of the type inputMessageReplyToMessage; may be null if none
	Date             int32                `json:"date"`               // Point in time (Unix timestamp) when the draft was created
	InputMessageText InputMessageContent  `json:"input_message_text"` // Content of the message draft; must be of the type inputMessageText, inputMessageVideoNote, or inputMessageVoiceNote
	EffectID         JSONInt64            `json:"effect_id"`          // Identifier of the effect to apply to the message when it is sent; 0 if none
}

// MessageType return the string telegram-type of DraftMessage
func (draftMessage *DraftMessage) MessageType() string {
	return "draftMessage"
}

// NewDraftMessage creates a new DraftMessage
//
// @param replyTo Information about the message to be replied; must be of the type inputMessageReplyToMessage; may be null if none
// @param date Point in time (Unix timestamp) when the draft was created
// @param inputMessageText Content of the message draft; must be of the type inputMessageText, inputMessageVideoNote, or inputMessageVoiceNote
// @param effectID Identifier of the effect to apply to the message when it is sent; 0 if none
func NewDraftMessage(replyTo *InputMessageReplyTo, date int32, inputMessageText InputMessageContent, effectID JSONInt64) *DraftMessage {
	draftMessageTemp := DraftMessage{
		tdCommon:         tdCommon{Type: "draftMessage"},
		ReplyTo:          replyTo,
		Date:             date,
		InputMessageText: inputMessageText,
		EffectID:         effectID,
	}

	return &draftMessageTemp
}

// UnmarshalJSON unmarshal to json
func (draftMessage *DraftMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Date     int32     `json:"date"`      // Point in time (Unix timestamp) when the draft was created
		EffectID JSONInt64 `json:"effect_id"` // Identifier of the effect to apply to the message when it is sent; 0 if none
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	draftMessage.tdCommon = tempObj.tdCommon
	draftMessage.Date = tempObj.Date
	draftMessage.EffectID = tempObj.EffectID

	fieldReplyTo, _ := unmarshalInputMessageReplyTo(objMap["reply_to"])
	draftMessage.ReplyTo = &fieldReplyTo

	fieldInputMessageText, _ := unmarshalInputMessageContent(objMap["input_message_text"])
	draftMessage.InputMessageText = fieldInputMessageText

	return nil
}

// ChatTypePrivate An ordinary chat with a user
type ChatTypePrivate struct {
	tdCommon
	UserID int64 `json:"user_id"` // User identifier
}

// MessageType return the string telegram-type of ChatTypePrivate
func (chatTypePrivate *ChatTypePrivate) MessageType() string {
	return "chatTypePrivate"
}

// NewChatTypePrivate creates a new ChatTypePrivate
//
// @param userID User identifier
func NewChatTypePrivate(userID int64) *ChatTypePrivate {
	chatTypePrivateTemp := ChatTypePrivate{
		tdCommon: tdCommon{Type: "chatTypePrivate"},
		UserID:   userID,
	}

	return &chatTypePrivateTemp
}

// UnmarshalJSON unmarshal to json
func (chatTypePrivate *ChatTypePrivate) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID int64 `json:"user_id"` // User identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatTypePrivate.tdCommon = tempObj.tdCommon
	chatTypePrivate.UserID = tempObj.UserID

	return nil
}

// GetChatTypeEnum return the enum type of this object
func (chatTypePrivate *ChatTypePrivate) GetChatTypeEnum() ChatTypeEnum {
	return ChatTypePrivateType
}

// ChatTypeBasicGroup A basic group (a chat with 0-200 other users)
type ChatTypeBasicGroup struct {
	tdCommon
	BasicGroupID int64 `json:"basic_group_id"` // Basic group identifier
}

// MessageType return the string telegram-type of ChatTypeBasicGroup
func (chatTypeBasicGroup *ChatTypeBasicGroup) MessageType() string {
	return "chatTypeBasicGroup"
}

// NewChatTypeBasicGroup creates a new ChatTypeBasicGroup
//
// @param basicGroupID Basic group identifier
func NewChatTypeBasicGroup(basicGroupID int64) *ChatTypeBasicGroup {
	chatTypeBasicGroupTemp := ChatTypeBasicGroup{
		tdCommon:     tdCommon{Type: "chatTypeBasicGroup"},
		BasicGroupID: basicGroupID,
	}

	return &chatTypeBasicGroupTemp
}

// UnmarshalJSON unmarshal to json
func (chatTypeBasicGroup *ChatTypeBasicGroup) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BasicGroupID int64 `json:"basic_group_id"` // Basic group identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatTypeBasicGroup.tdCommon = tempObj.tdCommon
	chatTypeBasicGroup.BasicGroupID = tempObj.BasicGroupID

	return nil
}

// GetChatTypeEnum return the enum type of this object
func (chatTypeBasicGroup *ChatTypeBasicGroup) GetChatTypeEnum() ChatTypeEnum {
	return ChatTypeBasicGroupType
}

// ChatTypeSupergroup A supergroup or channel (with unlimited members)
type ChatTypeSupergroup struct {
	tdCommon
	SupergroupID int64 `json:"supergroup_id"` // Supergroup or channel identifier
	IsChannel    bool  `json:"is_channel"`    // True, if the supergroup is a channel
}

// MessageType return the string telegram-type of ChatTypeSupergroup
func (chatTypeSupergroup *ChatTypeSupergroup) MessageType() string {
	return "chatTypeSupergroup"
}

// NewChatTypeSupergroup creates a new ChatTypeSupergroup
//
// @param supergroupID Supergroup or channel identifier
// @param isChannel True, if the supergroup is a channel
func NewChatTypeSupergroup(supergroupID int64, isChannel bool) *ChatTypeSupergroup {
	chatTypeSupergroupTemp := ChatTypeSupergroup{
		tdCommon:     tdCommon{Type: "chatTypeSupergroup"},
		SupergroupID: supergroupID,
		IsChannel:    isChannel,
	}

	return &chatTypeSupergroupTemp
}

// UnmarshalJSON unmarshal to json
func (chatTypeSupergroup *ChatTypeSupergroup) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SupergroupID int64 `json:"supergroup_id"` // Supergroup or channel identifier
		IsChannel    bool  `json:"is_channel"`    // True, if the supergroup is a channel
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatTypeSupergroup.tdCommon = tempObj.tdCommon
	chatTypeSupergroup.SupergroupID = tempObj.SupergroupID
	chatTypeSupergroup.IsChannel = tempObj.IsChannel

	return nil
}

// GetChatTypeEnum return the enum type of this object
func (chatTypeSupergroup *ChatTypeSupergroup) GetChatTypeEnum() ChatTypeEnum {
	return ChatTypeSupergroupType
}

// ChatTypeSecret A secret chat with a user
type ChatTypeSecret struct {
	tdCommon
	SecretChatID int32 `json:"secret_chat_id"` // Secret chat identifier
	UserID       int64 `json:"user_id"`        // User identifier of the other user in the secret chat
}

// MessageType return the string telegram-type of ChatTypeSecret
func (chatTypeSecret *ChatTypeSecret) MessageType() string {
	return "chatTypeSecret"
}

// NewChatTypeSecret creates a new ChatTypeSecret
//
// @param secretChatID Secret chat identifier
// @param userID User identifier of the other user in the secret chat
func NewChatTypeSecret(secretChatID int32, userID int64) *ChatTypeSecret {
	chatTypeSecretTemp := ChatTypeSecret{
		tdCommon:     tdCommon{Type: "chatTypeSecret"},
		SecretChatID: secretChatID,
		UserID:       userID,
	}

	return &chatTypeSecretTemp
}

// UnmarshalJSON unmarshal to json
func (chatTypeSecret *ChatTypeSecret) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SecretChatID int32 `json:"secret_chat_id"` // Secret chat identifier
		UserID       int64 `json:"user_id"`        // User identifier of the other user in the secret chat
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatTypeSecret.tdCommon = tempObj.tdCommon
	chatTypeSecret.SecretChatID = tempObj.SecretChatID
	chatTypeSecret.UserID = tempObj.UserID

	return nil
}

// GetChatTypeEnum return the enum type of this object
func (chatTypeSecret *ChatTypeSecret) GetChatTypeEnum() ChatTypeEnum {
	return ChatTypeSecretType
}

// ChatFolderIcon Represents an icon for a chat folder
type ChatFolderIcon struct {
	tdCommon
	Name string `json:"name"` // The chosen icon name for short folder representation; one of "All", "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat", "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport", "Study", "Trade", "Travel", "Work", "Airplane", "Book", "Light", "Like", "Money", "Note", "Palette"
}

// MessageType return the string telegram-type of ChatFolderIcon
func (chatFolderIcon *ChatFolderIcon) MessageType() string {
	return "chatFolderIcon"
}

// NewChatFolderIcon creates a new ChatFolderIcon
//
// @param name The chosen icon name for short folder representation; one of "All", "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat", "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport", "Study", "Trade", "Travel", "Work", "Airplane", "Book", "Light", "Like", "Money", "Note", "Palette"
func NewChatFolderIcon(name string) *ChatFolderIcon {
	chatFolderIconTemp := ChatFolderIcon{
		tdCommon: tdCommon{Type: "chatFolderIcon"},
		Name:     name,
	}

	return &chatFolderIconTemp
}

// UnmarshalJSON unmarshal to json
func (chatFolderIcon *ChatFolderIcon) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Name string `json:"name"` // The chosen icon name for short folder representation; one of "All", "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat", "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport", "Study", "Trade", "Travel", "Work", "Airplane", "Book", "Light", "Like", "Money", "Note", "Palette"
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatFolderIcon.tdCommon = tempObj.tdCommon
	chatFolderIcon.Name = tempObj.Name

	return nil
}

// ChatFolder Represents a folder for user chats
type ChatFolder struct {
	tdCommon
	Title              string          `json:"title"`                // The title of the folder; 1-12 characters without line feeds
	Icon               *ChatFolderIcon `json:"icon"`                 // The chosen icon for the chat folder; may be null. If null, use getChatFolderDefaultIconName to get default icon name for the folder
	ColorID            int32           `json:"color_id"`             // The identifier of the chosen color for the chat folder icon; from -1 to 6. If -1, then color is disabled. Can't be changed if folder tags are disabled or the current user doesn't have Telegram Premium subscription
	IsShareable        bool            `json:"is_shareable"`         // True, if at least one link has been created for the folder
	PinnedChatIDs      []int64         `json:"pinned_chat_ids"`      // The chat identifiers of pinned chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") pinned and always included non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
	IncludedChatIDs    []int64         `json:"included_chat_ids"`    // The chat identifiers of always included chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") pinned and always included non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
	ExcludedChatIDs    []int64         `json:"excluded_chat_ids"`    // The chat identifiers of always excluded chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") always excluded non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
	ExcludeMuted       bool            `json:"exclude_muted"`        // True, if muted chats need to be excluded
	ExcludeRead        bool            `json:"exclude_read"`         // True, if read chats need to be excluded
	ExcludeArchived    bool            `json:"exclude_archived"`     // True, if archived chats need to be excluded
	IncludeContacts    bool            `json:"include_contacts"`     // True, if contacts need to be included
	IncludeNonContacts bool            `json:"include_non_contacts"` // True, if non-contact users need to be included
	IncludeBots        bool            `json:"include_bots"`         // True, if bots need to be included
	IncludeGroups      bool            `json:"include_groups"`       // True, if basic groups and supergroups need to be included
	IncludeChannels    bool            `json:"include_channels"`     // True, if channels need to be included
}

// MessageType return the string telegram-type of ChatFolder
func (chatFolder *ChatFolder) MessageType() string {
	return "chatFolder"
}

// NewChatFolder creates a new ChatFolder
//
// @param title The title of the folder; 1-12 characters without line feeds
// @param icon The chosen icon for the chat folder; may be null. If null, use getChatFolderDefaultIconName to get default icon name for the folder
// @param colorID The identifier of the chosen color for the chat folder icon; from -1 to 6. If -1, then color is disabled. Can't be changed if folder tags are disabled or the current user doesn't have Telegram Premium subscription
// @param isShareable True, if at least one link has been created for the folder
// @param pinnedChatIDs The chat identifiers of pinned chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") pinned and always included non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
// @param includedChatIDs The chat identifiers of always included chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") pinned and always included non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
// @param excludedChatIDs The chat identifiers of always excluded chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") always excluded non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
// @param excludeMuted True, if muted chats need to be excluded
// @param excludeRead True, if read chats need to be excluded
// @param excludeArchived True, if archived chats need to be excluded
// @param includeContacts True, if contacts need to be included
// @param includeNonContacts True, if non-contact users need to be included
// @param includeBots True, if bots need to be included
// @param includeGroups True, if basic groups and supergroups need to be included
// @param includeChannels True, if channels need to be included
func NewChatFolder(title string, icon *ChatFolderIcon, colorID int32, isShareable bool, pinnedChatIDs []int64, includedChatIDs []int64, excludedChatIDs []int64, excludeMuted bool, excludeRead bool, excludeArchived bool, includeContacts bool, includeNonContacts bool, includeBots bool, includeGroups bool, includeChannels bool) *ChatFolder {
	chatFolderTemp := ChatFolder{
		tdCommon:           tdCommon{Type: "chatFolder"},
		Title:              title,
		Icon:               icon,
		ColorID:            colorID,
		IsShareable:        isShareable,
		PinnedChatIDs:      pinnedChatIDs,
		IncludedChatIDs:    includedChatIDs,
		ExcludedChatIDs:    excludedChatIDs,
		ExcludeMuted:       excludeMuted,
		ExcludeRead:        excludeRead,
		ExcludeArchived:    excludeArchived,
		IncludeContacts:    includeContacts,
		IncludeNonContacts: includeNonContacts,
		IncludeBots:        includeBots,
		IncludeGroups:      includeGroups,
		IncludeChannels:    includeChannels,
	}

	return &chatFolderTemp
}

// UnmarshalJSON unmarshal to json
func (chatFolder *ChatFolder) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Title              string          `json:"title"`                // The title of the folder; 1-12 characters without line feeds
		Icon               *ChatFolderIcon `json:"icon"`                 // The chosen icon for the chat folder; may be null. If null, use getChatFolderDefaultIconName to get default icon name for the folder
		ColorID            int32           `json:"color_id"`             // The identifier of the chosen color for the chat folder icon; from -1 to 6. If -1, then color is disabled. Can't be changed if folder tags are disabled or the current user doesn't have Telegram Premium subscription
		IsShareable        bool            `json:"is_shareable"`         // True, if at least one link has been created for the folder
		PinnedChatIDs      []int64         `json:"pinned_chat_ids"`      // The chat identifiers of pinned chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") pinned and always included non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
		IncludedChatIDs    []int64         `json:"included_chat_ids"`    // The chat identifiers of always included chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") pinned and always included non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
		ExcludedChatIDs    []int64         `json:"excluded_chat_ids"`    // The chat identifiers of always excluded chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") always excluded non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
		ExcludeMuted       bool            `json:"exclude_muted"`        // True, if muted chats need to be excluded
		ExcludeRead        bool            `json:"exclude_read"`         // True, if read chats need to be excluded
		ExcludeArchived    bool            `json:"exclude_archived"`     // True, if archived chats need to be excluded
		IncludeContacts    bool            `json:"include_contacts"`     // True, if contacts need to be included
		IncludeNonContacts bool            `json:"include_non_contacts"` // True, if non-contact users need to be included
		IncludeBots        bool            `json:"include_bots"`         // True, if bots need to be included
		IncludeGroups      bool            `json:"include_groups"`       // True, if basic groups and supergroups need to be included
		IncludeChannels    bool            `json:"include_channels"`     // True, if channels need to be included
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatFolder.tdCommon = tempObj.tdCommon
	chatFolder.Title = tempObj.Title
	chatFolder.Icon = tempObj.Icon
	chatFolder.ColorID = tempObj.ColorID
	chatFolder.IsShareable = tempObj.IsShareable
	chatFolder.PinnedChatIDs = tempObj.PinnedChatIDs
	chatFolder.IncludedChatIDs = tempObj.IncludedChatIDs
	chatFolder.ExcludedChatIDs = tempObj.ExcludedChatIDs
	chatFolder.ExcludeMuted = tempObj.ExcludeMuted
	chatFolder.ExcludeRead = tempObj.ExcludeRead
	chatFolder.ExcludeArchived = tempObj.ExcludeArchived
	chatFolder.IncludeContacts = tempObj.IncludeContacts
	chatFolder.IncludeNonContacts = tempObj.IncludeNonContacts
	chatFolder.IncludeBots = tempObj.IncludeBots
	chatFolder.IncludeGroups = tempObj.IncludeGroups
	chatFolder.IncludeChannels = tempObj.IncludeChannels

	return nil
}

// ChatFolderInfo Contains basic information about a chat folder
type ChatFolderInfo struct {
	tdCommon
	ID               int32           `json:"id"`                  // Unique chat folder identifier
	Title            string          `json:"title"`               // The title of the folder; 1-12 characters without line feeds
	Icon             *ChatFolderIcon `json:"icon"`                // The chosen or default icon for the chat folder
	ColorID          int32           `json:"color_id"`            // The identifier of the chosen color for the chat folder icon; from -1 to 6. If -1, then color is disabled
	IsShareable      bool            `json:"is_shareable"`        // True, if at least one link has been created for the folder
	HasMyInviteLinks bool            `json:"has_my_invite_links"` // True, if the chat folder has invite links created by the current user
}

// MessageType return the string telegram-type of ChatFolderInfo
func (chatFolderInfo *ChatFolderInfo) MessageType() string {
	return "chatFolderInfo"
}

// NewChatFolderInfo creates a new ChatFolderInfo
//
// @param iD Unique chat folder identifier
// @param title The title of the folder; 1-12 characters without line feeds
// @param icon The chosen or default icon for the chat folder
// @param colorID The identifier of the chosen color for the chat folder icon; from -1 to 6. If -1, then color is disabled
// @param isShareable True, if at least one link has been created for the folder
// @param hasMyInviteLinks True, if the chat folder has invite links created by the current user
func NewChatFolderInfo(iD int32, title string, icon *ChatFolderIcon, colorID int32, isShareable bool, hasMyInviteLinks bool) *ChatFolderInfo {
	chatFolderInfoTemp := ChatFolderInfo{
		tdCommon:         tdCommon{Type: "chatFolderInfo"},
		ID:               iD,
		Title:            title,
		Icon:             icon,
		ColorID:          colorID,
		IsShareable:      isShareable,
		HasMyInviteLinks: hasMyInviteLinks,
	}

	return &chatFolderInfoTemp
}

// UnmarshalJSON unmarshal to json
func (chatFolderInfo *ChatFolderInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID               int32           `json:"id"`                  // Unique chat folder identifier
		Title            string          `json:"title"`               // The title of the folder; 1-12 characters without line feeds
		Icon             *ChatFolderIcon `json:"icon"`                // The chosen or default icon for the chat folder
		ColorID          int32           `json:"color_id"`            // The identifier of the chosen color for the chat folder icon; from -1 to 6. If -1, then color is disabled
		IsShareable      bool            `json:"is_shareable"`        // True, if at least one link has been created for the folder
		HasMyInviteLinks bool            `json:"has_my_invite_links"` // True, if the chat folder has invite links created by the current user
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatFolderInfo.tdCommon = tempObj.tdCommon
	chatFolderInfo.ID = tempObj.ID
	chatFolderInfo.Title = tempObj.Title
	chatFolderInfo.Icon = tempObj.Icon
	chatFolderInfo.ColorID = tempObj.ColorID
	chatFolderInfo.IsShareable = tempObj.IsShareable
	chatFolderInfo.HasMyInviteLinks = tempObj.HasMyInviteLinks

	return nil
}

// ChatFolderInviteLink Contains a chat folder invite link
type ChatFolderInviteLink struct {
	tdCommon
	InviteLink string  `json:"invite_link"` // The chat folder invite link
	Name       string  `json:"name"`        // Name of the link
	ChatIDs    []int64 `json:"chat_ids"`    // Identifiers of chats, included in the link
}

// MessageType return the string telegram-type of ChatFolderInviteLink
func (chatFolderInviteLink *ChatFolderInviteLink) MessageType() string {
	return "chatFolderInviteLink"
}

// NewChatFolderInviteLink creates a new ChatFolderInviteLink
//
// @param inviteLink The chat folder invite link
// @param name Name of the link
// @param chatIDs Identifiers of chats, included in the link
func NewChatFolderInviteLink(inviteLink string, name string, chatIDs []int64) *ChatFolderInviteLink {
	chatFolderInviteLinkTemp := ChatFolderInviteLink{
		tdCommon:   tdCommon{Type: "chatFolderInviteLink"},
		InviteLink: inviteLink,
		Name:       name,
		ChatIDs:    chatIDs,
	}

	return &chatFolderInviteLinkTemp
}

// UnmarshalJSON unmarshal to json
func (chatFolderInviteLink *ChatFolderInviteLink) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		InviteLink string  `json:"invite_link"` // The chat folder invite link
		Name       string  `json:"name"`        // Name of the link
		ChatIDs    []int64 `json:"chat_ids"`    // Identifiers of chats, included in the link
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatFolderInviteLink.tdCommon = tempObj.tdCommon
	chatFolderInviteLink.InviteLink = tempObj.InviteLink
	chatFolderInviteLink.Name = tempObj.Name
	chatFolderInviteLink.ChatIDs = tempObj.ChatIDs

	return nil
}

// ChatFolderInviteLinks Represents a list of chat folder invite links
type ChatFolderInviteLinks struct {
	tdCommon
	InviteLinks []ChatFolderInviteLink `json:"invite_links"` // List of the invite links
}

// MessageType return the string telegram-type of ChatFolderInviteLinks
func (chatFolderInviteLinks *ChatFolderInviteLinks) MessageType() string {
	return "chatFolderInviteLinks"
}

// NewChatFolderInviteLinks creates a new ChatFolderInviteLinks
//
// @param inviteLinks List of the invite links
func NewChatFolderInviteLinks(inviteLinks []ChatFolderInviteLink) *ChatFolderInviteLinks {
	chatFolderInviteLinksTemp := ChatFolderInviteLinks{
		tdCommon:    tdCommon{Type: "chatFolderInviteLinks"},
		InviteLinks: inviteLinks,
	}

	return &chatFolderInviteLinksTemp
}

// UnmarshalJSON unmarshal to json
func (chatFolderInviteLinks *ChatFolderInviteLinks) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		InviteLinks []ChatFolderInviteLink `json:"invite_links"` // List of the invite links
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatFolderInviteLinks.tdCommon = tempObj.tdCommon
	chatFolderInviteLinks.InviteLinks = tempObj.InviteLinks

	return nil
}

// ChatFolderInviteLinkInfo Contains information about an invite link to a chat folder
type ChatFolderInviteLinkInfo struct {
	tdCommon
	ChatFolderInfo *ChatFolderInfo `json:"chat_folder_info"` // Basic information about the chat folder; chat folder identifier will be 0 if the user didn't have the chat folder yet
	MissingChatIDs []int64         `json:"missing_chat_ids"` // Identifiers of the chats from the link, which aren't added to the folder yet
	AddedChatIDs   []int64         `json:"added_chat_ids"`   // Identifiers of the chats from the link, which are added to the folder already
}

// MessageType return the string telegram-type of ChatFolderInviteLinkInfo
func (chatFolderInviteLinkInfo *ChatFolderInviteLinkInfo) MessageType() string {
	return "chatFolderInviteLinkInfo"
}

// NewChatFolderInviteLinkInfo creates a new ChatFolderInviteLinkInfo
//
// @param chatFolderInfo Basic information about the chat folder; chat folder identifier will be 0 if the user didn't have the chat folder yet
// @param missingChatIDs Identifiers of the chats from the link, which aren't added to the folder yet
// @param addedChatIDs Identifiers of the chats from the link, which are added to the folder already
func NewChatFolderInviteLinkInfo(chatFolderInfo *ChatFolderInfo, missingChatIDs []int64, addedChatIDs []int64) *ChatFolderInviteLinkInfo {
	chatFolderInviteLinkInfoTemp := ChatFolderInviteLinkInfo{
		tdCommon:       tdCommon{Type: "chatFolderInviteLinkInfo"},
		ChatFolderInfo: chatFolderInfo,
		MissingChatIDs: missingChatIDs,
		AddedChatIDs:   addedChatIDs,
	}

	return &chatFolderInviteLinkInfoTemp
}

// UnmarshalJSON unmarshal to json
func (chatFolderInviteLinkInfo *ChatFolderInviteLinkInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatFolderInfo *ChatFolderInfo `json:"chat_folder_info"` // Basic information about the chat folder; chat folder identifier will be 0 if the user didn't have the chat folder yet
		MissingChatIDs []int64         `json:"missing_chat_ids"` // Identifiers of the chats from the link, which aren't added to the folder yet
		AddedChatIDs   []int64         `json:"added_chat_ids"`   // Identifiers of the chats from the link, which are added to the folder already
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatFolderInviteLinkInfo.tdCommon = tempObj.tdCommon
	chatFolderInviteLinkInfo.ChatFolderInfo = tempObj.ChatFolderInfo
	chatFolderInviteLinkInfo.MissingChatIDs = tempObj.MissingChatIDs
	chatFolderInviteLinkInfo.AddedChatIDs = tempObj.AddedChatIDs

	return nil
}

// RecommendedChatFolder Describes a recommended chat folder
type RecommendedChatFolder struct {
	tdCommon
	Folder      *ChatFolder `json:"folder"`      // The chat folder
	Description string      `json:"description"` // Chat folder description
}

// MessageType return the string telegram-type of RecommendedChatFolder
func (recommendedChatFolder *RecommendedChatFolder) MessageType() string {
	return "recommendedChatFolder"
}

// NewRecommendedChatFolder creates a new RecommendedChatFolder
//
// @param folder The chat folder
// @param description Chat folder description
func NewRecommendedChatFolder(folder *ChatFolder, description string) *RecommendedChatFolder {
	recommendedChatFolderTemp := RecommendedChatFolder{
		tdCommon:    tdCommon{Type: "recommendedChatFolder"},
		Folder:      folder,
		Description: description,
	}

	return &recommendedChatFolderTemp
}

// UnmarshalJSON unmarshal to json
func (recommendedChatFolder *RecommendedChatFolder) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Folder      *ChatFolder `json:"folder"`      // The chat folder
		Description string      `json:"description"` // Chat folder description
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	recommendedChatFolder.tdCommon = tempObj.tdCommon
	recommendedChatFolder.Folder = tempObj.Folder
	recommendedChatFolder.Description = tempObj.Description

	return nil
}

// RecommendedChatFolders Contains a list of recommended chat folders
type RecommendedChatFolders struct {
	tdCommon
	ChatFolders []RecommendedChatFolder `json:"chat_folders"` // List of recommended chat folders
}

// MessageType return the string telegram-type of RecommendedChatFolders
func (recommendedChatFolders *RecommendedChatFolders) MessageType() string {
	return "recommendedChatFolders"
}

// NewRecommendedChatFolders creates a new RecommendedChatFolders
//
// @param chatFolders List of recommended chat folders
func NewRecommendedChatFolders(chatFolders []RecommendedChatFolder) *RecommendedChatFolders {
	recommendedChatFoldersTemp := RecommendedChatFolders{
		tdCommon:    tdCommon{Type: "recommendedChatFolders"},
		ChatFolders: chatFolders,
	}

	return &recommendedChatFoldersTemp
}

// UnmarshalJSON unmarshal to json
func (recommendedChatFolders *RecommendedChatFolders) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatFolders []RecommendedChatFolder `json:"chat_folders"` // List of recommended chat folders
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	recommendedChatFolders.tdCommon = tempObj.tdCommon
	recommendedChatFolders.ChatFolders = tempObj.ChatFolders

	return nil
}

// ArchiveChatListSettings Contains settings for automatic moving of chats to and from the Archive chat lists
type ArchiveChatListSettings struct {
	tdCommon
	ArchiveAndMuteNewChatsFromUnknownUsers bool `json:"archive_and_mute_new_chats_from_unknown_users"` // True, if new chats from non-contacts will be automatically archived and muted. Can be set to true only if the option "can_archive_and_mute_new_chats_from_unknown_users" is true
	KeepUnmutedChatsArchived               bool `json:"keep_unmuted_chats_archived"`                   // True, if unmuted chats will be kept in the Archive chat list when they get a new message
	KeepChatsFromFoldersArchived           bool `json:"keep_chats_from_folders_archived"`              // True, if unmuted chats, that are always included or pinned in a folder, will be kept in the Archive chat list when they get a new message. Ignored if keep_unmuted_chats_archived == true
}

// MessageType return the string telegram-type of ArchiveChatListSettings
func (archiveChatListSettings *ArchiveChatListSettings) MessageType() string {
	return "archiveChatListSettings"
}

// NewArchiveChatListSettings creates a new ArchiveChatListSettings
//
// @param archiveAndMuteNewChatsFromUnknownUsers True, if new chats from non-contacts will be automatically archived and muted. Can be set to true only if the option "can_archive_and_mute_new_chats_from_unknown_users" is true
// @param keepUnmutedChatsArchived True, if unmuted chats will be kept in the Archive chat list when they get a new message
// @param keepChatsFromFoldersArchived True, if unmuted chats, that are always included or pinned in a folder, will be kept in the Archive chat list when they get a new message. Ignored if keep_unmuted_chats_archived == true
func NewArchiveChatListSettings(archiveAndMuteNewChatsFromUnknownUsers bool, keepUnmutedChatsArchived bool, keepChatsFromFoldersArchived bool) *ArchiveChatListSettings {
	archiveChatListSettingsTemp := ArchiveChatListSettings{
		tdCommon:                               tdCommon{Type: "archiveChatListSettings"},
		ArchiveAndMuteNewChatsFromUnknownUsers: archiveAndMuteNewChatsFromUnknownUsers,
		KeepUnmutedChatsArchived:               keepUnmutedChatsArchived,
		KeepChatsFromFoldersArchived:           keepChatsFromFoldersArchived,
	}

	return &archiveChatListSettingsTemp
}

// UnmarshalJSON unmarshal to json
func (archiveChatListSettings *ArchiveChatListSettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ArchiveAndMuteNewChatsFromUnknownUsers bool `json:"archive_and_mute_new_chats_from_unknown_users"` // True, if new chats from non-contacts will be automatically archived and muted. Can be set to true only if the option "can_archive_and_mute_new_chats_from_unknown_users" is true
		KeepUnmutedChatsArchived               bool `json:"keep_unmuted_chats_archived"`                   // True, if unmuted chats will be kept in the Archive chat list when they get a new message
		KeepChatsFromFoldersArchived           bool `json:"keep_chats_from_folders_archived"`              // True, if unmuted chats, that are always included or pinned in a folder, will be kept in the Archive chat list when they get a new message. Ignored if keep_unmuted_chats_archived == true
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	archiveChatListSettings.tdCommon = tempObj.tdCommon
	archiveChatListSettings.ArchiveAndMuteNewChatsFromUnknownUsers = tempObj.ArchiveAndMuteNewChatsFromUnknownUsers
	archiveChatListSettings.KeepUnmutedChatsArchived = tempObj.KeepUnmutedChatsArchived
	archiveChatListSettings.KeepChatsFromFoldersArchived = tempObj.KeepChatsFromFoldersArchived

	return nil
}

// ChatListMain A main list of chats
type ChatListMain struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatListMain
func (chatListMain *ChatListMain) MessageType() string {
	return "chatListMain"
}

// NewChatListMain creates a new ChatListMain
//
func NewChatListMain() *ChatListMain {
	chatListMainTemp := ChatListMain{
		tdCommon: tdCommon{Type: "chatListMain"},
	}

	return &chatListMainTemp
}

// UnmarshalJSON unmarshal to json
func (chatListMain *ChatListMain) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatListMain.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatListEnum return the enum type of this object
func (chatListMain *ChatListMain) GetChatListEnum() ChatListEnum {
	return ChatListMainType
}

// ChatListArchive A list of chats usually located at the top of the main chat list. Unmuted chats are automatically moved from the Archive to the Main chat list when a new message arrives
type ChatListArchive struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatListArchive
func (chatListArchive *ChatListArchive) MessageType() string {
	return "chatListArchive"
}

// NewChatListArchive creates a new ChatListArchive
//
func NewChatListArchive() *ChatListArchive {
	chatListArchiveTemp := ChatListArchive{
		tdCommon: tdCommon{Type: "chatListArchive"},
	}

	return &chatListArchiveTemp
}

// UnmarshalJSON unmarshal to json
func (chatListArchive *ChatListArchive) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatListArchive.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatListEnum return the enum type of this object
func (chatListArchive *ChatListArchive) GetChatListEnum() ChatListEnum {
	return ChatListArchiveType
}

// ChatListFolder A list of chats added to a chat folder
type ChatListFolder struct {
	tdCommon
	ChatFolderID int32 `json:"chat_folder_id"` // Chat folder identifier
}

// MessageType return the string telegram-type of ChatListFolder
func (chatListFolder *ChatListFolder) MessageType() string {
	return "chatListFolder"
}

// NewChatListFolder creates a new ChatListFolder
//
// @param chatFolderID Chat folder identifier
func NewChatListFolder(chatFolderID int32) *ChatListFolder {
	chatListFolderTemp := ChatListFolder{
		tdCommon:     tdCommon{Type: "chatListFolder"},
		ChatFolderID: chatFolderID,
	}

	return &chatListFolderTemp
}

// UnmarshalJSON unmarshal to json
func (chatListFolder *ChatListFolder) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatFolderID int32 `json:"chat_folder_id"` // Chat folder identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatListFolder.tdCommon = tempObj.tdCommon
	chatListFolder.ChatFolderID = tempObj.ChatFolderID

	return nil
}

// GetChatListEnum return the enum type of this object
func (chatListFolder *ChatListFolder) GetChatListEnum() ChatListEnum {
	return ChatListFolderType
}

// ChatLists Contains a list of chat lists
type ChatLists struct {
	tdCommon
	ChatLists []ChatList `json:"chat_lists"` // List of chat lists
}

// MessageType return the string telegram-type of ChatLists
func (chatLists *ChatLists) MessageType() string {
	return "chatLists"
}

// NewChatLists creates a new ChatLists
//
// @param chatLists List of chat lists
func NewChatLists(chatLists []ChatList) *ChatLists {
	chatListsTemp := ChatLists{
		tdCommon:  tdCommon{Type: "chatLists"},
		ChatLists: chatLists,
	}

	return &chatListsTemp
}

// UnmarshalJSON unmarshal to json
func (chatLists *ChatLists) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatLists.tdCommon = tempObj.tdCommon

	fieldChatLists, _ := unmarshalChatListSlice(objMap["chat_lists"])
	chatLists.ChatLists = fieldChatLists

	return nil
}

// ChatSourceMtprotoProxy The chat is sponsored by the user's MTProxy server
type ChatSourceMtprotoProxy struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatSourceMtprotoProxy
func (chatSourceMtprotoProxy *ChatSourceMtprotoProxy) MessageType() string {
	return "chatSourceMtprotoProxy"
}

// NewChatSourceMtprotoProxy creates a new ChatSourceMtprotoProxy
//
func NewChatSourceMtprotoProxy() *ChatSourceMtprotoProxy {
	chatSourceMtprotoProxyTemp := ChatSourceMtprotoProxy{
		tdCommon: tdCommon{Type: "chatSourceMtprotoProxy"},
	}

	return &chatSourceMtprotoProxyTemp
}

// UnmarshalJSON unmarshal to json
func (chatSourceMtprotoProxy *ChatSourceMtprotoProxy) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatSourceMtprotoProxy.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatSourceEnum return the enum type of this object
func (chatSourceMtprotoProxy *ChatSourceMtprotoProxy) GetChatSourceEnum() ChatSourceEnum {
	return ChatSourceMtprotoProxyType
}

// ChatSourcePublicServiceAnnouncement The chat contains a public service announcement
type ChatSourcePublicServiceAnnouncement struct {
	tdCommon
	Type string `json:"type"` // The type of the announcement
	Text string `json:"text"` // The text of the announcement
}

// MessageType return the string telegram-type of ChatSourcePublicServiceAnnouncement
func (chatSourcePublicServiceAnnouncement *ChatSourcePublicServiceAnnouncement) MessageType() string {
	return "chatSourcePublicServiceAnnouncement"
}

// NewChatSourcePublicServiceAnnouncement creates a new ChatSourcePublicServiceAnnouncement
//
// @param typeParam The type of the announcement
// @param text The text of the announcement
func NewChatSourcePublicServiceAnnouncement(typeParam string, text string) *ChatSourcePublicServiceAnnouncement {
	chatSourcePublicServiceAnnouncementTemp := ChatSourcePublicServiceAnnouncement{
		tdCommon: tdCommon{Type: "chatSourcePublicServiceAnnouncement"},
		Type:     typeParam,
		Text:     text,
	}

	return &chatSourcePublicServiceAnnouncementTemp
}

// UnmarshalJSON unmarshal to json
func (chatSourcePublicServiceAnnouncement *ChatSourcePublicServiceAnnouncement) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Type string `json:"type"` // The type of the announcement
		Text string `json:"text"` // The text of the announcement
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatSourcePublicServiceAnnouncement.tdCommon = tempObj.tdCommon
	chatSourcePublicServiceAnnouncement.Type = tempObj.Type
	chatSourcePublicServiceAnnouncement.Text = tempObj.Text

	return nil
}

// GetChatSourceEnum return the enum type of this object
func (chatSourcePublicServiceAnnouncement *ChatSourcePublicServiceAnnouncement) GetChatSourceEnum() ChatSourceEnum {
	return ChatSourcePublicServiceAnnouncementType
}

// ChatPosition Describes a position of a chat in a chat list
type ChatPosition struct {
	tdCommon
	List     ChatList    `json:"list"`      // The chat list
	Order    JSONInt64   `json:"order"`     // A parameter used to determine order of the chat in the chat list. Chats must be sorted by the pair (order, chat.id) in descending order
	IsPinned bool        `json:"is_pinned"` // True, if the chat is pinned in the chat list
	Source   *ChatSource `json:"source"`    // Source of the chat in the chat list; may be null
}

// MessageType return the string telegram-type of ChatPosition
func (chatPosition *ChatPosition) MessageType() string {
	return "chatPosition"
}

// NewChatPosition creates a new ChatPosition
//
// @param list The chat list
// @param order A parameter used to determine order of the chat in the chat list. Chats must be sorted by the pair (order, chat.id) in descending order
// @param isPinned True, if the chat is pinned in the chat list
// @param source Source of the chat in the chat list; may be null
func NewChatPosition(list ChatList, order JSONInt64, isPinned bool, source *ChatSource) *ChatPosition {
	chatPositionTemp := ChatPosition{
		tdCommon: tdCommon{Type: "chatPosition"},
		List:     list,
		Order:    order,
		IsPinned: isPinned,
		Source:   source,
	}

	return &chatPositionTemp
}

// UnmarshalJSON unmarshal to json
func (chatPosition *ChatPosition) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Order    JSONInt64 `json:"order"`     // A parameter used to determine order of the chat in the chat list. Chats must be sorted by the pair (order, chat.id) in descending order
		IsPinned bool      `json:"is_pinned"` // True, if the chat is pinned in the chat list

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatPosition.tdCommon = tempObj.tdCommon
	chatPosition.Order = tempObj.Order
	chatPosition.IsPinned = tempObj.IsPinned

	fieldList, _ := unmarshalChatList(objMap["list"])
	chatPosition.List = fieldList

	fieldSource, _ := unmarshalChatSource(objMap["source"])
	chatPosition.Source = &fieldSource

	return nil
}

// ChatAvailableReactionsAll All reactions are available in the chat, excluding the paid reaction and custom reactions in channel chats
type ChatAvailableReactionsAll struct {
	tdCommon
	MaxReactionCount int32 `json:"max_reaction_count"` // The maximum allowed number of reactions per message; 1-11
}

// MessageType return the string telegram-type of ChatAvailableReactionsAll
func (chatAvailableReactionsAll *ChatAvailableReactionsAll) MessageType() string {
	return "chatAvailableReactionsAll"
}

// NewChatAvailableReactionsAll creates a new ChatAvailableReactionsAll
//
// @param maxReactionCount The maximum allowed number of reactions per message; 1-11
func NewChatAvailableReactionsAll(maxReactionCount int32) *ChatAvailableReactionsAll {
	chatAvailableReactionsAllTemp := ChatAvailableReactionsAll{
		tdCommon:         tdCommon{Type: "chatAvailableReactionsAll"},
		MaxReactionCount: maxReactionCount,
	}

	return &chatAvailableReactionsAllTemp
}

// UnmarshalJSON unmarshal to json
func (chatAvailableReactionsAll *ChatAvailableReactionsAll) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MaxReactionCount int32 `json:"max_reaction_count"` // The maximum allowed number of reactions per message; 1-11
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatAvailableReactionsAll.tdCommon = tempObj.tdCommon
	chatAvailableReactionsAll.MaxReactionCount = tempObj.MaxReactionCount

	return nil
}

// GetChatAvailableReactionsEnum return the enum type of this object
func (chatAvailableReactionsAll *ChatAvailableReactionsAll) GetChatAvailableReactionsEnum() ChatAvailableReactionsEnum {
	return ChatAvailableReactionsAllType
}

// ChatAvailableReactionsSome Only specific reactions are available in the chat
type ChatAvailableReactionsSome struct {
	tdCommon
	Reactions        []ReactionType `json:"reactions"`          // The list of reactions
	MaxReactionCount int32          `json:"max_reaction_count"` // The maximum allowed number of reactions per message; 1-11
}

// MessageType return the string telegram-type of ChatAvailableReactionsSome
func (chatAvailableReactionsSome *ChatAvailableReactionsSome) MessageType() string {
	return "chatAvailableReactionsSome"
}

// NewChatAvailableReactionsSome creates a new ChatAvailableReactionsSome
//
// @param reactions The list of reactions
// @param maxReactionCount The maximum allowed number of reactions per message; 1-11
func NewChatAvailableReactionsSome(reactions []ReactionType, maxReactionCount int32) *ChatAvailableReactionsSome {
	chatAvailableReactionsSomeTemp := ChatAvailableReactionsSome{
		tdCommon:         tdCommon{Type: "chatAvailableReactionsSome"},
		Reactions:        reactions,
		MaxReactionCount: maxReactionCount,
	}

	return &chatAvailableReactionsSomeTemp
}

// UnmarshalJSON unmarshal to json
func (chatAvailableReactionsSome *ChatAvailableReactionsSome) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MaxReactionCount int32 `json:"max_reaction_count"` // The maximum allowed number of reactions per message; 1-11
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatAvailableReactionsSome.tdCommon = tempObj.tdCommon
	chatAvailableReactionsSome.MaxReactionCount = tempObj.MaxReactionCount

	fieldReactions, _ := unmarshalReactionTypeSlice(objMap["reactions"])
	chatAvailableReactionsSome.Reactions = fieldReactions

	return nil
}

// GetChatAvailableReactionsEnum return the enum type of this object
func (chatAvailableReactionsSome *ChatAvailableReactionsSome) GetChatAvailableReactionsEnum() ChatAvailableReactionsEnum {
	return ChatAvailableReactionsSomeType
}

// SavedMessagesTag Represents a tag used in Saved Messages or a Saved Messages topic
type SavedMessagesTag struct {
	tdCommon
	Tag   ReactionType `json:"tag"`   // The tag
	Label string       `json:"label"` // Label of the tag; 0-12 characters. Always empty if the tag is returned for a Saved Messages topic
	Count int32        `json:"count"` // Number of times the tag was used; may be 0 if the tag has non-empty label
}

// MessageType return the string telegram-type of SavedMessagesTag
func (savedMessagesTag *SavedMessagesTag) MessageType() string {
	return "savedMessagesTag"
}

// NewSavedMessagesTag creates a new SavedMessagesTag
//
// @param tag The tag
// @param label Label of the tag; 0-12 characters. Always empty if the tag is returned for a Saved Messages topic
// @param count Number of times the tag was used; may be 0 if the tag has non-empty label
func NewSavedMessagesTag(tag ReactionType, label string, count int32) *SavedMessagesTag {
	savedMessagesTagTemp := SavedMessagesTag{
		tdCommon: tdCommon{Type: "savedMessagesTag"},
		Tag:      tag,
		Label:    label,
		Count:    count,
	}

	return &savedMessagesTagTemp
}

// UnmarshalJSON unmarshal to json
func (savedMessagesTag *SavedMessagesTag) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Label string `json:"label"` // Label of the tag; 0-12 characters. Always empty if the tag is returned for a Saved Messages topic
		Count int32  `json:"count"` // Number of times the tag was used; may be 0 if the tag has non-empty label
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	savedMessagesTag.tdCommon = tempObj.tdCommon
	savedMessagesTag.Label = tempObj.Label
	savedMessagesTag.Count = tempObj.Count

	fieldTag, _ := unmarshalReactionType(objMap["tag"])
	savedMessagesTag.Tag = fieldTag

	return nil
}

// SavedMessagesTags Contains a list of tags used in Saved Messages
type SavedMessagesTags struct {
	tdCommon
	Tags []SavedMessagesTag `json:"tags"` // List of tags
}

// MessageType return the string telegram-type of SavedMessagesTags
func (savedMessagesTags *SavedMessagesTags) MessageType() string {
	return "savedMessagesTags"
}

// NewSavedMessagesTags creates a new SavedMessagesTags
//
// @param tags List of tags
func NewSavedMessagesTags(tags []SavedMessagesTag) *SavedMessagesTags {
	savedMessagesTagsTemp := SavedMessagesTags{
		tdCommon: tdCommon{Type: "savedMessagesTags"},
		Tags:     tags,
	}

	return &savedMessagesTagsTemp
}

// UnmarshalJSON unmarshal to json
func (savedMessagesTags *SavedMessagesTags) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Tags []SavedMessagesTag `json:"tags"` // List of tags
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	savedMessagesTags.tdCommon = tempObj.tdCommon
	savedMessagesTags.Tags = tempObj.Tags

	return nil
}

// BusinessBotManageBar Contains information about a business bot that manages the chat
type BusinessBotManageBar struct {
	tdCommon
	BotUserID   int64  `json:"bot_user_id"`   // User identifier of the bot
	ManageURL   string `json:"manage_url"`    // URL to be opened to manage the bot
	IsBotPaused bool   `json:"is_bot_paused"` // True, if the bot is paused. Use toggleBusinessConnectedBotChatIsPaused to change the value of the field
	CanBotReply bool   `json:"can_bot_reply"` // True, if the bot can reply
}

// MessageType return the string telegram-type of BusinessBotManageBar
func (businessBotManageBar *BusinessBotManageBar) MessageType() string {
	return "businessBotManageBar"
}

// NewBusinessBotManageBar creates a new BusinessBotManageBar
//
// @param botUserID User identifier of the bot
// @param manageURL URL to be opened to manage the bot
// @param isBotPaused True, if the bot is paused. Use toggleBusinessConnectedBotChatIsPaused to change the value of the field
// @param canBotReply True, if the bot can reply
func NewBusinessBotManageBar(botUserID int64, manageURL string, isBotPaused bool, canBotReply bool) *BusinessBotManageBar {
	businessBotManageBarTemp := BusinessBotManageBar{
		tdCommon:    tdCommon{Type: "businessBotManageBar"},
		BotUserID:   botUserID,
		ManageURL:   manageURL,
		IsBotPaused: isBotPaused,
		CanBotReply: canBotReply,
	}

	return &businessBotManageBarTemp
}

// UnmarshalJSON unmarshal to json
func (businessBotManageBar *BusinessBotManageBar) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BotUserID   int64  `json:"bot_user_id"`   // User identifier of the bot
		ManageURL   string `json:"manage_url"`    // URL to be opened to manage the bot
		IsBotPaused bool   `json:"is_bot_paused"` // True, if the bot is paused. Use toggleBusinessConnectedBotChatIsPaused to change the value of the field
		CanBotReply bool   `json:"can_bot_reply"` // True, if the bot can reply
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessBotManageBar.tdCommon = tempObj.tdCommon
	businessBotManageBar.BotUserID = tempObj.BotUserID
	businessBotManageBar.ManageURL = tempObj.ManageURL
	businessBotManageBar.IsBotPaused = tempObj.IsBotPaused
	businessBotManageBar.CanBotReply = tempObj.CanBotReply

	return nil
}

// VideoChat Describes a video chat
type VideoChat struct {
	tdCommon
	GroupCallID          int32          `json:"group_call_id"`          // Group call identifier of an active video chat; 0 if none. Full information about the video chat can be received through the method getGroupCall
	HasParticipants      bool           `json:"has_participants"`       // True, if the video chat has participants
	DefaultParticipantID *MessageSender `json:"default_participant_id"` // Default group call participant identifier to join the video chat; may be null
}

// MessageType return the string telegram-type of VideoChat
func (videoChat *VideoChat) MessageType() string {
	return "videoChat"
}

// NewVideoChat creates a new VideoChat
//
// @param groupCallID Group call identifier of an active video chat; 0 if none. Full information about the video chat can be received through the method getGroupCall
// @param hasParticipants True, if the video chat has participants
// @param defaultParticipantID Default group call participant identifier to join the video chat; may be null
func NewVideoChat(groupCallID int32, hasParticipants bool, defaultParticipantID *MessageSender) *VideoChat {
	videoChatTemp := VideoChat{
		tdCommon:             tdCommon{Type: "videoChat"},
		GroupCallID:          groupCallID,
		HasParticipants:      hasParticipants,
		DefaultParticipantID: defaultParticipantID,
	}

	return &videoChatTemp
}

// UnmarshalJSON unmarshal to json
func (videoChat *VideoChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		GroupCallID     int32 `json:"group_call_id"`    // Group call identifier of an active video chat; 0 if none. Full information about the video chat can be received through the method getGroupCall
		HasParticipants bool  `json:"has_participants"` // True, if the video chat has participants

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	videoChat.tdCommon = tempObj.tdCommon
	videoChat.GroupCallID = tempObj.GroupCallID
	videoChat.HasParticipants = tempObj.HasParticipants

	fieldDefaultParticipantID, _ := unmarshalMessageSender(objMap["default_participant_id"])
	videoChat.DefaultParticipantID = &fieldDefaultParticipantID

	return nil
}

// Chat A chat. (Can be a private chat, basic group, supergroup, or secret chat)
type Chat struct {
	tdCommon
	ID                             int64                     `json:"id"`                                 // Chat unique identifier
	Type                           ChatType                  `json:"type"`                               // Type of the chat
	Title                          string                    `json:"title"`                              // Chat title
	Photo                          *ChatPhotoInfo            `json:"photo"`                              // Chat photo; may be null
	AccentColorID                  int32                     `json:"accent_color_id"`                    // Identifier of the accent color for message sender name, and backgrounds of chat photo, reply header, and link preview
	BackgroundCustomEmojiID        JSONInt64                 `json:"background_custom_emoji_id"`         // Identifier of a custom emoji to be shown on the reply header and link preview background for messages sent by the chat; 0 if none
	ProfileAccentColorID           int32                     `json:"profile_accent_color_id"`            // Identifier of the profile accent color for the chat's profile; -1 if none
	ProfileBackgroundCustomEmojiID JSONInt64                 `json:"profile_background_custom_emoji_id"` // Identifier of a custom emoji to be shown on the background of the chat's profile; 0 if none
	Permissions                    *ChatPermissions          `json:"permissions"`                        // Actions that non-administrator chat members are allowed to take in the chat
	LastMessage                    *Message                  `json:"last_message"`                       // Last message in the chat; may be null if none or unknown
	Positions                      []ChatPosition            `json:"positions"`                          // Positions of the chat in chat lists
	ChatLists                      []ChatList                `json:"chat_lists"`                         // Chat lists to which the chat belongs. A chat can have a non-zero position in a chat list even it doesn't belong to the chat list and have no position in a chat list even it belongs to the chat list
	MessageSenderID                *MessageSender            `json:"message_sender_id"`                  // Identifier of a user or chat that is selected to send messages in the chat; may be null if the user can't change message sender
	BlockList                      *BlockList                `json:"block_list"`                         // Block list to which the chat is added; may be null if none
	HasProtectedContent            bool                      `json:"has_protected_content"`              // True, if chat content can't be saved locally, forwarded, or copied
	IsTranslatable                 bool                      `json:"is_translatable"`                    // True, if translation of all messages in the chat must be suggested to the user
	IsMarkedAsUnread               bool                      `json:"is_marked_as_unread"`                // True, if the chat is marked as unread
	ViewAsTopics                   bool                      `json:"view_as_topics"`                     // True, if the chat is a forum supergroup that must be shown in the "View as topics" mode, or Saved Messages chat that must be shown in the "View as chats"
	HasScheduledMessages           bool                      `json:"has_scheduled_messages"`             // True, if the chat has scheduled messages
	CanBeDeletedOnlyForSelf        bool                      `json:"can_be_deleted_only_for_self"`       // True, if the chat messages can be deleted only for the current user while other users will continue to see the messages
	CanBeDeletedForAllUsers        bool                      `json:"can_be_deleted_for_all_users"`       // True, if the chat messages can be deleted for all users
	CanBeReported                  bool                      `json:"can_be_reported"`                    // True, if the chat can be reported to Telegram moderators through reportChat or reportChatPhoto
	DefaultDisableNotification     bool                      `json:"default_disable_notification"`       // Default value of the disable_notification parameter, used when a message is sent to the chat
	UnreadCount                    int32                     `json:"unread_count"`                       // Number of unread messages in the chat
	LastReadInboxMessageID         int64                     `json:"last_read_inbox_message_id"`         // Identifier of the last read incoming message
	LastReadOutboxMessageID        int64                     `json:"last_read_outbox_message_id"`        // Identifier of the last read outgoing message
	UnreadMentionCount             int32                     `json:"unread_mention_count"`               // Number of unread messages with a mention/reply in the chat
	UnreadReactionCount            int32                     `json:"unread_reaction_count"`              // Number of messages with unread reactions in the chat
	NotificationSettings           *ChatNotificationSettings `json:"notification_settings"`              // Notification settings for the chat
	AvailableReactions             ChatAvailableReactions    `json:"available_reactions"`                // Types of reaction, available in the chat
	MessageAutoDeleteTime          int32                     `json:"message_auto_delete_time"`           // Current message auto-delete or self-destruct timer setting for the chat, in seconds; 0 if disabled. Self-destruct timer in secret chats starts after the message or its content is viewed. Auto-delete timer in other chats starts from the send date
	EmojiStatus                    *EmojiStatus              `json:"emoji_status"`                       // Emoji status to be shown along with chat title; may be null
	Background                     *ChatBackground           `json:"background"`                         // Background set for the chat; may be null if none
	ThemeName                      string                    `json:"theme_name"`                         // If non-empty, name of a theme, set for the chat
	ActionBar                      *ChatActionBar            `json:"action_bar"`                         // Information about actions which must be possible to do through the chat action bar; may be null if none
	BusinessBotManageBar           *BusinessBotManageBar     `json:"business_bot_manage_bar"`            // Information about bar for managing a business bot in the chat; may be null if none
	VideoChat                      *VideoChat                `json:"video_chat"`                         // Information about video chat of the chat
	PendingJoinRequests            *ChatJoinRequestsInfo     `json:"pending_join_requests"`              // Information about pending join requests; may be null if none
	ReplyMarkupMessageID           int64                     `json:"reply_markup_message_id"`            // Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
	DraftMessage                   *DraftMessage             `json:"draft_message"`                      // A draft of a message in the chat; may be null if none
	ClientData                     string                    `json:"client_data"`                        // Application-specific data associated with the chat. (For example, the chat scroll position or local chat notification settings can be stored here.) Persistent if the message database is used
}

// MessageType return the string telegram-type of Chat
func (chat *Chat) MessageType() string {
	return "chat"
}

// NewChat creates a new Chat
//
// @param iD Chat unique identifier
// @param typeParam Type of the chat
// @param title Chat title
// @param photo Chat photo; may be null
// @param accentColorID Identifier of the accent color for message sender name, and backgrounds of chat photo, reply header, and link preview
// @param backgroundCustomEmojiID Identifier of a custom emoji to be shown on the reply header and link preview background for messages sent by the chat; 0 if none
// @param profileAccentColorID Identifier of the profile accent color for the chat's profile; -1 if none
// @param profileBackgroundCustomEmojiID Identifier of a custom emoji to be shown on the background of the chat's profile; 0 if none
// @param permissions Actions that non-administrator chat members are allowed to take in the chat
// @param lastMessage Last message in the chat; may be null if none or unknown
// @param positions Positions of the chat in chat lists
// @param chatLists Chat lists to which the chat belongs. A chat can have a non-zero position in a chat list even it doesn't belong to the chat list and have no position in a chat list even it belongs to the chat list
// @param messageSenderID Identifier of a user or chat that is selected to send messages in the chat; may be null if the user can't change message sender
// @param blockList Block list to which the chat is added; may be null if none
// @param hasProtectedContent True, if chat content can't be saved locally, forwarded, or copied
// @param isTranslatable True, if translation of all messages in the chat must be suggested to the user
// @param isMarkedAsUnread True, if the chat is marked as unread
// @param viewAsTopics True, if the chat is a forum supergroup that must be shown in the "View as topics" mode, or Saved Messages chat that must be shown in the "View as chats"
// @param hasScheduledMessages True, if the chat has scheduled messages
// @param canBeDeletedOnlyForSelf True, if the chat messages can be deleted only for the current user while other users will continue to see the messages
// @param canBeDeletedForAllUsers True, if the chat messages can be deleted for all users
// @param canBeReported True, if the chat can be reported to Telegram moderators through reportChat or reportChatPhoto
// @param defaultDisableNotification Default value of the disable_notification parameter, used when a message is sent to the chat
// @param unreadCount Number of unread messages in the chat
// @param lastReadInboxMessageID Identifier of the last read incoming message
// @param lastReadOutboxMessageID Identifier of the last read outgoing message
// @param unreadMentionCount Number of unread messages with a mention/reply in the chat
// @param unreadReactionCount Number of messages with unread reactions in the chat
// @param notificationSettings Notification settings for the chat
// @param availableReactions Types of reaction, available in the chat
// @param messageAutoDeleteTime Current message auto-delete or self-destruct timer setting for the chat, in seconds; 0 if disabled. Self-destruct timer in secret chats starts after the message or its content is viewed. Auto-delete timer in other chats starts from the send date
// @param emojiStatus Emoji status to be shown along with chat title; may be null
// @param background Background set for the chat; may be null if none
// @param themeName If non-empty, name of a theme, set for the chat
// @param actionBar Information about actions which must be possible to do through the chat action bar; may be null if none
// @param businessBotManageBar Information about bar for managing a business bot in the chat; may be null if none
// @param videoChat Information about video chat of the chat
// @param pendingJoinRequests Information about pending join requests; may be null if none
// @param replyMarkupMessageID Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
// @param draftMessage A draft of a message in the chat; may be null if none
// @param clientData Application-specific data associated with the chat. (For example, the chat scroll position or local chat notification settings can be stored here.) Persistent if the message database is used
func NewChat(iD int64, typeParam ChatType, title string, photo *ChatPhotoInfo, accentColorID int32, backgroundCustomEmojiID JSONInt64, profileAccentColorID int32, profileBackgroundCustomEmojiID JSONInt64, permissions *ChatPermissions, lastMessage *Message, positions []ChatPosition, chatLists []ChatList, messageSenderID *MessageSender, blockList *BlockList, hasProtectedContent bool, isTranslatable bool, isMarkedAsUnread bool, viewAsTopics bool, hasScheduledMessages bool, canBeDeletedOnlyForSelf bool, canBeDeletedForAllUsers bool, canBeReported bool, defaultDisableNotification bool, unreadCount int32, lastReadInboxMessageID int64, lastReadOutboxMessageID int64, unreadMentionCount int32, unreadReactionCount int32, notificationSettings *ChatNotificationSettings, availableReactions ChatAvailableReactions, messageAutoDeleteTime int32, emojiStatus *EmojiStatus, background *ChatBackground, themeName string, actionBar *ChatActionBar, businessBotManageBar *BusinessBotManageBar, videoChat *VideoChat, pendingJoinRequests *ChatJoinRequestsInfo, replyMarkupMessageID int64, draftMessage *DraftMessage, clientData string) *Chat {
	chatTemp := Chat{
		tdCommon:                       tdCommon{Type: "chat"},
		ID:                             iD,
		Type:                           typeParam,
		Title:                          title,
		Photo:                          photo,
		AccentColorID:                  accentColorID,
		BackgroundCustomEmojiID:        backgroundCustomEmojiID,
		ProfileAccentColorID:           profileAccentColorID,
		ProfileBackgroundCustomEmojiID: profileBackgroundCustomEmojiID,
		Permissions:                    permissions,
		LastMessage:                    lastMessage,
		Positions:                      positions,
		ChatLists:                      chatLists,
		MessageSenderID:                messageSenderID,
		BlockList:                      blockList,
		HasProtectedContent:            hasProtectedContent,
		IsTranslatable:                 isTranslatable,
		IsMarkedAsUnread:               isMarkedAsUnread,
		ViewAsTopics:                   viewAsTopics,
		HasScheduledMessages:           hasScheduledMessages,
		CanBeDeletedOnlyForSelf:        canBeDeletedOnlyForSelf,
		CanBeDeletedForAllUsers:        canBeDeletedForAllUsers,
		CanBeReported:                  canBeReported,
		DefaultDisableNotification:     defaultDisableNotification,
		UnreadCount:                    unreadCount,
		LastReadInboxMessageID:         lastReadInboxMessageID,
		LastReadOutboxMessageID:        lastReadOutboxMessageID,
		UnreadMentionCount:             unreadMentionCount,
		UnreadReactionCount:            unreadReactionCount,
		NotificationSettings:           notificationSettings,
		AvailableReactions:             availableReactions,
		MessageAutoDeleteTime:          messageAutoDeleteTime,
		EmojiStatus:                    emojiStatus,
		Background:                     background,
		ThemeName:                      themeName,
		ActionBar:                      actionBar,
		BusinessBotManageBar:           businessBotManageBar,
		VideoChat:                      videoChat,
		PendingJoinRequests:            pendingJoinRequests,
		ReplyMarkupMessageID:           replyMarkupMessageID,
		DraftMessage:                   draftMessage,
		ClientData:                     clientData,
	}

	return &chatTemp
}

// UnmarshalJSON unmarshal to json
func (chat *Chat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID                             int64                     `json:"id"`                                 // Chat unique identifier
		Title                          string                    `json:"title"`                              // Chat title
		Photo                          *ChatPhotoInfo            `json:"photo"`                              // Chat photo; may be null
		AccentColorID                  int32                     `json:"accent_color_id"`                    // Identifier of the accent color for message sender name, and backgrounds of chat photo, reply header, and link preview
		BackgroundCustomEmojiID        JSONInt64                 `json:"background_custom_emoji_id"`         // Identifier of a custom emoji to be shown on the reply header and link preview background for messages sent by the chat; 0 if none
		ProfileAccentColorID           int32                     `json:"profile_accent_color_id"`            // Identifier of the profile accent color for the chat's profile; -1 if none
		ProfileBackgroundCustomEmojiID JSONInt64                 `json:"profile_background_custom_emoji_id"` // Identifier of a custom emoji to be shown on the background of the chat's profile; 0 if none
		Permissions                    *ChatPermissions          `json:"permissions"`                        // Actions that non-administrator chat members are allowed to take in the chat
		Positions                      []ChatPosition            `json:"positions"`                          // Positions of the chat in chat lists
		HasProtectedContent            bool                      `json:"has_protected_content"`              // True, if chat content can't be saved locally, forwarded, or copied
		IsTranslatable                 bool                      `json:"is_translatable"`                    // True, if translation of all messages in the chat must be suggested to the user
		IsMarkedAsUnread               bool                      `json:"is_marked_as_unread"`                // True, if the chat is marked as unread
		ViewAsTopics                   bool                      `json:"view_as_topics"`                     // True, if the chat is a forum supergroup that must be shown in the "View as topics" mode, or Saved Messages chat that must be shown in the "View as chats"
		HasScheduledMessages           bool                      `json:"has_scheduled_messages"`             // True, if the chat has scheduled messages
		CanBeDeletedOnlyForSelf        bool                      `json:"can_be_deleted_only_for_self"`       // True, if the chat messages can be deleted only for the current user while other users will continue to see the messages
		CanBeDeletedForAllUsers        bool                      `json:"can_be_deleted_for_all_users"`       // True, if the chat messages can be deleted for all users
		CanBeReported                  bool                      `json:"can_be_reported"`                    // True, if the chat can be reported to Telegram moderators through reportChat or reportChatPhoto
		DefaultDisableNotification     bool                      `json:"default_disable_notification"`       // Default value of the disable_notification parameter, used when a message is sent to the chat
		UnreadCount                    int32                     `json:"unread_count"`                       // Number of unread messages in the chat
		LastReadInboxMessageID         int64                     `json:"last_read_inbox_message_id"`         // Identifier of the last read incoming message
		LastReadOutboxMessageID        int64                     `json:"last_read_outbox_message_id"`        // Identifier of the last read outgoing message
		UnreadMentionCount             int32                     `json:"unread_mention_count"`               // Number of unread messages with a mention/reply in the chat
		UnreadReactionCount            int32                     `json:"unread_reaction_count"`              // Number of messages with unread reactions in the chat
		NotificationSettings           *ChatNotificationSettings `json:"notification_settings"`              // Notification settings for the chat
		MessageAutoDeleteTime          int32                     `json:"message_auto_delete_time"`           // Current message auto-delete or self-destruct timer setting for the chat, in seconds; 0 if disabled. Self-destruct timer in secret chats starts after the message or its content is viewed. Auto-delete timer in other chats starts from the send date
		EmojiStatus                    *EmojiStatus              `json:"emoji_status"`                       // Emoji status to be shown along with chat title; may be null
		Background                     *ChatBackground           `json:"background"`                         // Background set for the chat; may be null if none
		ThemeName                      string                    `json:"theme_name"`                         // If non-empty, name of a theme, set for the chat
		BusinessBotManageBar           *BusinessBotManageBar     `json:"business_bot_manage_bar"`            // Information about bar for managing a business bot in the chat; may be null if none
		PendingJoinRequests            *ChatJoinRequestsInfo     `json:"pending_join_requests"`              // Information about pending join requests; may be null if none
		ReplyMarkupMessageID           int64                     `json:"reply_markup_message_id"`            // Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
		ClientData                     string                    `json:"client_data"`                        // Application-specific data associated with the chat. (For example, the chat scroll position or local chat notification settings can be stored here.) Persistent if the message database is used
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chat.tdCommon = tempObj.tdCommon
	chat.ID = tempObj.ID
	chat.Title = tempObj.Title
	chat.Photo = tempObj.Photo
	chat.AccentColorID = tempObj.AccentColorID
	chat.BackgroundCustomEmojiID = tempObj.BackgroundCustomEmojiID
	chat.ProfileAccentColorID = tempObj.ProfileAccentColorID
	chat.ProfileBackgroundCustomEmojiID = tempObj.ProfileBackgroundCustomEmojiID
	chat.Permissions = tempObj.Permissions
	chat.Positions = tempObj.Positions
	chat.HasProtectedContent = tempObj.HasProtectedContent
	chat.IsTranslatable = tempObj.IsTranslatable
	chat.IsMarkedAsUnread = tempObj.IsMarkedAsUnread
	chat.ViewAsTopics = tempObj.ViewAsTopics
	chat.HasScheduledMessages = tempObj.HasScheduledMessages
	chat.CanBeDeletedOnlyForSelf = tempObj.CanBeDeletedOnlyForSelf
	chat.CanBeDeletedForAllUsers = tempObj.CanBeDeletedForAllUsers
	chat.CanBeReported = tempObj.CanBeReported
	chat.DefaultDisableNotification = tempObj.DefaultDisableNotification
	chat.UnreadCount = tempObj.UnreadCount
	chat.LastReadInboxMessageID = tempObj.LastReadInboxMessageID
	chat.LastReadOutboxMessageID = tempObj.LastReadOutboxMessageID
	chat.UnreadMentionCount = tempObj.UnreadMentionCount
	chat.UnreadReactionCount = tempObj.UnreadReactionCount
	chat.NotificationSettings = tempObj.NotificationSettings
	chat.MessageAutoDeleteTime = tempObj.MessageAutoDeleteTime
	chat.EmojiStatus = tempObj.EmojiStatus
	chat.Background = tempObj.Background
	chat.ThemeName = tempObj.ThemeName
	chat.BusinessBotManageBar = tempObj.BusinessBotManageBar
	chat.PendingJoinRequests = tempObj.PendingJoinRequests
	chat.ReplyMarkupMessageID = tempObj.ReplyMarkupMessageID
	chat.ClientData = tempObj.ClientData

	fieldType, _ := unmarshalChatType(objMap["type"])
	chat.Type = fieldType

	fieldMessageSenderID, _ := unmarshalMessageSender(objMap["message_sender_id"])
	chat.MessageSenderID = &fieldMessageSenderID

	fieldBlockList, _ := unmarshalBlockList(objMap["block_list"])
	chat.BlockList = &fieldBlockList

	fieldAvailableReactions, _ := unmarshalChatAvailableReactions(objMap["available_reactions"])
	chat.AvailableReactions = fieldAvailableReactions

	fieldActionBar, _ := unmarshalChatActionBar(objMap["action_bar"])
	chat.ActionBar = &fieldActionBar

	var lastMessage Message
	if objMap["last_message"] != nil {
		err = lastMessage.UnmarshalJSON(*objMap["last_message"])
		if err != nil {
			return err
		}
	}

	chat.LastMessage = &lastMessage

	var videoChat VideoChat
	if objMap["video_chat"] != nil {
		err = videoChat.UnmarshalJSON(*objMap["video_chat"])
		if err != nil {
			return err
		}
	}

	chat.VideoChat = &videoChat

	var draftMessage DraftMessage
	if objMap["draft_message"] != nil {
		err = draftMessage.UnmarshalJSON(*objMap["draft_message"])
		if err != nil {
			return err
		}
	}

	chat.DraftMessage = &draftMessage

	fieldChatLists, _ := unmarshalChatListSlice(objMap["chat_lists"])
	chat.ChatLists = fieldChatLists

	return nil
}

// Chats Represents a list of chats
type Chats struct {
	tdCommon
	TotalCount int32   `json:"total_count"` // Approximate total number of chats found
	ChatIDs    []int64 `json:"chat_ids"`    // List of chat identifiers
}

// MessageType return the string telegram-type of Chats
func (chats *Chats) MessageType() string {
	return "chats"
}

// NewChats creates a new Chats
//
// @param totalCount Approximate total number of chats found
// @param chatIDs List of chat identifiers
func NewChats(totalCount int32, chatIDs []int64) *Chats {
	chatsTemp := Chats{
		tdCommon:   tdCommon{Type: "chats"},
		TotalCount: totalCount,
		ChatIDs:    chatIDs,
	}

	return &chatsTemp
}

// UnmarshalJSON unmarshal to json
func (chats *Chats) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32   `json:"total_count"` // Approximate total number of chats found
		ChatIDs    []int64 `json:"chat_ids"`    // List of chat identifiers
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chats.tdCommon = tempObj.tdCommon
	chats.TotalCount = tempObj.TotalCount
	chats.ChatIDs = tempObj.ChatIDs

	return nil
}

// FailedToAddMember Contains information about a user that has failed to be added to a chat
type FailedToAddMember struct {
	tdCommon
	UserID                        int64 `json:"user_id"`                           // User identifier
	PremiumWouldAllowInvite       bool  `json:"premium_would_allow_invite"`        // True, if subscription to Telegram Premium would have allowed to add the user to the chat
	PremiumRequiredToSendMessages bool  `json:"premium_required_to_send_messages"` // True, if subscription to Telegram Premium is required to send the user chat invite link
}

// MessageType return the string telegram-type of FailedToAddMember
func (failedToAddMember *FailedToAddMember) MessageType() string {
	return "failedToAddMember"
}

// NewFailedToAddMember creates a new FailedToAddMember
//
// @param userID User identifier
// @param premiumWouldAllowInvite True, if subscription to Telegram Premium would have allowed to add the user to the chat
// @param premiumRequiredToSendMessages True, if subscription to Telegram Premium is required to send the user chat invite link
func NewFailedToAddMember(userID int64, premiumWouldAllowInvite bool, premiumRequiredToSendMessages bool) *FailedToAddMember {
	failedToAddMemberTemp := FailedToAddMember{
		tdCommon:                      tdCommon{Type: "failedToAddMember"},
		UserID:                        userID,
		PremiumWouldAllowInvite:       premiumWouldAllowInvite,
		PremiumRequiredToSendMessages: premiumRequiredToSendMessages,
	}

	return &failedToAddMemberTemp
}

// UnmarshalJSON unmarshal to json
func (failedToAddMember *FailedToAddMember) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID                        int64 `json:"user_id"`                           // User identifier
		PremiumWouldAllowInvite       bool  `json:"premium_would_allow_invite"`        // True, if subscription to Telegram Premium would have allowed to add the user to the chat
		PremiumRequiredToSendMessages bool  `json:"premium_required_to_send_messages"` // True, if subscription to Telegram Premium is required to send the user chat invite link
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	failedToAddMember.tdCommon = tempObj.tdCommon
	failedToAddMember.UserID = tempObj.UserID
	failedToAddMember.PremiumWouldAllowInvite = tempObj.PremiumWouldAllowInvite
	failedToAddMember.PremiumRequiredToSendMessages = tempObj.PremiumRequiredToSendMessages

	return nil
}

// FailedToAddMembers Represents a list of users that has failed to be added to a chat
type FailedToAddMembers struct {
	tdCommon
	FailedToAddMembers []FailedToAddMember `json:"failed_to_add_members"` // Information about users that weren't added to the chat
}

// MessageType return the string telegram-type of FailedToAddMembers
func (failedToAddMembers *FailedToAddMembers) MessageType() string {
	return "failedToAddMembers"
}

// NewFailedToAddMembers creates a new FailedToAddMembers
//
// @param failedToAddMembers Information about users that weren't added to the chat
func NewFailedToAddMembers(failedToAddMembers []FailedToAddMember) *FailedToAddMembers {
	failedToAddMembersTemp := FailedToAddMembers{
		tdCommon:           tdCommon{Type: "failedToAddMembers"},
		FailedToAddMembers: failedToAddMembers,
	}

	return &failedToAddMembersTemp
}

// UnmarshalJSON unmarshal to json
func (failedToAddMembers *FailedToAddMembers) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		FailedToAddMembers []FailedToAddMember `json:"failed_to_add_members"` // Information about users that weren't added to the chat
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	failedToAddMembers.tdCommon = tempObj.tdCommon
	failedToAddMembers.FailedToAddMembers = tempObj.FailedToAddMembers

	return nil
}

// CreatedBasicGroupChat Contains information about a newly created basic group chat
type CreatedBasicGroupChat struct {
	tdCommon
	ChatID             int64               `json:"chat_id"`               // Chat identifier
	FailedToAddMembers *FailedToAddMembers `json:"failed_to_add_members"` // Information about failed to add members
}

// MessageType return the string telegram-type of CreatedBasicGroupChat
func (createdBasicGroupChat *CreatedBasicGroupChat) MessageType() string {
	return "createdBasicGroupChat"
}

// NewCreatedBasicGroupChat creates a new CreatedBasicGroupChat
//
// @param chatID Chat identifier
// @param failedToAddMembers Information about failed to add members
func NewCreatedBasicGroupChat(chatID int64, failedToAddMembers *FailedToAddMembers) *CreatedBasicGroupChat {
	createdBasicGroupChatTemp := CreatedBasicGroupChat{
		tdCommon:           tdCommon{Type: "createdBasicGroupChat"},
		ChatID:             chatID,
		FailedToAddMembers: failedToAddMembers,
	}

	return &createdBasicGroupChatTemp
}

// UnmarshalJSON unmarshal to json
func (createdBasicGroupChat *CreatedBasicGroupChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID             int64               `json:"chat_id"`               // Chat identifier
		FailedToAddMembers *FailedToAddMembers `json:"failed_to_add_members"` // Information about failed to add members
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	createdBasicGroupChat.tdCommon = tempObj.tdCommon
	createdBasicGroupChat.ChatID = tempObj.ChatID
	createdBasicGroupChat.FailedToAddMembers = tempObj.FailedToAddMembers

	return nil
}

// ChatNearby Describes a chat located nearby
type ChatNearby struct {
	tdCommon
	ChatID   int64 `json:"chat_id"`  // Chat identifier
	Distance int32 `json:"distance"` // Distance to the chat location, in meters
}

// MessageType return the string telegram-type of ChatNearby
func (chatNearby *ChatNearby) MessageType() string {
	return "chatNearby"
}

// NewChatNearby creates a new ChatNearby
//
// @param chatID Chat identifier
// @param distance Distance to the chat location, in meters
func NewChatNearby(chatID int64, distance int32) *ChatNearby {
	chatNearbyTemp := ChatNearby{
		tdCommon: tdCommon{Type: "chatNearby"},
		ChatID:   chatID,
		Distance: distance,
	}

	return &chatNearbyTemp
}

// UnmarshalJSON unmarshal to json
func (chatNearby *ChatNearby) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID   int64 `json:"chat_id"`  // Chat identifier
		Distance int32 `json:"distance"` // Distance to the chat location, in meters
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatNearby.tdCommon = tempObj.tdCommon
	chatNearby.ChatID = tempObj.ChatID
	chatNearby.Distance = tempObj.Distance

	return nil
}

// ChatsNearby Represents a list of chats located nearby
type ChatsNearby struct {
	tdCommon
	UsersNearby       []ChatNearby `json:"users_nearby"`       // List of users nearby
	SupergroupsNearby []ChatNearby `json:"supergroups_nearby"` // List of location-based supergroups nearby
}

// MessageType return the string telegram-type of ChatsNearby
func (chatsNearby *ChatsNearby) MessageType() string {
	return "chatsNearby"
}

// NewChatsNearby creates a new ChatsNearby
//
// @param usersNearby List of users nearby
// @param supergroupsNearby List of location-based supergroups nearby
func NewChatsNearby(usersNearby []ChatNearby, supergroupsNearby []ChatNearby) *ChatsNearby {
	chatsNearbyTemp := ChatsNearby{
		tdCommon:          tdCommon{Type: "chatsNearby"},
		UsersNearby:       usersNearby,
		SupergroupsNearby: supergroupsNearby,
	}

	return &chatsNearbyTemp
}

// UnmarshalJSON unmarshal to json
func (chatsNearby *ChatsNearby) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UsersNearby       []ChatNearby `json:"users_nearby"`       // List of users nearby
		SupergroupsNearby []ChatNearby `json:"supergroups_nearby"` // List of location-based supergroups nearby
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatsNearby.tdCommon = tempObj.tdCommon
	chatsNearby.UsersNearby = tempObj.UsersNearby
	chatsNearby.SupergroupsNearby = tempObj.SupergroupsNearby

	return nil
}

// PublicChatTypeHasUsername The chat is public, because it has an active username
type PublicChatTypeHasUsername struct {
	tdCommon
}

// MessageType return the string telegram-type of PublicChatTypeHasUsername
func (publicChatTypeHasUsername *PublicChatTypeHasUsername) MessageType() string {
	return "publicChatTypeHasUsername"
}

// NewPublicChatTypeHasUsername creates a new PublicChatTypeHasUsername
//
func NewPublicChatTypeHasUsername() *PublicChatTypeHasUsername {
	publicChatTypeHasUsernameTemp := PublicChatTypeHasUsername{
		tdCommon: tdCommon{Type: "publicChatTypeHasUsername"},
	}

	return &publicChatTypeHasUsernameTemp
}

// UnmarshalJSON unmarshal to json
func (publicChatTypeHasUsername *PublicChatTypeHasUsername) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	publicChatTypeHasUsername.tdCommon = tempObj.tdCommon

	return nil
}

// GetPublicChatTypeEnum return the enum type of this object
func (publicChatTypeHasUsername *PublicChatTypeHasUsername) GetPublicChatTypeEnum() PublicChatTypeEnum {
	return PublicChatTypeHasUsernameType
}

// PublicChatTypeIsLocationBased The chat is public, because it is a location-based supergroup
type PublicChatTypeIsLocationBased struct {
	tdCommon
}

// MessageType return the string telegram-type of PublicChatTypeIsLocationBased
func (publicChatTypeIsLocationBased *PublicChatTypeIsLocationBased) MessageType() string {
	return "publicChatTypeIsLocationBased"
}

// NewPublicChatTypeIsLocationBased creates a new PublicChatTypeIsLocationBased
//
func NewPublicChatTypeIsLocationBased() *PublicChatTypeIsLocationBased {
	publicChatTypeIsLocationBasedTemp := PublicChatTypeIsLocationBased{
		tdCommon: tdCommon{Type: "publicChatTypeIsLocationBased"},
	}

	return &publicChatTypeIsLocationBasedTemp
}

// UnmarshalJSON unmarshal to json
func (publicChatTypeIsLocationBased *PublicChatTypeIsLocationBased) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	publicChatTypeIsLocationBased.tdCommon = tempObj.tdCommon

	return nil
}

// GetPublicChatTypeEnum return the enum type of this object
func (publicChatTypeIsLocationBased *PublicChatTypeIsLocationBased) GetPublicChatTypeEnum() PublicChatTypeEnum {
	return PublicChatTypeIsLocationBasedType
}

// ChatActionBarReportSpam The chat can be reported as spam using the method reportChat with the reason reportReasonSpam. If the chat is a private chat with a user with an emoji status, then a notice about emoji status usage must be shown
type ChatActionBarReportSpam struct {
	tdCommon
	CanUnarchive bool `json:"can_unarchive"` // If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings
}

// MessageType return the string telegram-type of ChatActionBarReportSpam
func (chatActionBarReportSpam *ChatActionBarReportSpam) MessageType() string {
	return "chatActionBarReportSpam"
}

// NewChatActionBarReportSpam creates a new ChatActionBarReportSpam
//
// @param canUnarchive If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings
func NewChatActionBarReportSpam(canUnarchive bool) *ChatActionBarReportSpam {
	chatActionBarReportSpamTemp := ChatActionBarReportSpam{
		tdCommon:     tdCommon{Type: "chatActionBarReportSpam"},
		CanUnarchive: canUnarchive,
	}

	return &chatActionBarReportSpamTemp
}

// UnmarshalJSON unmarshal to json
func (chatActionBarReportSpam *ChatActionBarReportSpam) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CanUnarchive bool `json:"can_unarchive"` // If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActionBarReportSpam.tdCommon = tempObj.tdCommon
	chatActionBarReportSpam.CanUnarchive = tempObj.CanUnarchive

	return nil
}

// GetChatActionBarEnum return the enum type of this object
func (chatActionBarReportSpam *ChatActionBarReportSpam) GetChatActionBarEnum() ChatActionBarEnum {
	return ChatActionBarReportSpamType
}

// ChatActionBarReportUnrelatedLocation The chat is a location-based supergroup, which can be reported as having unrelated location using the method reportChat with the reason reportReasonUnrelatedLocation
type ChatActionBarReportUnrelatedLocation struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatActionBarReportUnrelatedLocation
func (chatActionBarReportUnrelatedLocation *ChatActionBarReportUnrelatedLocation) MessageType() string {
	return "chatActionBarReportUnrelatedLocation"
}

// NewChatActionBarReportUnrelatedLocation creates a new ChatActionBarReportUnrelatedLocation
//
func NewChatActionBarReportUnrelatedLocation() *ChatActionBarReportUnrelatedLocation {
	chatActionBarReportUnrelatedLocationTemp := ChatActionBarReportUnrelatedLocation{
		tdCommon: tdCommon{Type: "chatActionBarReportUnrelatedLocation"},
	}

	return &chatActionBarReportUnrelatedLocationTemp
}

// UnmarshalJSON unmarshal to json
func (chatActionBarReportUnrelatedLocation *ChatActionBarReportUnrelatedLocation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActionBarReportUnrelatedLocation.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatActionBarEnum return the enum type of this object
func (chatActionBarReportUnrelatedLocation *ChatActionBarReportUnrelatedLocation) GetChatActionBarEnum() ChatActionBarEnum {
	return ChatActionBarReportUnrelatedLocationType
}

// ChatActionBarInviteMembers The chat is a recently created group chat to which new members can be invited
type ChatActionBarInviteMembers struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatActionBarInviteMembers
func (chatActionBarInviteMembers *ChatActionBarInviteMembers) MessageType() string {
	return "chatActionBarInviteMembers"
}

// NewChatActionBarInviteMembers creates a new ChatActionBarInviteMembers
//
func NewChatActionBarInviteMembers() *ChatActionBarInviteMembers {
	chatActionBarInviteMembersTemp := ChatActionBarInviteMembers{
		tdCommon: tdCommon{Type: "chatActionBarInviteMembers"},
	}

	return &chatActionBarInviteMembersTemp
}

// UnmarshalJSON unmarshal to json
func (chatActionBarInviteMembers *ChatActionBarInviteMembers) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActionBarInviteMembers.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatActionBarEnum return the enum type of this object
func (chatActionBarInviteMembers *ChatActionBarInviteMembers) GetChatActionBarEnum() ChatActionBarEnum {
	return ChatActionBarInviteMembersType
}

// ChatActionBarReportAddBlock The chat is a private or secret chat, which can be reported using the method reportChat, or the other user can be blocked using the method setMessageSenderBlockList, or the other user can be added to the contact list using the method addContact. If the chat is a private chat with a user with an emoji status, then a notice about emoji status usage must be shown
type ChatActionBarReportAddBlock struct {
	tdCommon
	CanUnarchive bool  `json:"can_unarchive"` // If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings
	Distance     int32 `json:"distance"`      // If non-negative, the current user was found by the other user through searchChatsNearby and this is the distance between the users
}

// MessageType return the string telegram-type of ChatActionBarReportAddBlock
func (chatActionBarReportAddBlock *ChatActionBarReportAddBlock) MessageType() string {
	return "chatActionBarReportAddBlock"
}

// NewChatActionBarReportAddBlock creates a new ChatActionBarReportAddBlock
//
// @param canUnarchive If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings
// @param distance If non-negative, the current user was found by the other user through searchChatsNearby and this is the distance between the users
func NewChatActionBarReportAddBlock(canUnarchive bool, distance int32) *ChatActionBarReportAddBlock {
	chatActionBarReportAddBlockTemp := ChatActionBarReportAddBlock{
		tdCommon:     tdCommon{Type: "chatActionBarReportAddBlock"},
		CanUnarchive: canUnarchive,
		Distance:     distance,
	}

	return &chatActionBarReportAddBlockTemp
}

// UnmarshalJSON unmarshal to json
func (chatActionBarReportAddBlock *ChatActionBarReportAddBlock) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CanUnarchive bool  `json:"can_unarchive"` // If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings
		Distance     int32 `json:"distance"`      // If non-negative, the current user was found by the other user through searchChatsNearby and this is the distance between the users
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActionBarReportAddBlock.tdCommon = tempObj.tdCommon
	chatActionBarReportAddBlock.CanUnarchive = tempObj.CanUnarchive
	chatActionBarReportAddBlock.Distance = tempObj.Distance

	return nil
}

// GetChatActionBarEnum return the enum type of this object
func (chatActionBarReportAddBlock *ChatActionBarReportAddBlock) GetChatActionBarEnum() ChatActionBarEnum {
	return ChatActionBarReportAddBlockType
}

// ChatActionBarAddContact The chat is a private or secret chat and the other user can be added to the contact list using the method addContact
type ChatActionBarAddContact struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatActionBarAddContact
func (chatActionBarAddContact *ChatActionBarAddContact) MessageType() string {
	return "chatActionBarAddContact"
}

// NewChatActionBarAddContact creates a new ChatActionBarAddContact
//
func NewChatActionBarAddContact() *ChatActionBarAddContact {
	chatActionBarAddContactTemp := ChatActionBarAddContact{
		tdCommon: tdCommon{Type: "chatActionBarAddContact"},
	}

	return &chatActionBarAddContactTemp
}

// UnmarshalJSON unmarshal to json
func (chatActionBarAddContact *ChatActionBarAddContact) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActionBarAddContact.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatActionBarEnum return the enum type of this object
func (chatActionBarAddContact *ChatActionBarAddContact) GetChatActionBarEnum() ChatActionBarEnum {
	return ChatActionBarAddContactType
}

// ChatActionBarSharePhoneNumber The chat is a private or secret chat with a mutual contact and the user's phone number can be shared with the other user using the method sharePhoneNumber
type ChatActionBarSharePhoneNumber struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatActionBarSharePhoneNumber
func (chatActionBarSharePhoneNumber *ChatActionBarSharePhoneNumber) MessageType() string {
	return "chatActionBarSharePhoneNumber"
}

// NewChatActionBarSharePhoneNumber creates a new ChatActionBarSharePhoneNumber
//
func NewChatActionBarSharePhoneNumber() *ChatActionBarSharePhoneNumber {
	chatActionBarSharePhoneNumberTemp := ChatActionBarSharePhoneNumber{
		tdCommon: tdCommon{Type: "chatActionBarSharePhoneNumber"},
	}

	return &chatActionBarSharePhoneNumberTemp
}

// UnmarshalJSON unmarshal to json
func (chatActionBarSharePhoneNumber *ChatActionBarSharePhoneNumber) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActionBarSharePhoneNumber.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatActionBarEnum return the enum type of this object
func (chatActionBarSharePhoneNumber *ChatActionBarSharePhoneNumber) GetChatActionBarEnum() ChatActionBarEnum {
	return ChatActionBarSharePhoneNumberType
}

// ChatActionBarJoinRequest The chat is a private chat with an administrator of a chat to which the user sent join request
type ChatActionBarJoinRequest struct {
	tdCommon
	Title       string `json:"title"`        // Title of the chat to which the join request was sent
	IsChannel   bool   `json:"is_channel"`   // True, if the join request was sent to a channel chat
	RequestDate int32  `json:"request_date"` // Point in time (Unix timestamp) when the join request was sent
}

// MessageType return the string telegram-type of ChatActionBarJoinRequest
func (chatActionBarJoinRequest *ChatActionBarJoinRequest) MessageType() string {
	return "chatActionBarJoinRequest"
}

// NewChatActionBarJoinRequest creates a new ChatActionBarJoinRequest
//
// @param title Title of the chat to which the join request was sent
// @param isChannel True, if the join request was sent to a channel chat
// @param requestDate Point in time (Unix timestamp) when the join request was sent
func NewChatActionBarJoinRequest(title string, isChannel bool, requestDate int32) *ChatActionBarJoinRequest {
	chatActionBarJoinRequestTemp := ChatActionBarJoinRequest{
		tdCommon:    tdCommon{Type: "chatActionBarJoinRequest"},
		Title:       title,
		IsChannel:   isChannel,
		RequestDate: requestDate,
	}

	return &chatActionBarJoinRequestTemp
}

// UnmarshalJSON unmarshal to json
func (chatActionBarJoinRequest *ChatActionBarJoinRequest) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Title       string `json:"title"`        // Title of the chat to which the join request was sent
		IsChannel   bool   `json:"is_channel"`   // True, if the join request was sent to a channel chat
		RequestDate int32  `json:"request_date"` // Point in time (Unix timestamp) when the join request was sent
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActionBarJoinRequest.tdCommon = tempObj.tdCommon
	chatActionBarJoinRequest.Title = tempObj.Title
	chatActionBarJoinRequest.IsChannel = tempObj.IsChannel
	chatActionBarJoinRequest.RequestDate = tempObj.RequestDate

	return nil
}

// GetChatActionBarEnum return the enum type of this object
func (chatActionBarJoinRequest *ChatActionBarJoinRequest) GetChatActionBarEnum() ChatActionBarEnum {
	return ChatActionBarJoinRequestType
}

// KeyboardButtonTypeText A simple button, with text that must be sent when the button is pressed
type KeyboardButtonTypeText struct {
	tdCommon
}

// MessageType return the string telegram-type of KeyboardButtonTypeText
func (keyboardButtonTypeText *KeyboardButtonTypeText) MessageType() string {
	return "keyboardButtonTypeText"
}

// NewKeyboardButtonTypeText creates a new KeyboardButtonTypeText
//
func NewKeyboardButtonTypeText() *KeyboardButtonTypeText {
	keyboardButtonTypeTextTemp := KeyboardButtonTypeText{
		tdCommon: tdCommon{Type: "keyboardButtonTypeText"},
	}

	return &keyboardButtonTypeTextTemp
}

// UnmarshalJSON unmarshal to json
func (keyboardButtonTypeText *KeyboardButtonTypeText) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	keyboardButtonTypeText.tdCommon = tempObj.tdCommon

	return nil
}

// GetKeyboardButtonTypeEnum return the enum type of this object
func (keyboardButtonTypeText *KeyboardButtonTypeText) GetKeyboardButtonTypeEnum() KeyboardButtonTypeEnum {
	return KeyboardButtonTypeTextType
}

// KeyboardButtonTypeRequestPhoneNumber A button that sends the user's phone number when pressed; available only in private chats
type KeyboardButtonTypeRequestPhoneNumber struct {
	tdCommon
}

// MessageType return the string telegram-type of KeyboardButtonTypeRequestPhoneNumber
func (keyboardButtonTypeRequestPhoneNumber *KeyboardButtonTypeRequestPhoneNumber) MessageType() string {
	return "keyboardButtonTypeRequestPhoneNumber"
}

// NewKeyboardButtonTypeRequestPhoneNumber creates a new KeyboardButtonTypeRequestPhoneNumber
//
func NewKeyboardButtonTypeRequestPhoneNumber() *KeyboardButtonTypeRequestPhoneNumber {
	keyboardButtonTypeRequestPhoneNumberTemp := KeyboardButtonTypeRequestPhoneNumber{
		tdCommon: tdCommon{Type: "keyboardButtonTypeRequestPhoneNumber"},
	}

	return &keyboardButtonTypeRequestPhoneNumberTemp
}

// UnmarshalJSON unmarshal to json
func (keyboardButtonTypeRequestPhoneNumber *KeyboardButtonTypeRequestPhoneNumber) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	keyboardButtonTypeRequestPhoneNumber.tdCommon = tempObj.tdCommon

	return nil
}

// GetKeyboardButtonTypeEnum return the enum type of this object
func (keyboardButtonTypeRequestPhoneNumber *KeyboardButtonTypeRequestPhoneNumber) GetKeyboardButtonTypeEnum() KeyboardButtonTypeEnum {
	return KeyboardButtonTypeRequestPhoneNumberType
}

// KeyboardButtonTypeRequestLocation A button that sends the user's location when pressed; available only in private chats
type KeyboardButtonTypeRequestLocation struct {
	tdCommon
}

// MessageType return the string telegram-type of KeyboardButtonTypeRequestLocation
func (keyboardButtonTypeRequestLocation *KeyboardButtonTypeRequestLocation) MessageType() string {
	return "keyboardButtonTypeRequestLocation"
}

// NewKeyboardButtonTypeRequestLocation creates a new KeyboardButtonTypeRequestLocation
//
func NewKeyboardButtonTypeRequestLocation() *KeyboardButtonTypeRequestLocation {
	keyboardButtonTypeRequestLocationTemp := KeyboardButtonTypeRequestLocation{
		tdCommon: tdCommon{Type: "keyboardButtonTypeRequestLocation"},
	}

	return &keyboardButtonTypeRequestLocationTemp
}

// UnmarshalJSON unmarshal to json
func (keyboardButtonTypeRequestLocation *KeyboardButtonTypeRequestLocation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	keyboardButtonTypeRequestLocation.tdCommon = tempObj.tdCommon

	return nil
}

// GetKeyboardButtonTypeEnum return the enum type of this object
func (keyboardButtonTypeRequestLocation *KeyboardButtonTypeRequestLocation) GetKeyboardButtonTypeEnum() KeyboardButtonTypeEnum {
	return KeyboardButtonTypeRequestLocationType
}

// KeyboardButtonTypeRequestPoll A button that allows the user to create and send a poll when pressed; available only in private chats
type KeyboardButtonTypeRequestPoll struct {
	tdCommon
	ForceRegular bool `json:"force_regular"` // If true, only regular polls must be allowed to create
	ForceQuiz    bool `json:"force_quiz"`    // If true, only polls in quiz mode must be allowed to create
}

// MessageType return the string telegram-type of KeyboardButtonTypeRequestPoll
func (keyboardButtonTypeRequestPoll *KeyboardButtonTypeRequestPoll) MessageType() string {
	return "keyboardButtonTypeRequestPoll"
}

// NewKeyboardButtonTypeRequestPoll creates a new KeyboardButtonTypeRequestPoll
//
// @param forceRegular If true, only regular polls must be allowed to create
// @param forceQuiz If true, only polls in quiz mode must be allowed to create
func NewKeyboardButtonTypeRequestPoll(forceRegular bool, forceQuiz bool) *KeyboardButtonTypeRequestPoll {
	keyboardButtonTypeRequestPollTemp := KeyboardButtonTypeRequestPoll{
		tdCommon:     tdCommon{Type: "keyboardButtonTypeRequestPoll"},
		ForceRegular: forceRegular,
		ForceQuiz:    forceQuiz,
	}

	return &keyboardButtonTypeRequestPollTemp
}

// UnmarshalJSON unmarshal to json
func (keyboardButtonTypeRequestPoll *KeyboardButtonTypeRequestPoll) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ForceRegular bool `json:"force_regular"` // If true, only regular polls must be allowed to create
		ForceQuiz    bool `json:"force_quiz"`    // If true, only polls in quiz mode must be allowed to create
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	keyboardButtonTypeRequestPoll.tdCommon = tempObj.tdCommon
	keyboardButtonTypeRequestPoll.ForceRegular = tempObj.ForceRegular
	keyboardButtonTypeRequestPoll.ForceQuiz = tempObj.ForceQuiz

	return nil
}

// GetKeyboardButtonTypeEnum return the enum type of this object
func (keyboardButtonTypeRequestPoll *KeyboardButtonTypeRequestPoll) GetKeyboardButtonTypeEnum() KeyboardButtonTypeEnum {
	return KeyboardButtonTypeRequestPollType
}

// KeyboardButtonTypeRequestUsers A button that requests users to be shared by the current user; available only in private chats. Use the method shareUsersWithBot to complete the request
type KeyboardButtonTypeRequestUsers struct {
	tdCommon
	ID                    int32 `json:"id"`                       // Unique button identifier
	RestrictUserIsBot     bool  `json:"restrict_user_is_bot"`     // True, if the shared users must or must not be bots
	UserIsBot             bool  `json:"user_is_bot"`              // True, if the shared users must be bots; otherwise, the shared users must not be bots. Ignored if restrict_user_is_bot is false
	RestrictUserIsPremium bool  `json:"restrict_user_is_premium"` // True, if the shared users must or must not be Telegram Premium users
	UserIsPremium         bool  `json:"user_is_premium"`          // True, if the shared users must be Telegram Premium users; otherwise, the shared users must not be Telegram Premium users. Ignored if restrict_user_is_premium is false
	MaxQuantity           int32 `json:"max_quantity"`             // The maximum number of users to share
	RequestName           bool  `json:"request_name"`             // Pass true to request name of the users; bots only
	RequestUsername       bool  `json:"request_username"`         // Pass true to request username of the users; bots only
	RequestPhoto          bool  `json:"request_photo"`            // Pass true to request photo of the users; bots only
}

// MessageType return the string telegram-type of KeyboardButtonTypeRequestUsers
func (keyboardButtonTypeRequestUsers *KeyboardButtonTypeRequestUsers) MessageType() string {
	return "keyboardButtonTypeRequestUsers"
}

// NewKeyboardButtonTypeRequestUsers creates a new KeyboardButtonTypeRequestUsers
//
// @param iD Unique button identifier
// @param restrictUserIsBot True, if the shared users must or must not be bots
// @param userIsBot True, if the shared users must be bots; otherwise, the shared users must not be bots. Ignored if restrict_user_is_bot is false
// @param restrictUserIsPremium True, if the shared users must or must not be Telegram Premium users
// @param userIsPremium True, if the shared users must be Telegram Premium users; otherwise, the shared users must not be Telegram Premium users. Ignored if restrict_user_is_premium is false
// @param maxQuantity The maximum number of users to share
// @param requestName Pass true to request name of the users; bots only
// @param requestUsername Pass true to request username of the users; bots only
// @param requestPhoto Pass true to request photo of the users; bots only
func NewKeyboardButtonTypeRequestUsers(iD int32, restrictUserIsBot bool, userIsBot bool, restrictUserIsPremium bool, userIsPremium bool, maxQuantity int32, requestName bool, requestUsername bool, requestPhoto bool) *KeyboardButtonTypeRequestUsers {
	keyboardButtonTypeRequestUsersTemp := KeyboardButtonTypeRequestUsers{
		tdCommon:              tdCommon{Type: "keyboardButtonTypeRequestUsers"},
		ID:                    iD,
		RestrictUserIsBot:     restrictUserIsBot,
		UserIsBot:             userIsBot,
		RestrictUserIsPremium: restrictUserIsPremium,
		UserIsPremium:         userIsPremium,
		MaxQuantity:           maxQuantity,
		RequestName:           requestName,
		RequestUsername:       requestUsername,
		RequestPhoto:          requestPhoto,
	}

	return &keyboardButtonTypeRequestUsersTemp
}

// UnmarshalJSON unmarshal to json
func (keyboardButtonTypeRequestUsers *KeyboardButtonTypeRequestUsers) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID                    int32 `json:"id"`                       // Unique button identifier
		RestrictUserIsBot     bool  `json:"restrict_user_is_bot"`     // True, if the shared users must or must not be bots
		UserIsBot             bool  `json:"user_is_bot"`              // True, if the shared users must be bots; otherwise, the shared users must not be bots. Ignored if restrict_user_is_bot is false
		RestrictUserIsPremium bool  `json:"restrict_user_is_premium"` // True, if the shared users must or must not be Telegram Premium users
		UserIsPremium         bool  `json:"user_is_premium"`          // True, if the shared users must be Telegram Premium users; otherwise, the shared users must not be Telegram Premium users. Ignored if restrict_user_is_premium is false
		MaxQuantity           int32 `json:"max_quantity"`             // The maximum number of users to share
		RequestName           bool  `json:"request_name"`             // Pass true to request name of the users; bots only
		RequestUsername       bool  `json:"request_username"`         // Pass true to request username of the users; bots only
		RequestPhoto          bool  `json:"request_photo"`            // Pass true to request photo of the users; bots only
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	keyboardButtonTypeRequestUsers.tdCommon = tempObj.tdCommon
	keyboardButtonTypeRequestUsers.ID = tempObj.ID
	keyboardButtonTypeRequestUsers.RestrictUserIsBot = tempObj.RestrictUserIsBot
	keyboardButtonTypeRequestUsers.UserIsBot = tempObj.UserIsBot
	keyboardButtonTypeRequestUsers.RestrictUserIsPremium = tempObj.RestrictUserIsPremium
	keyboardButtonTypeRequestUsers.UserIsPremium = tempObj.UserIsPremium
	keyboardButtonTypeRequestUsers.MaxQuantity = tempObj.MaxQuantity
	keyboardButtonTypeRequestUsers.RequestName = tempObj.RequestName
	keyboardButtonTypeRequestUsers.RequestUsername = tempObj.RequestUsername
	keyboardButtonTypeRequestUsers.RequestPhoto = tempObj.RequestPhoto

	return nil
}

// GetKeyboardButtonTypeEnum return the enum type of this object
func (keyboardButtonTypeRequestUsers *KeyboardButtonTypeRequestUsers) GetKeyboardButtonTypeEnum() KeyboardButtonTypeEnum {
	return KeyboardButtonTypeRequestUsersType
}

// KeyboardButtonTypeRequestChat A button that requests a chat to be shared by the current user; available only in private chats. Use the method shareChatWithBot to complete the request
type KeyboardButtonTypeRequestChat struct {
	tdCommon
	ID                      int32                    `json:"id"`                         // Unique button identifier
	ChatIsChannel           bool                     `json:"chat_is_channel"`            // True, if the chat must be a channel; otherwise, a basic group or a supergroup chat is shared
	RestrictChatIsForum     bool                     `json:"restrict_chat_is_forum"`     // True, if the chat must or must not be a forum supergroup
	ChatIsForum             bool                     `json:"chat_is_forum"`              // True, if the chat must be a forum supergroup; otherwise, the chat must not be a forum supergroup. Ignored if restrict_chat_is_forum is false
	RestrictChatHasUsername bool                     `json:"restrict_chat_has_username"` // True, if the chat must or must not have a username
	ChatHasUsername         bool                     `json:"chat_has_username"`          // True, if the chat must have a username; otherwise, the chat must not have a username. Ignored if restrict_chat_has_username is false
	ChatIsCreated           bool                     `json:"chat_is_created"`            // True, if the chat must be created by the current user
	UserAdministratorRights *ChatAdministratorRights `json:"user_administrator_rights"`  // Expected user administrator rights in the chat; may be null if they aren't restricted
	BotAdministratorRights  *ChatAdministratorRights `json:"bot_administrator_rights"`   // Expected bot administrator rights in the chat; may be null if they aren't restricted
	BotIsMember             bool                     `json:"bot_is_member"`              // True, if the bot must be a member of the chat; for basic group and supergroup chats only
	RequestTitle            bool                     `json:"request_title"`              // Pass true to request title of the chat; bots only
	RequestUsername         bool                     `json:"request_username"`           // Pass true to request username of the chat; bots only
	RequestPhoto            bool                     `json:"request_photo"`              // Pass true to request photo of the chat; bots only
}

// MessageType return the string telegram-type of KeyboardButtonTypeRequestChat
func (keyboardButtonTypeRequestChat *KeyboardButtonTypeRequestChat) MessageType() string {
	return "keyboardButtonTypeRequestChat"
}

// NewKeyboardButtonTypeRequestChat creates a new KeyboardButtonTypeRequestChat
//
// @param iD Unique button identifier
// @param chatIsChannel True, if the chat must be a channel; otherwise, a basic group or a supergroup chat is shared
// @param restrictChatIsForum True, if the chat must or must not be a forum supergroup
// @param chatIsForum True, if the chat must be a forum supergroup; otherwise, the chat must not be a forum supergroup. Ignored if restrict_chat_is_forum is false
// @param restrictChatHasUsername True, if the chat must or must not have a username
// @param chatHasUsername True, if the chat must have a username; otherwise, the chat must not have a username. Ignored if restrict_chat_has_username is false
// @param chatIsCreated True, if the chat must be created by the current user
// @param userAdministratorRights Expected user administrator rights in the chat; may be null if they aren't restricted
// @param botAdministratorRights Expected bot administrator rights in the chat; may be null if they aren't restricted
// @param botIsMember True, if the bot must be a member of the chat; for basic group and supergroup chats only
// @param requestTitle Pass true to request title of the chat; bots only
// @param requestUsername Pass true to request username of the chat; bots only
// @param requestPhoto Pass true to request photo of the chat; bots only
func NewKeyboardButtonTypeRequestChat(iD int32, chatIsChannel bool, restrictChatIsForum bool, chatIsForum bool, restrictChatHasUsername bool, chatHasUsername bool, chatIsCreated bool, userAdministratorRights *ChatAdministratorRights, botAdministratorRights *ChatAdministratorRights, botIsMember bool, requestTitle bool, requestUsername bool, requestPhoto bool) *KeyboardButtonTypeRequestChat {
	keyboardButtonTypeRequestChatTemp := KeyboardButtonTypeRequestChat{
		tdCommon:                tdCommon{Type: "keyboardButtonTypeRequestChat"},
		ID:                      iD,
		ChatIsChannel:           chatIsChannel,
		RestrictChatIsForum:     restrictChatIsForum,
		ChatIsForum:             chatIsForum,
		RestrictChatHasUsername: restrictChatHasUsername,
		ChatHasUsername:         chatHasUsername,
		ChatIsCreated:           chatIsCreated,
		UserAdministratorRights: userAdministratorRights,
		BotAdministratorRights:  botAdministratorRights,
		BotIsMember:             botIsMember,
		RequestTitle:            requestTitle,
		RequestUsername:         requestUsername,
		RequestPhoto:            requestPhoto,
	}

	return &keyboardButtonTypeRequestChatTemp
}

// UnmarshalJSON unmarshal to json
func (keyboardButtonTypeRequestChat *KeyboardButtonTypeRequestChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID                      int32                    `json:"id"`                         // Unique button identifier
		ChatIsChannel           bool                     `json:"chat_is_channel"`            // True, if the chat must be a channel; otherwise, a basic group or a supergroup chat is shared
		RestrictChatIsForum     bool                     `json:"restrict_chat_is_forum"`     // True, if the chat must or must not be a forum supergroup
		ChatIsForum             bool                     `json:"chat_is_forum"`              // True, if the chat must be a forum supergroup; otherwise, the chat must not be a forum supergroup. Ignored if restrict_chat_is_forum is false
		RestrictChatHasUsername bool                     `json:"restrict_chat_has_username"` // True, if the chat must or must not have a username
		ChatHasUsername         bool                     `json:"chat_has_username"`          // True, if the chat must have a username; otherwise, the chat must not have a username. Ignored if restrict_chat_has_username is false
		ChatIsCreated           bool                     `json:"chat_is_created"`            // True, if the chat must be created by the current user
		UserAdministratorRights *ChatAdministratorRights `json:"user_administrator_rights"`  // Expected user administrator rights in the chat; may be null if they aren't restricted
		BotAdministratorRights  *ChatAdministratorRights `json:"bot_administrator_rights"`   // Expected bot administrator rights in the chat; may be null if they aren't restricted
		BotIsMember             bool                     `json:"bot_is_member"`              // True, if the bot must be a member of the chat; for basic group and supergroup chats only
		RequestTitle            bool                     `json:"request_title"`              // Pass true to request title of the chat; bots only
		RequestUsername         bool                     `json:"request_username"`           // Pass true to request username of the chat; bots only
		RequestPhoto            bool                     `json:"request_photo"`              // Pass true to request photo of the chat; bots only
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	keyboardButtonTypeRequestChat.tdCommon = tempObj.tdCommon
	keyboardButtonTypeRequestChat.ID = tempObj.ID
	keyboardButtonTypeRequestChat.ChatIsChannel = tempObj.ChatIsChannel
	keyboardButtonTypeRequestChat.RestrictChatIsForum = tempObj.RestrictChatIsForum
	keyboardButtonTypeRequestChat.ChatIsForum = tempObj.ChatIsForum
	keyboardButtonTypeRequestChat.RestrictChatHasUsername = tempObj.RestrictChatHasUsername
	keyboardButtonTypeRequestChat.ChatHasUsername = tempObj.ChatHasUsername
	keyboardButtonTypeRequestChat.ChatIsCreated = tempObj.ChatIsCreated
	keyboardButtonTypeRequestChat.UserAdministratorRights = tempObj.UserAdministratorRights
	keyboardButtonTypeRequestChat.BotAdministratorRights = tempObj.BotAdministratorRights
	keyboardButtonTypeRequestChat.BotIsMember = tempObj.BotIsMember
	keyboardButtonTypeRequestChat.RequestTitle = tempObj.RequestTitle
	keyboardButtonTypeRequestChat.RequestUsername = tempObj.RequestUsername
	keyboardButtonTypeRequestChat.RequestPhoto = tempObj.RequestPhoto

	return nil
}

// GetKeyboardButtonTypeEnum return the enum type of this object
func (keyboardButtonTypeRequestChat *KeyboardButtonTypeRequestChat) GetKeyboardButtonTypeEnum() KeyboardButtonTypeEnum {
	return KeyboardButtonTypeRequestChatType
}

// KeyboardButtonTypeWebApp A button that opens a Web App by calling getWebAppUrl
type KeyboardButtonTypeWebApp struct {
	tdCommon
	URL string `json:"url"` // An HTTP URL to pass to getWebAppUrl
}

// MessageType return the string telegram-type of KeyboardButtonTypeWebApp
func (keyboardButtonTypeWebApp *KeyboardButtonTypeWebApp) MessageType() string {
	return "keyboardButtonTypeWebApp"
}

// NewKeyboardButtonTypeWebApp creates a new KeyboardButtonTypeWebApp
//
// @param uRL An HTTP URL to pass to getWebAppUrl
func NewKeyboardButtonTypeWebApp(uRL string) *KeyboardButtonTypeWebApp {
	keyboardButtonTypeWebAppTemp := KeyboardButtonTypeWebApp{
		tdCommon: tdCommon{Type: "keyboardButtonTypeWebApp"},
		URL:      uRL,
	}

	return &keyboardButtonTypeWebAppTemp
}

// UnmarshalJSON unmarshal to json
func (keyboardButtonTypeWebApp *KeyboardButtonTypeWebApp) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL string `json:"url"` // An HTTP URL to pass to getWebAppUrl
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	keyboardButtonTypeWebApp.tdCommon = tempObj.tdCommon
	keyboardButtonTypeWebApp.URL = tempObj.URL

	return nil
}

// GetKeyboardButtonTypeEnum return the enum type of this object
func (keyboardButtonTypeWebApp *KeyboardButtonTypeWebApp) GetKeyboardButtonTypeEnum() KeyboardButtonTypeEnum {
	return KeyboardButtonTypeWebAppType
}

// KeyboardButton Represents a single button in a bot keyboard
type KeyboardButton struct {
	tdCommon
	Text string             `json:"text"` // Text of the button
	Type KeyboardButtonType `json:"type"` // Type of the button
}

// MessageType return the string telegram-type of KeyboardButton
func (keyboardButton *KeyboardButton) MessageType() string {
	return "keyboardButton"
}

// NewKeyboardButton creates a new KeyboardButton
//
// @param text Text of the button
// @param typeParam Type of the button
func NewKeyboardButton(text string, typeParam KeyboardButtonType) *KeyboardButton {
	keyboardButtonTemp := KeyboardButton{
		tdCommon: tdCommon{Type: "keyboardButton"},
		Text:     text,
		Type:     typeParam,
	}

	return &keyboardButtonTemp
}

// UnmarshalJSON unmarshal to json
func (keyboardButton *KeyboardButton) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Text string `json:"text"` // Text of the button

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	keyboardButton.tdCommon = tempObj.tdCommon
	keyboardButton.Text = tempObj.Text

	fieldType, _ := unmarshalKeyboardButtonType(objMap["type"])
	keyboardButton.Type = fieldType

	return nil
}

// InlineKeyboardButtonTypeURL A button that opens a specified URL
type InlineKeyboardButtonTypeURL struct {
	tdCommon
	URL string `json:"url"` // HTTP or tg:// URL to open. If the link is of the type internalLinkTypeWebApp, then the button must be marked as a Web App button
}

// MessageType return the string telegram-type of InlineKeyboardButtonTypeURL
func (inlineKeyboardButtonTypeURL *InlineKeyboardButtonTypeURL) MessageType() string {
	return "inlineKeyboardButtonTypeUrl"
}

// NewInlineKeyboardButtonTypeURL creates a new InlineKeyboardButtonTypeURL
//
// @param uRL HTTP or tg:// URL to open. If the link is of the type internalLinkTypeWebApp, then the button must be marked as a Web App button
func NewInlineKeyboardButtonTypeURL(uRL string) *InlineKeyboardButtonTypeURL {
	inlineKeyboardButtonTypeURLTemp := InlineKeyboardButtonTypeURL{
		tdCommon: tdCommon{Type: "inlineKeyboardButtonTypeUrl"},
		URL:      uRL,
	}

	return &inlineKeyboardButtonTypeURLTemp
}

// UnmarshalJSON unmarshal to json
func (inlineKeyboardButtonTypeURL *InlineKeyboardButtonTypeURL) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL string `json:"url"` // HTTP or tg:// URL to open. If the link is of the type internalLinkTypeWebApp, then the button must be marked as a Web App button
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineKeyboardButtonTypeURL.tdCommon = tempObj.tdCommon
	inlineKeyboardButtonTypeURL.URL = tempObj.URL

	return nil
}

// GetInlineKeyboardButtonTypeEnum return the enum type of this object
func (inlineKeyboardButtonTypeURL *InlineKeyboardButtonTypeURL) GetInlineKeyboardButtonTypeEnum() InlineKeyboardButtonTypeEnum {
	return InlineKeyboardButtonTypeURLType
}

// InlineKeyboardButtonTypeLoginURL A button that opens a specified URL and automatically authorize the current user by calling getLoginUrlInfo
type InlineKeyboardButtonTypeLoginURL struct {
	tdCommon
	URL         string `json:"url"`          // An HTTP URL to pass to getLoginUrlInfo
	ID          int64  `json:"id"`           // Unique button identifier
	ForwardText string `json:"forward_text"` // If non-empty, new text of the button in forwarded messages
}

// MessageType return the string telegram-type of InlineKeyboardButtonTypeLoginURL
func (inlineKeyboardButtonTypeLoginURL *InlineKeyboardButtonTypeLoginURL) MessageType() string {
	return "inlineKeyboardButtonTypeLoginUrl"
}

// NewInlineKeyboardButtonTypeLoginURL creates a new InlineKeyboardButtonTypeLoginURL
//
// @param uRL An HTTP URL to pass to getLoginUrlInfo
// @param iD Unique button identifier
// @param forwardText If non-empty, new text of the button in forwarded messages
func NewInlineKeyboardButtonTypeLoginURL(uRL string, iD int64, forwardText string) *InlineKeyboardButtonTypeLoginURL {
	inlineKeyboardButtonTypeLoginURLTemp := InlineKeyboardButtonTypeLoginURL{
		tdCommon:    tdCommon{Type: "inlineKeyboardButtonTypeLoginUrl"},
		URL:         uRL,
		ID:          iD,
		ForwardText: forwardText,
	}

	return &inlineKeyboardButtonTypeLoginURLTemp
}

// UnmarshalJSON unmarshal to json
func (inlineKeyboardButtonTypeLoginURL *InlineKeyboardButtonTypeLoginURL) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL         string `json:"url"`          // An HTTP URL to pass to getLoginUrlInfo
		ID          int64  `json:"id"`           // Unique button identifier
		ForwardText string `json:"forward_text"` // If non-empty, new text of the button in forwarded messages
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineKeyboardButtonTypeLoginURL.tdCommon = tempObj.tdCommon
	inlineKeyboardButtonTypeLoginURL.URL = tempObj.URL
	inlineKeyboardButtonTypeLoginURL.ID = tempObj.ID
	inlineKeyboardButtonTypeLoginURL.ForwardText = tempObj.ForwardText

	return nil
}

// GetInlineKeyboardButtonTypeEnum return the enum type of this object
func (inlineKeyboardButtonTypeLoginURL *InlineKeyboardButtonTypeLoginURL) GetInlineKeyboardButtonTypeEnum() InlineKeyboardButtonTypeEnum {
	return InlineKeyboardButtonTypeLoginURLType
}

// InlineKeyboardButtonTypeWebApp A button that opens a Web App by calling openWebApp
type InlineKeyboardButtonTypeWebApp struct {
	tdCommon
	URL string `json:"url"` // An HTTP URL to pass to openWebApp
}

// MessageType return the string telegram-type of InlineKeyboardButtonTypeWebApp
func (inlineKeyboardButtonTypeWebApp *InlineKeyboardButtonTypeWebApp) MessageType() string {
	return "inlineKeyboardButtonTypeWebApp"
}

// NewInlineKeyboardButtonTypeWebApp creates a new InlineKeyboardButtonTypeWebApp
//
// @param uRL An HTTP URL to pass to openWebApp
func NewInlineKeyboardButtonTypeWebApp(uRL string) *InlineKeyboardButtonTypeWebApp {
	inlineKeyboardButtonTypeWebAppTemp := InlineKeyboardButtonTypeWebApp{
		tdCommon: tdCommon{Type: "inlineKeyboardButtonTypeWebApp"},
		URL:      uRL,
	}

	return &inlineKeyboardButtonTypeWebAppTemp
}

// UnmarshalJSON unmarshal to json
func (inlineKeyboardButtonTypeWebApp *InlineKeyboardButtonTypeWebApp) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL string `json:"url"` // An HTTP URL to pass to openWebApp
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineKeyboardButtonTypeWebApp.tdCommon = tempObj.tdCommon
	inlineKeyboardButtonTypeWebApp.URL = tempObj.URL

	return nil
}

// GetInlineKeyboardButtonTypeEnum return the enum type of this object
func (inlineKeyboardButtonTypeWebApp *InlineKeyboardButtonTypeWebApp) GetInlineKeyboardButtonTypeEnum() InlineKeyboardButtonTypeEnum {
	return InlineKeyboardButtonTypeWebAppType
}

// InlineKeyboardButtonTypeCallback A button that sends a callback query to a bot
type InlineKeyboardButtonTypeCallback struct {
	tdCommon
	Data []byte `json:"data"` // Data to be sent to the bot via a callback query
}

// MessageType return the string telegram-type of InlineKeyboardButtonTypeCallback
func (inlineKeyboardButtonTypeCallback *InlineKeyboardButtonTypeCallback) MessageType() string {
	return "inlineKeyboardButtonTypeCallback"
}

// NewInlineKeyboardButtonTypeCallback creates a new InlineKeyboardButtonTypeCallback
//
// @param data Data to be sent to the bot via a callback query
func NewInlineKeyboardButtonTypeCallback(data []byte) *InlineKeyboardButtonTypeCallback {
	inlineKeyboardButtonTypeCallbackTemp := InlineKeyboardButtonTypeCallback{
		tdCommon: tdCommon{Type: "inlineKeyboardButtonTypeCallback"},
		Data:     data,
	}

	return &inlineKeyboardButtonTypeCallbackTemp
}

// UnmarshalJSON unmarshal to json
func (inlineKeyboardButtonTypeCallback *InlineKeyboardButtonTypeCallback) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Data []byte `json:"data"` // Data to be sent to the bot via a callback query
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineKeyboardButtonTypeCallback.tdCommon = tempObj.tdCommon
	inlineKeyboardButtonTypeCallback.Data = tempObj.Data

	return nil
}

// GetInlineKeyboardButtonTypeEnum return the enum type of this object
func (inlineKeyboardButtonTypeCallback *InlineKeyboardButtonTypeCallback) GetInlineKeyboardButtonTypeEnum() InlineKeyboardButtonTypeEnum {
	return InlineKeyboardButtonTypeCallbackType
}

// InlineKeyboardButtonTypeCallbackWithPassword A button that asks for the 2-step verification password of the current user and then sends a callback query to a bot
type InlineKeyboardButtonTypeCallbackWithPassword struct {
	tdCommon
	Data []byte `json:"data"` // Data to be sent to the bot via a callback query
}

// MessageType return the string telegram-type of InlineKeyboardButtonTypeCallbackWithPassword
func (inlineKeyboardButtonTypeCallbackWithPassword *InlineKeyboardButtonTypeCallbackWithPassword) MessageType() string {
	return "inlineKeyboardButtonTypeCallbackWithPassword"
}

// NewInlineKeyboardButtonTypeCallbackWithPassword creates a new InlineKeyboardButtonTypeCallbackWithPassword
//
// @param data Data to be sent to the bot via a callback query
func NewInlineKeyboardButtonTypeCallbackWithPassword(data []byte) *InlineKeyboardButtonTypeCallbackWithPassword {
	inlineKeyboardButtonTypeCallbackWithPasswordTemp := InlineKeyboardButtonTypeCallbackWithPassword{
		tdCommon: tdCommon{Type: "inlineKeyboardButtonTypeCallbackWithPassword"},
		Data:     data,
	}

	return &inlineKeyboardButtonTypeCallbackWithPasswordTemp
}

// UnmarshalJSON unmarshal to json
func (inlineKeyboardButtonTypeCallbackWithPassword *InlineKeyboardButtonTypeCallbackWithPassword) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Data []byte `json:"data"` // Data to be sent to the bot via a callback query
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineKeyboardButtonTypeCallbackWithPassword.tdCommon = tempObj.tdCommon
	inlineKeyboardButtonTypeCallbackWithPassword.Data = tempObj.Data

	return nil
}

// GetInlineKeyboardButtonTypeEnum return the enum type of this object
func (inlineKeyboardButtonTypeCallbackWithPassword *InlineKeyboardButtonTypeCallbackWithPassword) GetInlineKeyboardButtonTypeEnum() InlineKeyboardButtonTypeEnum {
	return InlineKeyboardButtonTypeCallbackWithPasswordType
}

// InlineKeyboardButtonTypeCallbackGame A button with a game that sends a callback query to a bot. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageGame
type InlineKeyboardButtonTypeCallbackGame struct {
	tdCommon
}

// MessageType return the string telegram-type of InlineKeyboardButtonTypeCallbackGame
func (inlineKeyboardButtonTypeCallbackGame *InlineKeyboardButtonTypeCallbackGame) MessageType() string {
	return "inlineKeyboardButtonTypeCallbackGame"
}

// NewInlineKeyboardButtonTypeCallbackGame creates a new InlineKeyboardButtonTypeCallbackGame
//
func NewInlineKeyboardButtonTypeCallbackGame() *InlineKeyboardButtonTypeCallbackGame {
	inlineKeyboardButtonTypeCallbackGameTemp := InlineKeyboardButtonTypeCallbackGame{
		tdCommon: tdCommon{Type: "inlineKeyboardButtonTypeCallbackGame"},
	}

	return &inlineKeyboardButtonTypeCallbackGameTemp
}

// UnmarshalJSON unmarshal to json
func (inlineKeyboardButtonTypeCallbackGame *InlineKeyboardButtonTypeCallbackGame) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineKeyboardButtonTypeCallbackGame.tdCommon = tempObj.tdCommon

	return nil
}

// GetInlineKeyboardButtonTypeEnum return the enum type of this object
func (inlineKeyboardButtonTypeCallbackGame *InlineKeyboardButtonTypeCallbackGame) GetInlineKeyboardButtonTypeEnum() InlineKeyboardButtonTypeEnum {
	return InlineKeyboardButtonTypeCallbackGameType
}

// InlineKeyboardButtonTypeSwitchInline A button that forces an inline query to the bot to be inserted in the input field
type InlineKeyboardButtonTypeSwitchInline struct {
	tdCommon
	Query      string     `json:"query"`       // Inline query to be sent to the bot
	TargetChat TargetChat `json:"target_chat"` // Target chat from which to send the inline query
}

// MessageType return the string telegram-type of InlineKeyboardButtonTypeSwitchInline
func (inlineKeyboardButtonTypeSwitchInline *InlineKeyboardButtonTypeSwitchInline) MessageType() string {
	return "inlineKeyboardButtonTypeSwitchInline"
}

// NewInlineKeyboardButtonTypeSwitchInline creates a new InlineKeyboardButtonTypeSwitchInline
//
// @param query Inline query to be sent to the bot
// @param targetChat Target chat from which to send the inline query
func NewInlineKeyboardButtonTypeSwitchInline(query string, targetChat TargetChat) *InlineKeyboardButtonTypeSwitchInline {
	inlineKeyboardButtonTypeSwitchInlineTemp := InlineKeyboardButtonTypeSwitchInline{
		tdCommon:   tdCommon{Type: "inlineKeyboardButtonTypeSwitchInline"},
		Query:      query,
		TargetChat: targetChat,
	}

	return &inlineKeyboardButtonTypeSwitchInlineTemp
}

// UnmarshalJSON unmarshal to json
func (inlineKeyboardButtonTypeSwitchInline *InlineKeyboardButtonTypeSwitchInline) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Query string `json:"query"` // Inline query to be sent to the bot

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineKeyboardButtonTypeSwitchInline.tdCommon = tempObj.tdCommon
	inlineKeyboardButtonTypeSwitchInline.Query = tempObj.Query

	fieldTargetChat, _ := unmarshalTargetChat(objMap["target_chat"])
	inlineKeyboardButtonTypeSwitchInline.TargetChat = fieldTargetChat

	return nil
}

// GetInlineKeyboardButtonTypeEnum return the enum type of this object
func (inlineKeyboardButtonTypeSwitchInline *InlineKeyboardButtonTypeSwitchInline) GetInlineKeyboardButtonTypeEnum() InlineKeyboardButtonTypeEnum {
	return InlineKeyboardButtonTypeSwitchInlineType
}

// InlineKeyboardButtonTypeBuy A button to buy something. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageInvoice
type InlineKeyboardButtonTypeBuy struct {
	tdCommon
}

// MessageType return the string telegram-type of InlineKeyboardButtonTypeBuy
func (inlineKeyboardButtonTypeBuy *InlineKeyboardButtonTypeBuy) MessageType() string {
	return "inlineKeyboardButtonTypeBuy"
}

// NewInlineKeyboardButtonTypeBuy creates a new InlineKeyboardButtonTypeBuy
//
func NewInlineKeyboardButtonTypeBuy() *InlineKeyboardButtonTypeBuy {
	inlineKeyboardButtonTypeBuyTemp := InlineKeyboardButtonTypeBuy{
		tdCommon: tdCommon{Type: "inlineKeyboardButtonTypeBuy"},
	}

	return &inlineKeyboardButtonTypeBuyTemp
}

// UnmarshalJSON unmarshal to json
func (inlineKeyboardButtonTypeBuy *InlineKeyboardButtonTypeBuy) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineKeyboardButtonTypeBuy.tdCommon = tempObj.tdCommon

	return nil
}

// GetInlineKeyboardButtonTypeEnum return the enum type of this object
func (inlineKeyboardButtonTypeBuy *InlineKeyboardButtonTypeBuy) GetInlineKeyboardButtonTypeEnum() InlineKeyboardButtonTypeEnum {
	return InlineKeyboardButtonTypeBuyType
}

// InlineKeyboardButtonTypeUser A button with a user reference to be handled in the same way as textEntityTypeMentionName entities
type InlineKeyboardButtonTypeUser struct {
	tdCommon
	UserID int64 `json:"user_id"` // User identifier
}

// MessageType return the string telegram-type of InlineKeyboardButtonTypeUser
func (inlineKeyboardButtonTypeUser *InlineKeyboardButtonTypeUser) MessageType() string {
	return "inlineKeyboardButtonTypeUser"
}

// NewInlineKeyboardButtonTypeUser creates a new InlineKeyboardButtonTypeUser
//
// @param userID User identifier
func NewInlineKeyboardButtonTypeUser(userID int64) *InlineKeyboardButtonTypeUser {
	inlineKeyboardButtonTypeUserTemp := InlineKeyboardButtonTypeUser{
		tdCommon: tdCommon{Type: "inlineKeyboardButtonTypeUser"},
		UserID:   userID,
	}

	return &inlineKeyboardButtonTypeUserTemp
}

// UnmarshalJSON unmarshal to json
func (inlineKeyboardButtonTypeUser *InlineKeyboardButtonTypeUser) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID int64 `json:"user_id"` // User identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineKeyboardButtonTypeUser.tdCommon = tempObj.tdCommon
	inlineKeyboardButtonTypeUser.UserID = tempObj.UserID

	return nil
}

// GetInlineKeyboardButtonTypeEnum return the enum type of this object
func (inlineKeyboardButtonTypeUser *InlineKeyboardButtonTypeUser) GetInlineKeyboardButtonTypeEnum() InlineKeyboardButtonTypeEnum {
	return InlineKeyboardButtonTypeUserType
}

// InlineKeyboardButton Represents a single button in an inline keyboard
type InlineKeyboardButton struct {
	tdCommon
	Text string                   `json:"text"` // Text of the button
	Type InlineKeyboardButtonType `json:"type"` // Type of the button
}

// MessageType return the string telegram-type of InlineKeyboardButton
func (inlineKeyboardButton *InlineKeyboardButton) MessageType() string {
	return "inlineKeyboardButton"
}

// NewInlineKeyboardButton creates a new InlineKeyboardButton
//
// @param text Text of the button
// @param typeParam Type of the button
func NewInlineKeyboardButton(text string, typeParam InlineKeyboardButtonType) *InlineKeyboardButton {
	inlineKeyboardButtonTemp := InlineKeyboardButton{
		tdCommon: tdCommon{Type: "inlineKeyboardButton"},
		Text:     text,
		Type:     typeParam,
	}

	return &inlineKeyboardButtonTemp
}

// UnmarshalJSON unmarshal to json
func (inlineKeyboardButton *InlineKeyboardButton) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Text string `json:"text"` // Text of the button

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineKeyboardButton.tdCommon = tempObj.tdCommon
	inlineKeyboardButton.Text = tempObj.Text

	fieldType, _ := unmarshalInlineKeyboardButtonType(objMap["type"])
	inlineKeyboardButton.Type = fieldType

	return nil
}

// ReplyMarkupRemoveKeyboard Instructs application to remove the keyboard once this message has been received. This kind of keyboard can't be received in an incoming message; instead, updateChatReplyMarkup with message_id == 0 will be sent
type ReplyMarkupRemoveKeyboard struct {
	tdCommon
	IsPersonal bool `json:"is_personal"` // True, if the keyboard is removed only for the mentioned users or the target user of a reply
}

// MessageType return the string telegram-type of ReplyMarkupRemoveKeyboard
func (replyMarkupRemoveKeyboard *ReplyMarkupRemoveKeyboard) MessageType() string {
	return "replyMarkupRemoveKeyboard"
}

// NewReplyMarkupRemoveKeyboard creates a new ReplyMarkupRemoveKeyboard
//
// @param isPersonal True, if the keyboard is removed only for the mentioned users or the target user of a reply
func NewReplyMarkupRemoveKeyboard(isPersonal bool) *ReplyMarkupRemoveKeyboard {
	replyMarkupRemoveKeyboardTemp := ReplyMarkupRemoveKeyboard{
		tdCommon:   tdCommon{Type: "replyMarkupRemoveKeyboard"},
		IsPersonal: isPersonal,
	}

	return &replyMarkupRemoveKeyboardTemp
}

// UnmarshalJSON unmarshal to json
func (replyMarkupRemoveKeyboard *ReplyMarkupRemoveKeyboard) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsPersonal bool `json:"is_personal"` // True, if the keyboard is removed only for the mentioned users or the target user of a reply
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	replyMarkupRemoveKeyboard.tdCommon = tempObj.tdCommon
	replyMarkupRemoveKeyboard.IsPersonal = tempObj.IsPersonal

	return nil
}

// GetReplyMarkupEnum return the enum type of this object
func (replyMarkupRemoveKeyboard *ReplyMarkupRemoveKeyboard) GetReplyMarkupEnum() ReplyMarkupEnum {
	return ReplyMarkupRemoveKeyboardType
}

// ReplyMarkupForceReply Instructs application to force a reply to this message
type ReplyMarkupForceReply struct {
	tdCommon
	IsPersonal            bool   `json:"is_personal"`             // True, if a forced reply must automatically be shown to the current user. For outgoing messages, specify true to show the forced reply only for the mentioned users and for the target user of a reply
	InputFieldPlaceholder string `json:"input_field_placeholder"` // If non-empty, the placeholder to be shown in the input field when the reply is active; 0-64 characters
}

// MessageType return the string telegram-type of ReplyMarkupForceReply
func (replyMarkupForceReply *ReplyMarkupForceReply) MessageType() string {
	return "replyMarkupForceReply"
}

// NewReplyMarkupForceReply creates a new ReplyMarkupForceReply
//
// @param isPersonal True, if a forced reply must automatically be shown to the current user. For outgoing messages, specify true to show the forced reply only for the mentioned users and for the target user of a reply
// @param inputFieldPlaceholder If non-empty, the placeholder to be shown in the input field when the reply is active; 0-64 characters
func NewReplyMarkupForceReply(isPersonal bool, inputFieldPlaceholder string) *ReplyMarkupForceReply {
	replyMarkupForceReplyTemp := ReplyMarkupForceReply{
		tdCommon:              tdCommon{Type: "replyMarkupForceReply"},
		IsPersonal:            isPersonal,
		InputFieldPlaceholder: inputFieldPlaceholder,
	}

	return &replyMarkupForceReplyTemp
}

// UnmarshalJSON unmarshal to json
func (replyMarkupForceReply *ReplyMarkupForceReply) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsPersonal            bool   `json:"is_personal"`             // True, if a forced reply must automatically be shown to the current user. For outgoing messages, specify true to show the forced reply only for the mentioned users and for the target user of a reply
		InputFieldPlaceholder string `json:"input_field_placeholder"` // If non-empty, the placeholder to be shown in the input field when the reply is active; 0-64 characters
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	replyMarkupForceReply.tdCommon = tempObj.tdCommon
	replyMarkupForceReply.IsPersonal = tempObj.IsPersonal
	replyMarkupForceReply.InputFieldPlaceholder = tempObj.InputFieldPlaceholder

	return nil
}

// GetReplyMarkupEnum return the enum type of this object
func (replyMarkupForceReply *ReplyMarkupForceReply) GetReplyMarkupEnum() ReplyMarkupEnum {
	return ReplyMarkupForceReplyType
}

// ReplyMarkupShowKeyboard Contains a custom keyboard layout to quickly reply to bots
type ReplyMarkupShowKeyboard struct {
	tdCommon
	Rows                  [][]KeyboardButton `json:"rows"`                    // A list of rows of bot keyboard buttons
	IsPersistent          bool               `json:"is_persistent"`           // True, if the keyboard is supposed to always be shown when the ordinary keyboard is hidden
	ResizeKeyboard        bool               `json:"resize_keyboard"`         // True, if the application needs to resize the keyboard vertically
	OneTime               bool               `json:"one_time"`                // True, if the application needs to hide the keyboard after use
	IsPersonal            bool               `json:"is_personal"`             // True, if the keyboard must automatically be shown to the current user. For outgoing messages, specify true to show the keyboard only for the mentioned users and for the target user of a reply
	InputFieldPlaceholder string             `json:"input_field_placeholder"` // If non-empty, the placeholder to be shown in the input field when the keyboard is active; 0-64 characters
}

// MessageType return the string telegram-type of ReplyMarkupShowKeyboard
func (replyMarkupShowKeyboard *ReplyMarkupShowKeyboard) MessageType() string {
	return "replyMarkupShowKeyboard"
}

// NewReplyMarkupShowKeyboard creates a new ReplyMarkupShowKeyboard
//
// @param rows A list of rows of bot keyboard buttons
// @param isPersistent True, if the keyboard is supposed to always be shown when the ordinary keyboard is hidden
// @param resizeKeyboard True, if the application needs to resize the keyboard vertically
// @param oneTime True, if the application needs to hide the keyboard after use
// @param isPersonal True, if the keyboard must automatically be shown to the current user. For outgoing messages, specify true to show the keyboard only for the mentioned users and for the target user of a reply
// @param inputFieldPlaceholder If non-empty, the placeholder to be shown in the input field when the keyboard is active; 0-64 characters
func NewReplyMarkupShowKeyboard(rows [][]KeyboardButton, isPersistent bool, resizeKeyboard bool, oneTime bool, isPersonal bool, inputFieldPlaceholder string) *ReplyMarkupShowKeyboard {
	replyMarkupShowKeyboardTemp := ReplyMarkupShowKeyboard{
		tdCommon:              tdCommon{Type: "replyMarkupShowKeyboard"},
		Rows:                  rows,
		IsPersistent:          isPersistent,
		ResizeKeyboard:        resizeKeyboard,
		OneTime:               oneTime,
		IsPersonal:            isPersonal,
		InputFieldPlaceholder: inputFieldPlaceholder,
	}

	return &replyMarkupShowKeyboardTemp
}

// UnmarshalJSON unmarshal to json
func (replyMarkupShowKeyboard *ReplyMarkupShowKeyboard) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Rows                  [][]KeyboardButton `json:"rows"`                    // A list of rows of bot keyboard buttons
		IsPersistent          bool               `json:"is_persistent"`           // True, if the keyboard is supposed to always be shown when the ordinary keyboard is hidden
		ResizeKeyboard        bool               `json:"resize_keyboard"`         // True, if the application needs to resize the keyboard vertically
		OneTime               bool               `json:"one_time"`                // True, if the application needs to hide the keyboard after use
		IsPersonal            bool               `json:"is_personal"`             // True, if the keyboard must automatically be shown to the current user. For outgoing messages, specify true to show the keyboard only for the mentioned users and for the target user of a reply
		InputFieldPlaceholder string             `json:"input_field_placeholder"` // If non-empty, the placeholder to be shown in the input field when the keyboard is active; 0-64 characters
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	replyMarkupShowKeyboard.tdCommon = tempObj.tdCommon
	replyMarkupShowKeyboard.Rows = tempObj.Rows
	replyMarkupShowKeyboard.IsPersistent = tempObj.IsPersistent
	replyMarkupShowKeyboard.ResizeKeyboard = tempObj.ResizeKeyboard
	replyMarkupShowKeyboard.OneTime = tempObj.OneTime
	replyMarkupShowKeyboard.IsPersonal = tempObj.IsPersonal
	replyMarkupShowKeyboard.InputFieldPlaceholder = tempObj.InputFieldPlaceholder

	return nil
}

// GetReplyMarkupEnum return the enum type of this object
func (replyMarkupShowKeyboard *ReplyMarkupShowKeyboard) GetReplyMarkupEnum() ReplyMarkupEnum {
	return ReplyMarkupShowKeyboardType
}

// ReplyMarkupInlineKeyboard Contains an inline keyboard layout
type ReplyMarkupInlineKeyboard struct {
	tdCommon
	Rows [][]InlineKeyboardButton `json:"rows"` // A list of rows of inline keyboard buttons
}

// MessageType return the string telegram-type of ReplyMarkupInlineKeyboard
func (replyMarkupInlineKeyboard *ReplyMarkupInlineKeyboard) MessageType() string {
	return "replyMarkupInlineKeyboard"
}

// NewReplyMarkupInlineKeyboard creates a new ReplyMarkupInlineKeyboard
//
// @param rows A list of rows of inline keyboard buttons
func NewReplyMarkupInlineKeyboard(rows [][]InlineKeyboardButton) *ReplyMarkupInlineKeyboard {
	replyMarkupInlineKeyboardTemp := ReplyMarkupInlineKeyboard{
		tdCommon: tdCommon{Type: "replyMarkupInlineKeyboard"},
		Rows:     rows,
	}

	return &replyMarkupInlineKeyboardTemp
}

// UnmarshalJSON unmarshal to json
func (replyMarkupInlineKeyboard *ReplyMarkupInlineKeyboard) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Rows [][]InlineKeyboardButton `json:"rows"` // A list of rows of inline keyboard buttons
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	replyMarkupInlineKeyboard.tdCommon = tempObj.tdCommon
	replyMarkupInlineKeyboard.Rows = tempObj.Rows

	return nil
}

// GetReplyMarkupEnum return the enum type of this object
func (replyMarkupInlineKeyboard *ReplyMarkupInlineKeyboard) GetReplyMarkupEnum() ReplyMarkupEnum {
	return ReplyMarkupInlineKeyboardType
}

// LoginURLInfoOpen An HTTP URL needs to be open
type LoginURLInfoOpen struct {
	tdCommon
	URL              string `json:"url"`               // The URL to open
	SkipConfirmation bool   `json:"skip_confirmation"` // True, if there is no need to show an ordinary open URL confirmation
}

// MessageType return the string telegram-type of LoginURLInfoOpen
func (loginURLInfoOpen *LoginURLInfoOpen) MessageType() string {
	return "loginUrlInfoOpen"
}

// NewLoginURLInfoOpen creates a new LoginURLInfoOpen
//
// @param uRL The URL to open
// @param skipConfirmation True, if there is no need to show an ordinary open URL confirmation
func NewLoginURLInfoOpen(uRL string, skipConfirmation bool) *LoginURLInfoOpen {
	loginURLInfoOpenTemp := LoginURLInfoOpen{
		tdCommon:         tdCommon{Type: "loginUrlInfoOpen"},
		URL:              uRL,
		SkipConfirmation: skipConfirmation,
	}

	return &loginURLInfoOpenTemp
}

// UnmarshalJSON unmarshal to json
func (loginURLInfoOpen *LoginURLInfoOpen) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL              string `json:"url"`               // The URL to open
		SkipConfirmation bool   `json:"skip_confirmation"` // True, if there is no need to show an ordinary open URL confirmation
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	loginURLInfoOpen.tdCommon = tempObj.tdCommon
	loginURLInfoOpen.URL = tempObj.URL
	loginURLInfoOpen.SkipConfirmation = tempObj.SkipConfirmation

	return nil
}

// LoginURLInfoRequestConfirmation An authorization confirmation dialog needs to be shown to the user
type LoginURLInfoRequestConfirmation struct {
	tdCommon
	URL                string `json:"url"`                  // An HTTP URL to be opened
	Domain             string `json:"domain"`               // A domain of the URL
	BotUserID          int64  `json:"bot_user_id"`          // User identifier of a bot linked with the website
	RequestWriteAccess bool   `json:"request_write_access"` // True, if the user must be asked for the permission to the bot to send them messages
}

// MessageType return the string telegram-type of LoginURLInfoRequestConfirmation
func (loginURLInfoRequestConfirmation *LoginURLInfoRequestConfirmation) MessageType() string {
	return "loginUrlInfoRequestConfirmation"
}

// NewLoginURLInfoRequestConfirmation creates a new LoginURLInfoRequestConfirmation
//
// @param uRL An HTTP URL to be opened
// @param domain A domain of the URL
// @param botUserID User identifier of a bot linked with the website
// @param requestWriteAccess True, if the user must be asked for the permission to the bot to send them messages
func NewLoginURLInfoRequestConfirmation(uRL string, domain string, botUserID int64, requestWriteAccess bool) *LoginURLInfoRequestConfirmation {
	loginURLInfoRequestConfirmationTemp := LoginURLInfoRequestConfirmation{
		tdCommon:           tdCommon{Type: "loginUrlInfoRequestConfirmation"},
		URL:                uRL,
		Domain:             domain,
		BotUserID:          botUserID,
		RequestWriteAccess: requestWriteAccess,
	}

	return &loginURLInfoRequestConfirmationTemp
}

// UnmarshalJSON unmarshal to json
func (loginURLInfoRequestConfirmation *LoginURLInfoRequestConfirmation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL                string `json:"url"`                  // An HTTP URL to be opened
		Domain             string `json:"domain"`               // A domain of the URL
		BotUserID          int64  `json:"bot_user_id"`          // User identifier of a bot linked with the website
		RequestWriteAccess bool   `json:"request_write_access"` // True, if the user must be asked for the permission to the bot to send them messages
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	loginURLInfoRequestConfirmation.tdCommon = tempObj.tdCommon
	loginURLInfoRequestConfirmation.URL = tempObj.URL
	loginURLInfoRequestConfirmation.Domain = tempObj.Domain
	loginURLInfoRequestConfirmation.BotUserID = tempObj.BotUserID
	loginURLInfoRequestConfirmation.RequestWriteAccess = tempObj.RequestWriteAccess

	return nil
}

// FoundWebApp Contains information about a Web App found by its short name
type FoundWebApp struct {
	tdCommon
	WebApp             *WebApp `json:"web_app"`              // The Web App
	RequestWriteAccess bool    `json:"request_write_access"` // True, if the user must be asked for the permission to the bot to send them messages
	SkipConfirmation   bool    `json:"skip_confirmation"`    // True, if there is no need to show an ordinary open URL confirmation before opening the Web App. The field must be ignored and confirmation must be shown anyway if the Web App link was hidden
}

// MessageType return the string telegram-type of FoundWebApp
func (foundWebApp *FoundWebApp) MessageType() string {
	return "foundWebApp"
}

// NewFoundWebApp creates a new FoundWebApp
//
// @param webApp The Web App
// @param requestWriteAccess True, if the user must be asked for the permission to the bot to send them messages
// @param skipConfirmation True, if there is no need to show an ordinary open URL confirmation before opening the Web App. The field must be ignored and confirmation must be shown anyway if the Web App link was hidden
func NewFoundWebApp(webApp *WebApp, requestWriteAccess bool, skipConfirmation bool) *FoundWebApp {
	foundWebAppTemp := FoundWebApp{
		tdCommon:           tdCommon{Type: "foundWebApp"},
		WebApp:             webApp,
		RequestWriteAccess: requestWriteAccess,
		SkipConfirmation:   skipConfirmation,
	}

	return &foundWebAppTemp
}

// UnmarshalJSON unmarshal to json
func (foundWebApp *FoundWebApp) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		WebApp             *WebApp `json:"web_app"`              // The Web App
		RequestWriteAccess bool    `json:"request_write_access"` // True, if the user must be asked for the permission to the bot to send them messages
		SkipConfirmation   bool    `json:"skip_confirmation"`    // True, if there is no need to show an ordinary open URL confirmation before opening the Web App. The field must be ignored and confirmation must be shown anyway if the Web App link was hidden
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	foundWebApp.tdCommon = tempObj.tdCommon
	foundWebApp.WebApp = tempObj.WebApp
	foundWebApp.RequestWriteAccess = tempObj.RequestWriteAccess
	foundWebApp.SkipConfirmation = tempObj.SkipConfirmation

	return nil
}

// WebAppInfo Contains information about a Web App
type WebAppInfo struct {
	tdCommon
	LaunchID JSONInt64 `json:"launch_id"` // Unique identifier for the Web App launch
	URL      string    `json:"url"`       // A Web App URL to open in a web view
}

// MessageType return the string telegram-type of WebAppInfo
func (webAppInfo *WebAppInfo) MessageType() string {
	return "webAppInfo"
}

// NewWebAppInfo creates a new WebAppInfo
//
// @param launchID Unique identifier for the Web App launch
// @param uRL A Web App URL to open in a web view
func NewWebAppInfo(launchID JSONInt64, uRL string) *WebAppInfo {
	webAppInfoTemp := WebAppInfo{
		tdCommon: tdCommon{Type: "webAppInfo"},
		LaunchID: launchID,
		URL:      uRL,
	}

	return &webAppInfoTemp
}

// UnmarshalJSON unmarshal to json
func (webAppInfo *WebAppInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		LaunchID JSONInt64 `json:"launch_id"` // Unique identifier for the Web App launch
		URL      string    `json:"url"`       // A Web App URL to open in a web view
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	webAppInfo.tdCommon = tempObj.tdCommon
	webAppInfo.LaunchID = tempObj.LaunchID
	webAppInfo.URL = tempObj.URL

	return nil
}

// MainWebApp Contains information about the main Web App of a bot
type MainWebApp struct {
	tdCommon
	URL       string `json:"url"`        // URL of the Web App to open
	IsCompact bool   `json:"is_compact"` // True, if the Web App must always be opened in the compact mode instead of the full-size mode
}

// MessageType return the string telegram-type of MainWebApp
func (mainWebApp *MainWebApp) MessageType() string {
	return "mainWebApp"
}

// NewMainWebApp creates a new MainWebApp
//
// @param uRL URL of the Web App to open
// @param isCompact True, if the Web App must always be opened in the compact mode instead of the full-size mode
func NewMainWebApp(uRL string, isCompact bool) *MainWebApp {
	mainWebAppTemp := MainWebApp{
		tdCommon:  tdCommon{Type: "mainWebApp"},
		URL:       uRL,
		IsCompact: isCompact,
	}

	return &mainWebAppTemp
}

// UnmarshalJSON unmarshal to json
func (mainWebApp *MainWebApp) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL       string `json:"url"`        // URL of the Web App to open
		IsCompact bool   `json:"is_compact"` // True, if the Web App must always be opened in the compact mode instead of the full-size mode
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	mainWebApp.tdCommon = tempObj.tdCommon
	mainWebApp.URL = tempObj.URL
	mainWebApp.IsCompact = tempObj.IsCompact

	return nil
}

// MessageThreadInfo Contains information about a message thread
type MessageThreadInfo struct {
	tdCommon
	ChatID             int64             `json:"chat_id"`              // Identifier of the chat to which the message thread belongs
	MessageThreadID    int64             `json:"message_thread_id"`    // Message thread identifier, unique within the chat
	ReplyInfo          *MessageReplyInfo `json:"reply_info"`           // Information about the message thread; may be null for forum topic threads
	UnreadMessageCount int32             `json:"unread_message_count"` // Approximate number of unread messages in the message thread
	Messages           []Message         `json:"messages"`             // The messages from which the thread starts. The messages are returned in reverse chronological order (i.e., in order of decreasing message_id)
	DraftMessage       *DraftMessage     `json:"draft_message"`        // A draft of a message in the message thread; may be null if none
}

// MessageType return the string telegram-type of MessageThreadInfo
func (messageThreadInfo *MessageThreadInfo) MessageType() string {
	return "messageThreadInfo"
}

// NewMessageThreadInfo creates a new MessageThreadInfo
//
// @param chatID Identifier of the chat to which the message thread belongs
// @param messageThreadID Message thread identifier, unique within the chat
// @param replyInfo Information about the message thread; may be null for forum topic threads
// @param unreadMessageCount Approximate number of unread messages in the message thread
// @param messages The messages from which the thread starts. The messages are returned in reverse chronological order (i.e., in order of decreasing message_id)
// @param draftMessage A draft of a message in the message thread; may be null if none
func NewMessageThreadInfo(chatID int64, messageThreadID int64, replyInfo *MessageReplyInfo, unreadMessageCount int32, messages []Message, draftMessage *DraftMessage) *MessageThreadInfo {
	messageThreadInfoTemp := MessageThreadInfo{
		tdCommon:           tdCommon{Type: "messageThreadInfo"},
		ChatID:             chatID,
		MessageThreadID:    messageThreadID,
		ReplyInfo:          replyInfo,
		UnreadMessageCount: unreadMessageCount,
		Messages:           messages,
		DraftMessage:       draftMessage,
	}

	return &messageThreadInfoTemp
}

// UnmarshalJSON unmarshal to json
func (messageThreadInfo *MessageThreadInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID             int64     `json:"chat_id"`              // Identifier of the chat to which the message thread belongs
		MessageThreadID    int64     `json:"message_thread_id"`    // Message thread identifier, unique within the chat
		UnreadMessageCount int32     `json:"unread_message_count"` // Approximate number of unread messages in the message thread
		Messages           []Message `json:"messages"`             // The messages from which the thread starts. The messages are returned in reverse chronological order (i.e., in order of decreasing message_id)

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageThreadInfo.tdCommon = tempObj.tdCommon
	messageThreadInfo.ChatID = tempObj.ChatID
	messageThreadInfo.MessageThreadID = tempObj.MessageThreadID
	messageThreadInfo.UnreadMessageCount = tempObj.UnreadMessageCount
	messageThreadInfo.Messages = tempObj.Messages

	var replyInfo MessageReplyInfo
	if objMap["reply_info"] != nil {
		err = replyInfo.UnmarshalJSON(*objMap["reply_info"])
		if err != nil {
			return err
		}
	}

	messageThreadInfo.ReplyInfo = &replyInfo

	var draftMessage DraftMessage
	if objMap["draft_message"] != nil {
		err = draftMessage.UnmarshalJSON(*objMap["draft_message"])
		if err != nil {
			return err
		}
	}

	messageThreadInfo.DraftMessage = &draftMessage

	return nil
}

// SavedMessagesTopicTypeMyNotes Topic containing messages sent by the current user of forwarded from an unknown chat
type SavedMessagesTopicTypeMyNotes struct {
	tdCommon
}

// MessageType return the string telegram-type of SavedMessagesTopicTypeMyNotes
func (savedMessagesTopicTypeMyNotes *SavedMessagesTopicTypeMyNotes) MessageType() string {
	return "savedMessagesTopicTypeMyNotes"
}

// NewSavedMessagesTopicTypeMyNotes creates a new SavedMessagesTopicTypeMyNotes
//
func NewSavedMessagesTopicTypeMyNotes() *SavedMessagesTopicTypeMyNotes {
	savedMessagesTopicTypeMyNotesTemp := SavedMessagesTopicTypeMyNotes{
		tdCommon: tdCommon{Type: "savedMessagesTopicTypeMyNotes"},
	}

	return &savedMessagesTopicTypeMyNotesTemp
}

// UnmarshalJSON unmarshal to json
func (savedMessagesTopicTypeMyNotes *SavedMessagesTopicTypeMyNotes) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	savedMessagesTopicTypeMyNotes.tdCommon = tempObj.tdCommon

	return nil
}

// GetSavedMessagesTopicTypeEnum return the enum type of this object
func (savedMessagesTopicTypeMyNotes *SavedMessagesTopicTypeMyNotes) GetSavedMessagesTopicTypeEnum() SavedMessagesTopicTypeEnum {
	return SavedMessagesTopicTypeMyNotesType
}

// SavedMessagesTopicTypeAuthorHidden Topic containing messages forwarded from a user with hidden privacy
type SavedMessagesTopicTypeAuthorHidden struct {
	tdCommon
}

// MessageType return the string telegram-type of SavedMessagesTopicTypeAuthorHidden
func (savedMessagesTopicTypeAuthorHidden *SavedMessagesTopicTypeAuthorHidden) MessageType() string {
	return "savedMessagesTopicTypeAuthorHidden"
}

// NewSavedMessagesTopicTypeAuthorHidden creates a new SavedMessagesTopicTypeAuthorHidden
//
func NewSavedMessagesTopicTypeAuthorHidden() *SavedMessagesTopicTypeAuthorHidden {
	savedMessagesTopicTypeAuthorHiddenTemp := SavedMessagesTopicTypeAuthorHidden{
		tdCommon: tdCommon{Type: "savedMessagesTopicTypeAuthorHidden"},
	}

	return &savedMessagesTopicTypeAuthorHiddenTemp
}

// UnmarshalJSON unmarshal to json
func (savedMessagesTopicTypeAuthorHidden *SavedMessagesTopicTypeAuthorHidden) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	savedMessagesTopicTypeAuthorHidden.tdCommon = tempObj.tdCommon

	return nil
}

// GetSavedMessagesTopicTypeEnum return the enum type of this object
func (savedMessagesTopicTypeAuthorHidden *SavedMessagesTopicTypeAuthorHidden) GetSavedMessagesTopicTypeEnum() SavedMessagesTopicTypeEnum {
	return SavedMessagesTopicTypeAuthorHiddenType
}

// SavedMessagesTopicTypeSavedFromChat Topic containing messages forwarded from a specific chat
type SavedMessagesTopicTypeSavedFromChat struct {
	tdCommon
	ChatID int64 `json:"chat_id"` // Identifier of the chat
}

// MessageType return the string telegram-type of SavedMessagesTopicTypeSavedFromChat
func (savedMessagesTopicTypeSavedFromChat *SavedMessagesTopicTypeSavedFromChat) MessageType() string {
	return "savedMessagesTopicTypeSavedFromChat"
}

// NewSavedMessagesTopicTypeSavedFromChat creates a new SavedMessagesTopicTypeSavedFromChat
//
// @param chatID Identifier of the chat
func NewSavedMessagesTopicTypeSavedFromChat(chatID int64) *SavedMessagesTopicTypeSavedFromChat {
	savedMessagesTopicTypeSavedFromChatTemp := SavedMessagesTopicTypeSavedFromChat{
		tdCommon: tdCommon{Type: "savedMessagesTopicTypeSavedFromChat"},
		ChatID:   chatID,
	}

	return &savedMessagesTopicTypeSavedFromChatTemp
}

// UnmarshalJSON unmarshal to json
func (savedMessagesTopicTypeSavedFromChat *SavedMessagesTopicTypeSavedFromChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID int64 `json:"chat_id"` // Identifier of the chat
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	savedMessagesTopicTypeSavedFromChat.tdCommon = tempObj.tdCommon
	savedMessagesTopicTypeSavedFromChat.ChatID = tempObj.ChatID

	return nil
}

// GetSavedMessagesTopicTypeEnum return the enum type of this object
func (savedMessagesTopicTypeSavedFromChat *SavedMessagesTopicTypeSavedFromChat) GetSavedMessagesTopicTypeEnum() SavedMessagesTopicTypeEnum {
	return SavedMessagesTopicTypeSavedFromChatType
}

// SavedMessagesTopic Contains information about a Saved Messages topic
type SavedMessagesTopic struct {
	tdCommon
	ID           int64                  `json:"id"`            // Unique topic identifier
	Type         SavedMessagesTopicType `json:"type"`          // Type of the topic
	IsPinned     bool                   `json:"is_pinned"`     // True, if the topic is pinned
	Order        JSONInt64              `json:"order"`         // A parameter used to determine order of the topic in the topic list. Topics must be sorted by the order in descending order
	LastMessage  *Message               `json:"last_message"`  // Last message in the topic; may be null if none or unknown
	DraftMessage *DraftMessage          `json:"draft_message"` // A draft of a message in the topic; may be null if none
}

// MessageType return the string telegram-type of SavedMessagesTopic
func (savedMessagesTopic *SavedMessagesTopic) MessageType() string {
	return "savedMessagesTopic"
}

// NewSavedMessagesTopic creates a new SavedMessagesTopic
//
// @param iD Unique topic identifier
// @param typeParam Type of the topic
// @param isPinned True, if the topic is pinned
// @param order A parameter used to determine order of the topic in the topic list. Topics must be sorted by the order in descending order
// @param lastMessage Last message in the topic; may be null if none or unknown
// @param draftMessage A draft of a message in the topic; may be null if none
func NewSavedMessagesTopic(iD int64, typeParam SavedMessagesTopicType, isPinned bool, order JSONInt64, lastMessage *Message, draftMessage *DraftMessage) *SavedMessagesTopic {
	savedMessagesTopicTemp := SavedMessagesTopic{
		tdCommon:     tdCommon{Type: "savedMessagesTopic"},
		ID:           iD,
		Type:         typeParam,
		IsPinned:     isPinned,
		Order:        order,
		LastMessage:  lastMessage,
		DraftMessage: draftMessage,
	}

	return &savedMessagesTopicTemp
}

// UnmarshalJSON unmarshal to json
func (savedMessagesTopic *SavedMessagesTopic) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID       int64     `json:"id"`        // Unique topic identifier
		IsPinned bool      `json:"is_pinned"` // True, if the topic is pinned
		Order    JSONInt64 `json:"order"`     // A parameter used to determine order of the topic in the topic list. Topics must be sorted by the order in descending order

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	savedMessagesTopic.tdCommon = tempObj.tdCommon
	savedMessagesTopic.ID = tempObj.ID
	savedMessagesTopic.IsPinned = tempObj.IsPinned
	savedMessagesTopic.Order = tempObj.Order

	fieldType, _ := unmarshalSavedMessagesTopicType(objMap["type"])
	savedMessagesTopic.Type = fieldType

	var lastMessage Message
	if objMap["last_message"] != nil {
		err = lastMessage.UnmarshalJSON(*objMap["last_message"])
		if err != nil {
			return err
		}
	}

	savedMessagesTopic.LastMessage = &lastMessage

	var draftMessage DraftMessage
	if objMap["draft_message"] != nil {
		err = draftMessage.UnmarshalJSON(*objMap["draft_message"])
		if err != nil {
			return err
		}
	}

	savedMessagesTopic.DraftMessage = &draftMessage

	return nil
}

// ForumTopicIcon Describes a forum topic icon
type ForumTopicIcon struct {
	tdCommon
	Color         int32     `json:"color"`           // Color of the topic icon in RGB format
	CustomEmojiID JSONInt64 `json:"custom_emoji_id"` // Unique identifier of the custom emoji shown on the topic icon; 0 if none
}

// MessageType return the string telegram-type of ForumTopicIcon
func (forumTopicIcon *ForumTopicIcon) MessageType() string {
	return "forumTopicIcon"
}

// NewForumTopicIcon creates a new ForumTopicIcon
//
// @param color Color of the topic icon in RGB format
// @param customEmojiID Unique identifier of the custom emoji shown on the topic icon; 0 if none
func NewForumTopicIcon(color int32, customEmojiID JSONInt64) *ForumTopicIcon {
	forumTopicIconTemp := ForumTopicIcon{
		tdCommon:      tdCommon{Type: "forumTopicIcon"},
		Color:         color,
		CustomEmojiID: customEmojiID,
	}

	return &forumTopicIconTemp
}

// UnmarshalJSON unmarshal to json
func (forumTopicIcon *ForumTopicIcon) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Color         int32     `json:"color"`           // Color of the topic icon in RGB format
		CustomEmojiID JSONInt64 `json:"custom_emoji_id"` // Unique identifier of the custom emoji shown on the topic icon; 0 if none
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	forumTopicIcon.tdCommon = tempObj.tdCommon
	forumTopicIcon.Color = tempObj.Color
	forumTopicIcon.CustomEmojiID = tempObj.CustomEmojiID

	return nil
}

// ForumTopicInfo Contains basic information about a forum topic
type ForumTopicInfo struct {
	tdCommon
	MessageThreadID int64           `json:"message_thread_id"` // Message thread identifier of the topic
	Name            string          `json:"name"`              // Name of the topic
	Icon            *ForumTopicIcon `json:"icon"`              // Icon of the topic
	CreationDate    int32           `json:"creation_date"`     // Point in time (Unix timestamp) when the topic was created
	CreatorID       MessageSender   `json:"creator_id"`        // Identifier of the creator of the topic
	IsGeneral       bool            `json:"is_general"`        // True, if the topic is the General topic list
	IsOutgoing      bool            `json:"is_outgoing"`       // True, if the topic was created by the current user
	IsClosed        bool            `json:"is_closed"`         // True, if the topic is closed
	IsHidden        bool            `json:"is_hidden"`         // True, if the topic is hidden above the topic list and closed; for General topic only
}

// MessageType return the string telegram-type of ForumTopicInfo
func (forumTopicInfo *ForumTopicInfo) MessageType() string {
	return "forumTopicInfo"
}

// NewForumTopicInfo creates a new ForumTopicInfo
//
// @param messageThreadID Message thread identifier of the topic
// @param name Name of the topic
// @param icon Icon of the topic
// @param creationDate Point in time (Unix timestamp) when the topic was created
// @param creatorID Identifier of the creator of the topic
// @param isGeneral True, if the topic is the General topic list
// @param isOutgoing True, if the topic was created by the current user
// @param isClosed True, if the topic is closed
// @param isHidden True, if the topic is hidden above the topic list and closed; for General topic only
func NewForumTopicInfo(messageThreadID int64, name string, icon *ForumTopicIcon, creationDate int32, creatorID MessageSender, isGeneral bool, isOutgoing bool, isClosed bool, isHidden bool) *ForumTopicInfo {
	forumTopicInfoTemp := ForumTopicInfo{
		tdCommon:        tdCommon{Type: "forumTopicInfo"},
		MessageThreadID: messageThreadID,
		Name:            name,
		Icon:            icon,
		CreationDate:    creationDate,
		CreatorID:       creatorID,
		IsGeneral:       isGeneral,
		IsOutgoing:      isOutgoing,
		IsClosed:        isClosed,
		IsHidden:        isHidden,
	}

	return &forumTopicInfoTemp
}

// UnmarshalJSON unmarshal to json
func (forumTopicInfo *ForumTopicInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MessageThreadID int64           `json:"message_thread_id"` // Message thread identifier of the topic
		Name            string          `json:"name"`              // Name of the topic
		Icon            *ForumTopicIcon `json:"icon"`              // Icon of the topic
		CreationDate    int32           `json:"creation_date"`     // Point in time (Unix timestamp) when the topic was created
		IsGeneral       bool            `json:"is_general"`        // True, if the topic is the General topic list
		IsOutgoing      bool            `json:"is_outgoing"`       // True, if the topic was created by the current user
		IsClosed        bool            `json:"is_closed"`         // True, if the topic is closed
		IsHidden        bool            `json:"is_hidden"`         // True, if the topic is hidden above the topic list and closed; for General topic only
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	forumTopicInfo.tdCommon = tempObj.tdCommon
	forumTopicInfo.MessageThreadID = tempObj.MessageThreadID
	forumTopicInfo.Name = tempObj.Name
	forumTopicInfo.Icon = tempObj.Icon
	forumTopicInfo.CreationDate = tempObj.CreationDate
	forumTopicInfo.IsGeneral = tempObj.IsGeneral
	forumTopicInfo.IsOutgoing = tempObj.IsOutgoing
	forumTopicInfo.IsClosed = tempObj.IsClosed
	forumTopicInfo.IsHidden = tempObj.IsHidden

	fieldCreatorID, _ := unmarshalMessageSender(objMap["creator_id"])
	forumTopicInfo.CreatorID = fieldCreatorID

	return nil
}

// ForumTopic Describes a forum topic
type ForumTopic struct {
	tdCommon
	Info                    *ForumTopicInfo           `json:"info"`                        // Basic information about the topic
	LastMessage             *Message                  `json:"last_message"`                // Last message in the topic; may be null if unknown
	IsPinned                bool                      `json:"is_pinned"`                   // True, if the topic is pinned in the topic list
	UnreadCount             int32                     `json:"unread_count"`                // Number of unread messages in the topic
	LastReadInboxMessageID  int64                     `json:"last_read_inbox_message_id"`  // Identifier of the last read incoming message
	LastReadOutboxMessageID int64                     `json:"last_read_outbox_message_id"` // Identifier of the last read outgoing message
	UnreadMentionCount      int32                     `json:"unread_mention_count"`        // Number of unread messages with a mention/reply in the topic
	UnreadReactionCount     int32                     `json:"unread_reaction_count"`       // Number of messages with unread reactions in the topic
	NotificationSettings    *ChatNotificationSettings `json:"notification_settings"`       // Notification settings for the topic
	DraftMessage            *DraftMessage             `json:"draft_message"`               // A draft of a message in the topic; may be null if none
}

// MessageType return the string telegram-type of ForumTopic
func (forumTopic *ForumTopic) MessageType() string {
	return "forumTopic"
}

// NewForumTopic creates a new ForumTopic
//
// @param info Basic information about the topic
// @param lastMessage Last message in the topic; may be null if unknown
// @param isPinned True, if the topic is pinned in the topic list
// @param unreadCount Number of unread messages in the topic
// @param lastReadInboxMessageID Identifier of the last read incoming message
// @param lastReadOutboxMessageID Identifier of the last read outgoing message
// @param unreadMentionCount Number of unread messages with a mention/reply in the topic
// @param unreadReactionCount Number of messages with unread reactions in the topic
// @param notificationSettings Notification settings for the topic
// @param draftMessage A draft of a message in the topic; may be null if none
func NewForumTopic(info *ForumTopicInfo, lastMessage *Message, isPinned bool, unreadCount int32, lastReadInboxMessageID int64, lastReadOutboxMessageID int64, unreadMentionCount int32, unreadReactionCount int32, notificationSettings *ChatNotificationSettings, draftMessage *DraftMessage) *ForumTopic {
	forumTopicTemp := ForumTopic{
		tdCommon:                tdCommon{Type: "forumTopic"},
		Info:                    info,
		LastMessage:             lastMessage,
		IsPinned:                isPinned,
		UnreadCount:             unreadCount,
		LastReadInboxMessageID:  lastReadInboxMessageID,
		LastReadOutboxMessageID: lastReadOutboxMessageID,
		UnreadMentionCount:      unreadMentionCount,
		UnreadReactionCount:     unreadReactionCount,
		NotificationSettings:    notificationSettings,
		DraftMessage:            draftMessage,
	}

	return &forumTopicTemp
}

// UnmarshalJSON unmarshal to json
func (forumTopic *ForumTopic) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsPinned                bool                      `json:"is_pinned"`                   // True, if the topic is pinned in the topic list
		UnreadCount             int32                     `json:"unread_count"`                // Number of unread messages in the topic
		LastReadInboxMessageID  int64                     `json:"last_read_inbox_message_id"`  // Identifier of the last read incoming message
		LastReadOutboxMessageID int64                     `json:"last_read_outbox_message_id"` // Identifier of the last read outgoing message
		UnreadMentionCount      int32                     `json:"unread_mention_count"`        // Number of unread messages with a mention/reply in the topic
		UnreadReactionCount     int32                     `json:"unread_reaction_count"`       // Number of messages with unread reactions in the topic
		NotificationSettings    *ChatNotificationSettings `json:"notification_settings"`       // Notification settings for the topic

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	forumTopic.tdCommon = tempObj.tdCommon
	forumTopic.IsPinned = tempObj.IsPinned
	forumTopic.UnreadCount = tempObj.UnreadCount
	forumTopic.LastReadInboxMessageID = tempObj.LastReadInboxMessageID
	forumTopic.LastReadOutboxMessageID = tempObj.LastReadOutboxMessageID
	forumTopic.UnreadMentionCount = tempObj.UnreadMentionCount
	forumTopic.UnreadReactionCount = tempObj.UnreadReactionCount
	forumTopic.NotificationSettings = tempObj.NotificationSettings

	var info ForumTopicInfo
	if objMap["info"] != nil {
		err = info.UnmarshalJSON(*objMap["info"])
		if err != nil {
			return err
		}
	}

	forumTopic.Info = &info

	var lastMessage Message
	if objMap["last_message"] != nil {
		err = lastMessage.UnmarshalJSON(*objMap["last_message"])
		if err != nil {
			return err
		}
	}

	forumTopic.LastMessage = &lastMessage

	var draftMessage DraftMessage
	if objMap["draft_message"] != nil {
		err = draftMessage.UnmarshalJSON(*objMap["draft_message"])
		if err != nil {
			return err
		}
	}

	forumTopic.DraftMessage = &draftMessage

	return nil
}

// ForumTopics Describes a list of forum topics
type ForumTopics struct {
	tdCommon
	TotalCount                int32        `json:"total_count"`                   // Approximate total number of forum topics found
	Topics                    []ForumTopic `json:"topics"`                        // List of forum topics
	NextOffsetDate            int32        `json:"next_offset_date"`              // Offset date for the next getForumTopics request
	NextOffsetMessageID       int64        `json:"next_offset_message_id"`        // Offset message identifier for the next getForumTopics request
	NextOffsetMessageThreadID int64        `json:"next_offset_message_thread_id"` // Offset message thread identifier for the next getForumTopics request
}

// MessageType return the string telegram-type of ForumTopics
func (forumTopics *ForumTopics) MessageType() string {
	return "forumTopics"
}

// NewForumTopics creates a new ForumTopics
//
// @param totalCount Approximate total number of forum topics found
// @param topics List of forum topics
// @param nextOffsetDate Offset date for the next getForumTopics request
// @param nextOffsetMessageID Offset message identifier for the next getForumTopics request
// @param nextOffsetMessageThreadID Offset message thread identifier for the next getForumTopics request
func NewForumTopics(totalCount int32, topics []ForumTopic, nextOffsetDate int32, nextOffsetMessageID int64, nextOffsetMessageThreadID int64) *ForumTopics {
	forumTopicsTemp := ForumTopics{
		tdCommon:                  tdCommon{Type: "forumTopics"},
		TotalCount:                totalCount,
		Topics:                    topics,
		NextOffsetDate:            nextOffsetDate,
		NextOffsetMessageID:       nextOffsetMessageID,
		NextOffsetMessageThreadID: nextOffsetMessageThreadID,
	}

	return &forumTopicsTemp
}

// UnmarshalJSON unmarshal to json
func (forumTopics *ForumTopics) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount                int32        `json:"total_count"`                   // Approximate total number of forum topics found
		Topics                    []ForumTopic `json:"topics"`                        // List of forum topics
		NextOffsetDate            int32        `json:"next_offset_date"`              // Offset date for the next getForumTopics request
		NextOffsetMessageID       int64        `json:"next_offset_message_id"`        // Offset message identifier for the next getForumTopics request
		NextOffsetMessageThreadID int64        `json:"next_offset_message_thread_id"` // Offset message thread identifier for the next getForumTopics request
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	forumTopics.tdCommon = tempObj.tdCommon
	forumTopics.TotalCount = tempObj.TotalCount
	forumTopics.Topics = tempObj.Topics
	forumTopics.NextOffsetDate = tempObj.NextOffsetDate
	forumTopics.NextOffsetMessageID = tempObj.NextOffsetMessageID
	forumTopics.NextOffsetMessageThreadID = tempObj.NextOffsetMessageThreadID

	return nil
}

// LinkPreviewOptions Options to be used for generation of a link preview
type LinkPreviewOptions struct {
	tdCommon
	IsDisabled      bool   `json:"is_disabled"`       // True, if link preview must be disabled
	URL             string `json:"url"`               // URL to use for link preview. If empty, then the first URL found in the message text will be used
	ForceSmallMedia bool   `json:"force_small_media"` // True, if shown media preview must be small; ignored in secret chats or if the URL isn't explicitly specified
	ForceLargeMedia bool   `json:"force_large_media"` // True, if shown media preview must be large; ignored in secret chats or if the URL isn't explicitly specified
	ShowAboveText   bool   `json:"show_above_text"`   // True, if link preview must be shown above message text; otherwise, the link preview will be shown below the message text; ignored in secret chats
}

// MessageType return the string telegram-type of LinkPreviewOptions
func (linkPreviewOptions *LinkPreviewOptions) MessageType() string {
	return "linkPreviewOptions"
}

// NewLinkPreviewOptions creates a new LinkPreviewOptions
//
// @param isDisabled True, if link preview must be disabled
// @param uRL URL to use for link preview. If empty, then the first URL found in the message text will be used
// @param forceSmallMedia True, if shown media preview must be small; ignored in secret chats or if the URL isn't explicitly specified
// @param forceLargeMedia True, if shown media preview must be large; ignored in secret chats or if the URL isn't explicitly specified
// @param showAboveText True, if link preview must be shown above message text; otherwise, the link preview will be shown below the message text; ignored in secret chats
func NewLinkPreviewOptions(isDisabled bool, uRL string, forceSmallMedia bool, forceLargeMedia bool, showAboveText bool) *LinkPreviewOptions {
	linkPreviewOptionsTemp := LinkPreviewOptions{
		tdCommon:        tdCommon{Type: "linkPreviewOptions"},
		IsDisabled:      isDisabled,
		URL:             uRL,
		ForceSmallMedia: forceSmallMedia,
		ForceLargeMedia: forceLargeMedia,
		ShowAboveText:   showAboveText,
	}

	return &linkPreviewOptionsTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewOptions *LinkPreviewOptions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsDisabled      bool   `json:"is_disabled"`       // True, if link preview must be disabled
		URL             string `json:"url"`               // URL to use for link preview. If empty, then the first URL found in the message text will be used
		ForceSmallMedia bool   `json:"force_small_media"` // True, if shown media preview must be small; ignored in secret chats or if the URL isn't explicitly specified
		ForceLargeMedia bool   `json:"force_large_media"` // True, if shown media preview must be large; ignored in secret chats or if the URL isn't explicitly specified
		ShowAboveText   bool   `json:"show_above_text"`   // True, if link preview must be shown above message text; otherwise, the link preview will be shown below the message text; ignored in secret chats
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewOptions.tdCommon = tempObj.tdCommon
	linkPreviewOptions.IsDisabled = tempObj.IsDisabled
	linkPreviewOptions.URL = tempObj.URL
	linkPreviewOptions.ForceSmallMedia = tempObj.ForceSmallMedia
	linkPreviewOptions.ForceLargeMedia = tempObj.ForceLargeMedia
	linkPreviewOptions.ShowAboveText = tempObj.ShowAboveText

	return nil
}

// SharedUser Contains information about a user shared with a bot
type SharedUser struct {
	tdCommon
	UserID    int64  `json:"user_id"`    // User identifier
	FirstName string `json:"first_name"` // First name of the user; for bots only
	LastName  string `json:"last_name"`  // Last name of the user; for bots only
	Username  string `json:"username"`   // Username of the user; for bots only
	Photo     *Photo `json:"photo"`      // Profile photo of the user; for bots only; may be null
}

// MessageType return the string telegram-type of SharedUser
func (sharedUser *SharedUser) MessageType() string {
	return "sharedUser"
}

// NewSharedUser creates a new SharedUser
//
// @param userID User identifier
// @param firstName First name of the user; for bots only
// @param lastName Last name of the user; for bots only
// @param username Username of the user; for bots only
// @param photo Profile photo of the user; for bots only; may be null
func NewSharedUser(userID int64, firstName string, lastName string, username string, photo *Photo) *SharedUser {
	sharedUserTemp := SharedUser{
		tdCommon:  tdCommon{Type: "sharedUser"},
		UserID:    userID,
		FirstName: firstName,
		LastName:  lastName,
		Username:  username,
		Photo:     photo,
	}

	return &sharedUserTemp
}

// UnmarshalJSON unmarshal to json
func (sharedUser *SharedUser) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID    int64  `json:"user_id"`    // User identifier
		FirstName string `json:"first_name"` // First name of the user; for bots only
		LastName  string `json:"last_name"`  // Last name of the user; for bots only
		Username  string `json:"username"`   // Username of the user; for bots only
		Photo     *Photo `json:"photo"`      // Profile photo of the user; for bots only; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sharedUser.tdCommon = tempObj.tdCommon
	sharedUser.UserID = tempObj.UserID
	sharedUser.FirstName = tempObj.FirstName
	sharedUser.LastName = tempObj.LastName
	sharedUser.Username = tempObj.Username
	sharedUser.Photo = tempObj.Photo

	return nil
}

// SharedChat Contains information about a chat shared with a bot
type SharedChat struct {
	tdCommon
	ChatID   int64  `json:"chat_id"`  // Chat identifier
	Title    string `json:"title"`    // Title of the chat; for bots only
	Username string `json:"username"` // Username of the chat; for bots only
	Photo    *Photo `json:"photo"`    // Photo of the chat; for bots only; may be null
}

// MessageType return the string telegram-type of SharedChat
func (sharedChat *SharedChat) MessageType() string {
	return "sharedChat"
}

// NewSharedChat creates a new SharedChat
//
// @param chatID Chat identifier
// @param title Title of the chat; for bots only
// @param username Username of the chat; for bots only
// @param photo Photo of the chat; for bots only; may be null
func NewSharedChat(chatID int64, title string, username string, photo *Photo) *SharedChat {
	sharedChatTemp := SharedChat{
		tdCommon: tdCommon{Type: "sharedChat"},
		ChatID:   chatID,
		Title:    title,
		Username: username,
		Photo:    photo,
	}

	return &sharedChatTemp
}

// UnmarshalJSON unmarshal to json
func (sharedChat *SharedChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID   int64  `json:"chat_id"`  // Chat identifier
		Title    string `json:"title"`    // Title of the chat; for bots only
		Username string `json:"username"` // Username of the chat; for bots only
		Photo    *Photo `json:"photo"`    // Photo of the chat; for bots only; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sharedChat.tdCommon = tempObj.tdCommon
	sharedChat.ChatID = tempObj.ChatID
	sharedChat.Title = tempObj.Title
	sharedChat.Username = tempObj.Username
	sharedChat.Photo = tempObj.Photo

	return nil
}

// ThemeSettings Describes theme settings
type ThemeSettings struct {
	tdCommon
	AccentColor                int32          `json:"accent_color"`                  // Theme accent color in ARGB format
	Background                 *Background    `json:"background"`                    // The background to be used in chats; may be null
	OutgoingMessageFill        BackgroundFill `json:"outgoing_message_fill"`         // The fill to be used as a background for outgoing messages
	AnimateOutgoingMessageFill bool           `json:"animate_outgoing_message_fill"` // If true, the freeform gradient fill needs to be animated on every sent message
	OutgoingMessageAccentColor int32          `json:"outgoing_message_accent_color"` // Accent color of outgoing messages in ARGB format
}

// MessageType return the string telegram-type of ThemeSettings
func (themeSettings *ThemeSettings) MessageType() string {
	return "themeSettings"
}

// NewThemeSettings creates a new ThemeSettings
//
// @param accentColor Theme accent color in ARGB format
// @param background The background to be used in chats; may be null
// @param outgoingMessageFill The fill to be used as a background for outgoing messages
// @param animateOutgoingMessageFill If true, the freeform gradient fill needs to be animated on every sent message
// @param outgoingMessageAccentColor Accent color of outgoing messages in ARGB format
func NewThemeSettings(accentColor int32, background *Background, outgoingMessageFill BackgroundFill, animateOutgoingMessageFill bool, outgoingMessageAccentColor int32) *ThemeSettings {
	themeSettingsTemp := ThemeSettings{
		tdCommon:                   tdCommon{Type: "themeSettings"},
		AccentColor:                accentColor,
		Background:                 background,
		OutgoingMessageFill:        outgoingMessageFill,
		AnimateOutgoingMessageFill: animateOutgoingMessageFill,
		OutgoingMessageAccentColor: outgoingMessageAccentColor,
	}

	return &themeSettingsTemp
}

// UnmarshalJSON unmarshal to json
func (themeSettings *ThemeSettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		AccentColor                int32 `json:"accent_color"`                  // Theme accent color in ARGB format
		AnimateOutgoingMessageFill bool  `json:"animate_outgoing_message_fill"` // If true, the freeform gradient fill needs to be animated on every sent message
		OutgoingMessageAccentColor int32 `json:"outgoing_message_accent_color"` // Accent color of outgoing messages in ARGB format
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	themeSettings.tdCommon = tempObj.tdCommon
	themeSettings.AccentColor = tempObj.AccentColor
	themeSettings.AnimateOutgoingMessageFill = tempObj.AnimateOutgoingMessageFill
	themeSettings.OutgoingMessageAccentColor = tempObj.OutgoingMessageAccentColor

	fieldOutgoingMessageFill, _ := unmarshalBackgroundFill(objMap["outgoing_message_fill"])
	themeSettings.OutgoingMessageFill = fieldOutgoingMessageFill

	var background Background
	if objMap["background"] != nil {
		err = background.UnmarshalJSON(*objMap["background"])
		if err != nil {
			return err
		}
	}

	themeSettings.Background = &background

	return nil
}

// RichTextPlain A plain text
type RichTextPlain struct {
	tdCommon
	Text string `json:"text"` // Text
}

// MessageType return the string telegram-type of RichTextPlain
func (richTextPlain *RichTextPlain) MessageType() string {
	return "richTextPlain"
}

// NewRichTextPlain creates a new RichTextPlain
//
// @param text Text
func NewRichTextPlain(text string) *RichTextPlain {
	richTextPlainTemp := RichTextPlain{
		tdCommon: tdCommon{Type: "richTextPlain"},
		Text:     text,
	}

	return &richTextPlainTemp
}

// UnmarshalJSON unmarshal to json
func (richTextPlain *RichTextPlain) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Text string `json:"text"` // Text
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	richTextPlain.tdCommon = tempObj.tdCommon
	richTextPlain.Text = tempObj.Text

	return nil
}

// GetRichTextEnum return the enum type of this object
func (richTextPlain *RichTextPlain) GetRichTextEnum() RichTextEnum {
	return RichTextPlainType
}

// RichTextBold A bold rich text
type RichTextBold struct {
	tdCommon
	Text RichText `json:"text"` // Text
}

// MessageType return the string telegram-type of RichTextBold
func (richTextBold *RichTextBold) MessageType() string {
	return "richTextBold"
}

// NewRichTextBold creates a new RichTextBold
//
// @param text Text
func NewRichTextBold(text RichText) *RichTextBold {
	richTextBoldTemp := RichTextBold{
		tdCommon: tdCommon{Type: "richTextBold"},
		Text:     text,
	}

	return &richTextBoldTemp
}

// UnmarshalJSON unmarshal to json
func (richTextBold *RichTextBold) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	richTextBold.tdCommon = tempObj.tdCommon

	fieldText, _ := unmarshalRichText(objMap["text"])
	richTextBold.Text = fieldText

	return nil
}

// GetRichTextEnum return the enum type of this object
func (richTextBold *RichTextBold) GetRichTextEnum() RichTextEnum {
	return RichTextBoldType
}

// RichTextItalic An italicized rich text
type RichTextItalic struct {
	tdCommon
	Text RichText `json:"text"` // Text
}

// MessageType return the string telegram-type of RichTextItalic
func (richTextItalic *RichTextItalic) MessageType() string {
	return "richTextItalic"
}

// NewRichTextItalic creates a new RichTextItalic
//
// @param text Text
func NewRichTextItalic(text RichText) *RichTextItalic {
	richTextItalicTemp := RichTextItalic{
		tdCommon: tdCommon{Type: "richTextItalic"},
		Text:     text,
	}

	return &richTextItalicTemp
}

// UnmarshalJSON unmarshal to json
func (richTextItalic *RichTextItalic) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	richTextItalic.tdCommon = tempObj.tdCommon

	fieldText, _ := unmarshalRichText(objMap["text"])
	richTextItalic.Text = fieldText

	return nil
}

// GetRichTextEnum return the enum type of this object
func (richTextItalic *RichTextItalic) GetRichTextEnum() RichTextEnum {
	return RichTextItalicType
}

// RichTextUnderline An underlined rich text
type RichTextUnderline struct {
	tdCommon
	Text RichText `json:"text"` // Text
}

// MessageType return the string telegram-type of RichTextUnderline
func (richTextUnderline *RichTextUnderline) MessageType() string {
	return "richTextUnderline"
}

// NewRichTextUnderline creates a new RichTextUnderline
//
// @param text Text
func NewRichTextUnderline(text RichText) *RichTextUnderline {
	richTextUnderlineTemp := RichTextUnderline{
		tdCommon: tdCommon{Type: "richTextUnderline"},
		Text:     text,
	}

	return &richTextUnderlineTemp
}

// UnmarshalJSON unmarshal to json
func (richTextUnderline *RichTextUnderline) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	richTextUnderline.tdCommon = tempObj.tdCommon

	fieldText, _ := unmarshalRichText(objMap["text"])
	richTextUnderline.Text = fieldText

	return nil
}

// GetRichTextEnum return the enum type of this object
func (richTextUnderline *RichTextUnderline) GetRichTextEnum() RichTextEnum {
	return RichTextUnderlineType
}

// RichTextStrikethrough A strikethrough rich text
type RichTextStrikethrough struct {
	tdCommon
	Text RichText `json:"text"` // Text
}

// MessageType return the string telegram-type of RichTextStrikethrough
func (richTextStrikethrough *RichTextStrikethrough) MessageType() string {
	return "richTextStrikethrough"
}

// NewRichTextStrikethrough creates a new RichTextStrikethrough
//
// @param text Text
func NewRichTextStrikethrough(text RichText) *RichTextStrikethrough {
	richTextStrikethroughTemp := RichTextStrikethrough{
		tdCommon: tdCommon{Type: "richTextStrikethrough"},
		Text:     text,
	}

	return &richTextStrikethroughTemp
}

// UnmarshalJSON unmarshal to json
func (richTextStrikethrough *RichTextStrikethrough) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	richTextStrikethrough.tdCommon = tempObj.tdCommon

	fieldText, _ := unmarshalRichText(objMap["text"])
	richTextStrikethrough.Text = fieldText

	return nil
}

// GetRichTextEnum return the enum type of this object
func (richTextStrikethrough *RichTextStrikethrough) GetRichTextEnum() RichTextEnum {
	return RichTextStrikethroughType
}

// RichTextFixed A fixed-width rich text
type RichTextFixed struct {
	tdCommon
	Text RichText `json:"text"` // Text
}

// MessageType return the string telegram-type of RichTextFixed
func (richTextFixed *RichTextFixed) MessageType() string {
	return "richTextFixed"
}

// NewRichTextFixed creates a new RichTextFixed
//
// @param text Text
func NewRichTextFixed(text RichText) *RichTextFixed {
	richTextFixedTemp := RichTextFixed{
		tdCommon: tdCommon{Type: "richTextFixed"},
		Text:     text,
	}

	return &richTextFixedTemp
}

// UnmarshalJSON unmarshal to json
func (richTextFixed *RichTextFixed) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	richTextFixed.tdCommon = tempObj.tdCommon

	fieldText, _ := unmarshalRichText(objMap["text"])
	richTextFixed.Text = fieldText

	return nil
}

// GetRichTextEnum return the enum type of this object
func (richTextFixed *RichTextFixed) GetRichTextEnum() RichTextEnum {
	return RichTextFixedType
}

// RichTextURL A rich text URL link
type RichTextURL struct {
	tdCommon
	Text     RichText `json:"text"`      // Text
	URL      string   `json:"url"`       // URL
	IsCached bool     `json:"is_cached"` // True, if the URL has cached instant view server-side
}

// MessageType return the string telegram-type of RichTextURL
func (richTextURL *RichTextURL) MessageType() string {
	return "richTextUrl"
}

// NewRichTextURL creates a new RichTextURL
//
// @param text Text
// @param uRL URL
// @param isCached True, if the URL has cached instant view server-side
func NewRichTextURL(text RichText, uRL string, isCached bool) *RichTextURL {
	richTextURLTemp := RichTextURL{
		tdCommon: tdCommon{Type: "richTextUrl"},
		Text:     text,
		URL:      uRL,
		IsCached: isCached,
	}

	return &richTextURLTemp
}

// UnmarshalJSON unmarshal to json
func (richTextURL *RichTextURL) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL      string `json:"url"`       // URL
		IsCached bool   `json:"is_cached"` // True, if the URL has cached instant view server-side
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	richTextURL.tdCommon = tempObj.tdCommon
	richTextURL.URL = tempObj.URL
	richTextURL.IsCached = tempObj.IsCached

	fieldText, _ := unmarshalRichText(objMap["text"])
	richTextURL.Text = fieldText

	return nil
}

// GetRichTextEnum return the enum type of this object
func (richTextURL *RichTextURL) GetRichTextEnum() RichTextEnum {
	return RichTextURLType
}

// RichTextEmailAddress A rich text email link
type RichTextEmailAddress struct {
	tdCommon
	Text         RichText `json:"text"`          // Text
	EmailAddress string   `json:"email_address"` // Email address
}

// MessageType return the string telegram-type of RichTextEmailAddress
func (richTextEmailAddress *RichTextEmailAddress) MessageType() string {
	return "richTextEmailAddress"
}

// NewRichTextEmailAddress creates a new RichTextEmailAddress
//
// @param text Text
// @param emailAddress Email address
func NewRichTextEmailAddress(text RichText, emailAddress string) *RichTextEmailAddress {
	richTextEmailAddressTemp := RichTextEmailAddress{
		tdCommon:     tdCommon{Type: "richTextEmailAddress"},
		Text:         text,
		EmailAddress: emailAddress,
	}

	return &richTextEmailAddressTemp
}

// UnmarshalJSON unmarshal to json
func (richTextEmailAddress *RichTextEmailAddress) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		EmailAddress string `json:"email_address"` // Email address
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	richTextEmailAddress.tdCommon = tempObj.tdCommon
	richTextEmailAddress.EmailAddress = tempObj.EmailAddress

	fieldText, _ := unmarshalRichText(objMap["text"])
	richTextEmailAddress.Text = fieldText

	return nil
}

// GetRichTextEnum return the enum type of this object
func (richTextEmailAddress *RichTextEmailAddress) GetRichTextEnum() RichTextEnum {
	return RichTextEmailAddressType
}

// RichTextSubscript A subscript rich text
type RichTextSubscript struct {
	tdCommon
	Text RichText `json:"text"` // Text
}

// MessageType return the string telegram-type of RichTextSubscript
func (richTextSubscript *RichTextSubscript) MessageType() string {
	return "richTextSubscript"
}

// NewRichTextSubscript creates a new RichTextSubscript
//
// @param text Text
func NewRichTextSubscript(text RichText) *RichTextSubscript {
	richTextSubscriptTemp := RichTextSubscript{
		tdCommon: tdCommon{Type: "richTextSubscript"},
		Text:     text,
	}

	return &richTextSubscriptTemp
}

// UnmarshalJSON unmarshal to json
func (richTextSubscript *RichTextSubscript) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	richTextSubscript.tdCommon = tempObj.tdCommon

	fieldText, _ := unmarshalRichText(objMap["text"])
	richTextSubscript.Text = fieldText

	return nil
}

// GetRichTextEnum return the enum type of this object
func (richTextSubscript *RichTextSubscript) GetRichTextEnum() RichTextEnum {
	return RichTextSubscriptType
}

// RichTextSuperscript A superscript rich text
type RichTextSuperscript struct {
	tdCommon
	Text RichText `json:"text"` // Text
}

// MessageType return the string telegram-type of RichTextSuperscript
func (richTextSuperscript *RichTextSuperscript) MessageType() string {
	return "richTextSuperscript"
}

// NewRichTextSuperscript creates a new RichTextSuperscript
//
// @param text Text
func NewRichTextSuperscript(text RichText) *RichTextSuperscript {
	richTextSuperscriptTemp := RichTextSuperscript{
		tdCommon: tdCommon{Type: "richTextSuperscript"},
		Text:     text,
	}

	return &richTextSuperscriptTemp
}

// UnmarshalJSON unmarshal to json
func (richTextSuperscript *RichTextSuperscript) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	richTextSuperscript.tdCommon = tempObj.tdCommon

	fieldText, _ := unmarshalRichText(objMap["text"])
	richTextSuperscript.Text = fieldText

	return nil
}

// GetRichTextEnum return the enum type of this object
func (richTextSuperscript *RichTextSuperscript) GetRichTextEnum() RichTextEnum {
	return RichTextSuperscriptType
}

// RichTextMarked A marked rich text
type RichTextMarked struct {
	tdCommon
	Text RichText `json:"text"` // Text
}

// MessageType return the string telegram-type of RichTextMarked
func (richTextMarked *RichTextMarked) MessageType() string {
	return "richTextMarked"
}

// NewRichTextMarked creates a new RichTextMarked
//
// @param text Text
func NewRichTextMarked(text RichText) *RichTextMarked {
	richTextMarkedTemp := RichTextMarked{
		tdCommon: tdCommon{Type: "richTextMarked"},
		Text:     text,
	}

	return &richTextMarkedTemp
}

// UnmarshalJSON unmarshal to json
func (richTextMarked *RichTextMarked) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	richTextMarked.tdCommon = tempObj.tdCommon

	fieldText, _ := unmarshalRichText(objMap["text"])
	richTextMarked.Text = fieldText

	return nil
}

// GetRichTextEnum return the enum type of this object
func (richTextMarked *RichTextMarked) GetRichTextEnum() RichTextEnum {
	return RichTextMarkedType
}

// RichTextPhoneNumber A rich text phone number
type RichTextPhoneNumber struct {
	tdCommon
	Text        RichText `json:"text"`         // Text
	PhoneNumber string   `json:"phone_number"` // Phone number
}

// MessageType return the string telegram-type of RichTextPhoneNumber
func (richTextPhoneNumber *RichTextPhoneNumber) MessageType() string {
	return "richTextPhoneNumber"
}

// NewRichTextPhoneNumber creates a new RichTextPhoneNumber
//
// @param text Text
// @param phoneNumber Phone number
func NewRichTextPhoneNumber(text RichText, phoneNumber string) *RichTextPhoneNumber {
	richTextPhoneNumberTemp := RichTextPhoneNumber{
		tdCommon:    tdCommon{Type: "richTextPhoneNumber"},
		Text:        text,
		PhoneNumber: phoneNumber,
	}

	return &richTextPhoneNumberTemp
}

// UnmarshalJSON unmarshal to json
func (richTextPhoneNumber *RichTextPhoneNumber) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PhoneNumber string `json:"phone_number"` // Phone number
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	richTextPhoneNumber.tdCommon = tempObj.tdCommon
	richTextPhoneNumber.PhoneNumber = tempObj.PhoneNumber

	fieldText, _ := unmarshalRichText(objMap["text"])
	richTextPhoneNumber.Text = fieldText

	return nil
}

// GetRichTextEnum return the enum type of this object
func (richTextPhoneNumber *RichTextPhoneNumber) GetRichTextEnum() RichTextEnum {
	return RichTextPhoneNumberType
}

// RichTextIcon A small image inside the text
type RichTextIcon struct {
	tdCommon
	Document *Document `json:"document"` // The image represented as a document. The image can be in GIF, JPEG or PNG format
	Width    int32     `json:"width"`    // Width of a bounding box in which the image must be shown; 0 if unknown
	Height   int32     `json:"height"`   // Height of a bounding box in which the image must be shown; 0 if unknown
}

// MessageType return the string telegram-type of RichTextIcon
func (richTextIcon *RichTextIcon) MessageType() string {
	return "richTextIcon"
}

// NewRichTextIcon creates a new RichTextIcon
//
// @param document The image represented as a document. The image can be in GIF, JPEG or PNG format
// @param width Width of a bounding box in which the image must be shown; 0 if unknown
// @param height Height of a bounding box in which the image must be shown; 0 if unknown
func NewRichTextIcon(document *Document, width int32, height int32) *RichTextIcon {
	richTextIconTemp := RichTextIcon{
		tdCommon: tdCommon{Type: "richTextIcon"},
		Document: document,
		Width:    width,
		Height:   height,
	}

	return &richTextIconTemp
}

// UnmarshalJSON unmarshal to json
func (richTextIcon *RichTextIcon) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Document *Document `json:"document"` // The image represented as a document. The image can be in GIF, JPEG or PNG format
		Width    int32     `json:"width"`    // Width of a bounding box in which the image must be shown; 0 if unknown
		Height   int32     `json:"height"`   // Height of a bounding box in which the image must be shown; 0 if unknown
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	richTextIcon.tdCommon = tempObj.tdCommon
	richTextIcon.Document = tempObj.Document
	richTextIcon.Width = tempObj.Width
	richTextIcon.Height = tempObj.Height

	return nil
}

// GetRichTextEnum return the enum type of this object
func (richTextIcon *RichTextIcon) GetRichTextEnum() RichTextEnum {
	return RichTextIconType
}

// RichTextReference A reference to a richTexts object on the same page
type RichTextReference struct {
	tdCommon
	Text       RichText `json:"text"`        // The text
	AnchorName string   `json:"anchor_name"` // The name of a richTextAnchor object, which is the first element of the target richTexts object
	URL        string   `json:"url"`         // An HTTP URL, opening the reference
}

// MessageType return the string telegram-type of RichTextReference
func (richTextReference *RichTextReference) MessageType() string {
	return "richTextReference"
}

// NewRichTextReference creates a new RichTextReference
//
// @param text The text
// @param anchorName The name of a richTextAnchor object, which is the first element of the target richTexts object
// @param uRL An HTTP URL, opening the reference
func NewRichTextReference(text RichText, anchorName string, uRL string) *RichTextReference {
	richTextReferenceTemp := RichTextReference{
		tdCommon:   tdCommon{Type: "richTextReference"},
		Text:       text,
		AnchorName: anchorName,
		URL:        uRL,
	}

	return &richTextReferenceTemp
}

// UnmarshalJSON unmarshal to json
func (richTextReference *RichTextReference) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		AnchorName string `json:"anchor_name"` // The name of a richTextAnchor object, which is the first element of the target richTexts object
		URL        string `json:"url"`         // An HTTP URL, opening the reference
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	richTextReference.tdCommon = tempObj.tdCommon
	richTextReference.AnchorName = tempObj.AnchorName
	richTextReference.URL = tempObj.URL

	fieldText, _ := unmarshalRichText(objMap["text"])
	richTextReference.Text = fieldText

	return nil
}

// GetRichTextEnum return the enum type of this object
func (richTextReference *RichTextReference) GetRichTextEnum() RichTextEnum {
	return RichTextReferenceType
}

// RichTextAnchor An anchor
type RichTextAnchor struct {
	tdCommon
	Name string `json:"name"` // Anchor name
}

// MessageType return the string telegram-type of RichTextAnchor
func (richTextAnchor *RichTextAnchor) MessageType() string {
	return "richTextAnchor"
}

// NewRichTextAnchor creates a new RichTextAnchor
//
// @param name Anchor name
func NewRichTextAnchor(name string) *RichTextAnchor {
	richTextAnchorTemp := RichTextAnchor{
		tdCommon: tdCommon{Type: "richTextAnchor"},
		Name:     name,
	}

	return &richTextAnchorTemp
}

// UnmarshalJSON unmarshal to json
func (richTextAnchor *RichTextAnchor) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Name string `json:"name"` // Anchor name
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	richTextAnchor.tdCommon = tempObj.tdCommon
	richTextAnchor.Name = tempObj.Name

	return nil
}

// GetRichTextEnum return the enum type of this object
func (richTextAnchor *RichTextAnchor) GetRichTextEnum() RichTextEnum {
	return RichTextAnchorType
}

// RichTextAnchorLink A link to an anchor on the same page
type RichTextAnchorLink struct {
	tdCommon
	Text       RichText `json:"text"`        // The link text
	AnchorName string   `json:"anchor_name"` // The anchor name. If the name is empty, the link must bring back to top
	URL        string   `json:"url"`         // An HTTP URL, opening the anchor
}

// MessageType return the string telegram-type of RichTextAnchorLink
func (richTextAnchorLink *RichTextAnchorLink) MessageType() string {
	return "richTextAnchorLink"
}

// NewRichTextAnchorLink creates a new RichTextAnchorLink
//
// @param text The link text
// @param anchorName The anchor name. If the name is empty, the link must bring back to top
// @param uRL An HTTP URL, opening the anchor
func NewRichTextAnchorLink(text RichText, anchorName string, uRL string) *RichTextAnchorLink {
	richTextAnchorLinkTemp := RichTextAnchorLink{
		tdCommon:   tdCommon{Type: "richTextAnchorLink"},
		Text:       text,
		AnchorName: anchorName,
		URL:        uRL,
	}

	return &richTextAnchorLinkTemp
}

// UnmarshalJSON unmarshal to json
func (richTextAnchorLink *RichTextAnchorLink) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		AnchorName string `json:"anchor_name"` // The anchor name. If the name is empty, the link must bring back to top
		URL        string `json:"url"`         // An HTTP URL, opening the anchor
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	richTextAnchorLink.tdCommon = tempObj.tdCommon
	richTextAnchorLink.AnchorName = tempObj.AnchorName
	richTextAnchorLink.URL = tempObj.URL

	fieldText, _ := unmarshalRichText(objMap["text"])
	richTextAnchorLink.Text = fieldText

	return nil
}

// GetRichTextEnum return the enum type of this object
func (richTextAnchorLink *RichTextAnchorLink) GetRichTextEnum() RichTextEnum {
	return RichTextAnchorLinkType
}

// RichTexts A concatenation of rich texts
type RichTexts struct {
	tdCommon
	Texts []RichText `json:"texts"` // Texts
}

// MessageType return the string telegram-type of RichTexts
func (richTexts *RichTexts) MessageType() string {
	return "richTexts"
}

// NewRichTexts creates a new RichTexts
//
// @param texts Texts
func NewRichTexts(texts []RichText) *RichTexts {
	richTextsTemp := RichTexts{
		tdCommon: tdCommon{Type: "richTexts"},
		Texts:    texts,
	}

	return &richTextsTemp
}

// UnmarshalJSON unmarshal to json
func (richTexts *RichTexts) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	richTexts.tdCommon = tempObj.tdCommon

	fieldTexts, _ := unmarshalRichTextSlice(objMap["texts"])
	richTexts.Texts = fieldTexts

	return nil
}

// GetRichTextEnum return the enum type of this object
func (richTexts *RichTexts) GetRichTextEnum() RichTextEnum {
	return RichTextsType
}

// PageBlockCaption Contains a caption of another block
type PageBlockCaption struct {
	tdCommon
	Text   RichText `json:"text"`   // Content of the caption
	Credit RichText `json:"credit"` // Block credit (like HTML tag <cite>)
}

// MessageType return the string telegram-type of PageBlockCaption
func (pageBlockCaption *PageBlockCaption) MessageType() string {
	return "pageBlockCaption"
}

// NewPageBlockCaption creates a new PageBlockCaption
//
// @param text Content of the caption
// @param credit Block credit (like HTML tag <cite>)
func NewPageBlockCaption(text RichText, credit RichText) *PageBlockCaption {
	pageBlockCaptionTemp := PageBlockCaption{
		tdCommon: tdCommon{Type: "pageBlockCaption"},
		Text:     text,
		Credit:   credit,
	}

	return &pageBlockCaptionTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockCaption *PageBlockCaption) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockCaption.tdCommon = tempObj.tdCommon

	fieldText, _ := unmarshalRichText(objMap["text"])
	pageBlockCaption.Text = fieldText

	fieldCredit, _ := unmarshalRichText(objMap["credit"])
	pageBlockCaption.Credit = fieldCredit

	return nil
}

// PageBlockListItem Describes an item of a list page block
type PageBlockListItem struct {
	tdCommon
	Label      string      `json:"label"`       // Item label
	PageBlocks []PageBlock `json:"page_blocks"` // Item blocks
}

// MessageType return the string telegram-type of PageBlockListItem
func (pageBlockListItem *PageBlockListItem) MessageType() string {
	return "pageBlockListItem"
}

// NewPageBlockListItem creates a new PageBlockListItem
//
// @param label Item label
// @param pageBlocks Item blocks
func NewPageBlockListItem(label string, pageBlocks []PageBlock) *PageBlockListItem {
	pageBlockListItemTemp := PageBlockListItem{
		tdCommon:   tdCommon{Type: "pageBlockListItem"},
		Label:      label,
		PageBlocks: pageBlocks,
	}

	return &pageBlockListItemTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockListItem *PageBlockListItem) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Label string `json:"label"` // Item label

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockListItem.tdCommon = tempObj.tdCommon
	pageBlockListItem.Label = tempObj.Label

	fieldPageBlocks, _ := unmarshalPageBlockSlice(objMap["page_blocks"])
	pageBlockListItem.PageBlocks = fieldPageBlocks

	return nil
}

// PageBlockHorizontalAlignmentLeft The content must be left-aligned
type PageBlockHorizontalAlignmentLeft struct {
	tdCommon
}

// MessageType return the string telegram-type of PageBlockHorizontalAlignmentLeft
func (pageBlockHorizontalAlignmentLeft *PageBlockHorizontalAlignmentLeft) MessageType() string {
	return "pageBlockHorizontalAlignmentLeft"
}

// NewPageBlockHorizontalAlignmentLeft creates a new PageBlockHorizontalAlignmentLeft
//
func NewPageBlockHorizontalAlignmentLeft() *PageBlockHorizontalAlignmentLeft {
	pageBlockHorizontalAlignmentLeftTemp := PageBlockHorizontalAlignmentLeft{
		tdCommon: tdCommon{Type: "pageBlockHorizontalAlignmentLeft"},
	}

	return &pageBlockHorizontalAlignmentLeftTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockHorizontalAlignmentLeft *PageBlockHorizontalAlignmentLeft) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockHorizontalAlignmentLeft.tdCommon = tempObj.tdCommon

	return nil
}

// GetPageBlockHorizontalAlignmentEnum return the enum type of this object
func (pageBlockHorizontalAlignmentLeft *PageBlockHorizontalAlignmentLeft) GetPageBlockHorizontalAlignmentEnum() PageBlockHorizontalAlignmentEnum {
	return PageBlockHorizontalAlignmentLeftType
}

// PageBlockHorizontalAlignmentCenter The content must be center-aligned
type PageBlockHorizontalAlignmentCenter struct {
	tdCommon
}

// MessageType return the string telegram-type of PageBlockHorizontalAlignmentCenter
func (pageBlockHorizontalAlignmentCenter *PageBlockHorizontalAlignmentCenter) MessageType() string {
	return "pageBlockHorizontalAlignmentCenter"
}

// NewPageBlockHorizontalAlignmentCenter creates a new PageBlockHorizontalAlignmentCenter
//
func NewPageBlockHorizontalAlignmentCenter() *PageBlockHorizontalAlignmentCenter {
	pageBlockHorizontalAlignmentCenterTemp := PageBlockHorizontalAlignmentCenter{
		tdCommon: tdCommon{Type: "pageBlockHorizontalAlignmentCenter"},
	}

	return &pageBlockHorizontalAlignmentCenterTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockHorizontalAlignmentCenter *PageBlockHorizontalAlignmentCenter) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockHorizontalAlignmentCenter.tdCommon = tempObj.tdCommon

	return nil
}

// GetPageBlockHorizontalAlignmentEnum return the enum type of this object
func (pageBlockHorizontalAlignmentCenter *PageBlockHorizontalAlignmentCenter) GetPageBlockHorizontalAlignmentEnum() PageBlockHorizontalAlignmentEnum {
	return PageBlockHorizontalAlignmentCenterType
}

// PageBlockHorizontalAlignmentRight The content must be right-aligned
type PageBlockHorizontalAlignmentRight struct {
	tdCommon
}

// MessageType return the string telegram-type of PageBlockHorizontalAlignmentRight
func (pageBlockHorizontalAlignmentRight *PageBlockHorizontalAlignmentRight) MessageType() string {
	return "pageBlockHorizontalAlignmentRight"
}

// NewPageBlockHorizontalAlignmentRight creates a new PageBlockHorizontalAlignmentRight
//
func NewPageBlockHorizontalAlignmentRight() *PageBlockHorizontalAlignmentRight {
	pageBlockHorizontalAlignmentRightTemp := PageBlockHorizontalAlignmentRight{
		tdCommon: tdCommon{Type: "pageBlockHorizontalAlignmentRight"},
	}

	return &pageBlockHorizontalAlignmentRightTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockHorizontalAlignmentRight *PageBlockHorizontalAlignmentRight) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockHorizontalAlignmentRight.tdCommon = tempObj.tdCommon

	return nil
}

// GetPageBlockHorizontalAlignmentEnum return the enum type of this object
func (pageBlockHorizontalAlignmentRight *PageBlockHorizontalAlignmentRight) GetPageBlockHorizontalAlignmentEnum() PageBlockHorizontalAlignmentEnum {
	return PageBlockHorizontalAlignmentRightType
}

// PageBlockVerticalAlignmentTop The content must be top-aligned
type PageBlockVerticalAlignmentTop struct {
	tdCommon
}

// MessageType return the string telegram-type of PageBlockVerticalAlignmentTop
func (pageBlockVerticalAlignmentTop *PageBlockVerticalAlignmentTop) MessageType() string {
	return "pageBlockVerticalAlignmentTop"
}

// NewPageBlockVerticalAlignmentTop creates a new PageBlockVerticalAlignmentTop
//
func NewPageBlockVerticalAlignmentTop() *PageBlockVerticalAlignmentTop {
	pageBlockVerticalAlignmentTopTemp := PageBlockVerticalAlignmentTop{
		tdCommon: tdCommon{Type: "pageBlockVerticalAlignmentTop"},
	}

	return &pageBlockVerticalAlignmentTopTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockVerticalAlignmentTop *PageBlockVerticalAlignmentTop) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockVerticalAlignmentTop.tdCommon = tempObj.tdCommon

	return nil
}

// GetPageBlockVerticalAlignmentEnum return the enum type of this object
func (pageBlockVerticalAlignmentTop *PageBlockVerticalAlignmentTop) GetPageBlockVerticalAlignmentEnum() PageBlockVerticalAlignmentEnum {
	return PageBlockVerticalAlignmentTopType
}

// PageBlockVerticalAlignmentMiddle The content must be middle-aligned
type PageBlockVerticalAlignmentMiddle struct {
	tdCommon
}

// MessageType return the string telegram-type of PageBlockVerticalAlignmentMiddle
func (pageBlockVerticalAlignmentMiddle *PageBlockVerticalAlignmentMiddle) MessageType() string {
	return "pageBlockVerticalAlignmentMiddle"
}

// NewPageBlockVerticalAlignmentMiddle creates a new PageBlockVerticalAlignmentMiddle
//
func NewPageBlockVerticalAlignmentMiddle() *PageBlockVerticalAlignmentMiddle {
	pageBlockVerticalAlignmentMiddleTemp := PageBlockVerticalAlignmentMiddle{
		tdCommon: tdCommon{Type: "pageBlockVerticalAlignmentMiddle"},
	}

	return &pageBlockVerticalAlignmentMiddleTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockVerticalAlignmentMiddle *PageBlockVerticalAlignmentMiddle) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockVerticalAlignmentMiddle.tdCommon = tempObj.tdCommon

	return nil
}

// GetPageBlockVerticalAlignmentEnum return the enum type of this object
func (pageBlockVerticalAlignmentMiddle *PageBlockVerticalAlignmentMiddle) GetPageBlockVerticalAlignmentEnum() PageBlockVerticalAlignmentEnum {
	return PageBlockVerticalAlignmentMiddleType
}

// PageBlockVerticalAlignmentBottom The content must be bottom-aligned
type PageBlockVerticalAlignmentBottom struct {
	tdCommon
}

// MessageType return the string telegram-type of PageBlockVerticalAlignmentBottom
func (pageBlockVerticalAlignmentBottom *PageBlockVerticalAlignmentBottom) MessageType() string {
	return "pageBlockVerticalAlignmentBottom"
}

// NewPageBlockVerticalAlignmentBottom creates a new PageBlockVerticalAlignmentBottom
//
func NewPageBlockVerticalAlignmentBottom() *PageBlockVerticalAlignmentBottom {
	pageBlockVerticalAlignmentBottomTemp := PageBlockVerticalAlignmentBottom{
		tdCommon: tdCommon{Type: "pageBlockVerticalAlignmentBottom"},
	}

	return &pageBlockVerticalAlignmentBottomTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockVerticalAlignmentBottom *PageBlockVerticalAlignmentBottom) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockVerticalAlignmentBottom.tdCommon = tempObj.tdCommon

	return nil
}

// GetPageBlockVerticalAlignmentEnum return the enum type of this object
func (pageBlockVerticalAlignmentBottom *PageBlockVerticalAlignmentBottom) GetPageBlockVerticalAlignmentEnum() PageBlockVerticalAlignmentEnum {
	return PageBlockVerticalAlignmentBottomType
}

// PageBlockTableCell Represents a cell of a table
type PageBlockTableCell struct {
	tdCommon
	Text     *RichText                    `json:"text"`      // Cell text; may be null. If the text is null, then the cell must be invisible
	IsHeader bool                         `json:"is_header"` // True, if it is a header cell
	Colspan  int32                        `json:"colspan"`   // The number of columns the cell spans
	Rowspan  int32                        `json:"rowspan"`   // The number of rows the cell spans
	Align    PageBlockHorizontalAlignment `json:"align"`     // Horizontal cell content alignment
	Valign   PageBlockVerticalAlignment   `json:"valign"`    // Vertical cell content alignment
}

// MessageType return the string telegram-type of PageBlockTableCell
func (pageBlockTableCell *PageBlockTableCell) MessageType() string {
	return "pageBlockTableCell"
}

// NewPageBlockTableCell creates a new PageBlockTableCell
//
// @param text Cell text; may be null. If the text is null, then the cell must be invisible
// @param isHeader True, if it is a header cell
// @param colspan The number of columns the cell spans
// @param rowspan The number of rows the cell spans
// @param align Horizontal cell content alignment
// @param valign Vertical cell content alignment
func NewPageBlockTableCell(text *RichText, isHeader bool, colspan int32, rowspan int32, align PageBlockHorizontalAlignment, valign PageBlockVerticalAlignment) *PageBlockTableCell {
	pageBlockTableCellTemp := PageBlockTableCell{
		tdCommon: tdCommon{Type: "pageBlockTableCell"},
		Text:     text,
		IsHeader: isHeader,
		Colspan:  colspan,
		Rowspan:  rowspan,
		Align:    align,
		Valign:   valign,
	}

	return &pageBlockTableCellTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockTableCell *PageBlockTableCell) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsHeader bool  `json:"is_header"` // True, if it is a header cell
		Colspan  int32 `json:"colspan"`   // The number of columns the cell spans
		Rowspan  int32 `json:"rowspan"`   // The number of rows the cell spans

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockTableCell.tdCommon = tempObj.tdCommon
	pageBlockTableCell.IsHeader = tempObj.IsHeader
	pageBlockTableCell.Colspan = tempObj.Colspan
	pageBlockTableCell.Rowspan = tempObj.Rowspan

	fieldText, _ := unmarshalRichText(objMap["text"])
	pageBlockTableCell.Text = &fieldText

	fieldAlign, _ := unmarshalPageBlockHorizontalAlignment(objMap["align"])
	pageBlockTableCell.Align = fieldAlign

	fieldValign, _ := unmarshalPageBlockVerticalAlignment(objMap["valign"])
	pageBlockTableCell.Valign = fieldValign

	return nil
}

// PageBlockRelatedArticle Contains information about a related article
type PageBlockRelatedArticle struct {
	tdCommon
	URL         string `json:"url"`          // Related article URL
	Title       string `json:"title"`        // Article title; may be empty
	Description string `json:"description"`  // Article description; may be empty
	Photo       *Photo `json:"photo"`        // Article photo; may be null
	Author      string `json:"author"`       // Article author; may be empty
	PublishDate int32  `json:"publish_date"` // Point in time (Unix timestamp) when the article was published; 0 if unknown
}

// MessageType return the string telegram-type of PageBlockRelatedArticle
func (pageBlockRelatedArticle *PageBlockRelatedArticle) MessageType() string {
	return "pageBlockRelatedArticle"
}

// NewPageBlockRelatedArticle creates a new PageBlockRelatedArticle
//
// @param uRL Related article URL
// @param title Article title; may be empty
// @param description Article description; may be empty
// @param photo Article photo; may be null
// @param author Article author; may be empty
// @param publishDate Point in time (Unix timestamp) when the article was published; 0 if unknown
func NewPageBlockRelatedArticle(uRL string, title string, description string, photo *Photo, author string, publishDate int32) *PageBlockRelatedArticle {
	pageBlockRelatedArticleTemp := PageBlockRelatedArticle{
		tdCommon:    tdCommon{Type: "pageBlockRelatedArticle"},
		URL:         uRL,
		Title:       title,
		Description: description,
		Photo:       photo,
		Author:      author,
		PublishDate: publishDate,
	}

	return &pageBlockRelatedArticleTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockRelatedArticle *PageBlockRelatedArticle) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL         string `json:"url"`          // Related article URL
		Title       string `json:"title"`        // Article title; may be empty
		Description string `json:"description"`  // Article description; may be empty
		Photo       *Photo `json:"photo"`        // Article photo; may be null
		Author      string `json:"author"`       // Article author; may be empty
		PublishDate int32  `json:"publish_date"` // Point in time (Unix timestamp) when the article was published; 0 if unknown
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockRelatedArticle.tdCommon = tempObj.tdCommon
	pageBlockRelatedArticle.URL = tempObj.URL
	pageBlockRelatedArticle.Title = tempObj.Title
	pageBlockRelatedArticle.Description = tempObj.Description
	pageBlockRelatedArticle.Photo = tempObj.Photo
	pageBlockRelatedArticle.Author = tempObj.Author
	pageBlockRelatedArticle.PublishDate = tempObj.PublishDate

	return nil
}

// PageBlockTitle The title of a page
type PageBlockTitle struct {
	tdCommon
	Title RichText `json:"title"` // Title
}

// MessageType return the string telegram-type of PageBlockTitle
func (pageBlockTitle *PageBlockTitle) MessageType() string {
	return "pageBlockTitle"
}

// NewPageBlockTitle creates a new PageBlockTitle
//
// @param title Title
func NewPageBlockTitle(title RichText) *PageBlockTitle {
	pageBlockTitleTemp := PageBlockTitle{
		tdCommon: tdCommon{Type: "pageBlockTitle"},
		Title:    title,
	}

	return &pageBlockTitleTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockTitle *PageBlockTitle) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockTitle.tdCommon = tempObj.tdCommon

	fieldTitle, _ := unmarshalRichText(objMap["title"])
	pageBlockTitle.Title = fieldTitle

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockTitle *PageBlockTitle) GetPageBlockEnum() PageBlockEnum {
	return PageBlockTitleType
}

// PageBlockSubtitle The subtitle of a page
type PageBlockSubtitle struct {
	tdCommon
	Subtitle RichText `json:"subtitle"` // Subtitle
}

// MessageType return the string telegram-type of PageBlockSubtitle
func (pageBlockSubtitle *PageBlockSubtitle) MessageType() string {
	return "pageBlockSubtitle"
}

// NewPageBlockSubtitle creates a new PageBlockSubtitle
//
// @param subtitle Subtitle
func NewPageBlockSubtitle(subtitle RichText) *PageBlockSubtitle {
	pageBlockSubtitleTemp := PageBlockSubtitle{
		tdCommon: tdCommon{Type: "pageBlockSubtitle"},
		Subtitle: subtitle,
	}

	return &pageBlockSubtitleTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockSubtitle *PageBlockSubtitle) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockSubtitle.tdCommon = tempObj.tdCommon

	fieldSubtitle, _ := unmarshalRichText(objMap["subtitle"])
	pageBlockSubtitle.Subtitle = fieldSubtitle

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockSubtitle *PageBlockSubtitle) GetPageBlockEnum() PageBlockEnum {
	return PageBlockSubtitleType
}

// PageBlockAuthorDate The author and publishing date of a page
type PageBlockAuthorDate struct {
	tdCommon
	Author      RichText `json:"author"`       // Author
	PublishDate int32    `json:"publish_date"` // Point in time (Unix timestamp) when the article was published; 0 if unknown
}

// MessageType return the string telegram-type of PageBlockAuthorDate
func (pageBlockAuthorDate *PageBlockAuthorDate) MessageType() string {
	return "pageBlockAuthorDate"
}

// NewPageBlockAuthorDate creates a new PageBlockAuthorDate
//
// @param author Author
// @param publishDate Point in time (Unix timestamp) when the article was published; 0 if unknown
func NewPageBlockAuthorDate(author RichText, publishDate int32) *PageBlockAuthorDate {
	pageBlockAuthorDateTemp := PageBlockAuthorDate{
		tdCommon:    tdCommon{Type: "pageBlockAuthorDate"},
		Author:      author,
		PublishDate: publishDate,
	}

	return &pageBlockAuthorDateTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockAuthorDate *PageBlockAuthorDate) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PublishDate int32 `json:"publish_date"` // Point in time (Unix timestamp) when the article was published; 0 if unknown
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockAuthorDate.tdCommon = tempObj.tdCommon
	pageBlockAuthorDate.PublishDate = tempObj.PublishDate

	fieldAuthor, _ := unmarshalRichText(objMap["author"])
	pageBlockAuthorDate.Author = fieldAuthor

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockAuthorDate *PageBlockAuthorDate) GetPageBlockEnum() PageBlockEnum {
	return PageBlockAuthorDateType
}

// PageBlockHeader A header
type PageBlockHeader struct {
	tdCommon
	Header RichText `json:"header"` // Header
}

// MessageType return the string telegram-type of PageBlockHeader
func (pageBlockHeader *PageBlockHeader) MessageType() string {
	return "pageBlockHeader"
}

// NewPageBlockHeader creates a new PageBlockHeader
//
// @param header Header
func NewPageBlockHeader(header RichText) *PageBlockHeader {
	pageBlockHeaderTemp := PageBlockHeader{
		tdCommon: tdCommon{Type: "pageBlockHeader"},
		Header:   header,
	}

	return &pageBlockHeaderTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockHeader *PageBlockHeader) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockHeader.tdCommon = tempObj.tdCommon

	fieldHeader, _ := unmarshalRichText(objMap["header"])
	pageBlockHeader.Header = fieldHeader

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockHeader *PageBlockHeader) GetPageBlockEnum() PageBlockEnum {
	return PageBlockHeaderType
}

// PageBlockSubheader A subheader
type PageBlockSubheader struct {
	tdCommon
	Subheader RichText `json:"subheader"` // Subheader
}

// MessageType return the string telegram-type of PageBlockSubheader
func (pageBlockSubheader *PageBlockSubheader) MessageType() string {
	return "pageBlockSubheader"
}

// NewPageBlockSubheader creates a new PageBlockSubheader
//
// @param subheader Subheader
func NewPageBlockSubheader(subheader RichText) *PageBlockSubheader {
	pageBlockSubheaderTemp := PageBlockSubheader{
		tdCommon:  tdCommon{Type: "pageBlockSubheader"},
		Subheader: subheader,
	}

	return &pageBlockSubheaderTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockSubheader *PageBlockSubheader) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockSubheader.tdCommon = tempObj.tdCommon

	fieldSubheader, _ := unmarshalRichText(objMap["subheader"])
	pageBlockSubheader.Subheader = fieldSubheader

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockSubheader *PageBlockSubheader) GetPageBlockEnum() PageBlockEnum {
	return PageBlockSubheaderType
}

// PageBlockKicker A kicker
type PageBlockKicker struct {
	tdCommon
	Kicker RichText `json:"kicker"` // Kicker
}

// MessageType return the string telegram-type of PageBlockKicker
func (pageBlockKicker *PageBlockKicker) MessageType() string {
	return "pageBlockKicker"
}

// NewPageBlockKicker creates a new PageBlockKicker
//
// @param kicker Kicker
func NewPageBlockKicker(kicker RichText) *PageBlockKicker {
	pageBlockKickerTemp := PageBlockKicker{
		tdCommon: tdCommon{Type: "pageBlockKicker"},
		Kicker:   kicker,
	}

	return &pageBlockKickerTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockKicker *PageBlockKicker) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockKicker.tdCommon = tempObj.tdCommon

	fieldKicker, _ := unmarshalRichText(objMap["kicker"])
	pageBlockKicker.Kicker = fieldKicker

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockKicker *PageBlockKicker) GetPageBlockEnum() PageBlockEnum {
	return PageBlockKickerType
}

// PageBlockParagraph A text paragraph
type PageBlockParagraph struct {
	tdCommon
	Text RichText `json:"text"` // Paragraph text
}

// MessageType return the string telegram-type of PageBlockParagraph
func (pageBlockParagraph *PageBlockParagraph) MessageType() string {
	return "pageBlockParagraph"
}

// NewPageBlockParagraph creates a new PageBlockParagraph
//
// @param text Paragraph text
func NewPageBlockParagraph(text RichText) *PageBlockParagraph {
	pageBlockParagraphTemp := PageBlockParagraph{
		tdCommon: tdCommon{Type: "pageBlockParagraph"},
		Text:     text,
	}

	return &pageBlockParagraphTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockParagraph *PageBlockParagraph) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockParagraph.tdCommon = tempObj.tdCommon

	fieldText, _ := unmarshalRichText(objMap["text"])
	pageBlockParagraph.Text = fieldText

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockParagraph *PageBlockParagraph) GetPageBlockEnum() PageBlockEnum {
	return PageBlockParagraphType
}

// PageBlockPreformatted A preformatted text paragraph
type PageBlockPreformatted struct {
	tdCommon
	Text     RichText `json:"text"`     // Paragraph text
	Language string   `json:"language"` // Programming language for which the text needs to be formatted
}

// MessageType return the string telegram-type of PageBlockPreformatted
func (pageBlockPreformatted *PageBlockPreformatted) MessageType() string {
	return "pageBlockPreformatted"
}

// NewPageBlockPreformatted creates a new PageBlockPreformatted
//
// @param text Paragraph text
// @param language Programming language for which the text needs to be formatted
func NewPageBlockPreformatted(text RichText, language string) *PageBlockPreformatted {
	pageBlockPreformattedTemp := PageBlockPreformatted{
		tdCommon: tdCommon{Type: "pageBlockPreformatted"},
		Text:     text,
		Language: language,
	}

	return &pageBlockPreformattedTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockPreformatted *PageBlockPreformatted) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Language string `json:"language"` // Programming language for which the text needs to be formatted
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockPreformatted.tdCommon = tempObj.tdCommon
	pageBlockPreformatted.Language = tempObj.Language

	fieldText, _ := unmarshalRichText(objMap["text"])
	pageBlockPreformatted.Text = fieldText

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockPreformatted *PageBlockPreformatted) GetPageBlockEnum() PageBlockEnum {
	return PageBlockPreformattedType
}

// PageBlockFooter The footer of a page
type PageBlockFooter struct {
	tdCommon
	Footer RichText `json:"footer"` // Footer
}

// MessageType return the string telegram-type of PageBlockFooter
func (pageBlockFooter *PageBlockFooter) MessageType() string {
	return "pageBlockFooter"
}

// NewPageBlockFooter creates a new PageBlockFooter
//
// @param footer Footer
func NewPageBlockFooter(footer RichText) *PageBlockFooter {
	pageBlockFooterTemp := PageBlockFooter{
		tdCommon: tdCommon{Type: "pageBlockFooter"},
		Footer:   footer,
	}

	return &pageBlockFooterTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockFooter *PageBlockFooter) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockFooter.tdCommon = tempObj.tdCommon

	fieldFooter, _ := unmarshalRichText(objMap["footer"])
	pageBlockFooter.Footer = fieldFooter

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockFooter *PageBlockFooter) GetPageBlockEnum() PageBlockEnum {
	return PageBlockFooterType
}

// PageBlockDivider An empty block separating a page
type PageBlockDivider struct {
	tdCommon
}

// MessageType return the string telegram-type of PageBlockDivider
func (pageBlockDivider *PageBlockDivider) MessageType() string {
	return "pageBlockDivider"
}

// NewPageBlockDivider creates a new PageBlockDivider
//
func NewPageBlockDivider() *PageBlockDivider {
	pageBlockDividerTemp := PageBlockDivider{
		tdCommon: tdCommon{Type: "pageBlockDivider"},
	}

	return &pageBlockDividerTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockDivider *PageBlockDivider) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockDivider.tdCommon = tempObj.tdCommon

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockDivider *PageBlockDivider) GetPageBlockEnum() PageBlockEnum {
	return PageBlockDividerType
}

// PageBlockAnchor An invisible anchor on a page, which can be used in a URL to open the page from the specified anchor
type PageBlockAnchor struct {
	tdCommon
	Name string `json:"name"` // Name of the anchor
}

// MessageType return the string telegram-type of PageBlockAnchor
func (pageBlockAnchor *PageBlockAnchor) MessageType() string {
	return "pageBlockAnchor"
}

// NewPageBlockAnchor creates a new PageBlockAnchor
//
// @param name Name of the anchor
func NewPageBlockAnchor(name string) *PageBlockAnchor {
	pageBlockAnchorTemp := PageBlockAnchor{
		tdCommon: tdCommon{Type: "pageBlockAnchor"},
		Name:     name,
	}

	return &pageBlockAnchorTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockAnchor *PageBlockAnchor) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Name string `json:"name"` // Name of the anchor
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockAnchor.tdCommon = tempObj.tdCommon
	pageBlockAnchor.Name = tempObj.Name

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockAnchor *PageBlockAnchor) GetPageBlockEnum() PageBlockEnum {
	return PageBlockAnchorType
}

// PageBlockList A list of data blocks
type PageBlockList struct {
	tdCommon
	Items []PageBlockListItem `json:"items"` // The items of the list
}

// MessageType return the string telegram-type of PageBlockList
func (pageBlockList *PageBlockList) MessageType() string {
	return "pageBlockList"
}

// NewPageBlockList creates a new PageBlockList
//
// @param items The items of the list
func NewPageBlockList(items []PageBlockListItem) *PageBlockList {
	pageBlockListTemp := PageBlockList{
		tdCommon: tdCommon{Type: "pageBlockList"},
		Items:    items,
	}

	return &pageBlockListTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockList *PageBlockList) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Items []PageBlockListItem `json:"items"` // The items of the list
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockList.tdCommon = tempObj.tdCommon
	pageBlockList.Items = tempObj.Items

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockList *PageBlockList) GetPageBlockEnum() PageBlockEnum {
	return PageBlockListType
}

// PageBlockBlockQuote A block quote
type PageBlockBlockQuote struct {
	tdCommon
	Text   RichText `json:"text"`   // Quote text
	Credit RichText `json:"credit"` // Quote credit
}

// MessageType return the string telegram-type of PageBlockBlockQuote
func (pageBlockBlockQuote *PageBlockBlockQuote) MessageType() string {
	return "pageBlockBlockQuote"
}

// NewPageBlockBlockQuote creates a new PageBlockBlockQuote
//
// @param text Quote text
// @param credit Quote credit
func NewPageBlockBlockQuote(text RichText, credit RichText) *PageBlockBlockQuote {
	pageBlockBlockQuoteTemp := PageBlockBlockQuote{
		tdCommon: tdCommon{Type: "pageBlockBlockQuote"},
		Text:     text,
		Credit:   credit,
	}

	return &pageBlockBlockQuoteTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockBlockQuote *PageBlockBlockQuote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockBlockQuote.tdCommon = tempObj.tdCommon

	fieldText, _ := unmarshalRichText(objMap["text"])
	pageBlockBlockQuote.Text = fieldText

	fieldCredit, _ := unmarshalRichText(objMap["credit"])
	pageBlockBlockQuote.Credit = fieldCredit

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockBlockQuote *PageBlockBlockQuote) GetPageBlockEnum() PageBlockEnum {
	return PageBlockBlockQuoteType
}

// PageBlockPullQuote A pull quote
type PageBlockPullQuote struct {
	tdCommon
	Text   RichText `json:"text"`   // Quote text
	Credit RichText `json:"credit"` // Quote credit
}

// MessageType return the string telegram-type of PageBlockPullQuote
func (pageBlockPullQuote *PageBlockPullQuote) MessageType() string {
	return "pageBlockPullQuote"
}

// NewPageBlockPullQuote creates a new PageBlockPullQuote
//
// @param text Quote text
// @param credit Quote credit
func NewPageBlockPullQuote(text RichText, credit RichText) *PageBlockPullQuote {
	pageBlockPullQuoteTemp := PageBlockPullQuote{
		tdCommon: tdCommon{Type: "pageBlockPullQuote"},
		Text:     text,
		Credit:   credit,
	}

	return &pageBlockPullQuoteTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockPullQuote *PageBlockPullQuote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockPullQuote.tdCommon = tempObj.tdCommon

	fieldText, _ := unmarshalRichText(objMap["text"])
	pageBlockPullQuote.Text = fieldText

	fieldCredit, _ := unmarshalRichText(objMap["credit"])
	pageBlockPullQuote.Credit = fieldCredit

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockPullQuote *PageBlockPullQuote) GetPageBlockEnum() PageBlockEnum {
	return PageBlockPullQuoteType
}

// PageBlockAnimation An animation
type PageBlockAnimation struct {
	tdCommon
	Animation    *Animation        `json:"animation"`     // Animation file; may be null
	Caption      *PageBlockCaption `json:"caption"`       // Animation caption
	NeedAutoplay bool              `json:"need_autoplay"` // True, if the animation must be played automatically
}

// MessageType return the string telegram-type of PageBlockAnimation
func (pageBlockAnimation *PageBlockAnimation) MessageType() string {
	return "pageBlockAnimation"
}

// NewPageBlockAnimation creates a new PageBlockAnimation
//
// @param animation Animation file; may be null
// @param caption Animation caption
// @param needAutoplay True, if the animation must be played automatically
func NewPageBlockAnimation(animation *Animation, caption *PageBlockCaption, needAutoplay bool) *PageBlockAnimation {
	pageBlockAnimationTemp := PageBlockAnimation{
		tdCommon:     tdCommon{Type: "pageBlockAnimation"},
		Animation:    animation,
		Caption:      caption,
		NeedAutoplay: needAutoplay,
	}

	return &pageBlockAnimationTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockAnimation *PageBlockAnimation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Animation    *Animation `json:"animation"`     // Animation file; may be null
		NeedAutoplay bool       `json:"need_autoplay"` // True, if the animation must be played automatically
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockAnimation.tdCommon = tempObj.tdCommon
	pageBlockAnimation.Animation = tempObj.Animation
	pageBlockAnimation.NeedAutoplay = tempObj.NeedAutoplay

	var caption PageBlockCaption
	if objMap["caption"] != nil {
		err = caption.UnmarshalJSON(*objMap["caption"])
		if err != nil {
			return err
		}
	}

	pageBlockAnimation.Caption = &caption

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockAnimation *PageBlockAnimation) GetPageBlockEnum() PageBlockEnum {
	return PageBlockAnimationType
}

// PageBlockAudio An audio file
type PageBlockAudio struct {
	tdCommon
	Audio   *Audio            `json:"audio"`   // Audio file; may be null
	Caption *PageBlockCaption `json:"caption"` // Audio file caption
}

// MessageType return the string telegram-type of PageBlockAudio
func (pageBlockAudio *PageBlockAudio) MessageType() string {
	return "pageBlockAudio"
}

// NewPageBlockAudio creates a new PageBlockAudio
//
// @param audio Audio file; may be null
// @param caption Audio file caption
func NewPageBlockAudio(audio *Audio, caption *PageBlockCaption) *PageBlockAudio {
	pageBlockAudioTemp := PageBlockAudio{
		tdCommon: tdCommon{Type: "pageBlockAudio"},
		Audio:    audio,
		Caption:  caption,
	}

	return &pageBlockAudioTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockAudio *PageBlockAudio) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Audio *Audio `json:"audio"` // Audio file; may be null

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockAudio.tdCommon = tempObj.tdCommon
	pageBlockAudio.Audio = tempObj.Audio

	var caption PageBlockCaption
	if objMap["caption"] != nil {
		err = caption.UnmarshalJSON(*objMap["caption"])
		if err != nil {
			return err
		}
	}

	pageBlockAudio.Caption = &caption

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockAudio *PageBlockAudio) GetPageBlockEnum() PageBlockEnum {
	return PageBlockAudioType
}

// PageBlockPhoto A photo
type PageBlockPhoto struct {
	tdCommon
	Photo   *Photo            `json:"photo"`   // Photo file; may be null
	Caption *PageBlockCaption `json:"caption"` // Photo caption
	URL     string            `json:"url"`     // URL that needs to be opened when the photo is clicked
}

// MessageType return the string telegram-type of PageBlockPhoto
func (pageBlockPhoto *PageBlockPhoto) MessageType() string {
	return "pageBlockPhoto"
}

// NewPageBlockPhoto creates a new PageBlockPhoto
//
// @param photo Photo file; may be null
// @param caption Photo caption
// @param uRL URL that needs to be opened when the photo is clicked
func NewPageBlockPhoto(photo *Photo, caption *PageBlockCaption, uRL string) *PageBlockPhoto {
	pageBlockPhotoTemp := PageBlockPhoto{
		tdCommon: tdCommon{Type: "pageBlockPhoto"},
		Photo:    photo,
		Caption:  caption,
		URL:      uRL,
	}

	return &pageBlockPhotoTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockPhoto *PageBlockPhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Photo *Photo `json:"photo"` // Photo file; may be null
		URL   string `json:"url"`   // URL that needs to be opened when the photo is clicked
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockPhoto.tdCommon = tempObj.tdCommon
	pageBlockPhoto.Photo = tempObj.Photo
	pageBlockPhoto.URL = tempObj.URL

	var caption PageBlockCaption
	if objMap["caption"] != nil {
		err = caption.UnmarshalJSON(*objMap["caption"])
		if err != nil {
			return err
		}
	}

	pageBlockPhoto.Caption = &caption

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockPhoto *PageBlockPhoto) GetPageBlockEnum() PageBlockEnum {
	return PageBlockPhotoType
}

// PageBlockVideo A video
type PageBlockVideo struct {
	tdCommon
	Video        *Video            `json:"video"`         // Video file; may be null
	Caption      *PageBlockCaption `json:"caption"`       // Video caption
	NeedAutoplay bool              `json:"need_autoplay"` // True, if the video must be played automatically
	IsLooped     bool              `json:"is_looped"`     // True, if the video must be looped
}

// MessageType return the string telegram-type of PageBlockVideo
func (pageBlockVideo *PageBlockVideo) MessageType() string {
	return "pageBlockVideo"
}

// NewPageBlockVideo creates a new PageBlockVideo
//
// @param video Video file; may be null
// @param caption Video caption
// @param needAutoplay True, if the video must be played automatically
// @param isLooped True, if the video must be looped
func NewPageBlockVideo(video *Video, caption *PageBlockCaption, needAutoplay bool, isLooped bool) *PageBlockVideo {
	pageBlockVideoTemp := PageBlockVideo{
		tdCommon:     tdCommon{Type: "pageBlockVideo"},
		Video:        video,
		Caption:      caption,
		NeedAutoplay: needAutoplay,
		IsLooped:     isLooped,
	}

	return &pageBlockVideoTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockVideo *PageBlockVideo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Video        *Video `json:"video"`         // Video file; may be null
		NeedAutoplay bool   `json:"need_autoplay"` // True, if the video must be played automatically
		IsLooped     bool   `json:"is_looped"`     // True, if the video must be looped
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockVideo.tdCommon = tempObj.tdCommon
	pageBlockVideo.Video = tempObj.Video
	pageBlockVideo.NeedAutoplay = tempObj.NeedAutoplay
	pageBlockVideo.IsLooped = tempObj.IsLooped

	var caption PageBlockCaption
	if objMap["caption"] != nil {
		err = caption.UnmarshalJSON(*objMap["caption"])
		if err != nil {
			return err
		}
	}

	pageBlockVideo.Caption = &caption

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockVideo *PageBlockVideo) GetPageBlockEnum() PageBlockEnum {
	return PageBlockVideoType
}

// PageBlockVoiceNote A voice note
type PageBlockVoiceNote struct {
	tdCommon
	VoiceNote *VoiceNote        `json:"voice_note"` // Voice note; may be null
	Caption   *PageBlockCaption `json:"caption"`    // Voice note caption
}

// MessageType return the string telegram-type of PageBlockVoiceNote
func (pageBlockVoiceNote *PageBlockVoiceNote) MessageType() string {
	return "pageBlockVoiceNote"
}

// NewPageBlockVoiceNote creates a new PageBlockVoiceNote
//
// @param voiceNote Voice note; may be null
// @param caption Voice note caption
func NewPageBlockVoiceNote(voiceNote *VoiceNote, caption *PageBlockCaption) *PageBlockVoiceNote {
	pageBlockVoiceNoteTemp := PageBlockVoiceNote{
		tdCommon:  tdCommon{Type: "pageBlockVoiceNote"},
		VoiceNote: voiceNote,
		Caption:   caption,
	}

	return &pageBlockVoiceNoteTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockVoiceNote *PageBlockVoiceNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockVoiceNote.tdCommon = tempObj.tdCommon

	var voiceNote VoiceNote
	if objMap["voice_note"] != nil {
		err = voiceNote.UnmarshalJSON(*objMap["voice_note"])
		if err != nil {
			return err
		}
	}

	pageBlockVoiceNote.VoiceNote = &voiceNote

	var caption PageBlockCaption
	if objMap["caption"] != nil {
		err = caption.UnmarshalJSON(*objMap["caption"])
		if err != nil {
			return err
		}
	}

	pageBlockVoiceNote.Caption = &caption

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockVoiceNote *PageBlockVoiceNote) GetPageBlockEnum() PageBlockEnum {
	return PageBlockVoiceNoteType
}

// PageBlockCover A page cover
type PageBlockCover struct {
	tdCommon
	Cover PageBlock `json:"cover"` // Cover
}

// MessageType return the string telegram-type of PageBlockCover
func (pageBlockCover *PageBlockCover) MessageType() string {
	return "pageBlockCover"
}

// NewPageBlockCover creates a new PageBlockCover
//
// @param cover Cover
func NewPageBlockCover(cover PageBlock) *PageBlockCover {
	pageBlockCoverTemp := PageBlockCover{
		tdCommon: tdCommon{Type: "pageBlockCover"},
		Cover:    cover,
	}

	return &pageBlockCoverTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockCover *PageBlockCover) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockCover.tdCommon = tempObj.tdCommon

	fieldCover, _ := unmarshalPageBlock(objMap["cover"])
	pageBlockCover.Cover = fieldCover

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockCover *PageBlockCover) GetPageBlockEnum() PageBlockEnum {
	return PageBlockCoverType
}

// PageBlockEmbedded An embedded web page
type PageBlockEmbedded struct {
	tdCommon
	URL            string            `json:"url"`             // URL of the embedded page, if available
	HTML           string            `json:"html"`            // HTML-markup of the embedded page
	PosterPhoto    *Photo            `json:"poster_photo"`    // Poster photo, if available; may be null
	Width          int32             `json:"width"`           // Block width; 0 if unknown
	Height         int32             `json:"height"`          // Block height; 0 if unknown
	Caption        *PageBlockCaption `json:"caption"`         // Block caption
	IsFullWidth    bool              `json:"is_full_width"`   // True, if the block must be full width
	AllowScrolling bool              `json:"allow_scrolling"` // True, if scrolling needs to be allowed
}

// MessageType return the string telegram-type of PageBlockEmbedded
func (pageBlockEmbedded *PageBlockEmbedded) MessageType() string {
	return "pageBlockEmbedded"
}

// NewPageBlockEmbedded creates a new PageBlockEmbedded
//
// @param uRL URL of the embedded page, if available
// @param hTML HTML-markup of the embedded page
// @param posterPhoto Poster photo, if available; may be null
// @param width Block width; 0 if unknown
// @param height Block height; 0 if unknown
// @param caption Block caption
// @param isFullWidth True, if the block must be full width
// @param allowScrolling True, if scrolling needs to be allowed
func NewPageBlockEmbedded(uRL string, hTML string, posterPhoto *Photo, width int32, height int32, caption *PageBlockCaption, isFullWidth bool, allowScrolling bool) *PageBlockEmbedded {
	pageBlockEmbeddedTemp := PageBlockEmbedded{
		tdCommon:       tdCommon{Type: "pageBlockEmbedded"},
		URL:            uRL,
		HTML:           hTML,
		PosterPhoto:    posterPhoto,
		Width:          width,
		Height:         height,
		Caption:        caption,
		IsFullWidth:    isFullWidth,
		AllowScrolling: allowScrolling,
	}

	return &pageBlockEmbeddedTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockEmbedded *PageBlockEmbedded) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL            string `json:"url"`             // URL of the embedded page, if available
		HTML           string `json:"html"`            // HTML-markup of the embedded page
		PosterPhoto    *Photo `json:"poster_photo"`    // Poster photo, if available; may be null
		Width          int32  `json:"width"`           // Block width; 0 if unknown
		Height         int32  `json:"height"`          // Block height; 0 if unknown
		IsFullWidth    bool   `json:"is_full_width"`   // True, if the block must be full width
		AllowScrolling bool   `json:"allow_scrolling"` // True, if scrolling needs to be allowed
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockEmbedded.tdCommon = tempObj.tdCommon
	pageBlockEmbedded.URL = tempObj.URL
	pageBlockEmbedded.HTML = tempObj.HTML
	pageBlockEmbedded.PosterPhoto = tempObj.PosterPhoto
	pageBlockEmbedded.Width = tempObj.Width
	pageBlockEmbedded.Height = tempObj.Height
	pageBlockEmbedded.IsFullWidth = tempObj.IsFullWidth
	pageBlockEmbedded.AllowScrolling = tempObj.AllowScrolling

	var caption PageBlockCaption
	if objMap["caption"] != nil {
		err = caption.UnmarshalJSON(*objMap["caption"])
		if err != nil {
			return err
		}
	}

	pageBlockEmbedded.Caption = &caption

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockEmbedded *PageBlockEmbedded) GetPageBlockEnum() PageBlockEnum {
	return PageBlockEmbeddedType
}

// PageBlockEmbeddedPost An embedded post
type PageBlockEmbeddedPost struct {
	tdCommon
	URL         string            `json:"url"`          // URL of the embedded post
	Author      string            `json:"author"`       // Post author
	AuthorPhoto *Photo            `json:"author_photo"` // Post author photo; may be null
	Date        int32             `json:"date"`         // Point in time (Unix timestamp) when the post was created; 0 if unknown
	PageBlocks  []PageBlock       `json:"page_blocks"`  // Post content
	Caption     *PageBlockCaption `json:"caption"`      // Post caption
}

// MessageType return the string telegram-type of PageBlockEmbeddedPost
func (pageBlockEmbeddedPost *PageBlockEmbeddedPost) MessageType() string {
	return "pageBlockEmbeddedPost"
}

// NewPageBlockEmbeddedPost creates a new PageBlockEmbeddedPost
//
// @param uRL URL of the embedded post
// @param author Post author
// @param authorPhoto Post author photo; may be null
// @param date Point in time (Unix timestamp) when the post was created; 0 if unknown
// @param pageBlocks Post content
// @param caption Post caption
func NewPageBlockEmbeddedPost(uRL string, author string, authorPhoto *Photo, date int32, pageBlocks []PageBlock, caption *PageBlockCaption) *PageBlockEmbeddedPost {
	pageBlockEmbeddedPostTemp := PageBlockEmbeddedPost{
		tdCommon:    tdCommon{Type: "pageBlockEmbeddedPost"},
		URL:         uRL,
		Author:      author,
		AuthorPhoto: authorPhoto,
		Date:        date,
		PageBlocks:  pageBlocks,
		Caption:     caption,
	}

	return &pageBlockEmbeddedPostTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockEmbeddedPost *PageBlockEmbeddedPost) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL         string `json:"url"`          // URL of the embedded post
		Author      string `json:"author"`       // Post author
		AuthorPhoto *Photo `json:"author_photo"` // Post author photo; may be null
		Date        int32  `json:"date"`         // Point in time (Unix timestamp) when the post was created; 0 if unknown

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockEmbeddedPost.tdCommon = tempObj.tdCommon
	pageBlockEmbeddedPost.URL = tempObj.URL
	pageBlockEmbeddedPost.Author = tempObj.Author
	pageBlockEmbeddedPost.AuthorPhoto = tempObj.AuthorPhoto
	pageBlockEmbeddedPost.Date = tempObj.Date

	var caption PageBlockCaption
	if objMap["caption"] != nil {
		err = caption.UnmarshalJSON(*objMap["caption"])
		if err != nil {
			return err
		}
	}

	pageBlockEmbeddedPost.Caption = &caption

	fieldPageBlocks, _ := unmarshalPageBlockSlice(objMap["page_blocks"])
	pageBlockEmbeddedPost.PageBlocks = fieldPageBlocks

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockEmbeddedPost *PageBlockEmbeddedPost) GetPageBlockEnum() PageBlockEnum {
	return PageBlockEmbeddedPostType
}

// PageBlockCollage A collage
type PageBlockCollage struct {
	tdCommon
	PageBlocks []PageBlock       `json:"page_blocks"` // Collage item contents
	Caption    *PageBlockCaption `json:"caption"`     // Block caption
}

// MessageType return the string telegram-type of PageBlockCollage
func (pageBlockCollage *PageBlockCollage) MessageType() string {
	return "pageBlockCollage"
}

// NewPageBlockCollage creates a new PageBlockCollage
//
// @param pageBlocks Collage item contents
// @param caption Block caption
func NewPageBlockCollage(pageBlocks []PageBlock, caption *PageBlockCaption) *PageBlockCollage {
	pageBlockCollageTemp := PageBlockCollage{
		tdCommon:   tdCommon{Type: "pageBlockCollage"},
		PageBlocks: pageBlocks,
		Caption:    caption,
	}

	return &pageBlockCollageTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockCollage *PageBlockCollage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockCollage.tdCommon = tempObj.tdCommon

	var caption PageBlockCaption
	if objMap["caption"] != nil {
		err = caption.UnmarshalJSON(*objMap["caption"])
		if err != nil {
			return err
		}
	}

	pageBlockCollage.Caption = &caption

	fieldPageBlocks, _ := unmarshalPageBlockSlice(objMap["page_blocks"])
	pageBlockCollage.PageBlocks = fieldPageBlocks

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockCollage *PageBlockCollage) GetPageBlockEnum() PageBlockEnum {
	return PageBlockCollageType
}

// PageBlockSlideshow A slideshow
type PageBlockSlideshow struct {
	tdCommon
	PageBlocks []PageBlock       `json:"page_blocks"` // Slideshow item contents
	Caption    *PageBlockCaption `json:"caption"`     // Block caption
}

// MessageType return the string telegram-type of PageBlockSlideshow
func (pageBlockSlideshow *PageBlockSlideshow) MessageType() string {
	return "pageBlockSlideshow"
}

// NewPageBlockSlideshow creates a new PageBlockSlideshow
//
// @param pageBlocks Slideshow item contents
// @param caption Block caption
func NewPageBlockSlideshow(pageBlocks []PageBlock, caption *PageBlockCaption) *PageBlockSlideshow {
	pageBlockSlideshowTemp := PageBlockSlideshow{
		tdCommon:   tdCommon{Type: "pageBlockSlideshow"},
		PageBlocks: pageBlocks,
		Caption:    caption,
	}

	return &pageBlockSlideshowTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockSlideshow *PageBlockSlideshow) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockSlideshow.tdCommon = tempObj.tdCommon

	var caption PageBlockCaption
	if objMap["caption"] != nil {
		err = caption.UnmarshalJSON(*objMap["caption"])
		if err != nil {
			return err
		}
	}

	pageBlockSlideshow.Caption = &caption

	fieldPageBlocks, _ := unmarshalPageBlockSlice(objMap["page_blocks"])
	pageBlockSlideshow.PageBlocks = fieldPageBlocks

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockSlideshow *PageBlockSlideshow) GetPageBlockEnum() PageBlockEnum {
	return PageBlockSlideshowType
}

// PageBlockChatLink A link to a chat
type PageBlockChatLink struct {
	tdCommon
	Title         string         `json:"title"`           // Chat title
	Photo         *ChatPhotoInfo `json:"photo"`           // Chat photo; may be null
	AccentColorID int32          `json:"accent_color_id"` // Identifier of the accent color for chat title and background of chat photo
	Username      string         `json:"username"`        // Chat username by which all other information about the chat can be resolved
}

// MessageType return the string telegram-type of PageBlockChatLink
func (pageBlockChatLink *PageBlockChatLink) MessageType() string {
	return "pageBlockChatLink"
}

// NewPageBlockChatLink creates a new PageBlockChatLink
//
// @param title Chat title
// @param photo Chat photo; may be null
// @param accentColorID Identifier of the accent color for chat title and background of chat photo
// @param username Chat username by which all other information about the chat can be resolved
func NewPageBlockChatLink(title string, photo *ChatPhotoInfo, accentColorID int32, username string) *PageBlockChatLink {
	pageBlockChatLinkTemp := PageBlockChatLink{
		tdCommon:      tdCommon{Type: "pageBlockChatLink"},
		Title:         title,
		Photo:         photo,
		AccentColorID: accentColorID,
		Username:      username,
	}

	return &pageBlockChatLinkTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockChatLink *PageBlockChatLink) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Title         string         `json:"title"`           // Chat title
		Photo         *ChatPhotoInfo `json:"photo"`           // Chat photo; may be null
		AccentColorID int32          `json:"accent_color_id"` // Identifier of the accent color for chat title and background of chat photo
		Username      string         `json:"username"`        // Chat username by which all other information about the chat can be resolved
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockChatLink.tdCommon = tempObj.tdCommon
	pageBlockChatLink.Title = tempObj.Title
	pageBlockChatLink.Photo = tempObj.Photo
	pageBlockChatLink.AccentColorID = tempObj.AccentColorID
	pageBlockChatLink.Username = tempObj.Username

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockChatLink *PageBlockChatLink) GetPageBlockEnum() PageBlockEnum {
	return PageBlockChatLinkType
}

// PageBlockTable A table
type PageBlockTable struct {
	tdCommon
	Caption    RichText               `json:"caption"`     // Table caption
	Cells      [][]PageBlockTableCell `json:"cells"`       // Table cells
	IsBordered bool                   `json:"is_bordered"` // True, if the table is bordered
	IsStriped  bool                   `json:"is_striped"`  // True, if the table is striped
}

// MessageType return the string telegram-type of PageBlockTable
func (pageBlockTable *PageBlockTable) MessageType() string {
	return "pageBlockTable"
}

// NewPageBlockTable creates a new PageBlockTable
//
// @param caption Table caption
// @param cells Table cells
// @param isBordered True, if the table is bordered
// @param isStriped True, if the table is striped
func NewPageBlockTable(caption RichText, cells [][]PageBlockTableCell, isBordered bool, isStriped bool) *PageBlockTable {
	pageBlockTableTemp := PageBlockTable{
		tdCommon:   tdCommon{Type: "pageBlockTable"},
		Caption:    caption,
		Cells:      cells,
		IsBordered: isBordered,
		IsStriped:  isStriped,
	}

	return &pageBlockTableTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockTable *PageBlockTable) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Cells      [][]PageBlockTableCell `json:"cells"`       // Table cells
		IsBordered bool                   `json:"is_bordered"` // True, if the table is bordered
		IsStriped  bool                   `json:"is_striped"`  // True, if the table is striped
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockTable.tdCommon = tempObj.tdCommon
	pageBlockTable.Cells = tempObj.Cells
	pageBlockTable.IsBordered = tempObj.IsBordered
	pageBlockTable.IsStriped = tempObj.IsStriped

	fieldCaption, _ := unmarshalRichText(objMap["caption"])
	pageBlockTable.Caption = fieldCaption

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockTable *PageBlockTable) GetPageBlockEnum() PageBlockEnum {
	return PageBlockTableType
}

// PageBlockDetails A collapsible block
type PageBlockDetails struct {
	tdCommon
	Header     RichText    `json:"header"`      // Always visible heading for the block
	PageBlocks []PageBlock `json:"page_blocks"` // Block contents
	IsOpen     bool        `json:"is_open"`     // True, if the block is open by default
}

// MessageType return the string telegram-type of PageBlockDetails
func (pageBlockDetails *PageBlockDetails) MessageType() string {
	return "pageBlockDetails"
}

// NewPageBlockDetails creates a new PageBlockDetails
//
// @param header Always visible heading for the block
// @param pageBlocks Block contents
// @param isOpen True, if the block is open by default
func NewPageBlockDetails(header RichText, pageBlocks []PageBlock, isOpen bool) *PageBlockDetails {
	pageBlockDetailsTemp := PageBlockDetails{
		tdCommon:   tdCommon{Type: "pageBlockDetails"},
		Header:     header,
		PageBlocks: pageBlocks,
		IsOpen:     isOpen,
	}

	return &pageBlockDetailsTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockDetails *PageBlockDetails) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsOpen bool `json:"is_open"` // True, if the block is open by default
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockDetails.tdCommon = tempObj.tdCommon
	pageBlockDetails.IsOpen = tempObj.IsOpen

	fieldHeader, _ := unmarshalRichText(objMap["header"])
	pageBlockDetails.Header = fieldHeader

	fieldPageBlocks, _ := unmarshalPageBlockSlice(objMap["page_blocks"])
	pageBlockDetails.PageBlocks = fieldPageBlocks

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockDetails *PageBlockDetails) GetPageBlockEnum() PageBlockEnum {
	return PageBlockDetailsType
}

// PageBlockRelatedArticles Related articles
type PageBlockRelatedArticles struct {
	tdCommon
	Header   RichText                  `json:"header"`   // Block header
	Articles []PageBlockRelatedArticle `json:"articles"` // List of related articles
}

// MessageType return the string telegram-type of PageBlockRelatedArticles
func (pageBlockRelatedArticles *PageBlockRelatedArticles) MessageType() string {
	return "pageBlockRelatedArticles"
}

// NewPageBlockRelatedArticles creates a new PageBlockRelatedArticles
//
// @param header Block header
// @param articles List of related articles
func NewPageBlockRelatedArticles(header RichText, articles []PageBlockRelatedArticle) *PageBlockRelatedArticles {
	pageBlockRelatedArticlesTemp := PageBlockRelatedArticles{
		tdCommon: tdCommon{Type: "pageBlockRelatedArticles"},
		Header:   header,
		Articles: articles,
	}

	return &pageBlockRelatedArticlesTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockRelatedArticles *PageBlockRelatedArticles) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Articles []PageBlockRelatedArticle `json:"articles"` // List of related articles
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockRelatedArticles.tdCommon = tempObj.tdCommon
	pageBlockRelatedArticles.Articles = tempObj.Articles

	fieldHeader, _ := unmarshalRichText(objMap["header"])
	pageBlockRelatedArticles.Header = fieldHeader

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockRelatedArticles *PageBlockRelatedArticles) GetPageBlockEnum() PageBlockEnum {
	return PageBlockRelatedArticlesType
}

// PageBlockMap A map
type PageBlockMap struct {
	tdCommon
	Location *Location         `json:"location"` // Location of the map center
	Zoom     int32             `json:"zoom"`     // Map zoom level
	Width    int32             `json:"width"`    // Map width
	Height   int32             `json:"height"`   // Map height
	Caption  *PageBlockCaption `json:"caption"`  // Block caption
}

// MessageType return the string telegram-type of PageBlockMap
func (pageBlockMap *PageBlockMap) MessageType() string {
	return "pageBlockMap"
}

// NewPageBlockMap creates a new PageBlockMap
//
// @param location Location of the map center
// @param zoom Map zoom level
// @param width Map width
// @param height Map height
// @param caption Block caption
func NewPageBlockMap(location *Location, zoom int32, width int32, height int32, caption *PageBlockCaption) *PageBlockMap {
	pageBlockMapTemp := PageBlockMap{
		tdCommon: tdCommon{Type: "pageBlockMap"},
		Location: location,
		Zoom:     zoom,
		Width:    width,
		Height:   height,
		Caption:  caption,
	}

	return &pageBlockMapTemp
}

// UnmarshalJSON unmarshal to json
func (pageBlockMap *PageBlockMap) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Location *Location `json:"location"` // Location of the map center
		Zoom     int32     `json:"zoom"`     // Map zoom level
		Width    int32     `json:"width"`    // Map width
		Height   int32     `json:"height"`   // Map height

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pageBlockMap.tdCommon = tempObj.tdCommon
	pageBlockMap.Location = tempObj.Location
	pageBlockMap.Zoom = tempObj.Zoom
	pageBlockMap.Width = tempObj.Width
	pageBlockMap.Height = tempObj.Height

	var caption PageBlockCaption
	if objMap["caption"] != nil {
		err = caption.UnmarshalJSON(*objMap["caption"])
		if err != nil {
			return err
		}
	}

	pageBlockMap.Caption = &caption

	return nil
}

// GetPageBlockEnum return the enum type of this object
func (pageBlockMap *PageBlockMap) GetPageBlockEnum() PageBlockEnum {
	return PageBlockMapType
}

// WebPageInstantView Describes an instant view page for a web page
type WebPageInstantView struct {
	tdCommon
	PageBlocks   []PageBlock      `json:"page_blocks"`   // Content of the instant view page
	ViewCount    int32            `json:"view_count"`    // Number of the instant view views; 0 if unknown
	Version      int32            `json:"version"`       // Version of the instant view; currently, can be 1 or 2
	IsRtl        bool             `json:"is_rtl"`        // True, if the instant view must be shown from right to left
	IsFull       bool             `json:"is_full"`       // True, if the instant view contains the full page. A network request might be needed to get the full instant view
	FeedbackLink InternalLinkType `json:"feedback_link"` // An internal link to be opened to leave feedback about the instant view
}

// MessageType return the string telegram-type of WebPageInstantView
func (webPageInstantView *WebPageInstantView) MessageType() string {
	return "webPageInstantView"
}

// NewWebPageInstantView creates a new WebPageInstantView
//
// @param pageBlocks Content of the instant view page
// @param viewCount Number of the instant view views; 0 if unknown
// @param version Version of the instant view; currently, can be 1 or 2
// @param isRtl True, if the instant view must be shown from right to left
// @param isFull True, if the instant view contains the full page. A network request might be needed to get the full instant view
// @param feedbackLink An internal link to be opened to leave feedback about the instant view
func NewWebPageInstantView(pageBlocks []PageBlock, viewCount int32, version int32, isRtl bool, isFull bool, feedbackLink InternalLinkType) *WebPageInstantView {
	webPageInstantViewTemp := WebPageInstantView{
		tdCommon:     tdCommon{Type: "webPageInstantView"},
		PageBlocks:   pageBlocks,
		ViewCount:    viewCount,
		Version:      version,
		IsRtl:        isRtl,
		IsFull:       isFull,
		FeedbackLink: feedbackLink,
	}

	return &webPageInstantViewTemp
}

// UnmarshalJSON unmarshal to json
func (webPageInstantView *WebPageInstantView) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ViewCount int32 `json:"view_count"` // Number of the instant view views; 0 if unknown
		Version   int32 `json:"version"`    // Version of the instant view; currently, can be 1 or 2
		IsRtl     bool  `json:"is_rtl"`     // True, if the instant view must be shown from right to left
		IsFull    bool  `json:"is_full"`    // True, if the instant view contains the full page. A network request might be needed to get the full instant view

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	webPageInstantView.tdCommon = tempObj.tdCommon
	webPageInstantView.ViewCount = tempObj.ViewCount
	webPageInstantView.Version = tempObj.Version
	webPageInstantView.IsRtl = tempObj.IsRtl
	webPageInstantView.IsFull = tempObj.IsFull

	fieldFeedbackLink, _ := unmarshalInternalLinkType(objMap["feedback_link"])
	webPageInstantView.FeedbackLink = fieldFeedbackLink

	fieldPageBlocks, _ := unmarshalPageBlockSlice(objMap["page_blocks"])
	webPageInstantView.PageBlocks = fieldPageBlocks

	return nil
}

// LinkPreviewAlbumMediaPhoto The media is a photo
type LinkPreviewAlbumMediaPhoto struct {
	tdCommon
	Photo *Photo `json:"photo"` // Photo description
}

// MessageType return the string telegram-type of LinkPreviewAlbumMediaPhoto
func (linkPreviewAlbumMediaPhoto *LinkPreviewAlbumMediaPhoto) MessageType() string {
	return "linkPreviewAlbumMediaPhoto"
}

// NewLinkPreviewAlbumMediaPhoto creates a new LinkPreviewAlbumMediaPhoto
//
// @param photo Photo description
func NewLinkPreviewAlbumMediaPhoto(photo *Photo) *LinkPreviewAlbumMediaPhoto {
	linkPreviewAlbumMediaPhotoTemp := LinkPreviewAlbumMediaPhoto{
		tdCommon: tdCommon{Type: "linkPreviewAlbumMediaPhoto"},
		Photo:    photo,
	}

	return &linkPreviewAlbumMediaPhotoTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewAlbumMediaPhoto *LinkPreviewAlbumMediaPhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Photo *Photo `json:"photo"` // Photo description
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewAlbumMediaPhoto.tdCommon = tempObj.tdCommon
	linkPreviewAlbumMediaPhoto.Photo = tempObj.Photo

	return nil
}

// GetLinkPreviewAlbumMediaEnum return the enum type of this object
func (linkPreviewAlbumMediaPhoto *LinkPreviewAlbumMediaPhoto) GetLinkPreviewAlbumMediaEnum() LinkPreviewAlbumMediaEnum {
	return LinkPreviewAlbumMediaPhotoType
}

// LinkPreviewAlbumMediaVideo The media is a video
type LinkPreviewAlbumMediaVideo struct {
	tdCommon
	Video *Video `json:"video"` // Video description
}

// MessageType return the string telegram-type of LinkPreviewAlbumMediaVideo
func (linkPreviewAlbumMediaVideo *LinkPreviewAlbumMediaVideo) MessageType() string {
	return "linkPreviewAlbumMediaVideo"
}

// NewLinkPreviewAlbumMediaVideo creates a new LinkPreviewAlbumMediaVideo
//
// @param video Video description
func NewLinkPreviewAlbumMediaVideo(video *Video) *LinkPreviewAlbumMediaVideo {
	linkPreviewAlbumMediaVideoTemp := LinkPreviewAlbumMediaVideo{
		tdCommon: tdCommon{Type: "linkPreviewAlbumMediaVideo"},
		Video:    video,
	}

	return &linkPreviewAlbumMediaVideoTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewAlbumMediaVideo *LinkPreviewAlbumMediaVideo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Video *Video `json:"video"` // Video description
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewAlbumMediaVideo.tdCommon = tempObj.tdCommon
	linkPreviewAlbumMediaVideo.Video = tempObj.Video

	return nil
}

// GetLinkPreviewAlbumMediaEnum return the enum type of this object
func (linkPreviewAlbumMediaVideo *LinkPreviewAlbumMediaVideo) GetLinkPreviewAlbumMediaEnum() LinkPreviewAlbumMediaEnum {
	return LinkPreviewAlbumMediaVideoType
}

// LinkPreviewTypeAlbum The link is a link to a media album consisting of photos and videos
type LinkPreviewTypeAlbum struct {
	tdCommon
	Media   []LinkPreviewAlbumMedia `json:"media"`   // The list of album media
	Caption string                  `json:"caption"` // Album caption
}

// MessageType return the string telegram-type of LinkPreviewTypeAlbum
func (linkPreviewTypeAlbum *LinkPreviewTypeAlbum) MessageType() string {
	return "linkPreviewTypeAlbum"
}

// NewLinkPreviewTypeAlbum creates a new LinkPreviewTypeAlbum
//
// @param media The list of album media
// @param caption Album caption
func NewLinkPreviewTypeAlbum(media []LinkPreviewAlbumMedia, caption string) *LinkPreviewTypeAlbum {
	linkPreviewTypeAlbumTemp := LinkPreviewTypeAlbum{
		tdCommon: tdCommon{Type: "linkPreviewTypeAlbum"},
		Media:    media,
		Caption:  caption,
	}

	return &linkPreviewTypeAlbumTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeAlbum *LinkPreviewTypeAlbum) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Caption string `json:"caption"` // Album caption
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeAlbum.tdCommon = tempObj.tdCommon
	linkPreviewTypeAlbum.Caption = tempObj.Caption

	fieldMedia, _ := unmarshalLinkPreviewAlbumMediaSlice(objMap["media"])
	linkPreviewTypeAlbum.Media = fieldMedia

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeAlbum *LinkPreviewTypeAlbum) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeAlbumType
}

// LinkPreviewTypeAnimation The link is a link to an animation
type LinkPreviewTypeAnimation struct {
	tdCommon
	Animation *Animation `json:"animation"` // The animation
}

// MessageType return the string telegram-type of LinkPreviewTypeAnimation
func (linkPreviewTypeAnimation *LinkPreviewTypeAnimation) MessageType() string {
	return "linkPreviewTypeAnimation"
}

// NewLinkPreviewTypeAnimation creates a new LinkPreviewTypeAnimation
//
// @param animation The animation
func NewLinkPreviewTypeAnimation(animation *Animation) *LinkPreviewTypeAnimation {
	linkPreviewTypeAnimationTemp := LinkPreviewTypeAnimation{
		tdCommon:  tdCommon{Type: "linkPreviewTypeAnimation"},
		Animation: animation,
	}

	return &linkPreviewTypeAnimationTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeAnimation *LinkPreviewTypeAnimation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Animation *Animation `json:"animation"` // The animation
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeAnimation.tdCommon = tempObj.tdCommon
	linkPreviewTypeAnimation.Animation = tempObj.Animation

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeAnimation *LinkPreviewTypeAnimation) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeAnimationType
}

// LinkPreviewTypeApp The link is a link to an app at App Store or Google Play
type LinkPreviewTypeApp struct {
	tdCommon
	Photo *Photo `json:"photo"` // Photo for the app
}

// MessageType return the string telegram-type of LinkPreviewTypeApp
func (linkPreviewTypeApp *LinkPreviewTypeApp) MessageType() string {
	return "linkPreviewTypeApp"
}

// NewLinkPreviewTypeApp creates a new LinkPreviewTypeApp
//
// @param photo Photo for the app
func NewLinkPreviewTypeApp(photo *Photo) *LinkPreviewTypeApp {
	linkPreviewTypeAppTemp := LinkPreviewTypeApp{
		tdCommon: tdCommon{Type: "linkPreviewTypeApp"},
		Photo:    photo,
	}

	return &linkPreviewTypeAppTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeApp *LinkPreviewTypeApp) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Photo *Photo `json:"photo"` // Photo for the app
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeApp.tdCommon = tempObj.tdCommon
	linkPreviewTypeApp.Photo = tempObj.Photo

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeApp *LinkPreviewTypeApp) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeAppType
}

// LinkPreviewTypeArticle The link is a link to a web site
type LinkPreviewTypeArticle struct {
	tdCommon
	Photo *Photo `json:"photo"` // Article's main photo; may be null
}

// MessageType return the string telegram-type of LinkPreviewTypeArticle
func (linkPreviewTypeArticle *LinkPreviewTypeArticle) MessageType() string {
	return "linkPreviewTypeArticle"
}

// NewLinkPreviewTypeArticle creates a new LinkPreviewTypeArticle
//
// @param photo Article's main photo; may be null
func NewLinkPreviewTypeArticle(photo *Photo) *LinkPreviewTypeArticle {
	linkPreviewTypeArticleTemp := LinkPreviewTypeArticle{
		tdCommon: tdCommon{Type: "linkPreviewTypeArticle"},
		Photo:    photo,
	}

	return &linkPreviewTypeArticleTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeArticle *LinkPreviewTypeArticle) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Photo *Photo `json:"photo"` // Article's main photo; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeArticle.tdCommon = tempObj.tdCommon
	linkPreviewTypeArticle.Photo = tempObj.Photo

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeArticle *LinkPreviewTypeArticle) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeArticleType
}

// LinkPreviewTypeAudio The link is a link to an audio
type LinkPreviewTypeAudio struct {
	tdCommon
	Audio *Audio `json:"audio"` // The audio description
}

// MessageType return the string telegram-type of LinkPreviewTypeAudio
func (linkPreviewTypeAudio *LinkPreviewTypeAudio) MessageType() string {
	return "linkPreviewTypeAudio"
}

// NewLinkPreviewTypeAudio creates a new LinkPreviewTypeAudio
//
// @param audio The audio description
func NewLinkPreviewTypeAudio(audio *Audio) *LinkPreviewTypeAudio {
	linkPreviewTypeAudioTemp := LinkPreviewTypeAudio{
		tdCommon: tdCommon{Type: "linkPreviewTypeAudio"},
		Audio:    audio,
	}

	return &linkPreviewTypeAudioTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeAudio *LinkPreviewTypeAudio) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Audio *Audio `json:"audio"` // The audio description
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeAudio.tdCommon = tempObj.tdCommon
	linkPreviewTypeAudio.Audio = tempObj.Audio

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeAudio *LinkPreviewTypeAudio) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeAudioType
}

// LinkPreviewTypeBackground The link is a link to a background. Link preview title and description are available only for filled backgrounds
type LinkPreviewTypeBackground struct {
	tdCommon
	Document       *Document       `json:"document"`        // Document with the background; may be null for filled backgrounds
	BackgroundType *BackgroundType `json:"background_type"` // Type of the background; may be null if unknown
}

// MessageType return the string telegram-type of LinkPreviewTypeBackground
func (linkPreviewTypeBackground *LinkPreviewTypeBackground) MessageType() string {
	return "linkPreviewTypeBackground"
}

// NewLinkPreviewTypeBackground creates a new LinkPreviewTypeBackground
//
// @param document Document with the background; may be null for filled backgrounds
// @param backgroundType Type of the background; may be null if unknown
func NewLinkPreviewTypeBackground(document *Document, backgroundType *BackgroundType) *LinkPreviewTypeBackground {
	linkPreviewTypeBackgroundTemp := LinkPreviewTypeBackground{
		tdCommon:       tdCommon{Type: "linkPreviewTypeBackground"},
		Document:       document,
		BackgroundType: backgroundType,
	}

	return &linkPreviewTypeBackgroundTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeBackground *LinkPreviewTypeBackground) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Document *Document `json:"document"` // Document with the background; may be null for filled backgrounds

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeBackground.tdCommon = tempObj.tdCommon
	linkPreviewTypeBackground.Document = tempObj.Document

	fieldBackgroundType, _ := unmarshalBackgroundType(objMap["background_type"])
	linkPreviewTypeBackground.BackgroundType = &fieldBackgroundType

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeBackground *LinkPreviewTypeBackground) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeBackgroundType
}

// LinkPreviewTypeChannelBoost The link is a link to boost a channel chat
type LinkPreviewTypeChannelBoost struct {
	tdCommon
	Photo *ChatPhoto `json:"photo"` // Photo of the chat; may be null
}

// MessageType return the string telegram-type of LinkPreviewTypeChannelBoost
func (linkPreviewTypeChannelBoost *LinkPreviewTypeChannelBoost) MessageType() string {
	return "linkPreviewTypeChannelBoost"
}

// NewLinkPreviewTypeChannelBoost creates a new LinkPreviewTypeChannelBoost
//
// @param photo Photo of the chat; may be null
func NewLinkPreviewTypeChannelBoost(photo *ChatPhoto) *LinkPreviewTypeChannelBoost {
	linkPreviewTypeChannelBoostTemp := LinkPreviewTypeChannelBoost{
		tdCommon: tdCommon{Type: "linkPreviewTypeChannelBoost"},
		Photo:    photo,
	}

	return &linkPreviewTypeChannelBoostTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeChannelBoost *LinkPreviewTypeChannelBoost) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Photo *ChatPhoto `json:"photo"` // Photo of the chat; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeChannelBoost.tdCommon = tempObj.tdCommon
	linkPreviewTypeChannelBoost.Photo = tempObj.Photo

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeChannelBoost *LinkPreviewTypeChannelBoost) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeChannelBoostType
}

// LinkPreviewTypeChat The link is a link to a chat
type LinkPreviewTypeChat struct {
	tdCommon
	Type               InviteLinkChatType `json:"type"`                 // Type of the chat
	Photo              *ChatPhoto         `json:"photo"`                // Photo of the chat; may be null
	CreatesJoinRequest bool               `json:"creates_join_request"` // True, if the link only creates join request
}

// MessageType return the string telegram-type of LinkPreviewTypeChat
func (linkPreviewTypeChat *LinkPreviewTypeChat) MessageType() string {
	return "linkPreviewTypeChat"
}

// NewLinkPreviewTypeChat creates a new LinkPreviewTypeChat
//
// @param typeParam Type of the chat
// @param photo Photo of the chat; may be null
// @param createsJoinRequest True, if the link only creates join request
func NewLinkPreviewTypeChat(typeParam InviteLinkChatType, photo *ChatPhoto, createsJoinRequest bool) *LinkPreviewTypeChat {
	linkPreviewTypeChatTemp := LinkPreviewTypeChat{
		tdCommon:           tdCommon{Type: "linkPreviewTypeChat"},
		Type:               typeParam,
		Photo:              photo,
		CreatesJoinRequest: createsJoinRequest,
	}

	return &linkPreviewTypeChatTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeChat *LinkPreviewTypeChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Photo              *ChatPhoto `json:"photo"`                // Photo of the chat; may be null
		CreatesJoinRequest bool       `json:"creates_join_request"` // True, if the link only creates join request
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeChat.tdCommon = tempObj.tdCommon
	linkPreviewTypeChat.Photo = tempObj.Photo
	linkPreviewTypeChat.CreatesJoinRequest = tempObj.CreatesJoinRequest

	fieldType, _ := unmarshalInviteLinkChatType(objMap["type"])
	linkPreviewTypeChat.Type = fieldType

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeChat *LinkPreviewTypeChat) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeChatType
}

// LinkPreviewTypeDocument The link is a link to a general file
type LinkPreviewTypeDocument struct {
	tdCommon
	Document *Document `json:"document"` // The document description
}

// MessageType return the string telegram-type of LinkPreviewTypeDocument
func (linkPreviewTypeDocument *LinkPreviewTypeDocument) MessageType() string {
	return "linkPreviewTypeDocument"
}

// NewLinkPreviewTypeDocument creates a new LinkPreviewTypeDocument
//
// @param document The document description
func NewLinkPreviewTypeDocument(document *Document) *LinkPreviewTypeDocument {
	linkPreviewTypeDocumentTemp := LinkPreviewTypeDocument{
		tdCommon: tdCommon{Type: "linkPreviewTypeDocument"},
		Document: document,
	}

	return &linkPreviewTypeDocumentTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeDocument *LinkPreviewTypeDocument) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Document *Document `json:"document"` // The document description
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeDocument.tdCommon = tempObj.tdCommon
	linkPreviewTypeDocument.Document = tempObj.Document

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeDocument *LinkPreviewTypeDocument) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeDocumentType
}

// LinkPreviewTypeEmbeddedAnimationPlayer The link is a link to an animation player
type LinkPreviewTypeEmbeddedAnimationPlayer struct {
	tdCommon
	URL       string `json:"url"`       // URL of the external animation player
	Thumbnail *Photo `json:"thumbnail"` // Thumbnail of the animation; may be null if unknown
	Duration  int32  `json:"duration"`  // Duration of the animation, in seconds
	Width     int32  `json:"width"`     // Expected width of the embedded player
	Height    int32  `json:"height"`    // Expected height of the embedded player
}

// MessageType return the string telegram-type of LinkPreviewTypeEmbeddedAnimationPlayer
func (linkPreviewTypeEmbeddedAnimationPlayer *LinkPreviewTypeEmbeddedAnimationPlayer) MessageType() string {
	return "linkPreviewTypeEmbeddedAnimationPlayer"
}

// NewLinkPreviewTypeEmbeddedAnimationPlayer creates a new LinkPreviewTypeEmbeddedAnimationPlayer
//
// @param uRL URL of the external animation player
// @param thumbnail Thumbnail of the animation; may be null if unknown
// @param duration Duration of the animation, in seconds
// @param width Expected width of the embedded player
// @param height Expected height of the embedded player
func NewLinkPreviewTypeEmbeddedAnimationPlayer(uRL string, thumbnail *Photo, duration int32, width int32, height int32) *LinkPreviewTypeEmbeddedAnimationPlayer {
	linkPreviewTypeEmbeddedAnimationPlayerTemp := LinkPreviewTypeEmbeddedAnimationPlayer{
		tdCommon:  tdCommon{Type: "linkPreviewTypeEmbeddedAnimationPlayer"},
		URL:       uRL,
		Thumbnail: thumbnail,
		Duration:  duration,
		Width:     width,
		Height:    height,
	}

	return &linkPreviewTypeEmbeddedAnimationPlayerTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeEmbeddedAnimationPlayer *LinkPreviewTypeEmbeddedAnimationPlayer) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL       string `json:"url"`       // URL of the external animation player
		Thumbnail *Photo `json:"thumbnail"` // Thumbnail of the animation; may be null if unknown
		Duration  int32  `json:"duration"`  // Duration of the animation, in seconds
		Width     int32  `json:"width"`     // Expected width of the embedded player
		Height    int32  `json:"height"`    // Expected height of the embedded player
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeEmbeddedAnimationPlayer.tdCommon = tempObj.tdCommon
	linkPreviewTypeEmbeddedAnimationPlayer.URL = tempObj.URL
	linkPreviewTypeEmbeddedAnimationPlayer.Thumbnail = tempObj.Thumbnail
	linkPreviewTypeEmbeddedAnimationPlayer.Duration = tempObj.Duration
	linkPreviewTypeEmbeddedAnimationPlayer.Width = tempObj.Width
	linkPreviewTypeEmbeddedAnimationPlayer.Height = tempObj.Height

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeEmbeddedAnimationPlayer *LinkPreviewTypeEmbeddedAnimationPlayer) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeEmbeddedAnimationPlayerType
}

// LinkPreviewTypeEmbeddedAudioPlayer The link is a link to an audio player
type LinkPreviewTypeEmbeddedAudioPlayer struct {
	tdCommon
	URL       string `json:"url"`       // URL of the external audio player
	Thumbnail *Photo `json:"thumbnail"` // Thumbnail of the audio; may be null if unknown
	Duration  int32  `json:"duration"`  // Duration of the audio, in seconds
	Width     int32  `json:"width"`     // Expected width of the embedded player
	Height    int32  `json:"height"`    // Expected height of the embedded player
}

// MessageType return the string telegram-type of LinkPreviewTypeEmbeddedAudioPlayer
func (linkPreviewTypeEmbeddedAudioPlayer *LinkPreviewTypeEmbeddedAudioPlayer) MessageType() string {
	return "linkPreviewTypeEmbeddedAudioPlayer"
}

// NewLinkPreviewTypeEmbeddedAudioPlayer creates a new LinkPreviewTypeEmbeddedAudioPlayer
//
// @param uRL URL of the external audio player
// @param thumbnail Thumbnail of the audio; may be null if unknown
// @param duration Duration of the audio, in seconds
// @param width Expected width of the embedded player
// @param height Expected height of the embedded player
func NewLinkPreviewTypeEmbeddedAudioPlayer(uRL string, thumbnail *Photo, duration int32, width int32, height int32) *LinkPreviewTypeEmbeddedAudioPlayer {
	linkPreviewTypeEmbeddedAudioPlayerTemp := LinkPreviewTypeEmbeddedAudioPlayer{
		tdCommon:  tdCommon{Type: "linkPreviewTypeEmbeddedAudioPlayer"},
		URL:       uRL,
		Thumbnail: thumbnail,
		Duration:  duration,
		Width:     width,
		Height:    height,
	}

	return &linkPreviewTypeEmbeddedAudioPlayerTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeEmbeddedAudioPlayer *LinkPreviewTypeEmbeddedAudioPlayer) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL       string `json:"url"`       // URL of the external audio player
		Thumbnail *Photo `json:"thumbnail"` // Thumbnail of the audio; may be null if unknown
		Duration  int32  `json:"duration"`  // Duration of the audio, in seconds
		Width     int32  `json:"width"`     // Expected width of the embedded player
		Height    int32  `json:"height"`    // Expected height of the embedded player
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeEmbeddedAudioPlayer.tdCommon = tempObj.tdCommon
	linkPreviewTypeEmbeddedAudioPlayer.URL = tempObj.URL
	linkPreviewTypeEmbeddedAudioPlayer.Thumbnail = tempObj.Thumbnail
	linkPreviewTypeEmbeddedAudioPlayer.Duration = tempObj.Duration
	linkPreviewTypeEmbeddedAudioPlayer.Width = tempObj.Width
	linkPreviewTypeEmbeddedAudioPlayer.Height = tempObj.Height

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeEmbeddedAudioPlayer *LinkPreviewTypeEmbeddedAudioPlayer) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeEmbeddedAudioPlayerType
}

// LinkPreviewTypeEmbeddedVideoPlayer The link is a link to a video player
type LinkPreviewTypeEmbeddedVideoPlayer struct {
	tdCommon
	URL       string `json:"url"`       // URL of the external video player
	Thumbnail *Photo `json:"thumbnail"` // Thumbnail of the video; may be null if unknown
	Duration  int32  `json:"duration"`  // Duration of the video, in seconds
	Width     int32  `json:"width"`     // Expected width of the embedded player
	Height    int32  `json:"height"`    // Expected height of the embedded player
}

// MessageType return the string telegram-type of LinkPreviewTypeEmbeddedVideoPlayer
func (linkPreviewTypeEmbeddedVideoPlayer *LinkPreviewTypeEmbeddedVideoPlayer) MessageType() string {
	return "linkPreviewTypeEmbeddedVideoPlayer"
}

// NewLinkPreviewTypeEmbeddedVideoPlayer creates a new LinkPreviewTypeEmbeddedVideoPlayer
//
// @param uRL URL of the external video player
// @param thumbnail Thumbnail of the video; may be null if unknown
// @param duration Duration of the video, in seconds
// @param width Expected width of the embedded player
// @param height Expected height of the embedded player
func NewLinkPreviewTypeEmbeddedVideoPlayer(uRL string, thumbnail *Photo, duration int32, width int32, height int32) *LinkPreviewTypeEmbeddedVideoPlayer {
	linkPreviewTypeEmbeddedVideoPlayerTemp := LinkPreviewTypeEmbeddedVideoPlayer{
		tdCommon:  tdCommon{Type: "linkPreviewTypeEmbeddedVideoPlayer"},
		URL:       uRL,
		Thumbnail: thumbnail,
		Duration:  duration,
		Width:     width,
		Height:    height,
	}

	return &linkPreviewTypeEmbeddedVideoPlayerTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeEmbeddedVideoPlayer *LinkPreviewTypeEmbeddedVideoPlayer) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL       string `json:"url"`       // URL of the external video player
		Thumbnail *Photo `json:"thumbnail"` // Thumbnail of the video; may be null if unknown
		Duration  int32  `json:"duration"`  // Duration of the video, in seconds
		Width     int32  `json:"width"`     // Expected width of the embedded player
		Height    int32  `json:"height"`    // Expected height of the embedded player
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeEmbeddedVideoPlayer.tdCommon = tempObj.tdCommon
	linkPreviewTypeEmbeddedVideoPlayer.URL = tempObj.URL
	linkPreviewTypeEmbeddedVideoPlayer.Thumbnail = tempObj.Thumbnail
	linkPreviewTypeEmbeddedVideoPlayer.Duration = tempObj.Duration
	linkPreviewTypeEmbeddedVideoPlayer.Width = tempObj.Width
	linkPreviewTypeEmbeddedVideoPlayer.Height = tempObj.Height

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeEmbeddedVideoPlayer *LinkPreviewTypeEmbeddedVideoPlayer) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeEmbeddedVideoPlayerType
}

// LinkPreviewTypeExternalAudio The link is a link to an audio file
type LinkPreviewTypeExternalAudio struct {
	tdCommon
	URL      string `json:"url"`       // URL of the audio file
	MimeType string `json:"mime_type"` // MIME type of the audio file
	Duration int32  `json:"duration"`  // Duration of the audio, in seconds; 0 if unknown
}

// MessageType return the string telegram-type of LinkPreviewTypeExternalAudio
func (linkPreviewTypeExternalAudio *LinkPreviewTypeExternalAudio) MessageType() string {
	return "linkPreviewTypeExternalAudio"
}

// NewLinkPreviewTypeExternalAudio creates a new LinkPreviewTypeExternalAudio
//
// @param uRL URL of the audio file
// @param mimeType MIME type of the audio file
// @param duration Duration of the audio, in seconds; 0 if unknown
func NewLinkPreviewTypeExternalAudio(uRL string, mimeType string, duration int32) *LinkPreviewTypeExternalAudio {
	linkPreviewTypeExternalAudioTemp := LinkPreviewTypeExternalAudio{
		tdCommon: tdCommon{Type: "linkPreviewTypeExternalAudio"},
		URL:      uRL,
		MimeType: mimeType,
		Duration: duration,
	}

	return &linkPreviewTypeExternalAudioTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeExternalAudio *LinkPreviewTypeExternalAudio) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL      string `json:"url"`       // URL of the audio file
		MimeType string `json:"mime_type"` // MIME type of the audio file
		Duration int32  `json:"duration"`  // Duration of the audio, in seconds; 0 if unknown
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeExternalAudio.tdCommon = tempObj.tdCommon
	linkPreviewTypeExternalAudio.URL = tempObj.URL
	linkPreviewTypeExternalAudio.MimeType = tempObj.MimeType
	linkPreviewTypeExternalAudio.Duration = tempObj.Duration

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeExternalAudio *LinkPreviewTypeExternalAudio) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeExternalAudioType
}

// LinkPreviewTypeExternalVideo The link is a link to a video file
type LinkPreviewTypeExternalVideo struct {
	tdCommon
	URL      string `json:"url"`       // URL of the video file
	MimeType string `json:"mime_type"` // MIME type of the video file
	Width    int32  `json:"width"`     // Expected width of the video preview; 0 if unknown
	Height   int32  `json:"height"`    // Expected height of the video preview; 0 if unknown
	Duration int32  `json:"duration"`  // Duration of the video, in seconds; 0 if unknown
}

// MessageType return the string telegram-type of LinkPreviewTypeExternalVideo
func (linkPreviewTypeExternalVideo *LinkPreviewTypeExternalVideo) MessageType() string {
	return "linkPreviewTypeExternalVideo"
}

// NewLinkPreviewTypeExternalVideo creates a new LinkPreviewTypeExternalVideo
//
// @param uRL URL of the video file
// @param mimeType MIME type of the video file
// @param width Expected width of the video preview; 0 if unknown
// @param height Expected height of the video preview; 0 if unknown
// @param duration Duration of the video, in seconds; 0 if unknown
func NewLinkPreviewTypeExternalVideo(uRL string, mimeType string, width int32, height int32, duration int32) *LinkPreviewTypeExternalVideo {
	linkPreviewTypeExternalVideoTemp := LinkPreviewTypeExternalVideo{
		tdCommon: tdCommon{Type: "linkPreviewTypeExternalVideo"},
		URL:      uRL,
		MimeType: mimeType,
		Width:    width,
		Height:   height,
		Duration: duration,
	}

	return &linkPreviewTypeExternalVideoTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeExternalVideo *LinkPreviewTypeExternalVideo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL      string `json:"url"`       // URL of the video file
		MimeType string `json:"mime_type"` // MIME type of the video file
		Width    int32  `json:"width"`     // Expected width of the video preview; 0 if unknown
		Height   int32  `json:"height"`    // Expected height of the video preview; 0 if unknown
		Duration int32  `json:"duration"`  // Duration of the video, in seconds; 0 if unknown
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeExternalVideo.tdCommon = tempObj.tdCommon
	linkPreviewTypeExternalVideo.URL = tempObj.URL
	linkPreviewTypeExternalVideo.MimeType = tempObj.MimeType
	linkPreviewTypeExternalVideo.Width = tempObj.Width
	linkPreviewTypeExternalVideo.Height = tempObj.Height
	linkPreviewTypeExternalVideo.Duration = tempObj.Duration

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeExternalVideo *LinkPreviewTypeExternalVideo) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeExternalVideoType
}

// LinkPreviewTypeInvoice The link is a link to an invoice
type LinkPreviewTypeInvoice struct {
	tdCommon
}

// MessageType return the string telegram-type of LinkPreviewTypeInvoice
func (linkPreviewTypeInvoice *LinkPreviewTypeInvoice) MessageType() string {
	return "linkPreviewTypeInvoice"
}

// NewLinkPreviewTypeInvoice creates a new LinkPreviewTypeInvoice
//
func NewLinkPreviewTypeInvoice() *LinkPreviewTypeInvoice {
	linkPreviewTypeInvoiceTemp := LinkPreviewTypeInvoice{
		tdCommon: tdCommon{Type: "linkPreviewTypeInvoice"},
	}

	return &linkPreviewTypeInvoiceTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeInvoice *LinkPreviewTypeInvoice) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeInvoice.tdCommon = tempObj.tdCommon

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeInvoice *LinkPreviewTypeInvoice) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeInvoiceType
}

// LinkPreviewTypeMessage The link is a link to a text or a poll Telegram message
type LinkPreviewTypeMessage struct {
	tdCommon
}

// MessageType return the string telegram-type of LinkPreviewTypeMessage
func (linkPreviewTypeMessage *LinkPreviewTypeMessage) MessageType() string {
	return "linkPreviewTypeMessage"
}

// NewLinkPreviewTypeMessage creates a new LinkPreviewTypeMessage
//
func NewLinkPreviewTypeMessage() *LinkPreviewTypeMessage {
	linkPreviewTypeMessageTemp := LinkPreviewTypeMessage{
		tdCommon: tdCommon{Type: "linkPreviewTypeMessage"},
	}

	return &linkPreviewTypeMessageTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeMessage *LinkPreviewTypeMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeMessage.tdCommon = tempObj.tdCommon

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeMessage *LinkPreviewTypeMessage) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeMessageType
}

// LinkPreviewTypePhoto The link is a link to a photo
type LinkPreviewTypePhoto struct {
	tdCommon
	Photo *Photo `json:"photo"` // The photo
}

// MessageType return the string telegram-type of LinkPreviewTypePhoto
func (linkPreviewTypePhoto *LinkPreviewTypePhoto) MessageType() string {
	return "linkPreviewTypePhoto"
}

// NewLinkPreviewTypePhoto creates a new LinkPreviewTypePhoto
//
// @param photo The photo
func NewLinkPreviewTypePhoto(photo *Photo) *LinkPreviewTypePhoto {
	linkPreviewTypePhotoTemp := LinkPreviewTypePhoto{
		tdCommon: tdCommon{Type: "linkPreviewTypePhoto"},
		Photo:    photo,
	}

	return &linkPreviewTypePhotoTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypePhoto *LinkPreviewTypePhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Photo *Photo `json:"photo"` // The photo
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypePhoto.tdCommon = tempObj.tdCommon
	linkPreviewTypePhoto.Photo = tempObj.Photo

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypePhoto *LinkPreviewTypePhoto) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypePhotoType
}

// LinkPreviewTypePremiumGiftCode The link is a link to a Telegram Premium gift code
type LinkPreviewTypePremiumGiftCode struct {
	tdCommon
}

// MessageType return the string telegram-type of LinkPreviewTypePremiumGiftCode
func (linkPreviewTypePremiumGiftCode *LinkPreviewTypePremiumGiftCode) MessageType() string {
	return "linkPreviewTypePremiumGiftCode"
}

// NewLinkPreviewTypePremiumGiftCode creates a new LinkPreviewTypePremiumGiftCode
//
func NewLinkPreviewTypePremiumGiftCode() *LinkPreviewTypePremiumGiftCode {
	linkPreviewTypePremiumGiftCodeTemp := LinkPreviewTypePremiumGiftCode{
		tdCommon: tdCommon{Type: "linkPreviewTypePremiumGiftCode"},
	}

	return &linkPreviewTypePremiumGiftCodeTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypePremiumGiftCode *LinkPreviewTypePremiumGiftCode) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypePremiumGiftCode.tdCommon = tempObj.tdCommon

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypePremiumGiftCode *LinkPreviewTypePremiumGiftCode) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypePremiumGiftCodeType
}

// LinkPreviewTypeShareableChatFolder The link is a link to a shareable chat folder
type LinkPreviewTypeShareableChatFolder struct {
	tdCommon
}

// MessageType return the string telegram-type of LinkPreviewTypeShareableChatFolder
func (linkPreviewTypeShareableChatFolder *LinkPreviewTypeShareableChatFolder) MessageType() string {
	return "linkPreviewTypeShareableChatFolder"
}

// NewLinkPreviewTypeShareableChatFolder creates a new LinkPreviewTypeShareableChatFolder
//
func NewLinkPreviewTypeShareableChatFolder() *LinkPreviewTypeShareableChatFolder {
	linkPreviewTypeShareableChatFolderTemp := LinkPreviewTypeShareableChatFolder{
		tdCommon: tdCommon{Type: "linkPreviewTypeShareableChatFolder"},
	}

	return &linkPreviewTypeShareableChatFolderTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeShareableChatFolder *LinkPreviewTypeShareableChatFolder) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeShareableChatFolder.tdCommon = tempObj.tdCommon

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeShareableChatFolder *LinkPreviewTypeShareableChatFolder) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeShareableChatFolderType
}

// LinkPreviewTypeSticker The link is a link to a sticker
type LinkPreviewTypeSticker struct {
	tdCommon
	Sticker *Sticker `json:"sticker"` // The sticker. It can be an arbitrary WEBP image and can have dimensions bigger than 512
}

// MessageType return the string telegram-type of LinkPreviewTypeSticker
func (linkPreviewTypeSticker *LinkPreviewTypeSticker) MessageType() string {
	return "linkPreviewTypeSticker"
}

// NewLinkPreviewTypeSticker creates a new LinkPreviewTypeSticker
//
// @param sticker The sticker. It can be an arbitrary WEBP image and can have dimensions bigger than 512
func NewLinkPreviewTypeSticker(sticker *Sticker) *LinkPreviewTypeSticker {
	linkPreviewTypeStickerTemp := LinkPreviewTypeSticker{
		tdCommon: tdCommon{Type: "linkPreviewTypeSticker"},
		Sticker:  sticker,
	}

	return &linkPreviewTypeStickerTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeSticker *LinkPreviewTypeSticker) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeSticker.tdCommon = tempObj.tdCommon

	var sticker Sticker
	if objMap["sticker"] != nil {
		err = sticker.UnmarshalJSON(*objMap["sticker"])
		if err != nil {
			return err
		}
	}

	linkPreviewTypeSticker.Sticker = &sticker

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeSticker *LinkPreviewTypeSticker) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeStickerType
}

// LinkPreviewTypeStickerSet The link is a link to a sticker set
type LinkPreviewTypeStickerSet struct {
	tdCommon
	Stickers []Sticker `json:"stickers"` // Up to 4 stickers from the sticker set
}

// MessageType return the string telegram-type of LinkPreviewTypeStickerSet
func (linkPreviewTypeStickerSet *LinkPreviewTypeStickerSet) MessageType() string {
	return "linkPreviewTypeStickerSet"
}

// NewLinkPreviewTypeStickerSet creates a new LinkPreviewTypeStickerSet
//
// @param stickers Up to 4 stickers from the sticker set
func NewLinkPreviewTypeStickerSet(stickers []Sticker) *LinkPreviewTypeStickerSet {
	linkPreviewTypeStickerSetTemp := LinkPreviewTypeStickerSet{
		tdCommon: tdCommon{Type: "linkPreviewTypeStickerSet"},
		Stickers: stickers,
	}

	return &linkPreviewTypeStickerSetTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeStickerSet *LinkPreviewTypeStickerSet) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Stickers []Sticker `json:"stickers"` // Up to 4 stickers from the sticker set
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeStickerSet.tdCommon = tempObj.tdCommon
	linkPreviewTypeStickerSet.Stickers = tempObj.Stickers

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeStickerSet *LinkPreviewTypeStickerSet) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeStickerSetType
}

// LinkPreviewTypeStory The link is a link to a story. Link preview description is unavailable
type LinkPreviewTypeStory struct {
	tdCommon
	StorySenderChatID int64 `json:"story_sender_chat_id"` // The identifier of the chat that posted the story
	StoryID           int32 `json:"story_id"`             // Story identifier
}

// MessageType return the string telegram-type of LinkPreviewTypeStory
func (linkPreviewTypeStory *LinkPreviewTypeStory) MessageType() string {
	return "linkPreviewTypeStory"
}

// NewLinkPreviewTypeStory creates a new LinkPreviewTypeStory
//
// @param storySenderChatID The identifier of the chat that posted the story
// @param storyID Story identifier
func NewLinkPreviewTypeStory(storySenderChatID int64, storyID int32) *LinkPreviewTypeStory {
	linkPreviewTypeStoryTemp := LinkPreviewTypeStory{
		tdCommon:          tdCommon{Type: "linkPreviewTypeStory"},
		StorySenderChatID: storySenderChatID,
		StoryID:           storyID,
	}

	return &linkPreviewTypeStoryTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeStory *LinkPreviewTypeStory) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StorySenderChatID int64 `json:"story_sender_chat_id"` // The identifier of the chat that posted the story
		StoryID           int32 `json:"story_id"`             // Story identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeStory.tdCommon = tempObj.tdCommon
	linkPreviewTypeStory.StorySenderChatID = tempObj.StorySenderChatID
	linkPreviewTypeStory.StoryID = tempObj.StoryID

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeStory *LinkPreviewTypeStory) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeStoryType
}

// LinkPreviewTypeSupergroupBoost The link is a link to boost a supergroup chat
type LinkPreviewTypeSupergroupBoost struct {
	tdCommon
	Photo *ChatPhoto `json:"photo"` // Photo of the chat; may be null
}

// MessageType return the string telegram-type of LinkPreviewTypeSupergroupBoost
func (linkPreviewTypeSupergroupBoost *LinkPreviewTypeSupergroupBoost) MessageType() string {
	return "linkPreviewTypeSupergroupBoost"
}

// NewLinkPreviewTypeSupergroupBoost creates a new LinkPreviewTypeSupergroupBoost
//
// @param photo Photo of the chat; may be null
func NewLinkPreviewTypeSupergroupBoost(photo *ChatPhoto) *LinkPreviewTypeSupergroupBoost {
	linkPreviewTypeSupergroupBoostTemp := LinkPreviewTypeSupergroupBoost{
		tdCommon: tdCommon{Type: "linkPreviewTypeSupergroupBoost"},
		Photo:    photo,
	}

	return &linkPreviewTypeSupergroupBoostTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeSupergroupBoost *LinkPreviewTypeSupergroupBoost) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Photo *ChatPhoto `json:"photo"` // Photo of the chat; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeSupergroupBoost.tdCommon = tempObj.tdCommon
	linkPreviewTypeSupergroupBoost.Photo = tempObj.Photo

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeSupergroupBoost *LinkPreviewTypeSupergroupBoost) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeSupergroupBoostType
}

// LinkPreviewTypeTheme The link is a link to a cloud theme. TDLib has no theme support yet
type LinkPreviewTypeTheme struct {
	tdCommon
	Documents []Document     `json:"documents"` // The list of files with theme description
	Settings  *ThemeSettings `json:"settings"`  // Settings for the cloud theme
}

// MessageType return the string telegram-type of LinkPreviewTypeTheme
func (linkPreviewTypeTheme *LinkPreviewTypeTheme) MessageType() string {
	return "linkPreviewTypeTheme"
}

// NewLinkPreviewTypeTheme creates a new LinkPreviewTypeTheme
//
// @param documents The list of files with theme description
// @param settings Settings for the cloud theme
func NewLinkPreviewTypeTheme(documents []Document, settings *ThemeSettings) *LinkPreviewTypeTheme {
	linkPreviewTypeThemeTemp := LinkPreviewTypeTheme{
		tdCommon:  tdCommon{Type: "linkPreviewTypeTheme"},
		Documents: documents,
		Settings:  settings,
	}

	return &linkPreviewTypeThemeTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeTheme *LinkPreviewTypeTheme) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Documents []Document `json:"documents"` // The list of files with theme description

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeTheme.tdCommon = tempObj.tdCommon
	linkPreviewTypeTheme.Documents = tempObj.Documents

	var settings ThemeSettings
	if objMap["settings"] != nil {
		err = settings.UnmarshalJSON(*objMap["settings"])
		if err != nil {
			return err
		}
	}

	linkPreviewTypeTheme.Settings = &settings

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeTheme *LinkPreviewTypeTheme) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeThemeType
}

// LinkPreviewTypeUnsupported The link preview type is unsupported yet
type LinkPreviewTypeUnsupported struct {
	tdCommon
}

// MessageType return the string telegram-type of LinkPreviewTypeUnsupported
func (linkPreviewTypeUnsupported *LinkPreviewTypeUnsupported) MessageType() string {
	return "linkPreviewTypeUnsupported"
}

// NewLinkPreviewTypeUnsupported creates a new LinkPreviewTypeUnsupported
//
func NewLinkPreviewTypeUnsupported() *LinkPreviewTypeUnsupported {
	linkPreviewTypeUnsupportedTemp := LinkPreviewTypeUnsupported{
		tdCommon: tdCommon{Type: "linkPreviewTypeUnsupported"},
	}

	return &linkPreviewTypeUnsupportedTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeUnsupported *LinkPreviewTypeUnsupported) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeUnsupported.tdCommon = tempObj.tdCommon

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeUnsupported *LinkPreviewTypeUnsupported) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeUnsupportedType
}

// LinkPreviewTypeUser The link is a link to a user
type LinkPreviewTypeUser struct {
	tdCommon
	Photo *ChatPhoto `json:"photo"`  // Photo of the user; may be null if none
	IsBot bool       `json:"is_bot"` // True, if the user is a bot
}

// MessageType return the string telegram-type of LinkPreviewTypeUser
func (linkPreviewTypeUser *LinkPreviewTypeUser) MessageType() string {
	return "linkPreviewTypeUser"
}

// NewLinkPreviewTypeUser creates a new LinkPreviewTypeUser
//
// @param photo Photo of the user; may be null if none
// @param isBot True, if the user is a bot
func NewLinkPreviewTypeUser(photo *ChatPhoto, isBot bool) *LinkPreviewTypeUser {
	linkPreviewTypeUserTemp := LinkPreviewTypeUser{
		tdCommon: tdCommon{Type: "linkPreviewTypeUser"},
		Photo:    photo,
		IsBot:    isBot,
	}

	return &linkPreviewTypeUserTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeUser *LinkPreviewTypeUser) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Photo *ChatPhoto `json:"photo"`  // Photo of the user; may be null if none
		IsBot bool       `json:"is_bot"` // True, if the user is a bot
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeUser.tdCommon = tempObj.tdCommon
	linkPreviewTypeUser.Photo = tempObj.Photo
	linkPreviewTypeUser.IsBot = tempObj.IsBot

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeUser *LinkPreviewTypeUser) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeUserType
}

// LinkPreviewTypeVideo The link is a link to a video
type LinkPreviewTypeVideo struct {
	tdCommon
	Video *Video `json:"video"` // The video description
}

// MessageType return the string telegram-type of LinkPreviewTypeVideo
func (linkPreviewTypeVideo *LinkPreviewTypeVideo) MessageType() string {
	return "linkPreviewTypeVideo"
}

// NewLinkPreviewTypeVideo creates a new LinkPreviewTypeVideo
//
// @param video The video description
func NewLinkPreviewTypeVideo(video *Video) *LinkPreviewTypeVideo {
	linkPreviewTypeVideoTemp := LinkPreviewTypeVideo{
		tdCommon: tdCommon{Type: "linkPreviewTypeVideo"},
		Video:    video,
	}

	return &linkPreviewTypeVideoTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeVideo *LinkPreviewTypeVideo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Video *Video `json:"video"` // The video description
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeVideo.tdCommon = tempObj.tdCommon
	linkPreviewTypeVideo.Video = tempObj.Video

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeVideo *LinkPreviewTypeVideo) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeVideoType
}

// LinkPreviewTypeVideoChat The link is a link to a video chat
type LinkPreviewTypeVideoChat struct {
	tdCommon
	Photo        *ChatPhoto `json:"photo"`          // Photo of the chat with the video chat; may be null if none
	IsLiveStream bool       `json:"is_live_stream"` // True, if the video chat is expected to be a live stream in a channel or a broadcast group
}

// MessageType return the string telegram-type of LinkPreviewTypeVideoChat
func (linkPreviewTypeVideoChat *LinkPreviewTypeVideoChat) MessageType() string {
	return "linkPreviewTypeVideoChat"
}

// NewLinkPreviewTypeVideoChat creates a new LinkPreviewTypeVideoChat
//
// @param photo Photo of the chat with the video chat; may be null if none
// @param isLiveStream True, if the video chat is expected to be a live stream in a channel or a broadcast group
func NewLinkPreviewTypeVideoChat(photo *ChatPhoto, isLiveStream bool) *LinkPreviewTypeVideoChat {
	linkPreviewTypeVideoChatTemp := LinkPreviewTypeVideoChat{
		tdCommon:     tdCommon{Type: "linkPreviewTypeVideoChat"},
		Photo:        photo,
		IsLiveStream: isLiveStream,
	}

	return &linkPreviewTypeVideoChatTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeVideoChat *LinkPreviewTypeVideoChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Photo        *ChatPhoto `json:"photo"`          // Photo of the chat with the video chat; may be null if none
		IsLiveStream bool       `json:"is_live_stream"` // True, if the video chat is expected to be a live stream in a channel or a broadcast group
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeVideoChat.tdCommon = tempObj.tdCommon
	linkPreviewTypeVideoChat.Photo = tempObj.Photo
	linkPreviewTypeVideoChat.IsLiveStream = tempObj.IsLiveStream

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeVideoChat *LinkPreviewTypeVideoChat) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeVideoChatType
}

// LinkPreviewTypeVideoNote The link is a link to a video note message
type LinkPreviewTypeVideoNote struct {
	tdCommon
	VideoNote *VideoNote `json:"video_note"` // The video note
}

// MessageType return the string telegram-type of LinkPreviewTypeVideoNote
func (linkPreviewTypeVideoNote *LinkPreviewTypeVideoNote) MessageType() string {
	return "linkPreviewTypeVideoNote"
}

// NewLinkPreviewTypeVideoNote creates a new LinkPreviewTypeVideoNote
//
// @param videoNote The video note
func NewLinkPreviewTypeVideoNote(videoNote *VideoNote) *LinkPreviewTypeVideoNote {
	linkPreviewTypeVideoNoteTemp := LinkPreviewTypeVideoNote{
		tdCommon:  tdCommon{Type: "linkPreviewTypeVideoNote"},
		VideoNote: videoNote,
	}

	return &linkPreviewTypeVideoNoteTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeVideoNote *LinkPreviewTypeVideoNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeVideoNote.tdCommon = tempObj.tdCommon

	var videoNote VideoNote
	if objMap["video_note"] != nil {
		err = videoNote.UnmarshalJSON(*objMap["video_note"])
		if err != nil {
			return err
		}
	}

	linkPreviewTypeVideoNote.VideoNote = &videoNote

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeVideoNote *LinkPreviewTypeVideoNote) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeVideoNoteType
}

// LinkPreviewTypeVoiceNote The link is a link to a voice note message
type LinkPreviewTypeVoiceNote struct {
	tdCommon
	VoiceNote *VoiceNote `json:"voice_note"` // The voice note
}

// MessageType return the string telegram-type of LinkPreviewTypeVoiceNote
func (linkPreviewTypeVoiceNote *LinkPreviewTypeVoiceNote) MessageType() string {
	return "linkPreviewTypeVoiceNote"
}

// NewLinkPreviewTypeVoiceNote creates a new LinkPreviewTypeVoiceNote
//
// @param voiceNote The voice note
func NewLinkPreviewTypeVoiceNote(voiceNote *VoiceNote) *LinkPreviewTypeVoiceNote {
	linkPreviewTypeVoiceNoteTemp := LinkPreviewTypeVoiceNote{
		tdCommon:  tdCommon{Type: "linkPreviewTypeVoiceNote"},
		VoiceNote: voiceNote,
	}

	return &linkPreviewTypeVoiceNoteTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeVoiceNote *LinkPreviewTypeVoiceNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeVoiceNote.tdCommon = tempObj.tdCommon

	var voiceNote VoiceNote
	if objMap["voice_note"] != nil {
		err = voiceNote.UnmarshalJSON(*objMap["voice_note"])
		if err != nil {
			return err
		}
	}

	linkPreviewTypeVoiceNote.VoiceNote = &voiceNote

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeVoiceNote *LinkPreviewTypeVoiceNote) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeVoiceNoteType
}

// LinkPreviewTypeWebApp The link is a link to a Web App
type LinkPreviewTypeWebApp struct {
	tdCommon
	Photo *Photo `json:"photo"` // Web App photo
}

// MessageType return the string telegram-type of LinkPreviewTypeWebApp
func (linkPreviewTypeWebApp *LinkPreviewTypeWebApp) MessageType() string {
	return "linkPreviewTypeWebApp"
}

// NewLinkPreviewTypeWebApp creates a new LinkPreviewTypeWebApp
//
// @param photo Web App photo
func NewLinkPreviewTypeWebApp(photo *Photo) *LinkPreviewTypeWebApp {
	linkPreviewTypeWebAppTemp := LinkPreviewTypeWebApp{
		tdCommon: tdCommon{Type: "linkPreviewTypeWebApp"},
		Photo:    photo,
	}

	return &linkPreviewTypeWebAppTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreviewTypeWebApp *LinkPreviewTypeWebApp) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Photo *Photo `json:"photo"` // Web App photo
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreviewTypeWebApp.tdCommon = tempObj.tdCommon
	linkPreviewTypeWebApp.Photo = tempObj.Photo

	return nil
}

// GetLinkPreviewTypeEnum return the enum type of this object
func (linkPreviewTypeWebApp *LinkPreviewTypeWebApp) GetLinkPreviewTypeEnum() LinkPreviewTypeEnum {
	return LinkPreviewTypeWebAppType
}

// LinkPreview Describes a link preview
type LinkPreview struct {
	tdCommon
	URL                       string          `json:"url"`                          // Original URL of the link
	DisplayURL                string          `json:"display_url"`                  // URL to display
	SiteName                  string          `json:"site_name"`                    // Short name of the site (e.g., Google Docs, App Store)
	Title                     string          `json:"title"`                        // Title of the content
	Description               *FormattedText  `json:"description"`                  // Description of the content
	Author                    string          `json:"author"`                       // Author of the content
	Type                      LinkPreviewType `json:"type"`                         // Type of the link preview
	HasLargeMedia             bool            `json:"has_large_media"`              // True, if size of media in the preview can be changed
	ShowLargeMedia            bool            `json:"show_large_media"`             // True, if large media preview must be shown; otherwise, the media preview must be shown small and only the first frame must be shown for videos
	ShowMediaAboveDescription bool            `json:"show_media_above_description"` // True, if media must be shown above link preview description; otherwise, the media must be shown below the description
	SkipConfirmation          bool            `json:"skip_confirmation"`            // True, if there is no need to show an ordinary open URL confirmation, when opening the URL from the preview, because the URL is shown in the message text in clear
	ShowAboveText             bool            `json:"show_above_text"`              // True, if the link preview must be shown above message text; otherwise, the link preview must be shown below the message text
	InstantViewVersion        int32           `json:"instant_view_version"`         // Version of instant view (currently, can be 1 or 2) for the web page; 0 if none
}

// MessageType return the string telegram-type of LinkPreview
func (linkPreview *LinkPreview) MessageType() string {
	return "linkPreview"
}

// NewLinkPreview creates a new LinkPreview
//
// @param uRL Original URL of the link
// @param displayURL URL to display
// @param siteName Short name of the site (e.g., Google Docs, App Store)
// @param title Title of the content
// @param description Description of the content
// @param author Author of the content
// @param typeParam Type of the link preview
// @param hasLargeMedia True, if size of media in the preview can be changed
// @param showLargeMedia True, if large media preview must be shown; otherwise, the media preview must be shown small and only the first frame must be shown for videos
// @param showMediaAboveDescription True, if media must be shown above link preview description; otherwise, the media must be shown below the description
// @param skipConfirmation True, if there is no need to show an ordinary open URL confirmation, when opening the URL from the preview, because the URL is shown in the message text in clear
// @param showAboveText True, if the link preview must be shown above message text; otherwise, the link preview must be shown below the message text
// @param instantViewVersion Version of instant view (currently, can be 1 or 2) for the web page; 0 if none
func NewLinkPreview(uRL string, displayURL string, siteName string, title string, description *FormattedText, author string, typeParam LinkPreviewType, hasLargeMedia bool, showLargeMedia bool, showMediaAboveDescription bool, skipConfirmation bool, showAboveText bool, instantViewVersion int32) *LinkPreview {
	linkPreviewTemp := LinkPreview{
		tdCommon:                  tdCommon{Type: "linkPreview"},
		URL:                       uRL,
		DisplayURL:                displayURL,
		SiteName:                  siteName,
		Title:                     title,
		Description:               description,
		Author:                    author,
		Type:                      typeParam,
		HasLargeMedia:             hasLargeMedia,
		ShowLargeMedia:            showLargeMedia,
		ShowMediaAboveDescription: showMediaAboveDescription,
		SkipConfirmation:          skipConfirmation,
		ShowAboveText:             showAboveText,
		InstantViewVersion:        instantViewVersion,
	}

	return &linkPreviewTemp
}

// UnmarshalJSON unmarshal to json
func (linkPreview *LinkPreview) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL                       string         `json:"url"`                          // Original URL of the link
		DisplayURL                string         `json:"display_url"`                  // URL to display
		SiteName                  string         `json:"site_name"`                    // Short name of the site (e.g., Google Docs, App Store)
		Title                     string         `json:"title"`                        // Title of the content
		Description               *FormattedText `json:"description"`                  // Description of the content
		Author                    string         `json:"author"`                       // Author of the content
		HasLargeMedia             bool           `json:"has_large_media"`              // True, if size of media in the preview can be changed
		ShowLargeMedia            bool           `json:"show_large_media"`             // True, if large media preview must be shown; otherwise, the media preview must be shown small and only the first frame must be shown for videos
		ShowMediaAboveDescription bool           `json:"show_media_above_description"` // True, if media must be shown above link preview description; otherwise, the media must be shown below the description
		SkipConfirmation          bool           `json:"skip_confirmation"`            // True, if there is no need to show an ordinary open URL confirmation, when opening the URL from the preview, because the URL is shown in the message text in clear
		ShowAboveText             bool           `json:"show_above_text"`              // True, if the link preview must be shown above message text; otherwise, the link preview must be shown below the message text
		InstantViewVersion        int32          `json:"instant_view_version"`         // Version of instant view (currently, can be 1 or 2) for the web page; 0 if none
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	linkPreview.tdCommon = tempObj.tdCommon
	linkPreview.URL = tempObj.URL
	linkPreview.DisplayURL = tempObj.DisplayURL
	linkPreview.SiteName = tempObj.SiteName
	linkPreview.Title = tempObj.Title
	linkPreview.Description = tempObj.Description
	linkPreview.Author = tempObj.Author
	linkPreview.HasLargeMedia = tempObj.HasLargeMedia
	linkPreview.ShowLargeMedia = tempObj.ShowLargeMedia
	linkPreview.ShowMediaAboveDescription = tempObj.ShowMediaAboveDescription
	linkPreview.SkipConfirmation = tempObj.SkipConfirmation
	linkPreview.ShowAboveText = tempObj.ShowAboveText
	linkPreview.InstantViewVersion = tempObj.InstantViewVersion

	fieldType, _ := unmarshalLinkPreviewType(objMap["type"])
	linkPreview.Type = fieldType

	return nil
}

// CountryInfo Contains information about a country
type CountryInfo struct {
	tdCommon
	CountryCode  string   `json:"country_code"`  // A two-letter ISO 3166-1 alpha-2 country code
	Name         string   `json:"name"`          // Native name of the country
	EnglishName  string   `json:"english_name"`  // English name of the country
	IsHidden     bool     `json:"is_hidden"`     // True, if the country must be hidden from the list of all countries
	CallingCodes []string `json:"calling_codes"` // List of country calling codes
}

// MessageType return the string telegram-type of CountryInfo
func (countryInfo *CountryInfo) MessageType() string {
	return "countryInfo"
}

// NewCountryInfo creates a new CountryInfo
//
// @param countryCode A two-letter ISO 3166-1 alpha-2 country code
// @param name Native name of the country
// @param englishName English name of the country
// @param isHidden True, if the country must be hidden from the list of all countries
// @param callingCodes List of country calling codes
func NewCountryInfo(countryCode string, name string, englishName string, isHidden bool, callingCodes []string) *CountryInfo {
	countryInfoTemp := CountryInfo{
		tdCommon:     tdCommon{Type: "countryInfo"},
		CountryCode:  countryCode,
		Name:         name,
		EnglishName:  englishName,
		IsHidden:     isHidden,
		CallingCodes: callingCodes,
	}

	return &countryInfoTemp
}

// UnmarshalJSON unmarshal to json
func (countryInfo *CountryInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CountryCode  string   `json:"country_code"`  // A two-letter ISO 3166-1 alpha-2 country code
		Name         string   `json:"name"`          // Native name of the country
		EnglishName  string   `json:"english_name"`  // English name of the country
		IsHidden     bool     `json:"is_hidden"`     // True, if the country must be hidden from the list of all countries
		CallingCodes []string `json:"calling_codes"` // List of country calling codes
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	countryInfo.tdCommon = tempObj.tdCommon
	countryInfo.CountryCode = tempObj.CountryCode
	countryInfo.Name = tempObj.Name
	countryInfo.EnglishName = tempObj.EnglishName
	countryInfo.IsHidden = tempObj.IsHidden
	countryInfo.CallingCodes = tempObj.CallingCodes

	return nil
}

// Countries Contains information about countries
type Countries struct {
	tdCommon
	Countries []CountryInfo `json:"countries"` // The list of countries
}

// MessageType return the string telegram-type of Countries
func (countries *Countries) MessageType() string {
	return "countries"
}

// NewCountries creates a new Countries
//
// @param countries The list of countries
func NewCountries(countries []CountryInfo) *Countries {
	countriesTemp := Countries{
		tdCommon:  tdCommon{Type: "countries"},
		Countries: countries,
	}

	return &countriesTemp
}

// UnmarshalJSON unmarshal to json
func (countries *Countries) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Countries []CountryInfo `json:"countries"` // The list of countries
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	countries.tdCommon = tempObj.tdCommon
	countries.Countries = tempObj.Countries

	return nil
}

// PhoneNumberInfo Contains information about a phone number
type PhoneNumberInfo struct {
	tdCommon
	Country              *CountryInfo `json:"country"`                // Information about the country to which the phone number belongs; may be null
	CountryCallingCode   string       `json:"country_calling_code"`   // The part of the phone number denoting country calling code or its part
	FormattedPhoneNumber string       `json:"formatted_phone_number"` // The phone number without country calling code formatted accordingly to local rules. Expected digits are returned as '-', but even more digits might be entered by the user
	IsAnonymous          bool         `json:"is_anonymous"`           // True, if the phone number was bought at https://fragment.com and isn't tied to a SIM card. Information about the phone number can be received using getCollectibleItemInfo
}

// MessageType return the string telegram-type of PhoneNumberInfo
func (phoneNumberInfo *PhoneNumberInfo) MessageType() string {
	return "phoneNumberInfo"
}

// NewPhoneNumberInfo creates a new PhoneNumberInfo
//
// @param country Information about the country to which the phone number belongs; may be null
// @param countryCallingCode The part of the phone number denoting country calling code or its part
// @param formattedPhoneNumber The phone number without country calling code formatted accordingly to local rules. Expected digits are returned as '-', but even more digits might be entered by the user
// @param isAnonymous True, if the phone number was bought at https://fragment.com and isn't tied to a SIM card. Information about the phone number can be received using getCollectibleItemInfo
func NewPhoneNumberInfo(country *CountryInfo, countryCallingCode string, formattedPhoneNumber string, isAnonymous bool) *PhoneNumberInfo {
	phoneNumberInfoTemp := PhoneNumberInfo{
		tdCommon:             tdCommon{Type: "phoneNumberInfo"},
		Country:              country,
		CountryCallingCode:   countryCallingCode,
		FormattedPhoneNumber: formattedPhoneNumber,
		IsAnonymous:          isAnonymous,
	}

	return &phoneNumberInfoTemp
}

// UnmarshalJSON unmarshal to json
func (phoneNumberInfo *PhoneNumberInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Country              *CountryInfo `json:"country"`                // Information about the country to which the phone number belongs; may be null
		CountryCallingCode   string       `json:"country_calling_code"`   // The part of the phone number denoting country calling code or its part
		FormattedPhoneNumber string       `json:"formatted_phone_number"` // The phone number without country calling code formatted accordingly to local rules. Expected digits are returned as '-', but even more digits might be entered by the user
		IsAnonymous          bool         `json:"is_anonymous"`           // True, if the phone number was bought at https://fragment.com and isn't tied to a SIM card. Information about the phone number can be received using getCollectibleItemInfo
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	phoneNumberInfo.tdCommon = tempObj.tdCommon
	phoneNumberInfo.Country = tempObj.Country
	phoneNumberInfo.CountryCallingCode = tempObj.CountryCallingCode
	phoneNumberInfo.FormattedPhoneNumber = tempObj.FormattedPhoneNumber
	phoneNumberInfo.IsAnonymous = tempObj.IsAnonymous

	return nil
}

// CollectibleItemTypeUsername A username
type CollectibleItemTypeUsername struct {
	tdCommon
	Username string `json:"username"` // The username
}

// MessageType return the string telegram-type of CollectibleItemTypeUsername
func (collectibleItemTypeUsername *CollectibleItemTypeUsername) MessageType() string {
	return "collectibleItemTypeUsername"
}

// NewCollectibleItemTypeUsername creates a new CollectibleItemTypeUsername
//
// @param username The username
func NewCollectibleItemTypeUsername(username string) *CollectibleItemTypeUsername {
	collectibleItemTypeUsernameTemp := CollectibleItemTypeUsername{
		tdCommon: tdCommon{Type: "collectibleItemTypeUsername"},
		Username: username,
	}

	return &collectibleItemTypeUsernameTemp
}

// UnmarshalJSON unmarshal to json
func (collectibleItemTypeUsername *CollectibleItemTypeUsername) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Username string `json:"username"` // The username
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	collectibleItemTypeUsername.tdCommon = tempObj.tdCommon
	collectibleItemTypeUsername.Username = tempObj.Username

	return nil
}

// GetCollectibleItemTypeEnum return the enum type of this object
func (collectibleItemTypeUsername *CollectibleItemTypeUsername) GetCollectibleItemTypeEnum() CollectibleItemTypeEnum {
	return CollectibleItemTypeUsernameType
}

// CollectibleItemTypePhoneNumber A phone number
type CollectibleItemTypePhoneNumber struct {
	tdCommon
	PhoneNumber string `json:"phone_number"` // The phone number
}

// MessageType return the string telegram-type of CollectibleItemTypePhoneNumber
func (collectibleItemTypePhoneNumber *CollectibleItemTypePhoneNumber) MessageType() string {
	return "collectibleItemTypePhoneNumber"
}

// NewCollectibleItemTypePhoneNumber creates a new CollectibleItemTypePhoneNumber
//
// @param phoneNumber The phone number
func NewCollectibleItemTypePhoneNumber(phoneNumber string) *CollectibleItemTypePhoneNumber {
	collectibleItemTypePhoneNumberTemp := CollectibleItemTypePhoneNumber{
		tdCommon:    tdCommon{Type: "collectibleItemTypePhoneNumber"},
		PhoneNumber: phoneNumber,
	}

	return &collectibleItemTypePhoneNumberTemp
}

// UnmarshalJSON unmarshal to json
func (collectibleItemTypePhoneNumber *CollectibleItemTypePhoneNumber) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PhoneNumber string `json:"phone_number"` // The phone number
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	collectibleItemTypePhoneNumber.tdCommon = tempObj.tdCommon
	collectibleItemTypePhoneNumber.PhoneNumber = tempObj.PhoneNumber

	return nil
}

// GetCollectibleItemTypeEnum return the enum type of this object
func (collectibleItemTypePhoneNumber *CollectibleItemTypePhoneNumber) GetCollectibleItemTypeEnum() CollectibleItemTypeEnum {
	return CollectibleItemTypePhoneNumberType
}

// CollectibleItemInfo Contains information about a collectible item and its last purchase
type CollectibleItemInfo struct {
	tdCommon
	PurchaseDate         int32     `json:"purchase_date"`         // Point in time (Unix timestamp) when the item was purchased
	Currency             string    `json:"currency"`              // Currency for the paid amount
	Amount               int64     `json:"amount"`                // The paid amount, in the smallest units of the currency
	Cryptocurrency       string    `json:"cryptocurrency"`        // Cryptocurrency used to pay for the item
	CryptocurrencyAmount JSONInt64 `json:"cryptocurrency_amount"` // The paid amount, in the smallest units of the cryptocurrency
	URL                  string    `json:"url"`                   // Individual URL for the item on https://fragment.com
}

// MessageType return the string telegram-type of CollectibleItemInfo
func (collectibleItemInfo *CollectibleItemInfo) MessageType() string {
	return "collectibleItemInfo"
}

// NewCollectibleItemInfo creates a new CollectibleItemInfo
//
// @param purchaseDate Point in time (Unix timestamp) when the item was purchased
// @param currency Currency for the paid amount
// @param amount The paid amount, in the smallest units of the currency
// @param cryptocurrency Cryptocurrency used to pay for the item
// @param cryptocurrencyAmount The paid amount, in the smallest units of the cryptocurrency
// @param uRL Individual URL for the item on https://fragment.com
func NewCollectibleItemInfo(purchaseDate int32, currency string, amount int64, cryptocurrency string, cryptocurrencyAmount JSONInt64, uRL string) *CollectibleItemInfo {
	collectibleItemInfoTemp := CollectibleItemInfo{
		tdCommon:             tdCommon{Type: "collectibleItemInfo"},
		PurchaseDate:         purchaseDate,
		Currency:             currency,
		Amount:               amount,
		Cryptocurrency:       cryptocurrency,
		CryptocurrencyAmount: cryptocurrencyAmount,
		URL:                  uRL,
	}

	return &collectibleItemInfoTemp
}

// UnmarshalJSON unmarshal to json
func (collectibleItemInfo *CollectibleItemInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PurchaseDate         int32     `json:"purchase_date"`         // Point in time (Unix timestamp) when the item was purchased
		Currency             string    `json:"currency"`              // Currency for the paid amount
		Amount               int64     `json:"amount"`                // The paid amount, in the smallest units of the currency
		Cryptocurrency       string    `json:"cryptocurrency"`        // Cryptocurrency used to pay for the item
		CryptocurrencyAmount JSONInt64 `json:"cryptocurrency_amount"` // The paid amount, in the smallest units of the cryptocurrency
		URL                  string    `json:"url"`                   // Individual URL for the item on https://fragment.com
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	collectibleItemInfo.tdCommon = tempObj.tdCommon
	collectibleItemInfo.PurchaseDate = tempObj.PurchaseDate
	collectibleItemInfo.Currency = tempObj.Currency
	collectibleItemInfo.Amount = tempObj.Amount
	collectibleItemInfo.Cryptocurrency = tempObj.Cryptocurrency
	collectibleItemInfo.CryptocurrencyAmount = tempObj.CryptocurrencyAmount
	collectibleItemInfo.URL = tempObj.URL

	return nil
}

// BankCardActionOpenURL Describes an action associated with a bank card number
type BankCardActionOpenURL struct {
	tdCommon
	Text string `json:"text"` // Action text
	URL  string `json:"url"`  // The URL to be opened
}

// MessageType return the string telegram-type of BankCardActionOpenURL
func (bankCardActionOpenURL *BankCardActionOpenURL) MessageType() string {
	return "bankCardActionOpenUrl"
}

// NewBankCardActionOpenURL creates a new BankCardActionOpenURL
//
// @param text Action text
// @param uRL The URL to be opened
func NewBankCardActionOpenURL(text string, uRL string) *BankCardActionOpenURL {
	bankCardActionOpenURLTemp := BankCardActionOpenURL{
		tdCommon: tdCommon{Type: "bankCardActionOpenUrl"},
		Text:     text,
		URL:      uRL,
	}

	return &bankCardActionOpenURLTemp
}

// UnmarshalJSON unmarshal to json
func (bankCardActionOpenURL *BankCardActionOpenURL) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Text string `json:"text"` // Action text
		URL  string `json:"url"`  // The URL to be opened
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	bankCardActionOpenURL.tdCommon = tempObj.tdCommon
	bankCardActionOpenURL.Text = tempObj.Text
	bankCardActionOpenURL.URL = tempObj.URL

	return nil
}

// BankCardInfo Information about a bank card
type BankCardInfo struct {
	tdCommon
	Title   string                  `json:"title"`   // Title of the bank card description
	Actions []BankCardActionOpenURL `json:"actions"` // Actions that can be done with the bank card number
}

// MessageType return the string telegram-type of BankCardInfo
func (bankCardInfo *BankCardInfo) MessageType() string {
	return "bankCardInfo"
}

// NewBankCardInfo creates a new BankCardInfo
//
// @param title Title of the bank card description
// @param actions Actions that can be done with the bank card number
func NewBankCardInfo(title string, actions []BankCardActionOpenURL) *BankCardInfo {
	bankCardInfoTemp := BankCardInfo{
		tdCommon: tdCommon{Type: "bankCardInfo"},
		Title:    title,
		Actions:  actions,
	}

	return &bankCardInfoTemp
}

// UnmarshalJSON unmarshal to json
func (bankCardInfo *BankCardInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Title   string                  `json:"title"`   // Title of the bank card description
		Actions []BankCardActionOpenURL `json:"actions"` // Actions that can be done with the bank card number
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	bankCardInfo.tdCommon = tempObj.tdCommon
	bankCardInfo.Title = tempObj.Title
	bankCardInfo.Actions = tempObj.Actions

	return nil
}

// Address Describes an address
type Address struct {
	tdCommon
	CountryCode string `json:"country_code"` // A two-letter ISO 3166-1 alpha-2 country code
	State       string `json:"state"`        // State, if applicable
	City        string `json:"city"`         // City
	StreetLine1 string `json:"street_line1"` // First line of the address
	StreetLine2 string `json:"street_line2"` // Second line of the address
	PostalCode  string `json:"postal_code"`  // Address postal code
}

// MessageType return the string telegram-type of Address
func (address *Address) MessageType() string {
	return "address"
}

// NewAddress creates a new Address
//
// @param countryCode A two-letter ISO 3166-1 alpha-2 country code
// @param state State, if applicable
// @param city City
// @param streetLine1 First line of the address
// @param streetLine2 Second line of the address
// @param postalCode Address postal code
func NewAddress(countryCode string, state string, city string, streetLine1 string, streetLine2 string, postalCode string) *Address {
	addressTemp := Address{
		tdCommon:    tdCommon{Type: "address"},
		CountryCode: countryCode,
		State:       state,
		City:        city,
		StreetLine1: streetLine1,
		StreetLine2: streetLine2,
		PostalCode:  postalCode,
	}

	return &addressTemp
}

// UnmarshalJSON unmarshal to json
func (address *Address) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CountryCode string `json:"country_code"` // A two-letter ISO 3166-1 alpha-2 country code
		State       string `json:"state"`        // State, if applicable
		City        string `json:"city"`         // City
		StreetLine1 string `json:"street_line1"` // First line of the address
		StreetLine2 string `json:"street_line2"` // Second line of the address
		PostalCode  string `json:"postal_code"`  // Address postal code
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	address.tdCommon = tempObj.tdCommon
	address.CountryCode = tempObj.CountryCode
	address.State = tempObj.State
	address.City = tempObj.City
	address.StreetLine1 = tempObj.StreetLine1
	address.StreetLine2 = tempObj.StreetLine2
	address.PostalCode = tempObj.PostalCode

	return nil
}

// LocationAddress Describes an address of a location
type LocationAddress struct {
	tdCommon
	CountryCode string `json:"country_code"` // A two-letter ISO 3166-1 alpha-2 country code
	State       string `json:"state"`        // State, if applicable; empty if unknown
	City        string `json:"city"`         // City; empty if unknown
	Street      string `json:"street"`       // The address; empty if unknown
}

// MessageType return the string telegram-type of LocationAddress
func (locationAddress *LocationAddress) MessageType() string {
	return "locationAddress"
}

// NewLocationAddress creates a new LocationAddress
//
// @param countryCode A two-letter ISO 3166-1 alpha-2 country code
// @param state State, if applicable; empty if unknown
// @param city City; empty if unknown
// @param street The address; empty if unknown
func NewLocationAddress(countryCode string, state string, city string, street string) *LocationAddress {
	locationAddressTemp := LocationAddress{
		tdCommon:    tdCommon{Type: "locationAddress"},
		CountryCode: countryCode,
		State:       state,
		City:        city,
		Street:      street,
	}

	return &locationAddressTemp
}

// UnmarshalJSON unmarshal to json
func (locationAddress *LocationAddress) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CountryCode string `json:"country_code"` // A two-letter ISO 3166-1 alpha-2 country code
		State       string `json:"state"`        // State, if applicable; empty if unknown
		City        string `json:"city"`         // City; empty if unknown
		Street      string `json:"street"`       // The address; empty if unknown
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	locationAddress.tdCommon = tempObj.tdCommon
	locationAddress.CountryCode = tempObj.CountryCode
	locationAddress.State = tempObj.State
	locationAddress.City = tempObj.City
	locationAddress.Street = tempObj.Street

	return nil
}

// ThemeParameters Contains parameters of the application theme
type ThemeParameters struct {
	tdCommon
	BackgroundColor          int32 `json:"background_color"`            // A color of the background in the RGB24 format
	SecondaryBackgroundColor int32 `json:"secondary_background_color"`  // A secondary color for the background in the RGB24 format
	HeaderBackgroundColor    int32 `json:"header_background_color"`     // A color of the header background in the RGB24 format
	BottomBarBackgroundColor int32 `json:"bottom_bar_background_color"` // A color of the bottom bar background in the RGB24 format
	SectionBackgroundColor   int32 `json:"section_background_color"`    // A color of the section background in the RGB24 format
	SectionSeparatorColor    int32 `json:"section_separator_color"`     // A color of the section separator in the RGB24 format
	TextColor                int32 `json:"text_color"`                  // A color of text in the RGB24 format
	AccentTextColor          int32 `json:"accent_text_color"`           // An accent color of the text in the RGB24 format
	SectionHeaderTextColor   int32 `json:"section_header_text_color"`   // A color of text on the section headers in the RGB24 format
	SubtitleTextColor        int32 `json:"subtitle_text_color"`         // A color of the subtitle text in the RGB24 format
	DestructiveTextColor     int32 `json:"destructive_text_color"`      // A color of the text for destructive actions in the RGB24 format
	HintColor                int32 `json:"hint_color"`                  // A color of hints in the RGB24 format
	LinkColor                int32 `json:"link_color"`                  // A color of links in the RGB24 format
	ButtonColor              int32 `json:"button_color"`                // A color of the buttons in the RGB24 format
	ButtonTextColor          int32 `json:"button_text_color"`           // A color of text on the buttons in the RGB24 format
}

// MessageType return the string telegram-type of ThemeParameters
func (themeParameters *ThemeParameters) MessageType() string {
	return "themeParameters"
}

// NewThemeParameters creates a new ThemeParameters
//
// @param backgroundColor A color of the background in the RGB24 format
// @param secondaryBackgroundColor A secondary color for the background in the RGB24 format
// @param headerBackgroundColor A color of the header background in the RGB24 format
// @param bottomBarBackgroundColor A color of the bottom bar background in the RGB24 format
// @param sectionBackgroundColor A color of the section background in the RGB24 format
// @param sectionSeparatorColor A color of the section separator in the RGB24 format
// @param textColor A color of text in the RGB24 format
// @param accentTextColor An accent color of the text in the RGB24 format
// @param sectionHeaderTextColor A color of text on the section headers in the RGB24 format
// @param subtitleTextColor A color of the subtitle text in the RGB24 format
// @param destructiveTextColor A color of the text for destructive actions in the RGB24 format
// @param hintColor A color of hints in the RGB24 format
// @param linkColor A color of links in the RGB24 format
// @param buttonColor A color of the buttons in the RGB24 format
// @param buttonTextColor A color of text on the buttons in the RGB24 format
func NewThemeParameters(backgroundColor int32, secondaryBackgroundColor int32, headerBackgroundColor int32, bottomBarBackgroundColor int32, sectionBackgroundColor int32, sectionSeparatorColor int32, textColor int32, accentTextColor int32, sectionHeaderTextColor int32, subtitleTextColor int32, destructiveTextColor int32, hintColor int32, linkColor int32, buttonColor int32, buttonTextColor int32) *ThemeParameters {
	themeParametersTemp := ThemeParameters{
		tdCommon:                 tdCommon{Type: "themeParameters"},
		BackgroundColor:          backgroundColor,
		SecondaryBackgroundColor: secondaryBackgroundColor,
		HeaderBackgroundColor:    headerBackgroundColor,
		BottomBarBackgroundColor: bottomBarBackgroundColor,
		SectionBackgroundColor:   sectionBackgroundColor,
		SectionSeparatorColor:    sectionSeparatorColor,
		TextColor:                textColor,
		AccentTextColor:          accentTextColor,
		SectionHeaderTextColor:   sectionHeaderTextColor,
		SubtitleTextColor:        subtitleTextColor,
		DestructiveTextColor:     destructiveTextColor,
		HintColor:                hintColor,
		LinkColor:                linkColor,
		ButtonColor:              buttonColor,
		ButtonTextColor:          buttonTextColor,
	}

	return &themeParametersTemp
}

// UnmarshalJSON unmarshal to json
func (themeParameters *ThemeParameters) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BackgroundColor          int32 `json:"background_color"`            // A color of the background in the RGB24 format
		SecondaryBackgroundColor int32 `json:"secondary_background_color"`  // A secondary color for the background in the RGB24 format
		HeaderBackgroundColor    int32 `json:"header_background_color"`     // A color of the header background in the RGB24 format
		BottomBarBackgroundColor int32 `json:"bottom_bar_background_color"` // A color of the bottom bar background in the RGB24 format
		SectionBackgroundColor   int32 `json:"section_background_color"`    // A color of the section background in the RGB24 format
		SectionSeparatorColor    int32 `json:"section_separator_color"`     // A color of the section separator in the RGB24 format
		TextColor                int32 `json:"text_color"`                  // A color of text in the RGB24 format
		AccentTextColor          int32 `json:"accent_text_color"`           // An accent color of the text in the RGB24 format
		SectionHeaderTextColor   int32 `json:"section_header_text_color"`   // A color of text on the section headers in the RGB24 format
		SubtitleTextColor        int32 `json:"subtitle_text_color"`         // A color of the subtitle text in the RGB24 format
		DestructiveTextColor     int32 `json:"destructive_text_color"`      // A color of the text for destructive actions in the RGB24 format
		HintColor                int32 `json:"hint_color"`                  // A color of hints in the RGB24 format
		LinkColor                int32 `json:"link_color"`                  // A color of links in the RGB24 format
		ButtonColor              int32 `json:"button_color"`                // A color of the buttons in the RGB24 format
		ButtonTextColor          int32 `json:"button_text_color"`           // A color of text on the buttons in the RGB24 format
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	themeParameters.tdCommon = tempObj.tdCommon
	themeParameters.BackgroundColor = tempObj.BackgroundColor
	themeParameters.SecondaryBackgroundColor = tempObj.SecondaryBackgroundColor
	themeParameters.HeaderBackgroundColor = tempObj.HeaderBackgroundColor
	themeParameters.BottomBarBackgroundColor = tempObj.BottomBarBackgroundColor
	themeParameters.SectionBackgroundColor = tempObj.SectionBackgroundColor
	themeParameters.SectionSeparatorColor = tempObj.SectionSeparatorColor
	themeParameters.TextColor = tempObj.TextColor
	themeParameters.AccentTextColor = tempObj.AccentTextColor
	themeParameters.SectionHeaderTextColor = tempObj.SectionHeaderTextColor
	themeParameters.SubtitleTextColor = tempObj.SubtitleTextColor
	themeParameters.DestructiveTextColor = tempObj.DestructiveTextColor
	themeParameters.HintColor = tempObj.HintColor
	themeParameters.LinkColor = tempObj.LinkColor
	themeParameters.ButtonColor = tempObj.ButtonColor
	themeParameters.ButtonTextColor = tempObj.ButtonTextColor

	return nil
}

// LabeledPricePart Portion of the price of a product (e.g., "delivery cost", "tax amount")
type LabeledPricePart struct {
	tdCommon
	Label  string `json:"label"`  // Label for this portion of the product price
	Amount int64  `json:"amount"` // Currency amount in the smallest units of the currency
}

// MessageType return the string telegram-type of LabeledPricePart
func (labeledPricePart *LabeledPricePart) MessageType() string {
	return "labeledPricePart"
}

// NewLabeledPricePart creates a new LabeledPricePart
//
// @param label Label for this portion of the product price
// @param amount Currency amount in the smallest units of the currency
func NewLabeledPricePart(label string, amount int64) *LabeledPricePart {
	labeledPricePartTemp := LabeledPricePart{
		tdCommon: tdCommon{Type: "labeledPricePart"},
		Label:    label,
		Amount:   amount,
	}

	return &labeledPricePartTemp
}

// UnmarshalJSON unmarshal to json
func (labeledPricePart *LabeledPricePart) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Label  string `json:"label"`  // Label for this portion of the product price
		Amount int64  `json:"amount"` // Currency amount in the smallest units of the currency
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	labeledPricePart.tdCommon = tempObj.tdCommon
	labeledPricePart.Label = tempObj.Label
	labeledPricePart.Amount = tempObj.Amount

	return nil
}

// Invoice Product invoice
type Invoice struct {
	tdCommon
	Currency                          string             `json:"currency"`                               // ISO 4217 currency code
	PriceParts                        []LabeledPricePart `json:"price_parts"`                            // A list of objects used to calculate the total price of the product
	MaxTipAmount                      int64              `json:"max_tip_amount"`                         // The maximum allowed amount of tip in the smallest units of the currency
	SuggestedTipAmounts               []int64            `json:"suggested_tip_amounts"`                  // Suggested amounts of tip in the smallest units of the currency
	RecurringPaymentTermsOfServiceURL string             `json:"recurring_payment_terms_of_service_url"` // An HTTP URL with terms of service for recurring payments. If non-empty, the invoice payment will result in recurring payments and the user must accept the terms of service before allowed to pay
	TermsOfServiceURL                 string             `json:"terms_of_service_url"`                   // An HTTP URL with terms of service for non-recurring payments. If non-empty, then the user must accept the terms of service before allowed to pay
	IsTest                            bool               `json:"is_test"`                                // True, if the payment is a test payment
	NeedName                          bool               `json:"need_name"`                              // True, if the user's name is needed for payment
	NeedPhoneNumber                   bool               `json:"need_phone_number"`                      // True, if the user's phone number is needed for payment
	NeedEmailAddress                  bool               `json:"need_email_address"`                     // True, if the user's email address is needed for payment
	NeedShippingAddress               bool               `json:"need_shipping_address"`                  // True, if the user's shipping address is needed for payment
	SendPhoneNumberToProvider         bool               `json:"send_phone_number_to_provider"`          // True, if the user's phone number will be sent to the provider
	SendEmailAddressToProvider        bool               `json:"send_email_address_to_provider"`         // True, if the user's email address will be sent to the provider
	IsFlexible                        bool               `json:"is_flexible"`                            // True, if the total price depends on the shipping method
}

// MessageType return the string telegram-type of Invoice
func (invoice *Invoice) MessageType() string {
	return "invoice"
}

// NewInvoice creates a new Invoice
//
// @param currency ISO 4217 currency code
// @param priceParts A list of objects used to calculate the total price of the product
// @param maxTipAmount The maximum allowed amount of tip in the smallest units of the currency
// @param suggestedTipAmounts Suggested amounts of tip in the smallest units of the currency
// @param recurringPaymentTermsOfServiceURL An HTTP URL with terms of service for recurring payments. If non-empty, the invoice payment will result in recurring payments and the user must accept the terms of service before allowed to pay
// @param termsOfServiceURL An HTTP URL with terms of service for non-recurring payments. If non-empty, then the user must accept the terms of service before allowed to pay
// @param isTest True, if the payment is a test payment
// @param needName True, if the user's name is needed for payment
// @param needPhoneNumber True, if the user's phone number is needed for payment
// @param needEmailAddress True, if the user's email address is needed for payment
// @param needShippingAddress True, if the user's shipping address is needed for payment
// @param sendPhoneNumberToProvider True, if the user's phone number will be sent to the provider
// @param sendEmailAddressToProvider True, if the user's email address will be sent to the provider
// @param isFlexible True, if the total price depends on the shipping method
func NewInvoice(currency string, priceParts []LabeledPricePart, maxTipAmount int64, suggestedTipAmounts []int64, recurringPaymentTermsOfServiceURL string, termsOfServiceURL string, isTest bool, needName bool, needPhoneNumber bool, needEmailAddress bool, needShippingAddress bool, sendPhoneNumberToProvider bool, sendEmailAddressToProvider bool, isFlexible bool) *Invoice {
	invoiceTemp := Invoice{
		tdCommon:                          tdCommon{Type: "invoice"},
		Currency:                          currency,
		PriceParts:                        priceParts,
		MaxTipAmount:                      maxTipAmount,
		SuggestedTipAmounts:               suggestedTipAmounts,
		RecurringPaymentTermsOfServiceURL: recurringPaymentTermsOfServiceURL,
		TermsOfServiceURL:                 termsOfServiceURL,
		IsTest:                            isTest,
		NeedName:                          needName,
		NeedPhoneNumber:                   needPhoneNumber,
		NeedEmailAddress:                  needEmailAddress,
		NeedShippingAddress:               needShippingAddress,
		SendPhoneNumberToProvider:         sendPhoneNumberToProvider,
		SendEmailAddressToProvider:        sendEmailAddressToProvider,
		IsFlexible:                        isFlexible,
	}

	return &invoiceTemp
}

// UnmarshalJSON unmarshal to json
func (invoice *Invoice) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Currency                          string             `json:"currency"`                               // ISO 4217 currency code
		PriceParts                        []LabeledPricePart `json:"price_parts"`                            // A list of objects used to calculate the total price of the product
		MaxTipAmount                      int64              `json:"max_tip_amount"`                         // The maximum allowed amount of tip in the smallest units of the currency
		SuggestedTipAmounts               []int64            `json:"suggested_tip_amounts"`                  // Suggested amounts of tip in the smallest units of the currency
		RecurringPaymentTermsOfServiceURL string             `json:"recurring_payment_terms_of_service_url"` // An HTTP URL with terms of service for recurring payments. If non-empty, the invoice payment will result in recurring payments and the user must accept the terms of service before allowed to pay
		TermsOfServiceURL                 string             `json:"terms_of_service_url"`                   // An HTTP URL with terms of service for non-recurring payments. If non-empty, then the user must accept the terms of service before allowed to pay
		IsTest                            bool               `json:"is_test"`                                // True, if the payment is a test payment
		NeedName                          bool               `json:"need_name"`                              // True, if the user's name is needed for payment
		NeedPhoneNumber                   bool               `json:"need_phone_number"`                      // True, if the user's phone number is needed for payment
		NeedEmailAddress                  bool               `json:"need_email_address"`                     // True, if the user's email address is needed for payment
		NeedShippingAddress               bool               `json:"need_shipping_address"`                  // True, if the user's shipping address is needed for payment
		SendPhoneNumberToProvider         bool               `json:"send_phone_number_to_provider"`          // True, if the user's phone number will be sent to the provider
		SendEmailAddressToProvider        bool               `json:"send_email_address_to_provider"`         // True, if the user's email address will be sent to the provider
		IsFlexible                        bool               `json:"is_flexible"`                            // True, if the total price depends on the shipping method
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	invoice.tdCommon = tempObj.tdCommon
	invoice.Currency = tempObj.Currency
	invoice.PriceParts = tempObj.PriceParts
	invoice.MaxTipAmount = tempObj.MaxTipAmount
	invoice.SuggestedTipAmounts = tempObj.SuggestedTipAmounts
	invoice.RecurringPaymentTermsOfServiceURL = tempObj.RecurringPaymentTermsOfServiceURL
	invoice.TermsOfServiceURL = tempObj.TermsOfServiceURL
	invoice.IsTest = tempObj.IsTest
	invoice.NeedName = tempObj.NeedName
	invoice.NeedPhoneNumber = tempObj.NeedPhoneNumber
	invoice.NeedEmailAddress = tempObj.NeedEmailAddress
	invoice.NeedShippingAddress = tempObj.NeedShippingAddress
	invoice.SendPhoneNumberToProvider = tempObj.SendPhoneNumberToProvider
	invoice.SendEmailAddressToProvider = tempObj.SendEmailAddressToProvider
	invoice.IsFlexible = tempObj.IsFlexible

	return nil
}

// OrderInfo Order information
type OrderInfo struct {
	tdCommon
	Name            string   `json:"name"`             // Name of the user
	PhoneNumber     string   `json:"phone_number"`     // Phone number of the user
	EmailAddress    string   `json:"email_address"`    // Email address of the user
	ShippingAddress *Address `json:"shipping_address"` // Shipping address for this order; may be null
}

// MessageType return the string telegram-type of OrderInfo
func (orderInfo *OrderInfo) MessageType() string {
	return "orderInfo"
}

// NewOrderInfo creates a new OrderInfo
//
// @param name Name of the user
// @param phoneNumber Phone number of the user
// @param emailAddress Email address of the user
// @param shippingAddress Shipping address for this order; may be null
func NewOrderInfo(name string, phoneNumber string, emailAddress string, shippingAddress *Address) *OrderInfo {
	orderInfoTemp := OrderInfo{
		tdCommon:        tdCommon{Type: "orderInfo"},
		Name:            name,
		PhoneNumber:     phoneNumber,
		EmailAddress:    emailAddress,
		ShippingAddress: shippingAddress,
	}

	return &orderInfoTemp
}

// UnmarshalJSON unmarshal to json
func (orderInfo *OrderInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Name            string   `json:"name"`             // Name of the user
		PhoneNumber     string   `json:"phone_number"`     // Phone number of the user
		EmailAddress    string   `json:"email_address"`    // Email address of the user
		ShippingAddress *Address `json:"shipping_address"` // Shipping address for this order; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	orderInfo.tdCommon = tempObj.tdCommon
	orderInfo.Name = tempObj.Name
	orderInfo.PhoneNumber = tempObj.PhoneNumber
	orderInfo.EmailAddress = tempObj.EmailAddress
	orderInfo.ShippingAddress = tempObj.ShippingAddress

	return nil
}

// ShippingOption One shipping option
type ShippingOption struct {
	tdCommon
	ID         string             `json:"id"`          // Shipping option identifier
	Title      string             `json:"title"`       // Option title
	PriceParts []LabeledPricePart `json:"price_parts"` // A list of objects used to calculate the total shipping costs
}

// MessageType return the string telegram-type of ShippingOption
func (shippingOption *ShippingOption) MessageType() string {
	return "shippingOption"
}

// NewShippingOption creates a new ShippingOption
//
// @param iD Shipping option identifier
// @param title Option title
// @param priceParts A list of objects used to calculate the total shipping costs
func NewShippingOption(iD string, title string, priceParts []LabeledPricePart) *ShippingOption {
	shippingOptionTemp := ShippingOption{
		tdCommon:   tdCommon{Type: "shippingOption"},
		ID:         iD,
		Title:      title,
		PriceParts: priceParts,
	}

	return &shippingOptionTemp
}

// UnmarshalJSON unmarshal to json
func (shippingOption *ShippingOption) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID         string             `json:"id"`          // Shipping option identifier
		Title      string             `json:"title"`       // Option title
		PriceParts []LabeledPricePart `json:"price_parts"` // A list of objects used to calculate the total shipping costs
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	shippingOption.tdCommon = tempObj.tdCommon
	shippingOption.ID = tempObj.ID
	shippingOption.Title = tempObj.Title
	shippingOption.PriceParts = tempObj.PriceParts

	return nil
}

// SavedCredentials Contains information about saved payment credentials
type SavedCredentials struct {
	tdCommon
	ID    string `json:"id"`    // Unique identifier of the saved credentials
	Title string `json:"title"` // Title of the saved credentials
}

// MessageType return the string telegram-type of SavedCredentials
func (savedCredentials *SavedCredentials) MessageType() string {
	return "savedCredentials"
}

// NewSavedCredentials creates a new SavedCredentials
//
// @param iD Unique identifier of the saved credentials
// @param title Title of the saved credentials
func NewSavedCredentials(iD string, title string) *SavedCredentials {
	savedCredentialsTemp := SavedCredentials{
		tdCommon: tdCommon{Type: "savedCredentials"},
		ID:       iD,
		Title:    title,
	}

	return &savedCredentialsTemp
}

// UnmarshalJSON unmarshal to json
func (savedCredentials *SavedCredentials) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID    string `json:"id"`    // Unique identifier of the saved credentials
		Title string `json:"title"` // Title of the saved credentials
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	savedCredentials.tdCommon = tempObj.tdCommon
	savedCredentials.ID = tempObj.ID
	savedCredentials.Title = tempObj.Title

	return nil
}

// InputCredentialsSaved Applies if a user chooses some previously saved payment credentials. To use their previously saved credentials, the user must have a valid temporary password
type InputCredentialsSaved struct {
	tdCommon
	SavedCredentialsID string `json:"saved_credentials_id"` // Identifier of the saved credentials
}

// MessageType return the string telegram-type of InputCredentialsSaved
func (inputCredentialsSaved *InputCredentialsSaved) MessageType() string {
	return "inputCredentialsSaved"
}

// NewInputCredentialsSaved creates a new InputCredentialsSaved
//
// @param savedCredentialsID Identifier of the saved credentials
func NewInputCredentialsSaved(savedCredentialsID string) *InputCredentialsSaved {
	inputCredentialsSavedTemp := InputCredentialsSaved{
		tdCommon:           tdCommon{Type: "inputCredentialsSaved"},
		SavedCredentialsID: savedCredentialsID,
	}

	return &inputCredentialsSavedTemp
}

// UnmarshalJSON unmarshal to json
func (inputCredentialsSaved *InputCredentialsSaved) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SavedCredentialsID string `json:"saved_credentials_id"` // Identifier of the saved credentials
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputCredentialsSaved.tdCommon = tempObj.tdCommon
	inputCredentialsSaved.SavedCredentialsID = tempObj.SavedCredentialsID

	return nil
}

// GetInputCredentialsEnum return the enum type of this object
func (inputCredentialsSaved *InputCredentialsSaved) GetInputCredentialsEnum() InputCredentialsEnum {
	return InputCredentialsSavedType
}

// InputCredentialsNew Applies if a user enters new credentials on a payment provider website
type InputCredentialsNew struct {
	tdCommon
	Data      string `json:"data"`       // JSON-encoded data with the credential identifier from the payment provider
	AllowSave bool   `json:"allow_save"` // True, if the credential identifier can be saved on the server side
}

// MessageType return the string telegram-type of InputCredentialsNew
func (inputCredentialsNew *InputCredentialsNew) MessageType() string {
	return "inputCredentialsNew"
}

// NewInputCredentialsNew creates a new InputCredentialsNew
//
// @param data JSON-encoded data with the credential identifier from the payment provider
// @param allowSave True, if the credential identifier can be saved on the server side
func NewInputCredentialsNew(data string, allowSave bool) *InputCredentialsNew {
	inputCredentialsNewTemp := InputCredentialsNew{
		tdCommon:  tdCommon{Type: "inputCredentialsNew"},
		Data:      data,
		AllowSave: allowSave,
	}

	return &inputCredentialsNewTemp
}

// UnmarshalJSON unmarshal to json
func (inputCredentialsNew *InputCredentialsNew) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Data      string `json:"data"`       // JSON-encoded data with the credential identifier from the payment provider
		AllowSave bool   `json:"allow_save"` // True, if the credential identifier can be saved on the server side
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputCredentialsNew.tdCommon = tempObj.tdCommon
	inputCredentialsNew.Data = tempObj.Data
	inputCredentialsNew.AllowSave = tempObj.AllowSave

	return nil
}

// GetInputCredentialsEnum return the enum type of this object
func (inputCredentialsNew *InputCredentialsNew) GetInputCredentialsEnum() InputCredentialsEnum {
	return InputCredentialsNewType
}

// InputCredentialsApplePay Applies if a user enters new credentials using Apple Pay
type InputCredentialsApplePay struct {
	tdCommon
	Data string `json:"data"` // JSON-encoded data with the credential identifier
}

// MessageType return the string telegram-type of InputCredentialsApplePay
func (inputCredentialsApplePay *InputCredentialsApplePay) MessageType() string {
	return "inputCredentialsApplePay"
}

// NewInputCredentialsApplePay creates a new InputCredentialsApplePay
//
// @param data JSON-encoded data with the credential identifier
func NewInputCredentialsApplePay(data string) *InputCredentialsApplePay {
	inputCredentialsApplePayTemp := InputCredentialsApplePay{
		tdCommon: tdCommon{Type: "inputCredentialsApplePay"},
		Data:     data,
	}

	return &inputCredentialsApplePayTemp
}

// UnmarshalJSON unmarshal to json
func (inputCredentialsApplePay *InputCredentialsApplePay) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Data string `json:"data"` // JSON-encoded data with the credential identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputCredentialsApplePay.tdCommon = tempObj.tdCommon
	inputCredentialsApplePay.Data = tempObj.Data

	return nil
}

// GetInputCredentialsEnum return the enum type of this object
func (inputCredentialsApplePay *InputCredentialsApplePay) GetInputCredentialsEnum() InputCredentialsEnum {
	return InputCredentialsApplePayType
}

// InputCredentialsGooglePay Applies if a user enters new credentials using Google Pay
type InputCredentialsGooglePay struct {
	tdCommon
	Data string `json:"data"` // JSON-encoded data with the credential identifier
}

// MessageType return the string telegram-type of InputCredentialsGooglePay
func (inputCredentialsGooglePay *InputCredentialsGooglePay) MessageType() string {
	return "inputCredentialsGooglePay"
}

// NewInputCredentialsGooglePay creates a new InputCredentialsGooglePay
//
// @param data JSON-encoded data with the credential identifier
func NewInputCredentialsGooglePay(data string) *InputCredentialsGooglePay {
	inputCredentialsGooglePayTemp := InputCredentialsGooglePay{
		tdCommon: tdCommon{Type: "inputCredentialsGooglePay"},
		Data:     data,
	}

	return &inputCredentialsGooglePayTemp
}

// UnmarshalJSON unmarshal to json
func (inputCredentialsGooglePay *InputCredentialsGooglePay) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Data string `json:"data"` // JSON-encoded data with the credential identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputCredentialsGooglePay.tdCommon = tempObj.tdCommon
	inputCredentialsGooglePay.Data = tempObj.Data

	return nil
}

// GetInputCredentialsEnum return the enum type of this object
func (inputCredentialsGooglePay *InputCredentialsGooglePay) GetInputCredentialsEnum() InputCredentialsEnum {
	return InputCredentialsGooglePayType
}

// PaymentProviderSmartGlocal Smart Glocal payment provider
type PaymentProviderSmartGlocal struct {
	tdCommon
	PublicToken string `json:"public_token"` // Public payment token
	TokenizeURL string `json:"tokenize_url"` // URL for sending card tokenization requests
}

// MessageType return the string telegram-type of PaymentProviderSmartGlocal
func (paymentProviderSmartGlocal *PaymentProviderSmartGlocal) MessageType() string {
	return "paymentProviderSmartGlocal"
}

// NewPaymentProviderSmartGlocal creates a new PaymentProviderSmartGlocal
//
// @param publicToken Public payment token
// @param tokenizeURL URL for sending card tokenization requests
func NewPaymentProviderSmartGlocal(publicToken string, tokenizeURL string) *PaymentProviderSmartGlocal {
	paymentProviderSmartGlocalTemp := PaymentProviderSmartGlocal{
		tdCommon:    tdCommon{Type: "paymentProviderSmartGlocal"},
		PublicToken: publicToken,
		TokenizeURL: tokenizeURL,
	}

	return &paymentProviderSmartGlocalTemp
}

// UnmarshalJSON unmarshal to json
func (paymentProviderSmartGlocal *PaymentProviderSmartGlocal) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PublicToken string `json:"public_token"` // Public payment token
		TokenizeURL string `json:"tokenize_url"` // URL for sending card tokenization requests
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	paymentProviderSmartGlocal.tdCommon = tempObj.tdCommon
	paymentProviderSmartGlocal.PublicToken = tempObj.PublicToken
	paymentProviderSmartGlocal.TokenizeURL = tempObj.TokenizeURL

	return nil
}

// GetPaymentProviderEnum return the enum type of this object
func (paymentProviderSmartGlocal *PaymentProviderSmartGlocal) GetPaymentProviderEnum() PaymentProviderEnum {
	return PaymentProviderSmartGlocalType
}

// PaymentProviderStripe Stripe payment provider
type PaymentProviderStripe struct {
	tdCommon
	PublishableKey     string `json:"publishable_key"`      // Stripe API publishable key
	NeedCountry        bool   `json:"need_country"`         // True, if the user country must be provided
	NeedPostalCode     bool   `json:"need_postal_code"`     // True, if the user ZIP/postal code must be provided
	NeedCardholderName bool   `json:"need_cardholder_name"` // True, if the cardholder name must be provided
}

// MessageType return the string telegram-type of PaymentProviderStripe
func (paymentProviderStripe *PaymentProviderStripe) MessageType() string {
	return "paymentProviderStripe"
}

// NewPaymentProviderStripe creates a new PaymentProviderStripe
//
// @param publishableKey Stripe API publishable key
// @param needCountry True, if the user country must be provided
// @param needPostalCode True, if the user ZIP/postal code must be provided
// @param needCardholderName True, if the cardholder name must be provided
func NewPaymentProviderStripe(publishableKey string, needCountry bool, needPostalCode bool, needCardholderName bool) *PaymentProviderStripe {
	paymentProviderStripeTemp := PaymentProviderStripe{
		tdCommon:           tdCommon{Type: "paymentProviderStripe"},
		PublishableKey:     publishableKey,
		NeedCountry:        needCountry,
		NeedPostalCode:     needPostalCode,
		NeedCardholderName: needCardholderName,
	}

	return &paymentProviderStripeTemp
}

// UnmarshalJSON unmarshal to json
func (paymentProviderStripe *PaymentProviderStripe) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PublishableKey     string `json:"publishable_key"`      // Stripe API publishable key
		NeedCountry        bool   `json:"need_country"`         // True, if the user country must be provided
		NeedPostalCode     bool   `json:"need_postal_code"`     // True, if the user ZIP/postal code must be provided
		NeedCardholderName bool   `json:"need_cardholder_name"` // True, if the cardholder name must be provided
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	paymentProviderStripe.tdCommon = tempObj.tdCommon
	paymentProviderStripe.PublishableKey = tempObj.PublishableKey
	paymentProviderStripe.NeedCountry = tempObj.NeedCountry
	paymentProviderStripe.NeedPostalCode = tempObj.NeedPostalCode
	paymentProviderStripe.NeedCardholderName = tempObj.NeedCardholderName

	return nil
}

// GetPaymentProviderEnum return the enum type of this object
func (paymentProviderStripe *PaymentProviderStripe) GetPaymentProviderEnum() PaymentProviderEnum {
	return PaymentProviderStripeType
}

// PaymentProviderOther Some other payment provider, for which a web payment form must be shown
type PaymentProviderOther struct {
	tdCommon
	URL string `json:"url"` // Payment form URL
}

// MessageType return the string telegram-type of PaymentProviderOther
func (paymentProviderOther *PaymentProviderOther) MessageType() string {
	return "paymentProviderOther"
}

// NewPaymentProviderOther creates a new PaymentProviderOther
//
// @param uRL Payment form URL
func NewPaymentProviderOther(uRL string) *PaymentProviderOther {
	paymentProviderOtherTemp := PaymentProviderOther{
		tdCommon: tdCommon{Type: "paymentProviderOther"},
		URL:      uRL,
	}

	return &paymentProviderOtherTemp
}

// UnmarshalJSON unmarshal to json
func (paymentProviderOther *PaymentProviderOther) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL string `json:"url"` // Payment form URL
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	paymentProviderOther.tdCommon = tempObj.tdCommon
	paymentProviderOther.URL = tempObj.URL

	return nil
}

// GetPaymentProviderEnum return the enum type of this object
func (paymentProviderOther *PaymentProviderOther) GetPaymentProviderEnum() PaymentProviderEnum {
	return PaymentProviderOtherType
}

// PaymentOption Describes an additional payment option
type PaymentOption struct {
	tdCommon
	Title string `json:"title"` // Title for the payment option
	URL   string `json:"url"`   // Payment form URL to be opened in a web view
}

// MessageType return the string telegram-type of PaymentOption
func (paymentOption *PaymentOption) MessageType() string {
	return "paymentOption"
}

// NewPaymentOption creates a new PaymentOption
//
// @param title Title for the payment option
// @param uRL Payment form URL to be opened in a web view
func NewPaymentOption(title string, uRL string) *PaymentOption {
	paymentOptionTemp := PaymentOption{
		tdCommon: tdCommon{Type: "paymentOption"},
		Title:    title,
		URL:      uRL,
	}

	return &paymentOptionTemp
}

// UnmarshalJSON unmarshal to json
func (paymentOption *PaymentOption) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Title string `json:"title"` // Title for the payment option
		URL   string `json:"url"`   // Payment form URL to be opened in a web view
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	paymentOption.tdCommon = tempObj.tdCommon
	paymentOption.Title = tempObj.Title
	paymentOption.URL = tempObj.URL

	return nil
}

// PaymentFormTypeRegular The payment form is for a regular payment
type PaymentFormTypeRegular struct {
	tdCommon
	Invoice                  *Invoice           `json:"invoice"`                    // Full information about the invoice
	PaymentProviderUserID    int64              `json:"payment_provider_user_id"`   // User identifier of the payment provider bot
	PaymentProvider          PaymentProvider    `json:"payment_provider"`           // Information about the payment provider
	AdditionalPaymentOptions []PaymentOption    `json:"additional_payment_options"` // The list of additional payment options
	SavedOrderInfo           *OrderInfo         `json:"saved_order_info"`           // Saved server-side order information; may be null
	SavedCredentials         []SavedCredentials `json:"saved_credentials"`          // The list of saved payment credentials
	CanSaveCredentials       bool               `json:"can_save_credentials"`       // True, if the user can choose to save credentials
	NeedPassword             bool               `json:"need_password"`              // True, if the user will be able to save credentials, if sets up a 2-step verification password
}

// MessageType return the string telegram-type of PaymentFormTypeRegular
func (paymentFormTypeRegular *PaymentFormTypeRegular) MessageType() string {
	return "paymentFormTypeRegular"
}

// NewPaymentFormTypeRegular creates a new PaymentFormTypeRegular
//
// @param invoice Full information about the invoice
// @param paymentProviderUserID User identifier of the payment provider bot
// @param paymentProvider Information about the payment provider
// @param additionalPaymentOptions The list of additional payment options
// @param savedOrderInfo Saved server-side order information; may be null
// @param savedCredentials The list of saved payment credentials
// @param canSaveCredentials True, if the user can choose to save credentials
// @param needPassword True, if the user will be able to save credentials, if sets up a 2-step verification password
func NewPaymentFormTypeRegular(invoice *Invoice, paymentProviderUserID int64, paymentProvider PaymentProvider, additionalPaymentOptions []PaymentOption, savedOrderInfo *OrderInfo, savedCredentials []SavedCredentials, canSaveCredentials bool, needPassword bool) *PaymentFormTypeRegular {
	paymentFormTypeRegularTemp := PaymentFormTypeRegular{
		tdCommon:                 tdCommon{Type: "paymentFormTypeRegular"},
		Invoice:                  invoice,
		PaymentProviderUserID:    paymentProviderUserID,
		PaymentProvider:          paymentProvider,
		AdditionalPaymentOptions: additionalPaymentOptions,
		SavedOrderInfo:           savedOrderInfo,
		SavedCredentials:         savedCredentials,
		CanSaveCredentials:       canSaveCredentials,
		NeedPassword:             needPassword,
	}

	return &paymentFormTypeRegularTemp
}

// UnmarshalJSON unmarshal to json
func (paymentFormTypeRegular *PaymentFormTypeRegular) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Invoice                  *Invoice           `json:"invoice"`                    // Full information about the invoice
		PaymentProviderUserID    int64              `json:"payment_provider_user_id"`   // User identifier of the payment provider bot
		AdditionalPaymentOptions []PaymentOption    `json:"additional_payment_options"` // The list of additional payment options
		SavedOrderInfo           *OrderInfo         `json:"saved_order_info"`           // Saved server-side order information; may be null
		SavedCredentials         []SavedCredentials `json:"saved_credentials"`          // The list of saved payment credentials
		CanSaveCredentials       bool               `json:"can_save_credentials"`       // True, if the user can choose to save credentials
		NeedPassword             bool               `json:"need_password"`              // True, if the user will be able to save credentials, if sets up a 2-step verification password
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	paymentFormTypeRegular.tdCommon = tempObj.tdCommon
	paymentFormTypeRegular.Invoice = tempObj.Invoice
	paymentFormTypeRegular.PaymentProviderUserID = tempObj.PaymentProviderUserID
	paymentFormTypeRegular.AdditionalPaymentOptions = tempObj.AdditionalPaymentOptions
	paymentFormTypeRegular.SavedOrderInfo = tempObj.SavedOrderInfo
	paymentFormTypeRegular.SavedCredentials = tempObj.SavedCredentials
	paymentFormTypeRegular.CanSaveCredentials = tempObj.CanSaveCredentials
	paymentFormTypeRegular.NeedPassword = tempObj.NeedPassword

	fieldPaymentProvider, _ := unmarshalPaymentProvider(objMap["payment_provider"])
	paymentFormTypeRegular.PaymentProvider = fieldPaymentProvider

	return nil
}

// GetPaymentFormTypeEnum return the enum type of this object
func (paymentFormTypeRegular *PaymentFormTypeRegular) GetPaymentFormTypeEnum() PaymentFormTypeEnum {
	return PaymentFormTypeRegularType
}

// PaymentFormTypeStars The payment form is for a payment in Telegram Stars
type PaymentFormTypeStars struct {
	tdCommon
	StarCount int64 `json:"star_count"` // Number of Telegram Stars that will be paid
}

// MessageType return the string telegram-type of PaymentFormTypeStars
func (paymentFormTypeStars *PaymentFormTypeStars) MessageType() string {
	return "paymentFormTypeStars"
}

// NewPaymentFormTypeStars creates a new PaymentFormTypeStars
//
// @param starCount Number of Telegram Stars that will be paid
func NewPaymentFormTypeStars(starCount int64) *PaymentFormTypeStars {
	paymentFormTypeStarsTemp := PaymentFormTypeStars{
		tdCommon:  tdCommon{Type: "paymentFormTypeStars"},
		StarCount: starCount,
	}

	return &paymentFormTypeStarsTemp
}

// UnmarshalJSON unmarshal to json
func (paymentFormTypeStars *PaymentFormTypeStars) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StarCount int64 `json:"star_count"` // Number of Telegram Stars that will be paid
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	paymentFormTypeStars.tdCommon = tempObj.tdCommon
	paymentFormTypeStars.StarCount = tempObj.StarCount

	return nil
}

// GetPaymentFormTypeEnum return the enum type of this object
func (paymentFormTypeStars *PaymentFormTypeStars) GetPaymentFormTypeEnum() PaymentFormTypeEnum {
	return PaymentFormTypeStarsType
}

// PaymentForm Contains information about an invoice payment form
type PaymentForm struct {
	tdCommon
	ID              JSONInt64       `json:"id"`                 // The payment form identifier
	Type            PaymentFormType `json:"type"`               // Type of the payment form
	SellerBotUserID int64           `json:"seller_bot_user_id"` // User identifier of the seller bot
	ProductInfo     *ProductInfo    `json:"product_info"`       // Information about the product
}

// MessageType return the string telegram-type of PaymentForm
func (paymentForm *PaymentForm) MessageType() string {
	return "paymentForm"
}

// NewPaymentForm creates a new PaymentForm
//
// @param iD The payment form identifier
// @param typeParam Type of the payment form
// @param sellerBotUserID User identifier of the seller bot
// @param productInfo Information about the product
func NewPaymentForm(iD JSONInt64, typeParam PaymentFormType, sellerBotUserID int64, productInfo *ProductInfo) *PaymentForm {
	paymentFormTemp := PaymentForm{
		tdCommon:        tdCommon{Type: "paymentForm"},
		ID:              iD,
		Type:            typeParam,
		SellerBotUserID: sellerBotUserID,
		ProductInfo:     productInfo,
	}

	return &paymentFormTemp
}

// UnmarshalJSON unmarshal to json
func (paymentForm *PaymentForm) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID              JSONInt64    `json:"id"`                 // The payment form identifier
		SellerBotUserID int64        `json:"seller_bot_user_id"` // User identifier of the seller bot
		ProductInfo     *ProductInfo `json:"product_info"`       // Information about the product
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	paymentForm.tdCommon = tempObj.tdCommon
	paymentForm.ID = tempObj.ID
	paymentForm.SellerBotUserID = tempObj.SellerBotUserID
	paymentForm.ProductInfo = tempObj.ProductInfo

	fieldType, _ := unmarshalPaymentFormType(objMap["type"])
	paymentForm.Type = fieldType

	return nil
}

// ValidatedOrderInfo Contains a temporary identifier of validated order information, which is stored for one hour, and the available shipping options
type ValidatedOrderInfo struct {
	tdCommon
	OrderInfoID     string           `json:"order_info_id"`    // Temporary identifier of the order information
	ShippingOptions []ShippingOption `json:"shipping_options"` // Available shipping options
}

// MessageType return the string telegram-type of ValidatedOrderInfo
func (validatedOrderInfo *ValidatedOrderInfo) MessageType() string {
	return "validatedOrderInfo"
}

// NewValidatedOrderInfo creates a new ValidatedOrderInfo
//
// @param orderInfoID Temporary identifier of the order information
// @param shippingOptions Available shipping options
func NewValidatedOrderInfo(orderInfoID string, shippingOptions []ShippingOption) *ValidatedOrderInfo {
	validatedOrderInfoTemp := ValidatedOrderInfo{
		tdCommon:        tdCommon{Type: "validatedOrderInfo"},
		OrderInfoID:     orderInfoID,
		ShippingOptions: shippingOptions,
	}

	return &validatedOrderInfoTemp
}

// UnmarshalJSON unmarshal to json
func (validatedOrderInfo *ValidatedOrderInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OrderInfoID     string           `json:"order_info_id"`    // Temporary identifier of the order information
		ShippingOptions []ShippingOption `json:"shipping_options"` // Available shipping options
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	validatedOrderInfo.tdCommon = tempObj.tdCommon
	validatedOrderInfo.OrderInfoID = tempObj.OrderInfoID
	validatedOrderInfo.ShippingOptions = tempObj.ShippingOptions

	return nil
}

// PaymentResult Contains the result of a payment request
type PaymentResult struct {
	tdCommon
	Success         bool   `json:"success"`          // True, if the payment request was successful; otherwise, the verification_url will be non-empty
	VerificationURL string `json:"verification_url"` // URL for additional payment credentials verification
}

// MessageType return the string telegram-type of PaymentResult
func (paymentResult *PaymentResult) MessageType() string {
	return "paymentResult"
}

// NewPaymentResult creates a new PaymentResult
//
// @param success True, if the payment request was successful; otherwise, the verification_url will be non-empty
// @param verificationURL URL for additional payment credentials verification
func NewPaymentResult(success bool, verificationURL string) *PaymentResult {
	paymentResultTemp := PaymentResult{
		tdCommon:        tdCommon{Type: "paymentResult"},
		Success:         success,
		VerificationURL: verificationURL,
	}

	return &paymentResultTemp
}

// UnmarshalJSON unmarshal to json
func (paymentResult *PaymentResult) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Success         bool   `json:"success"`          // True, if the payment request was successful; otherwise, the verification_url will be non-empty
		VerificationURL string `json:"verification_url"` // URL for additional payment credentials verification
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	paymentResult.tdCommon = tempObj.tdCommon
	paymentResult.Success = tempObj.Success
	paymentResult.VerificationURL = tempObj.VerificationURL

	return nil
}

// PaymentReceiptTypeRegular The payment was done using a third-party payment provider
type PaymentReceiptTypeRegular struct {
	tdCommon
	PaymentProviderUserID int64           `json:"payment_provider_user_id"` // User identifier of the payment provider bot
	Invoice               *Invoice        `json:"invoice"`                  // Information about the invoice
	OrderInfo             *OrderInfo      `json:"order_info"`               // Order information; may be null
	ShippingOption        *ShippingOption `json:"shipping_option"`          // Chosen shipping option; may be null
	CredentialsTitle      string          `json:"credentials_title"`        // Title of the saved credentials chosen by the buyer
	TipAmount             int64           `json:"tip_amount"`               // The amount of tip chosen by the buyer in the smallest units of the currency
}

// MessageType return the string telegram-type of PaymentReceiptTypeRegular
func (paymentReceiptTypeRegular *PaymentReceiptTypeRegular) MessageType() string {
	return "paymentReceiptTypeRegular"
}

// NewPaymentReceiptTypeRegular creates a new PaymentReceiptTypeRegular
//
// @param paymentProviderUserID User identifier of the payment provider bot
// @param invoice Information about the invoice
// @param orderInfo Order information; may be null
// @param shippingOption Chosen shipping option; may be null
// @param credentialsTitle Title of the saved credentials chosen by the buyer
// @param tipAmount The amount of tip chosen by the buyer in the smallest units of the currency
func NewPaymentReceiptTypeRegular(paymentProviderUserID int64, invoice *Invoice, orderInfo *OrderInfo, shippingOption *ShippingOption, credentialsTitle string, tipAmount int64) *PaymentReceiptTypeRegular {
	paymentReceiptTypeRegularTemp := PaymentReceiptTypeRegular{
		tdCommon:              tdCommon{Type: "paymentReceiptTypeRegular"},
		PaymentProviderUserID: paymentProviderUserID,
		Invoice:               invoice,
		OrderInfo:             orderInfo,
		ShippingOption:        shippingOption,
		CredentialsTitle:      credentialsTitle,
		TipAmount:             tipAmount,
	}

	return &paymentReceiptTypeRegularTemp
}

// UnmarshalJSON unmarshal to json
func (paymentReceiptTypeRegular *PaymentReceiptTypeRegular) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PaymentProviderUserID int64           `json:"payment_provider_user_id"` // User identifier of the payment provider bot
		Invoice               *Invoice        `json:"invoice"`                  // Information about the invoice
		OrderInfo             *OrderInfo      `json:"order_info"`               // Order information; may be null
		ShippingOption        *ShippingOption `json:"shipping_option"`          // Chosen shipping option; may be null
		CredentialsTitle      string          `json:"credentials_title"`        // Title of the saved credentials chosen by the buyer
		TipAmount             int64           `json:"tip_amount"`               // The amount of tip chosen by the buyer in the smallest units of the currency
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	paymentReceiptTypeRegular.tdCommon = tempObj.tdCommon
	paymentReceiptTypeRegular.PaymentProviderUserID = tempObj.PaymentProviderUserID
	paymentReceiptTypeRegular.Invoice = tempObj.Invoice
	paymentReceiptTypeRegular.OrderInfo = tempObj.OrderInfo
	paymentReceiptTypeRegular.ShippingOption = tempObj.ShippingOption
	paymentReceiptTypeRegular.CredentialsTitle = tempObj.CredentialsTitle
	paymentReceiptTypeRegular.TipAmount = tempObj.TipAmount

	return nil
}

// GetPaymentReceiptTypeEnum return the enum type of this object
func (paymentReceiptTypeRegular *PaymentReceiptTypeRegular) GetPaymentReceiptTypeEnum() PaymentReceiptTypeEnum {
	return PaymentReceiptTypeRegularType
}

// PaymentReceiptTypeStars The payment was done using Telegram Stars
type PaymentReceiptTypeStars struct {
	tdCommon
	StarCount     int64  `json:"star_count"`     // Number of Telegram Stars that were paid
	TransactionID string `json:"transaction_id"` // Unique identifier of the transaction that can be used to dispute it
}

// MessageType return the string telegram-type of PaymentReceiptTypeStars
func (paymentReceiptTypeStars *PaymentReceiptTypeStars) MessageType() string {
	return "paymentReceiptTypeStars"
}

// NewPaymentReceiptTypeStars creates a new PaymentReceiptTypeStars
//
// @param starCount Number of Telegram Stars that were paid
// @param transactionID Unique identifier of the transaction that can be used to dispute it
func NewPaymentReceiptTypeStars(starCount int64, transactionID string) *PaymentReceiptTypeStars {
	paymentReceiptTypeStarsTemp := PaymentReceiptTypeStars{
		tdCommon:      tdCommon{Type: "paymentReceiptTypeStars"},
		StarCount:     starCount,
		TransactionID: transactionID,
	}

	return &paymentReceiptTypeStarsTemp
}

// UnmarshalJSON unmarshal to json
func (paymentReceiptTypeStars *PaymentReceiptTypeStars) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StarCount     int64  `json:"star_count"`     // Number of Telegram Stars that were paid
		TransactionID string `json:"transaction_id"` // Unique identifier of the transaction that can be used to dispute it
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	paymentReceiptTypeStars.tdCommon = tempObj.tdCommon
	paymentReceiptTypeStars.StarCount = tempObj.StarCount
	paymentReceiptTypeStars.TransactionID = tempObj.TransactionID

	return nil
}

// GetPaymentReceiptTypeEnum return the enum type of this object
func (paymentReceiptTypeStars *PaymentReceiptTypeStars) GetPaymentReceiptTypeEnum() PaymentReceiptTypeEnum {
	return PaymentReceiptTypeStarsType
}

// PaymentReceipt Contains information about a successful payment
type PaymentReceipt struct {
	tdCommon
	ProductInfo     *ProductInfo       `json:"product_info"`       // Information about the product
	Date            int32              `json:"date"`               // Point in time (Unix timestamp) when the payment was made
	SellerBotUserID int64              `json:"seller_bot_user_id"` // User identifier of the seller bot
	Type            PaymentReceiptType `json:"type"`               // Type of the payment receipt
}

// MessageType return the string telegram-type of PaymentReceipt
func (paymentReceipt *PaymentReceipt) MessageType() string {
	return "paymentReceipt"
}

// NewPaymentReceipt creates a new PaymentReceipt
//
// @param productInfo Information about the product
// @param date Point in time (Unix timestamp) when the payment was made
// @param sellerBotUserID User identifier of the seller bot
// @param typeParam Type of the payment receipt
func NewPaymentReceipt(productInfo *ProductInfo, date int32, sellerBotUserID int64, typeParam PaymentReceiptType) *PaymentReceipt {
	paymentReceiptTemp := PaymentReceipt{
		tdCommon:        tdCommon{Type: "paymentReceipt"},
		ProductInfo:     productInfo,
		Date:            date,
		SellerBotUserID: sellerBotUserID,
		Type:            typeParam,
	}

	return &paymentReceiptTemp
}

// UnmarshalJSON unmarshal to json
func (paymentReceipt *PaymentReceipt) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ProductInfo     *ProductInfo `json:"product_info"`       // Information about the product
		Date            int32        `json:"date"`               // Point in time (Unix timestamp) when the payment was made
		SellerBotUserID int64        `json:"seller_bot_user_id"` // User identifier of the seller bot

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	paymentReceipt.tdCommon = tempObj.tdCommon
	paymentReceipt.ProductInfo = tempObj.ProductInfo
	paymentReceipt.Date = tempObj.Date
	paymentReceipt.SellerBotUserID = tempObj.SellerBotUserID

	fieldType, _ := unmarshalPaymentReceiptType(objMap["type"])
	paymentReceipt.Type = fieldType

	return nil
}

// InputInvoiceMessage An invoice from a message of the type messageInvoice or paid media purchase from messagePaidMedia
type InputInvoiceMessage struct {
	tdCommon
	ChatID    int64 `json:"chat_id"`    // Chat identifier of the message
	MessageID int64 `json:"message_id"` // Message identifier
}

// MessageType return the string telegram-type of InputInvoiceMessage
func (inputInvoiceMessage *InputInvoiceMessage) MessageType() string {
	return "inputInvoiceMessage"
}

// NewInputInvoiceMessage creates a new InputInvoiceMessage
//
// @param chatID Chat identifier of the message
// @param messageID Message identifier
func NewInputInvoiceMessage(chatID int64, messageID int64) *InputInvoiceMessage {
	inputInvoiceMessageTemp := InputInvoiceMessage{
		tdCommon:  tdCommon{Type: "inputInvoiceMessage"},
		ChatID:    chatID,
		MessageID: messageID,
	}

	return &inputInvoiceMessageTemp
}

// UnmarshalJSON unmarshal to json
func (inputInvoiceMessage *InputInvoiceMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID    int64 `json:"chat_id"`    // Chat identifier of the message
		MessageID int64 `json:"message_id"` // Message identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputInvoiceMessage.tdCommon = tempObj.tdCommon
	inputInvoiceMessage.ChatID = tempObj.ChatID
	inputInvoiceMessage.MessageID = tempObj.MessageID

	return nil
}

// GetInputInvoiceEnum return the enum type of this object
func (inputInvoiceMessage *InputInvoiceMessage) GetInputInvoiceEnum() InputInvoiceEnum {
	return InputInvoiceMessageType
}

// InputInvoiceName An invoice from a link of the type internalLinkTypeInvoice
type InputInvoiceName struct {
	tdCommon
	Name string `json:"name"` // Name of the invoice
}

// MessageType return the string telegram-type of InputInvoiceName
func (inputInvoiceName *InputInvoiceName) MessageType() string {
	return "inputInvoiceName"
}

// NewInputInvoiceName creates a new InputInvoiceName
//
// @param name Name of the invoice
func NewInputInvoiceName(name string) *InputInvoiceName {
	inputInvoiceNameTemp := InputInvoiceName{
		tdCommon: tdCommon{Type: "inputInvoiceName"},
		Name:     name,
	}

	return &inputInvoiceNameTemp
}

// UnmarshalJSON unmarshal to json
func (inputInvoiceName *InputInvoiceName) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Name string `json:"name"` // Name of the invoice
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputInvoiceName.tdCommon = tempObj.tdCommon
	inputInvoiceName.Name = tempObj.Name

	return nil
}

// GetInputInvoiceEnum return the enum type of this object
func (inputInvoiceName *InputInvoiceName) GetInputInvoiceEnum() InputInvoiceEnum {
	return InputInvoiceNameType
}

// InputInvoiceTelegram An invoice for a payment toward Telegram; must not be used in the in-store apps
type InputInvoiceTelegram struct {
	tdCommon
	Purpose TelegramPaymentPurpose `json:"purpose"` // Transaction purpose
}

// MessageType return the string telegram-type of InputInvoiceTelegram
func (inputInvoiceTelegram *InputInvoiceTelegram) MessageType() string {
	return "inputInvoiceTelegram"
}

// NewInputInvoiceTelegram creates a new InputInvoiceTelegram
//
// @param purpose Transaction purpose
func NewInputInvoiceTelegram(purpose TelegramPaymentPurpose) *InputInvoiceTelegram {
	inputInvoiceTelegramTemp := InputInvoiceTelegram{
		tdCommon: tdCommon{Type: "inputInvoiceTelegram"},
		Purpose:  purpose,
	}

	return &inputInvoiceTelegramTemp
}

// UnmarshalJSON unmarshal to json
func (inputInvoiceTelegram *InputInvoiceTelegram) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputInvoiceTelegram.tdCommon = tempObj.tdCommon

	fieldPurpose, _ := unmarshalTelegramPaymentPurpose(objMap["purpose"])
	inputInvoiceTelegram.Purpose = fieldPurpose

	return nil
}

// GetInputInvoiceEnum return the enum type of this object
func (inputInvoiceTelegram *InputInvoiceTelegram) GetInputInvoiceEnum() InputInvoiceEnum {
	return InputInvoiceTelegramType
}

// PaidMediaPreview The media is hidden until the invoice is paid
type PaidMediaPreview struct {
	tdCommon
	Width         int32          `json:"width"`         // Media width; 0 if unknown
	Height        int32          `json:"height"`        // Media height; 0 if unknown
	Duration      int32          `json:"duration"`      // Media duration, in seconds; 0 if unknown
	Minithumbnail *Minithumbnail `json:"minithumbnail"` // Media minithumbnail; may be null
}

// MessageType return the string telegram-type of PaidMediaPreview
func (paidMediaPreview *PaidMediaPreview) MessageType() string {
	return "paidMediaPreview"
}

// NewPaidMediaPreview creates a new PaidMediaPreview
//
// @param width Media width; 0 if unknown
// @param height Media height; 0 if unknown
// @param duration Media duration, in seconds; 0 if unknown
// @param minithumbnail Media minithumbnail; may be null
func NewPaidMediaPreview(width int32, height int32, duration int32, minithumbnail *Minithumbnail) *PaidMediaPreview {
	paidMediaPreviewTemp := PaidMediaPreview{
		tdCommon:      tdCommon{Type: "paidMediaPreview"},
		Width:         width,
		Height:        height,
		Duration:      duration,
		Minithumbnail: minithumbnail,
	}

	return &paidMediaPreviewTemp
}

// UnmarshalJSON unmarshal to json
func (paidMediaPreview *PaidMediaPreview) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Width         int32          `json:"width"`         // Media width; 0 if unknown
		Height        int32          `json:"height"`        // Media height; 0 if unknown
		Duration      int32          `json:"duration"`      // Media duration, in seconds; 0 if unknown
		Minithumbnail *Minithumbnail `json:"minithumbnail"` // Media minithumbnail; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	paidMediaPreview.tdCommon = tempObj.tdCommon
	paidMediaPreview.Width = tempObj.Width
	paidMediaPreview.Height = tempObj.Height
	paidMediaPreview.Duration = tempObj.Duration
	paidMediaPreview.Minithumbnail = tempObj.Minithumbnail

	return nil
}

// GetPaidMediaEnum return the enum type of this object
func (paidMediaPreview *PaidMediaPreview) GetPaidMediaEnum() PaidMediaEnum {
	return PaidMediaPreviewType
}

// PaidMediaPhoto The media is a photo
type PaidMediaPhoto struct {
	tdCommon
	Photo *Photo `json:"photo"` // The photo
}

// MessageType return the string telegram-type of PaidMediaPhoto
func (paidMediaPhoto *PaidMediaPhoto) MessageType() string {
	return "paidMediaPhoto"
}

// NewPaidMediaPhoto creates a new PaidMediaPhoto
//
// @param photo The photo
func NewPaidMediaPhoto(photo *Photo) *PaidMediaPhoto {
	paidMediaPhotoTemp := PaidMediaPhoto{
		tdCommon: tdCommon{Type: "paidMediaPhoto"},
		Photo:    photo,
	}

	return &paidMediaPhotoTemp
}

// UnmarshalJSON unmarshal to json
func (paidMediaPhoto *PaidMediaPhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Photo *Photo `json:"photo"` // The photo
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	paidMediaPhoto.tdCommon = tempObj.tdCommon
	paidMediaPhoto.Photo = tempObj.Photo

	return nil
}

// GetPaidMediaEnum return the enum type of this object
func (paidMediaPhoto *PaidMediaPhoto) GetPaidMediaEnum() PaidMediaEnum {
	return PaidMediaPhotoType
}

// PaidMediaVideo The media is a video
type PaidMediaVideo struct {
	tdCommon
	Video *Video `json:"video"` // The video
}

// MessageType return the string telegram-type of PaidMediaVideo
func (paidMediaVideo *PaidMediaVideo) MessageType() string {
	return "paidMediaVideo"
}

// NewPaidMediaVideo creates a new PaidMediaVideo
//
// @param video The video
func NewPaidMediaVideo(video *Video) *PaidMediaVideo {
	paidMediaVideoTemp := PaidMediaVideo{
		tdCommon: tdCommon{Type: "paidMediaVideo"},
		Video:    video,
	}

	return &paidMediaVideoTemp
}

// UnmarshalJSON unmarshal to json
func (paidMediaVideo *PaidMediaVideo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Video *Video `json:"video"` // The video
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	paidMediaVideo.tdCommon = tempObj.tdCommon
	paidMediaVideo.Video = tempObj.Video

	return nil
}

// GetPaidMediaEnum return the enum type of this object
func (paidMediaVideo *PaidMediaVideo) GetPaidMediaEnum() PaidMediaEnum {
	return PaidMediaVideoType
}

// PaidMediaUnsupported The media is unsupported
type PaidMediaUnsupported struct {
	tdCommon
}

// MessageType return the string telegram-type of PaidMediaUnsupported
func (paidMediaUnsupported *PaidMediaUnsupported) MessageType() string {
	return "paidMediaUnsupported"
}

// NewPaidMediaUnsupported creates a new PaidMediaUnsupported
//
func NewPaidMediaUnsupported() *PaidMediaUnsupported {
	paidMediaUnsupportedTemp := PaidMediaUnsupported{
		tdCommon: tdCommon{Type: "paidMediaUnsupported"},
	}

	return &paidMediaUnsupportedTemp
}

// UnmarshalJSON unmarshal to json
func (paidMediaUnsupported *PaidMediaUnsupported) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	paidMediaUnsupported.tdCommon = tempObj.tdCommon

	return nil
}

// GetPaidMediaEnum return the enum type of this object
func (paidMediaUnsupported *PaidMediaUnsupported) GetPaidMediaEnum() PaidMediaEnum {
	return PaidMediaUnsupportedType
}

// GiveawayParameters Describes parameters of a giveaway
type GiveawayParameters struct {
	tdCommon
	BoostedChatID        int64    `json:"boosted_chat_id"`        // Identifier of the supergroup or channel chat, which will be automatically boosted by the winners of the giveaway for duration of the Telegram Premium subscription, or for the specified time. If the chat is a channel, then can_post_messages right is required in the channel, otherwise, the user must be an administrator in the supergroup
	AdditionalChatIDs    []int64  `json:"additional_chat_ids"`    // Identifiers of other supergroup or channel chats that must be subscribed by the users to be eligible for the giveaway. There can be up to getOption("giveaway_additional_chat_count_max") additional chats
	WinnersSelectionDate int32    `json:"winners_selection_date"` // Point in time (Unix timestamp) when the giveaway is expected to be performed; must be 60-getOption("giveaway_duration_max") seconds in the future in scheduled giveaways
	OnlyNewMembers       bool     `json:"only_new_members"`       // True, if only new members of the chats will be eligible for the giveaway
	HasPublicWinners     bool     `json:"has_public_winners"`     // True, if the list of winners of the giveaway will be available to everyone
	CountryCodes         []string `json:"country_codes"`          // The list of two-letter ISO 3166-1 alpha-2 codes of countries, users from which will be eligible for the giveaway. If empty, then all users can participate in the giveaway. There can be up to getOption("giveaway_country_count_max") chosen countries. Users with phone number that was bought at https://fragment.com can participate in any giveaway and the country code "FT" must not be specified in the list
	PrizeDescription     string   `json:"prize_description"`      // Additional description of the giveaway prize; 0-128 characters
}

// MessageType return the string telegram-type of GiveawayParameters
func (giveawayParameters *GiveawayParameters) MessageType() string {
	return "giveawayParameters"
}

// NewGiveawayParameters creates a new GiveawayParameters
//
// @param boostedChatID Identifier of the supergroup or channel chat, which will be automatically boosted by the winners of the giveaway for duration of the Telegram Premium subscription, or for the specified time. If the chat is a channel, then can_post_messages right is required in the channel, otherwise, the user must be an administrator in the supergroup
// @param additionalChatIDs Identifiers of other supergroup or channel chats that must be subscribed by the users to be eligible for the giveaway. There can be up to getOption("giveaway_additional_chat_count_max") additional chats
// @param winnersSelectionDate Point in time (Unix timestamp) when the giveaway is expected to be performed; must be 60-getOption("giveaway_duration_max") seconds in the future in scheduled giveaways
// @param onlyNewMembers True, if only new members of the chats will be eligible for the giveaway
// @param hasPublicWinners True, if the list of winners of the giveaway will be available to everyone
// @param countryCodes The list of two-letter ISO 3166-1 alpha-2 codes of countries, users from which will be eligible for the giveaway. If empty, then all users can participate in the giveaway. There can be up to getOption("giveaway_country_count_max") chosen countries. Users with phone number that was bought at https://fragment.com can participate in any giveaway and the country code "FT" must not be specified in the list
// @param prizeDescription Additional description of the giveaway prize; 0-128 characters
func NewGiveawayParameters(boostedChatID int64, additionalChatIDs []int64, winnersSelectionDate int32, onlyNewMembers bool, hasPublicWinners bool, countryCodes []string, prizeDescription string) *GiveawayParameters {
	giveawayParametersTemp := GiveawayParameters{
		tdCommon:             tdCommon{Type: "giveawayParameters"},
		BoostedChatID:        boostedChatID,
		AdditionalChatIDs:    additionalChatIDs,
		WinnersSelectionDate: winnersSelectionDate,
		OnlyNewMembers:       onlyNewMembers,
		HasPublicWinners:     hasPublicWinners,
		CountryCodes:         countryCodes,
		PrizeDescription:     prizeDescription,
	}

	return &giveawayParametersTemp
}

// UnmarshalJSON unmarshal to json
func (giveawayParameters *GiveawayParameters) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BoostedChatID        int64    `json:"boosted_chat_id"`        // Identifier of the supergroup or channel chat, which will be automatically boosted by the winners of the giveaway for duration of the Telegram Premium subscription, or for the specified time. If the chat is a channel, then can_post_messages right is required in the channel, otherwise, the user must be an administrator in the supergroup
		AdditionalChatIDs    []int64  `json:"additional_chat_ids"`    // Identifiers of other supergroup or channel chats that must be subscribed by the users to be eligible for the giveaway. There can be up to getOption("giveaway_additional_chat_count_max") additional chats
		WinnersSelectionDate int32    `json:"winners_selection_date"` // Point in time (Unix timestamp) when the giveaway is expected to be performed; must be 60-getOption("giveaway_duration_max") seconds in the future in scheduled giveaways
		OnlyNewMembers       bool     `json:"only_new_members"`       // True, if only new members of the chats will be eligible for the giveaway
		HasPublicWinners     bool     `json:"has_public_winners"`     // True, if the list of winners of the giveaway will be available to everyone
		CountryCodes         []string `json:"country_codes"`          // The list of two-letter ISO 3166-1 alpha-2 codes of countries, users from which will be eligible for the giveaway. If empty, then all users can participate in the giveaway. There can be up to getOption("giveaway_country_count_max") chosen countries. Users with phone number that was bought at https://fragment.com can participate in any giveaway and the country code "FT" must not be specified in the list
		PrizeDescription     string   `json:"prize_description"`      // Additional description of the giveaway prize; 0-128 characters
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	giveawayParameters.tdCommon = tempObj.tdCommon
	giveawayParameters.BoostedChatID = tempObj.BoostedChatID
	giveawayParameters.AdditionalChatIDs = tempObj.AdditionalChatIDs
	giveawayParameters.WinnersSelectionDate = tempObj.WinnersSelectionDate
	giveawayParameters.OnlyNewMembers = tempObj.OnlyNewMembers
	giveawayParameters.HasPublicWinners = tempObj.HasPublicWinners
	giveawayParameters.CountryCodes = tempObj.CountryCodes
	giveawayParameters.PrizeDescription = tempObj.PrizeDescription

	return nil
}

// DatedFile File with the date it was uploaded
type DatedFile struct {
	tdCommon
	File *File `json:"file"` // The file
	Date int32 `json:"date"` // Point in time (Unix timestamp) when the file was uploaded
}

// MessageType return the string telegram-type of DatedFile
func (datedFile *DatedFile) MessageType() string {
	return "datedFile"
}

// NewDatedFile creates a new DatedFile
//
// @param file The file
// @param date Point in time (Unix timestamp) when the file was uploaded
func NewDatedFile(file *File, date int32) *DatedFile {
	datedFileTemp := DatedFile{
		tdCommon: tdCommon{Type: "datedFile"},
		File:     file,
		Date:     date,
	}

	return &datedFileTemp
}

// UnmarshalJSON unmarshal to json
func (datedFile *DatedFile) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		File *File `json:"file"` // The file
		Date int32 `json:"date"` // Point in time (Unix timestamp) when the file was uploaded
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	datedFile.tdCommon = tempObj.tdCommon
	datedFile.File = tempObj.File
	datedFile.Date = tempObj.Date

	return nil
}

// PassportElementTypePersonalDetails A Telegram Passport element containing the user's personal details
type PassportElementTypePersonalDetails struct {
	tdCommon
}

// MessageType return the string telegram-type of PassportElementTypePersonalDetails
func (passportElementTypePersonalDetails *PassportElementTypePersonalDetails) MessageType() string {
	return "passportElementTypePersonalDetails"
}

// NewPassportElementTypePersonalDetails creates a new PassportElementTypePersonalDetails
//
func NewPassportElementTypePersonalDetails() *PassportElementTypePersonalDetails {
	passportElementTypePersonalDetailsTemp := PassportElementTypePersonalDetails{
		tdCommon: tdCommon{Type: "passportElementTypePersonalDetails"},
	}

	return &passportElementTypePersonalDetailsTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementTypePersonalDetails *PassportElementTypePersonalDetails) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementTypePersonalDetails.tdCommon = tempObj.tdCommon

	return nil
}

// GetPassportElementTypeEnum return the enum type of this object
func (passportElementTypePersonalDetails *PassportElementTypePersonalDetails) GetPassportElementTypeEnum() PassportElementTypeEnum {
	return PassportElementTypePersonalDetailsType
}

// PassportElementTypePassport A Telegram Passport element containing the user's passport
type PassportElementTypePassport struct {
	tdCommon
}

// MessageType return the string telegram-type of PassportElementTypePassport
func (passportElementTypePassport *PassportElementTypePassport) MessageType() string {
	return "passportElementTypePassport"
}

// NewPassportElementTypePassport creates a new PassportElementTypePassport
//
func NewPassportElementTypePassport() *PassportElementTypePassport {
	passportElementTypePassportTemp := PassportElementTypePassport{
		tdCommon: tdCommon{Type: "passportElementTypePassport"},
	}

	return &passportElementTypePassportTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementTypePassport *PassportElementTypePassport) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementTypePassport.tdCommon = tempObj.tdCommon

	return nil
}

// GetPassportElementTypeEnum return the enum type of this object
func (passportElementTypePassport *PassportElementTypePassport) GetPassportElementTypeEnum() PassportElementTypeEnum {
	return PassportElementTypePassportType
}

// PassportElementTypeDriverLicense A Telegram Passport element containing the user's driver license
type PassportElementTypeDriverLicense struct {
	tdCommon
}

// MessageType return the string telegram-type of PassportElementTypeDriverLicense
func (passportElementTypeDriverLicense *PassportElementTypeDriverLicense) MessageType() string {
	return "passportElementTypeDriverLicense"
}

// NewPassportElementTypeDriverLicense creates a new PassportElementTypeDriverLicense
//
func NewPassportElementTypeDriverLicense() *PassportElementTypeDriverLicense {
	passportElementTypeDriverLicenseTemp := PassportElementTypeDriverLicense{
		tdCommon: tdCommon{Type: "passportElementTypeDriverLicense"},
	}

	return &passportElementTypeDriverLicenseTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementTypeDriverLicense *PassportElementTypeDriverLicense) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementTypeDriverLicense.tdCommon = tempObj.tdCommon

	return nil
}

// GetPassportElementTypeEnum return the enum type of this object
func (passportElementTypeDriverLicense *PassportElementTypeDriverLicense) GetPassportElementTypeEnum() PassportElementTypeEnum {
	return PassportElementTypeDriverLicenseType
}

// PassportElementTypeIDentityCard A Telegram Passport element containing the user's identity card
type PassportElementTypeIDentityCard struct {
	tdCommon
}

// MessageType return the string telegram-type of PassportElementTypeIDentityCard
func (passportElementTypeIDentityCard *PassportElementTypeIDentityCard) MessageType() string {
	return "passportElementTypeIdentityCard"
}

// NewPassportElementTypeIDentityCard creates a new PassportElementTypeIDentityCard
//
func NewPassportElementTypeIDentityCard() *PassportElementTypeIDentityCard {
	passportElementTypeIDentityCardTemp := PassportElementTypeIDentityCard{
		tdCommon: tdCommon{Type: "passportElementTypeIdentityCard"},
	}

	return &passportElementTypeIDentityCardTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementTypeIDentityCard *PassportElementTypeIDentityCard) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementTypeIDentityCard.tdCommon = tempObj.tdCommon

	return nil
}

// GetPassportElementTypeEnum return the enum type of this object
func (passportElementTypeIDentityCard *PassportElementTypeIDentityCard) GetPassportElementTypeEnum() PassportElementTypeEnum {
	return PassportElementTypeIDentityCardType
}

// PassportElementTypeInternalPassport A Telegram Passport element containing the user's internal passport
type PassportElementTypeInternalPassport struct {
	tdCommon
}

// MessageType return the string telegram-type of PassportElementTypeInternalPassport
func (passportElementTypeInternalPassport *PassportElementTypeInternalPassport) MessageType() string {
	return "passportElementTypeInternalPassport"
}

// NewPassportElementTypeInternalPassport creates a new PassportElementTypeInternalPassport
//
func NewPassportElementTypeInternalPassport() *PassportElementTypeInternalPassport {
	passportElementTypeInternalPassportTemp := PassportElementTypeInternalPassport{
		tdCommon: tdCommon{Type: "passportElementTypeInternalPassport"},
	}

	return &passportElementTypeInternalPassportTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementTypeInternalPassport *PassportElementTypeInternalPassport) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementTypeInternalPassport.tdCommon = tempObj.tdCommon

	return nil
}

// GetPassportElementTypeEnum return the enum type of this object
func (passportElementTypeInternalPassport *PassportElementTypeInternalPassport) GetPassportElementTypeEnum() PassportElementTypeEnum {
	return PassportElementTypeInternalPassportType
}

// PassportElementTypeAddress A Telegram Passport element containing the user's address
type PassportElementTypeAddress struct {
	tdCommon
}

// MessageType return the string telegram-type of PassportElementTypeAddress
func (passportElementTypeAddress *PassportElementTypeAddress) MessageType() string {
	return "passportElementTypeAddress"
}

// NewPassportElementTypeAddress creates a new PassportElementTypeAddress
//
func NewPassportElementTypeAddress() *PassportElementTypeAddress {
	passportElementTypeAddressTemp := PassportElementTypeAddress{
		tdCommon: tdCommon{Type: "passportElementTypeAddress"},
	}

	return &passportElementTypeAddressTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementTypeAddress *PassportElementTypeAddress) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementTypeAddress.tdCommon = tempObj.tdCommon

	return nil
}

// GetPassportElementTypeEnum return the enum type of this object
func (passportElementTypeAddress *PassportElementTypeAddress) GetPassportElementTypeEnum() PassportElementTypeEnum {
	return PassportElementTypeAddressType
}

// PassportElementTypeUtilityBill A Telegram Passport element containing the user's utility bill
type PassportElementTypeUtilityBill struct {
	tdCommon
}

// MessageType return the string telegram-type of PassportElementTypeUtilityBill
func (passportElementTypeUtilityBill *PassportElementTypeUtilityBill) MessageType() string {
	return "passportElementTypeUtilityBill"
}

// NewPassportElementTypeUtilityBill creates a new PassportElementTypeUtilityBill
//
func NewPassportElementTypeUtilityBill() *PassportElementTypeUtilityBill {
	passportElementTypeUtilityBillTemp := PassportElementTypeUtilityBill{
		tdCommon: tdCommon{Type: "passportElementTypeUtilityBill"},
	}

	return &passportElementTypeUtilityBillTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementTypeUtilityBill *PassportElementTypeUtilityBill) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementTypeUtilityBill.tdCommon = tempObj.tdCommon

	return nil
}

// GetPassportElementTypeEnum return the enum type of this object
func (passportElementTypeUtilityBill *PassportElementTypeUtilityBill) GetPassportElementTypeEnum() PassportElementTypeEnum {
	return PassportElementTypeUtilityBillType
}

// PassportElementTypeBankStatement A Telegram Passport element containing the user's bank statement
type PassportElementTypeBankStatement struct {
	tdCommon
}

// MessageType return the string telegram-type of PassportElementTypeBankStatement
func (passportElementTypeBankStatement *PassportElementTypeBankStatement) MessageType() string {
	return "passportElementTypeBankStatement"
}

// NewPassportElementTypeBankStatement creates a new PassportElementTypeBankStatement
//
func NewPassportElementTypeBankStatement() *PassportElementTypeBankStatement {
	passportElementTypeBankStatementTemp := PassportElementTypeBankStatement{
		tdCommon: tdCommon{Type: "passportElementTypeBankStatement"},
	}

	return &passportElementTypeBankStatementTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementTypeBankStatement *PassportElementTypeBankStatement) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementTypeBankStatement.tdCommon = tempObj.tdCommon

	return nil
}

// GetPassportElementTypeEnum return the enum type of this object
func (passportElementTypeBankStatement *PassportElementTypeBankStatement) GetPassportElementTypeEnum() PassportElementTypeEnum {
	return PassportElementTypeBankStatementType
}

// PassportElementTypeRentalAgreement A Telegram Passport element containing the user's rental agreement
type PassportElementTypeRentalAgreement struct {
	tdCommon
}

// MessageType return the string telegram-type of PassportElementTypeRentalAgreement
func (passportElementTypeRentalAgreement *PassportElementTypeRentalAgreement) MessageType() string {
	return "passportElementTypeRentalAgreement"
}

// NewPassportElementTypeRentalAgreement creates a new PassportElementTypeRentalAgreement
//
func NewPassportElementTypeRentalAgreement() *PassportElementTypeRentalAgreement {
	passportElementTypeRentalAgreementTemp := PassportElementTypeRentalAgreement{
		tdCommon: tdCommon{Type: "passportElementTypeRentalAgreement"},
	}

	return &passportElementTypeRentalAgreementTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementTypeRentalAgreement *PassportElementTypeRentalAgreement) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementTypeRentalAgreement.tdCommon = tempObj.tdCommon

	return nil
}

// GetPassportElementTypeEnum return the enum type of this object
func (passportElementTypeRentalAgreement *PassportElementTypeRentalAgreement) GetPassportElementTypeEnum() PassportElementTypeEnum {
	return PassportElementTypeRentalAgreementType
}

// PassportElementTypePassportRegistration A Telegram Passport element containing the registration page of the user's passport
type PassportElementTypePassportRegistration struct {
	tdCommon
}

// MessageType return the string telegram-type of PassportElementTypePassportRegistration
func (passportElementTypePassportRegistration *PassportElementTypePassportRegistration) MessageType() string {
	return "passportElementTypePassportRegistration"
}

// NewPassportElementTypePassportRegistration creates a new PassportElementTypePassportRegistration
//
func NewPassportElementTypePassportRegistration() *PassportElementTypePassportRegistration {
	passportElementTypePassportRegistrationTemp := PassportElementTypePassportRegistration{
		tdCommon: tdCommon{Type: "passportElementTypePassportRegistration"},
	}

	return &passportElementTypePassportRegistrationTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementTypePassportRegistration *PassportElementTypePassportRegistration) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementTypePassportRegistration.tdCommon = tempObj.tdCommon

	return nil
}

// GetPassportElementTypeEnum return the enum type of this object
func (passportElementTypePassportRegistration *PassportElementTypePassportRegistration) GetPassportElementTypeEnum() PassportElementTypeEnum {
	return PassportElementTypePassportRegistrationType
}

// PassportElementTypeTemporaryRegistration A Telegram Passport element containing the user's temporary registration
type PassportElementTypeTemporaryRegistration struct {
	tdCommon
}

// MessageType return the string telegram-type of PassportElementTypeTemporaryRegistration
func (passportElementTypeTemporaryRegistration *PassportElementTypeTemporaryRegistration) MessageType() string {
	return "passportElementTypeTemporaryRegistration"
}

// NewPassportElementTypeTemporaryRegistration creates a new PassportElementTypeTemporaryRegistration
//
func NewPassportElementTypeTemporaryRegistration() *PassportElementTypeTemporaryRegistration {
	passportElementTypeTemporaryRegistrationTemp := PassportElementTypeTemporaryRegistration{
		tdCommon: tdCommon{Type: "passportElementTypeTemporaryRegistration"},
	}

	return &passportElementTypeTemporaryRegistrationTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementTypeTemporaryRegistration *PassportElementTypeTemporaryRegistration) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementTypeTemporaryRegistration.tdCommon = tempObj.tdCommon

	return nil
}

// GetPassportElementTypeEnum return the enum type of this object
func (passportElementTypeTemporaryRegistration *PassportElementTypeTemporaryRegistration) GetPassportElementTypeEnum() PassportElementTypeEnum {
	return PassportElementTypeTemporaryRegistrationType
}

// PassportElementTypePhoneNumber A Telegram Passport element containing the user's phone number
type PassportElementTypePhoneNumber struct {
	tdCommon
}

// MessageType return the string telegram-type of PassportElementTypePhoneNumber
func (passportElementTypePhoneNumber *PassportElementTypePhoneNumber) MessageType() string {
	return "passportElementTypePhoneNumber"
}

// NewPassportElementTypePhoneNumber creates a new PassportElementTypePhoneNumber
//
func NewPassportElementTypePhoneNumber() *PassportElementTypePhoneNumber {
	passportElementTypePhoneNumberTemp := PassportElementTypePhoneNumber{
		tdCommon: tdCommon{Type: "passportElementTypePhoneNumber"},
	}

	return &passportElementTypePhoneNumberTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementTypePhoneNumber *PassportElementTypePhoneNumber) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementTypePhoneNumber.tdCommon = tempObj.tdCommon

	return nil
}

// GetPassportElementTypeEnum return the enum type of this object
func (passportElementTypePhoneNumber *PassportElementTypePhoneNumber) GetPassportElementTypeEnum() PassportElementTypeEnum {
	return PassportElementTypePhoneNumberType
}

// PassportElementTypeEmailAddress A Telegram Passport element containing the user's email address
type PassportElementTypeEmailAddress struct {
	tdCommon
}

// MessageType return the string telegram-type of PassportElementTypeEmailAddress
func (passportElementTypeEmailAddress *PassportElementTypeEmailAddress) MessageType() string {
	return "passportElementTypeEmailAddress"
}

// NewPassportElementTypeEmailAddress creates a new PassportElementTypeEmailAddress
//
func NewPassportElementTypeEmailAddress() *PassportElementTypeEmailAddress {
	passportElementTypeEmailAddressTemp := PassportElementTypeEmailAddress{
		tdCommon: tdCommon{Type: "passportElementTypeEmailAddress"},
	}

	return &passportElementTypeEmailAddressTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementTypeEmailAddress *PassportElementTypeEmailAddress) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementTypeEmailAddress.tdCommon = tempObj.tdCommon

	return nil
}

// GetPassportElementTypeEnum return the enum type of this object
func (passportElementTypeEmailAddress *PassportElementTypeEmailAddress) GetPassportElementTypeEnum() PassportElementTypeEnum {
	return PassportElementTypeEmailAddressType
}

// Date Represents a date according to the Gregorian calendar
type Date struct {
	tdCommon
	Day   int32 `json:"day"`   // Day of the month; 1-31
	Month int32 `json:"month"` // Month; 1-12
	Year  int32 `json:"year"`  // Year; 1-9999
}

// MessageType return the string telegram-type of Date
func (date *Date) MessageType() string {
	return "date"
}

// NewDate creates a new Date
//
// @param day Day of the month; 1-31
// @param month Month; 1-12
// @param year Year; 1-9999
func NewDate(day int32, month int32, year int32) *Date {
	dateTemp := Date{
		tdCommon: tdCommon{Type: "date"},
		Day:      day,
		Month:    month,
		Year:     year,
	}

	return &dateTemp
}

// UnmarshalJSON unmarshal to json
func (date *Date) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Day   int32 `json:"day"`   // Day of the month; 1-31
		Month int32 `json:"month"` // Month; 1-12
		Year  int32 `json:"year"`  // Year; 1-9999
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	date.tdCommon = tempObj.tdCommon
	date.Day = tempObj.Day
	date.Month = tempObj.Month
	date.Year = tempObj.Year

	return nil
}

// PersonalDetails Contains the user's personal details
type PersonalDetails struct {
	tdCommon
	FirstName            string `json:"first_name"`             // First name of the user written in English; 1-255 characters
	MiddleName           string `json:"middle_name"`            // Middle name of the user written in English; 0-255 characters
	LastName             string `json:"last_name"`              // Last name of the user written in English; 1-255 characters
	NativeFirstName      string `json:"native_first_name"`      // Native first name of the user; 1-255 characters
	NativeMiddleName     string `json:"native_middle_name"`     // Native middle name of the user; 0-255 characters
	NativeLastName       string `json:"native_last_name"`       // Native last name of the user; 1-255 characters
	Birthdate            *Date  `json:"birthdate"`              // Birthdate of the user
	Gender               string `json:"gender"`                 // Gender of the user, "male" or "female"
	CountryCode          string `json:"country_code"`           // A two-letter ISO 3166-1 alpha-2 country code of the user's country
	ResidenceCountryCode string `json:"residence_country_code"` // A two-letter ISO 3166-1 alpha-2 country code of the user's residence country
}

// MessageType return the string telegram-type of PersonalDetails
func (personalDetails *PersonalDetails) MessageType() string {
	return "personalDetails"
}

// NewPersonalDetails creates a new PersonalDetails
//
// @param firstName First name of the user written in English; 1-255 characters
// @param middleName Middle name of the user written in English; 0-255 characters
// @param lastName Last name of the user written in English; 1-255 characters
// @param nativeFirstName Native first name of the user; 1-255 characters
// @param nativeMiddleName Native middle name of the user; 0-255 characters
// @param nativeLastName Native last name of the user; 1-255 characters
// @param birthdate Birthdate of the user
// @param gender Gender of the user, "male" or "female"
// @param countryCode A two-letter ISO 3166-1 alpha-2 country code of the user's country
// @param residenceCountryCode A two-letter ISO 3166-1 alpha-2 country code of the user's residence country
func NewPersonalDetails(firstName string, middleName string, lastName string, nativeFirstName string, nativeMiddleName string, nativeLastName string, birthdate *Date, gender string, countryCode string, residenceCountryCode string) *PersonalDetails {
	personalDetailsTemp := PersonalDetails{
		tdCommon:             tdCommon{Type: "personalDetails"},
		FirstName:            firstName,
		MiddleName:           middleName,
		LastName:             lastName,
		NativeFirstName:      nativeFirstName,
		NativeMiddleName:     nativeMiddleName,
		NativeLastName:       nativeLastName,
		Birthdate:            birthdate,
		Gender:               gender,
		CountryCode:          countryCode,
		ResidenceCountryCode: residenceCountryCode,
	}

	return &personalDetailsTemp
}

// UnmarshalJSON unmarshal to json
func (personalDetails *PersonalDetails) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		FirstName            string `json:"first_name"`             // First name of the user written in English; 1-255 characters
		MiddleName           string `json:"middle_name"`            // Middle name of the user written in English; 0-255 characters
		LastName             string `json:"last_name"`              // Last name of the user written in English; 1-255 characters
		NativeFirstName      string `json:"native_first_name"`      // Native first name of the user; 1-255 characters
		NativeMiddleName     string `json:"native_middle_name"`     // Native middle name of the user; 0-255 characters
		NativeLastName       string `json:"native_last_name"`       // Native last name of the user; 1-255 characters
		Birthdate            *Date  `json:"birthdate"`              // Birthdate of the user
		Gender               string `json:"gender"`                 // Gender of the user, "male" or "female"
		CountryCode          string `json:"country_code"`           // A two-letter ISO 3166-1 alpha-2 country code of the user's country
		ResidenceCountryCode string `json:"residence_country_code"` // A two-letter ISO 3166-1 alpha-2 country code of the user's residence country
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	personalDetails.tdCommon = tempObj.tdCommon
	personalDetails.FirstName = tempObj.FirstName
	personalDetails.MiddleName = tempObj.MiddleName
	personalDetails.LastName = tempObj.LastName
	personalDetails.NativeFirstName = tempObj.NativeFirstName
	personalDetails.NativeMiddleName = tempObj.NativeMiddleName
	personalDetails.NativeLastName = tempObj.NativeLastName
	personalDetails.Birthdate = tempObj.Birthdate
	personalDetails.Gender = tempObj.Gender
	personalDetails.CountryCode = tempObj.CountryCode
	personalDetails.ResidenceCountryCode = tempObj.ResidenceCountryCode

	return nil
}

// IDentityDocument An identity document
type IDentityDocument struct {
	tdCommon
	Number         string      `json:"number"`          // Document number; 1-24 characters
	ExpirationDate *Date       `json:"expiration_date"` // Document expiration date; may be null if not applicable
	FrontSide      *DatedFile  `json:"front_side"`      // Front side of the document
	ReverseSide    *DatedFile  `json:"reverse_side"`    // Reverse side of the document; only for driver license and identity card; may be null
	Selfie         *DatedFile  `json:"selfie"`          // Selfie with the document; may be null
	Translation    []DatedFile `json:"translation"`     // List of files containing a certified English translation of the document
}

// MessageType return the string telegram-type of IDentityDocument
func (iDentityDocument *IDentityDocument) MessageType() string {
	return "identityDocument"
}

// NewIDentityDocument creates a new IDentityDocument
//
// @param number Document number; 1-24 characters
// @param expirationDate Document expiration date; may be null if not applicable
// @param frontSide Front side of the document
// @param reverseSide Reverse side of the document; only for driver license and identity card; may be null
// @param selfie Selfie with the document; may be null
// @param translation List of files containing a certified English translation of the document
func NewIDentityDocument(number string, expirationDate *Date, frontSide *DatedFile, reverseSide *DatedFile, selfie *DatedFile, translation []DatedFile) *IDentityDocument {
	iDentityDocumentTemp := IDentityDocument{
		tdCommon:       tdCommon{Type: "identityDocument"},
		Number:         number,
		ExpirationDate: expirationDate,
		FrontSide:      frontSide,
		ReverseSide:    reverseSide,
		Selfie:         selfie,
		Translation:    translation,
	}

	return &iDentityDocumentTemp
}

// UnmarshalJSON unmarshal to json
func (iDentityDocument *IDentityDocument) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Number         string      `json:"number"`          // Document number; 1-24 characters
		ExpirationDate *Date       `json:"expiration_date"` // Document expiration date; may be null if not applicable
		FrontSide      *DatedFile  `json:"front_side"`      // Front side of the document
		ReverseSide    *DatedFile  `json:"reverse_side"`    // Reverse side of the document; only for driver license and identity card; may be null
		Selfie         *DatedFile  `json:"selfie"`          // Selfie with the document; may be null
		Translation    []DatedFile `json:"translation"`     // List of files containing a certified English translation of the document
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	iDentityDocument.tdCommon = tempObj.tdCommon
	iDentityDocument.Number = tempObj.Number
	iDentityDocument.ExpirationDate = tempObj.ExpirationDate
	iDentityDocument.FrontSide = tempObj.FrontSide
	iDentityDocument.ReverseSide = tempObj.ReverseSide
	iDentityDocument.Selfie = tempObj.Selfie
	iDentityDocument.Translation = tempObj.Translation

	return nil
}

// InputIDentityDocument An identity document to be saved to Telegram Passport
type InputIDentityDocument struct {
	tdCommon
	Number         string      `json:"number"`          // Document number; 1-24 characters
	ExpirationDate *Date       `json:"expiration_date"` // Document expiration date; pass null if not applicable
	FrontSide      InputFile   `json:"front_side"`      // Front side of the document
	ReverseSide    InputFile   `json:"reverse_side"`    // Reverse side of the document; only for driver license and identity card; pass null otherwise
	Selfie         InputFile   `json:"selfie"`          // Selfie with the document; pass null if unavailable
	Translation    []InputFile `json:"translation"`     // List of files containing a certified English translation of the document
}

// MessageType return the string telegram-type of InputIDentityDocument
func (inputIDentityDocument *InputIDentityDocument) MessageType() string {
	return "inputIdentityDocument"
}

// NewInputIDentityDocument creates a new InputIDentityDocument
//
// @param number Document number; 1-24 characters
// @param expirationDate Document expiration date; pass null if not applicable
// @param frontSide Front side of the document
// @param reverseSide Reverse side of the document; only for driver license and identity card; pass null otherwise
// @param selfie Selfie with the document; pass null if unavailable
// @param translation List of files containing a certified English translation of the document
func NewInputIDentityDocument(number string, expirationDate *Date, frontSide InputFile, reverseSide InputFile, selfie InputFile, translation []InputFile) *InputIDentityDocument {
	inputIDentityDocumentTemp := InputIDentityDocument{
		tdCommon:       tdCommon{Type: "inputIdentityDocument"},
		Number:         number,
		ExpirationDate: expirationDate,
		FrontSide:      frontSide,
		ReverseSide:    reverseSide,
		Selfie:         selfie,
		Translation:    translation,
	}

	return &inputIDentityDocumentTemp
}

// UnmarshalJSON unmarshal to json
func (inputIDentityDocument *InputIDentityDocument) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Number         string `json:"number"`          // Document number; 1-24 characters
		ExpirationDate *Date  `json:"expiration_date"` // Document expiration date; pass null if not applicable

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputIDentityDocument.tdCommon = tempObj.tdCommon
	inputIDentityDocument.Number = tempObj.Number
	inputIDentityDocument.ExpirationDate = tempObj.ExpirationDate

	fieldFrontSide, _ := unmarshalInputFile(objMap["front_side"])
	inputIDentityDocument.FrontSide = fieldFrontSide

	fieldReverseSide, _ := unmarshalInputFile(objMap["reverse_side"])
	inputIDentityDocument.ReverseSide = fieldReverseSide

	fieldSelfie, _ := unmarshalInputFile(objMap["selfie"])
	inputIDentityDocument.Selfie = fieldSelfie

	fieldTranslation, _ := unmarshalInputFileSlice(objMap["translation"])
	inputIDentityDocument.Translation = fieldTranslation

	return nil
}

// PersonalDocument A personal document, containing some information about a user
type PersonalDocument struct {
	tdCommon
	Files       []DatedFile `json:"files"`       // List of files containing the pages of the document
	Translation []DatedFile `json:"translation"` // List of files containing a certified English translation of the document
}

// MessageType return the string telegram-type of PersonalDocument
func (personalDocument *PersonalDocument) MessageType() string {
	return "personalDocument"
}

// NewPersonalDocument creates a new PersonalDocument
//
// @param files List of files containing the pages of the document
// @param translation List of files containing a certified English translation of the document
func NewPersonalDocument(files []DatedFile, translation []DatedFile) *PersonalDocument {
	personalDocumentTemp := PersonalDocument{
		tdCommon:    tdCommon{Type: "personalDocument"},
		Files:       files,
		Translation: translation,
	}

	return &personalDocumentTemp
}

// UnmarshalJSON unmarshal to json
func (personalDocument *PersonalDocument) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Files       []DatedFile `json:"files"`       // List of files containing the pages of the document
		Translation []DatedFile `json:"translation"` // List of files containing a certified English translation of the document
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	personalDocument.tdCommon = tempObj.tdCommon
	personalDocument.Files = tempObj.Files
	personalDocument.Translation = tempObj.Translation

	return nil
}

// InputPersonalDocument A personal document to be saved to Telegram Passport
type InputPersonalDocument struct {
	tdCommon
	Files       []InputFile `json:"files"`       // List of files containing the pages of the document
	Translation []InputFile `json:"translation"` // List of files containing a certified English translation of the document
}

// MessageType return the string telegram-type of InputPersonalDocument
func (inputPersonalDocument *InputPersonalDocument) MessageType() string {
	return "inputPersonalDocument"
}

// NewInputPersonalDocument creates a new InputPersonalDocument
//
// @param files List of files containing the pages of the document
// @param translation List of files containing a certified English translation of the document
func NewInputPersonalDocument(files []InputFile, translation []InputFile) *InputPersonalDocument {
	inputPersonalDocumentTemp := InputPersonalDocument{
		tdCommon:    tdCommon{Type: "inputPersonalDocument"},
		Files:       files,
		Translation: translation,
	}

	return &inputPersonalDocumentTemp
}

// UnmarshalJSON unmarshal to json
func (inputPersonalDocument *InputPersonalDocument) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPersonalDocument.tdCommon = tempObj.tdCommon

	fieldFiles, _ := unmarshalInputFileSlice(objMap["files"])
	inputPersonalDocument.Files = fieldFiles

	fieldTranslation, _ := unmarshalInputFileSlice(objMap["translation"])
	inputPersonalDocument.Translation = fieldTranslation

	return nil
}

// PassportElementPersonalDetails A Telegram Passport element containing the user's personal details
type PassportElementPersonalDetails struct {
	tdCommon
	PersonalDetails *PersonalDetails `json:"personal_details"` // Personal details of the user
}

// MessageType return the string telegram-type of PassportElementPersonalDetails
func (passportElementPersonalDetails *PassportElementPersonalDetails) MessageType() string {
	return "passportElementPersonalDetails"
}

// NewPassportElementPersonalDetails creates a new PassportElementPersonalDetails
//
// @param personalDetails Personal details of the user
func NewPassportElementPersonalDetails(personalDetails *PersonalDetails) *PassportElementPersonalDetails {
	passportElementPersonalDetailsTemp := PassportElementPersonalDetails{
		tdCommon:        tdCommon{Type: "passportElementPersonalDetails"},
		PersonalDetails: personalDetails,
	}

	return &passportElementPersonalDetailsTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementPersonalDetails *PassportElementPersonalDetails) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PersonalDetails *PersonalDetails `json:"personal_details"` // Personal details of the user
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementPersonalDetails.tdCommon = tempObj.tdCommon
	passportElementPersonalDetails.PersonalDetails = tempObj.PersonalDetails

	return nil
}

// GetPassportElementEnum return the enum type of this object
func (passportElementPersonalDetails *PassportElementPersonalDetails) GetPassportElementEnum() PassportElementEnum {
	return PassportElementPersonalDetailsType
}

// PassportElementPassport A Telegram Passport element containing the user's passport
type PassportElementPassport struct {
	tdCommon
	Passport *IDentityDocument `json:"passport"` // Passport
}

// MessageType return the string telegram-type of PassportElementPassport
func (passportElementPassport *PassportElementPassport) MessageType() string {
	return "passportElementPassport"
}

// NewPassportElementPassport creates a new PassportElementPassport
//
// @param passport Passport
func NewPassportElementPassport(passport *IDentityDocument) *PassportElementPassport {
	passportElementPassportTemp := PassportElementPassport{
		tdCommon: tdCommon{Type: "passportElementPassport"},
		Passport: passport,
	}

	return &passportElementPassportTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementPassport *PassportElementPassport) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Passport *IDentityDocument `json:"passport"` // Passport
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementPassport.tdCommon = tempObj.tdCommon
	passportElementPassport.Passport = tempObj.Passport

	return nil
}

// GetPassportElementEnum return the enum type of this object
func (passportElementPassport *PassportElementPassport) GetPassportElementEnum() PassportElementEnum {
	return PassportElementPassportType
}

// PassportElementDriverLicense A Telegram Passport element containing the user's driver license
type PassportElementDriverLicense struct {
	tdCommon
	DriverLicense *IDentityDocument `json:"driver_license"` // Driver license
}

// MessageType return the string telegram-type of PassportElementDriverLicense
func (passportElementDriverLicense *PassportElementDriverLicense) MessageType() string {
	return "passportElementDriverLicense"
}

// NewPassportElementDriverLicense creates a new PassportElementDriverLicense
//
// @param driverLicense Driver license
func NewPassportElementDriverLicense(driverLicense *IDentityDocument) *PassportElementDriverLicense {
	passportElementDriverLicenseTemp := PassportElementDriverLicense{
		tdCommon:      tdCommon{Type: "passportElementDriverLicense"},
		DriverLicense: driverLicense,
	}

	return &passportElementDriverLicenseTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementDriverLicense *PassportElementDriverLicense) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		DriverLicense *IDentityDocument `json:"driver_license"` // Driver license
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementDriverLicense.tdCommon = tempObj.tdCommon
	passportElementDriverLicense.DriverLicense = tempObj.DriverLicense

	return nil
}

// GetPassportElementEnum return the enum type of this object
func (passportElementDriverLicense *PassportElementDriverLicense) GetPassportElementEnum() PassportElementEnum {
	return PassportElementDriverLicenseType
}

// PassportElementIDentityCard A Telegram Passport element containing the user's identity card
type PassportElementIDentityCard struct {
	tdCommon
	IDentityCard *IDentityDocument `json:"identity_card"` // Identity card
}

// MessageType return the string telegram-type of PassportElementIDentityCard
func (passportElementIDentityCard *PassportElementIDentityCard) MessageType() string {
	return "passportElementIdentityCard"
}

// NewPassportElementIDentityCard creates a new PassportElementIDentityCard
//
// @param iDentityCard Identity card
func NewPassportElementIDentityCard(iDentityCard *IDentityDocument) *PassportElementIDentityCard {
	passportElementIDentityCardTemp := PassportElementIDentityCard{
		tdCommon:     tdCommon{Type: "passportElementIdentityCard"},
		IDentityCard: iDentityCard,
	}

	return &passportElementIDentityCardTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementIDentityCard *PassportElementIDentityCard) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IDentityCard *IDentityDocument `json:"identity_card"` // Identity card
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementIDentityCard.tdCommon = tempObj.tdCommon
	passportElementIDentityCard.IDentityCard = tempObj.IDentityCard

	return nil
}

// GetPassportElementEnum return the enum type of this object
func (passportElementIDentityCard *PassportElementIDentityCard) GetPassportElementEnum() PassportElementEnum {
	return PassportElementIDentityCardType
}

// PassportElementInternalPassport A Telegram Passport element containing the user's internal passport
type PassportElementInternalPassport struct {
	tdCommon
	InternalPassport *IDentityDocument `json:"internal_passport"` // Internal passport
}

// MessageType return the string telegram-type of PassportElementInternalPassport
func (passportElementInternalPassport *PassportElementInternalPassport) MessageType() string {
	return "passportElementInternalPassport"
}

// NewPassportElementInternalPassport creates a new PassportElementInternalPassport
//
// @param internalPassport Internal passport
func NewPassportElementInternalPassport(internalPassport *IDentityDocument) *PassportElementInternalPassport {
	passportElementInternalPassportTemp := PassportElementInternalPassport{
		tdCommon:         tdCommon{Type: "passportElementInternalPassport"},
		InternalPassport: internalPassport,
	}

	return &passportElementInternalPassportTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementInternalPassport *PassportElementInternalPassport) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		InternalPassport *IDentityDocument `json:"internal_passport"` // Internal passport
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementInternalPassport.tdCommon = tempObj.tdCommon
	passportElementInternalPassport.InternalPassport = tempObj.InternalPassport

	return nil
}

// GetPassportElementEnum return the enum type of this object
func (passportElementInternalPassport *PassportElementInternalPassport) GetPassportElementEnum() PassportElementEnum {
	return PassportElementInternalPassportType
}

// PassportElementAddress A Telegram Passport element containing the user's address
type PassportElementAddress struct {
	tdCommon
	Address *Address `json:"address"` // Address
}

// MessageType return the string telegram-type of PassportElementAddress
func (passportElementAddress *PassportElementAddress) MessageType() string {
	return "passportElementAddress"
}

// NewPassportElementAddress creates a new PassportElementAddress
//
// @param address Address
func NewPassportElementAddress(address *Address) *PassportElementAddress {
	passportElementAddressTemp := PassportElementAddress{
		tdCommon: tdCommon{Type: "passportElementAddress"},
		Address:  address,
	}

	return &passportElementAddressTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementAddress *PassportElementAddress) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Address *Address `json:"address"` // Address
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementAddress.tdCommon = tempObj.tdCommon
	passportElementAddress.Address = tempObj.Address

	return nil
}

// GetPassportElementEnum return the enum type of this object
func (passportElementAddress *PassportElementAddress) GetPassportElementEnum() PassportElementEnum {
	return PassportElementAddressType
}

// PassportElementUtilityBill A Telegram Passport element containing the user's utility bill
type PassportElementUtilityBill struct {
	tdCommon
	UtilityBill *PersonalDocument `json:"utility_bill"` // Utility bill
}

// MessageType return the string telegram-type of PassportElementUtilityBill
func (passportElementUtilityBill *PassportElementUtilityBill) MessageType() string {
	return "passportElementUtilityBill"
}

// NewPassportElementUtilityBill creates a new PassportElementUtilityBill
//
// @param utilityBill Utility bill
func NewPassportElementUtilityBill(utilityBill *PersonalDocument) *PassportElementUtilityBill {
	passportElementUtilityBillTemp := PassportElementUtilityBill{
		tdCommon:    tdCommon{Type: "passportElementUtilityBill"},
		UtilityBill: utilityBill,
	}

	return &passportElementUtilityBillTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementUtilityBill *PassportElementUtilityBill) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UtilityBill *PersonalDocument `json:"utility_bill"` // Utility bill
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementUtilityBill.tdCommon = tempObj.tdCommon
	passportElementUtilityBill.UtilityBill = tempObj.UtilityBill

	return nil
}

// GetPassportElementEnum return the enum type of this object
func (passportElementUtilityBill *PassportElementUtilityBill) GetPassportElementEnum() PassportElementEnum {
	return PassportElementUtilityBillType
}

// PassportElementBankStatement A Telegram Passport element containing the user's bank statement
type PassportElementBankStatement struct {
	tdCommon
	BankStatement *PersonalDocument `json:"bank_statement"` // Bank statement
}

// MessageType return the string telegram-type of PassportElementBankStatement
func (passportElementBankStatement *PassportElementBankStatement) MessageType() string {
	return "passportElementBankStatement"
}

// NewPassportElementBankStatement creates a new PassportElementBankStatement
//
// @param bankStatement Bank statement
func NewPassportElementBankStatement(bankStatement *PersonalDocument) *PassportElementBankStatement {
	passportElementBankStatementTemp := PassportElementBankStatement{
		tdCommon:      tdCommon{Type: "passportElementBankStatement"},
		BankStatement: bankStatement,
	}

	return &passportElementBankStatementTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementBankStatement *PassportElementBankStatement) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BankStatement *PersonalDocument `json:"bank_statement"` // Bank statement
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementBankStatement.tdCommon = tempObj.tdCommon
	passportElementBankStatement.BankStatement = tempObj.BankStatement

	return nil
}

// GetPassportElementEnum return the enum type of this object
func (passportElementBankStatement *PassportElementBankStatement) GetPassportElementEnum() PassportElementEnum {
	return PassportElementBankStatementType
}

// PassportElementRentalAgreement A Telegram Passport element containing the user's rental agreement
type PassportElementRentalAgreement struct {
	tdCommon
	RentalAgreement *PersonalDocument `json:"rental_agreement"` // Rental agreement
}

// MessageType return the string telegram-type of PassportElementRentalAgreement
func (passportElementRentalAgreement *PassportElementRentalAgreement) MessageType() string {
	return "passportElementRentalAgreement"
}

// NewPassportElementRentalAgreement creates a new PassportElementRentalAgreement
//
// @param rentalAgreement Rental agreement
func NewPassportElementRentalAgreement(rentalAgreement *PersonalDocument) *PassportElementRentalAgreement {
	passportElementRentalAgreementTemp := PassportElementRentalAgreement{
		tdCommon:        tdCommon{Type: "passportElementRentalAgreement"},
		RentalAgreement: rentalAgreement,
	}

	return &passportElementRentalAgreementTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementRentalAgreement *PassportElementRentalAgreement) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		RentalAgreement *PersonalDocument `json:"rental_agreement"` // Rental agreement
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementRentalAgreement.tdCommon = tempObj.tdCommon
	passportElementRentalAgreement.RentalAgreement = tempObj.RentalAgreement

	return nil
}

// GetPassportElementEnum return the enum type of this object
func (passportElementRentalAgreement *PassportElementRentalAgreement) GetPassportElementEnum() PassportElementEnum {
	return PassportElementRentalAgreementType
}

// PassportElementPassportRegistration A Telegram Passport element containing the user's passport registration pages
type PassportElementPassportRegistration struct {
	tdCommon
	PassportRegistration *PersonalDocument `json:"passport_registration"` // Passport registration pages
}

// MessageType return the string telegram-type of PassportElementPassportRegistration
func (passportElementPassportRegistration *PassportElementPassportRegistration) MessageType() string {
	return "passportElementPassportRegistration"
}

// NewPassportElementPassportRegistration creates a new PassportElementPassportRegistration
//
// @param passportRegistration Passport registration pages
func NewPassportElementPassportRegistration(passportRegistration *PersonalDocument) *PassportElementPassportRegistration {
	passportElementPassportRegistrationTemp := PassportElementPassportRegistration{
		tdCommon:             tdCommon{Type: "passportElementPassportRegistration"},
		PassportRegistration: passportRegistration,
	}

	return &passportElementPassportRegistrationTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementPassportRegistration *PassportElementPassportRegistration) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PassportRegistration *PersonalDocument `json:"passport_registration"` // Passport registration pages
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementPassportRegistration.tdCommon = tempObj.tdCommon
	passportElementPassportRegistration.PassportRegistration = tempObj.PassportRegistration

	return nil
}

// GetPassportElementEnum return the enum type of this object
func (passportElementPassportRegistration *PassportElementPassportRegistration) GetPassportElementEnum() PassportElementEnum {
	return PassportElementPassportRegistrationType
}

// PassportElementTemporaryRegistration A Telegram Passport element containing the user's temporary registration
type PassportElementTemporaryRegistration struct {
	tdCommon
	TemporaryRegistration *PersonalDocument `json:"temporary_registration"` // Temporary registration
}

// MessageType return the string telegram-type of PassportElementTemporaryRegistration
func (passportElementTemporaryRegistration *PassportElementTemporaryRegistration) MessageType() string {
	return "passportElementTemporaryRegistration"
}

// NewPassportElementTemporaryRegistration creates a new PassportElementTemporaryRegistration
//
// @param temporaryRegistration Temporary registration
func NewPassportElementTemporaryRegistration(temporaryRegistration *PersonalDocument) *PassportElementTemporaryRegistration {
	passportElementTemporaryRegistrationTemp := PassportElementTemporaryRegistration{
		tdCommon:              tdCommon{Type: "passportElementTemporaryRegistration"},
		TemporaryRegistration: temporaryRegistration,
	}

	return &passportElementTemporaryRegistrationTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementTemporaryRegistration *PassportElementTemporaryRegistration) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TemporaryRegistration *PersonalDocument `json:"temporary_registration"` // Temporary registration
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementTemporaryRegistration.tdCommon = tempObj.tdCommon
	passportElementTemporaryRegistration.TemporaryRegistration = tempObj.TemporaryRegistration

	return nil
}

// GetPassportElementEnum return the enum type of this object
func (passportElementTemporaryRegistration *PassportElementTemporaryRegistration) GetPassportElementEnum() PassportElementEnum {
	return PassportElementTemporaryRegistrationType
}

// PassportElementPhoneNumber A Telegram Passport element containing the user's phone number
type PassportElementPhoneNumber struct {
	tdCommon
	PhoneNumber string `json:"phone_number"` // Phone number
}

// MessageType return the string telegram-type of PassportElementPhoneNumber
func (passportElementPhoneNumber *PassportElementPhoneNumber) MessageType() string {
	return "passportElementPhoneNumber"
}

// NewPassportElementPhoneNumber creates a new PassportElementPhoneNumber
//
// @param phoneNumber Phone number
func NewPassportElementPhoneNumber(phoneNumber string) *PassportElementPhoneNumber {
	passportElementPhoneNumberTemp := PassportElementPhoneNumber{
		tdCommon:    tdCommon{Type: "passportElementPhoneNumber"},
		PhoneNumber: phoneNumber,
	}

	return &passportElementPhoneNumberTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementPhoneNumber *PassportElementPhoneNumber) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PhoneNumber string `json:"phone_number"` // Phone number
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementPhoneNumber.tdCommon = tempObj.tdCommon
	passportElementPhoneNumber.PhoneNumber = tempObj.PhoneNumber

	return nil
}

// GetPassportElementEnum return the enum type of this object
func (passportElementPhoneNumber *PassportElementPhoneNumber) GetPassportElementEnum() PassportElementEnum {
	return PassportElementPhoneNumberType
}

// PassportElementEmailAddress A Telegram Passport element containing the user's email address
type PassportElementEmailAddress struct {
	tdCommon
	EmailAddress string `json:"email_address"` // Email address
}

// MessageType return the string telegram-type of PassportElementEmailAddress
func (passportElementEmailAddress *PassportElementEmailAddress) MessageType() string {
	return "passportElementEmailAddress"
}

// NewPassportElementEmailAddress creates a new PassportElementEmailAddress
//
// @param emailAddress Email address
func NewPassportElementEmailAddress(emailAddress string) *PassportElementEmailAddress {
	passportElementEmailAddressTemp := PassportElementEmailAddress{
		tdCommon:     tdCommon{Type: "passportElementEmailAddress"},
		EmailAddress: emailAddress,
	}

	return &passportElementEmailAddressTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementEmailAddress *PassportElementEmailAddress) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		EmailAddress string `json:"email_address"` // Email address
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementEmailAddress.tdCommon = tempObj.tdCommon
	passportElementEmailAddress.EmailAddress = tempObj.EmailAddress

	return nil
}

// GetPassportElementEnum return the enum type of this object
func (passportElementEmailAddress *PassportElementEmailAddress) GetPassportElementEnum() PassportElementEnum {
	return PassportElementEmailAddressType
}

// InputPassportElementPersonalDetails A Telegram Passport element to be saved containing the user's personal details
type InputPassportElementPersonalDetails struct {
	tdCommon
	PersonalDetails *PersonalDetails `json:"personal_details"` // Personal details of the user
}

// MessageType return the string telegram-type of InputPassportElementPersonalDetails
func (inputPassportElementPersonalDetails *InputPassportElementPersonalDetails) MessageType() string {
	return "inputPassportElementPersonalDetails"
}

// NewInputPassportElementPersonalDetails creates a new InputPassportElementPersonalDetails
//
// @param personalDetails Personal details of the user
func NewInputPassportElementPersonalDetails(personalDetails *PersonalDetails) *InputPassportElementPersonalDetails {
	inputPassportElementPersonalDetailsTemp := InputPassportElementPersonalDetails{
		tdCommon:        tdCommon{Type: "inputPassportElementPersonalDetails"},
		PersonalDetails: personalDetails,
	}

	return &inputPassportElementPersonalDetailsTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementPersonalDetails *InputPassportElementPersonalDetails) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PersonalDetails *PersonalDetails `json:"personal_details"` // Personal details of the user
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementPersonalDetails.tdCommon = tempObj.tdCommon
	inputPassportElementPersonalDetails.PersonalDetails = tempObj.PersonalDetails

	return nil
}

// GetInputPassportElementEnum return the enum type of this object
func (inputPassportElementPersonalDetails *InputPassportElementPersonalDetails) GetInputPassportElementEnum() InputPassportElementEnum {
	return InputPassportElementPersonalDetailsType
}

// InputPassportElementPassport A Telegram Passport element to be saved containing the user's passport
type InputPassportElementPassport struct {
	tdCommon
	Passport *InputIDentityDocument `json:"passport"` // The passport to be saved
}

// MessageType return the string telegram-type of InputPassportElementPassport
func (inputPassportElementPassport *InputPassportElementPassport) MessageType() string {
	return "inputPassportElementPassport"
}

// NewInputPassportElementPassport creates a new InputPassportElementPassport
//
// @param passport The passport to be saved
func NewInputPassportElementPassport(passport *InputIDentityDocument) *InputPassportElementPassport {
	inputPassportElementPassportTemp := InputPassportElementPassport{
		tdCommon: tdCommon{Type: "inputPassportElementPassport"},
		Passport: passport,
	}

	return &inputPassportElementPassportTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementPassport *InputPassportElementPassport) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementPassport.tdCommon = tempObj.tdCommon

	var passport InputIDentityDocument
	if objMap["passport"] != nil {
		err = passport.UnmarshalJSON(*objMap["passport"])
		if err != nil {
			return err
		}
	}

	inputPassportElementPassport.Passport = &passport

	return nil
}

// GetInputPassportElementEnum return the enum type of this object
func (inputPassportElementPassport *InputPassportElementPassport) GetInputPassportElementEnum() InputPassportElementEnum {
	return InputPassportElementPassportType
}

// InputPassportElementDriverLicense A Telegram Passport element to be saved containing the user's driver license
type InputPassportElementDriverLicense struct {
	tdCommon
	DriverLicense *InputIDentityDocument `json:"driver_license"` // The driver license to be saved
}

// MessageType return the string telegram-type of InputPassportElementDriverLicense
func (inputPassportElementDriverLicense *InputPassportElementDriverLicense) MessageType() string {
	return "inputPassportElementDriverLicense"
}

// NewInputPassportElementDriverLicense creates a new InputPassportElementDriverLicense
//
// @param driverLicense The driver license to be saved
func NewInputPassportElementDriverLicense(driverLicense *InputIDentityDocument) *InputPassportElementDriverLicense {
	inputPassportElementDriverLicenseTemp := InputPassportElementDriverLicense{
		tdCommon:      tdCommon{Type: "inputPassportElementDriverLicense"},
		DriverLicense: driverLicense,
	}

	return &inputPassportElementDriverLicenseTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementDriverLicense *InputPassportElementDriverLicense) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementDriverLicense.tdCommon = tempObj.tdCommon

	var driverLicense InputIDentityDocument
	if objMap["driver_license"] != nil {
		err = driverLicense.UnmarshalJSON(*objMap["driver_license"])
		if err != nil {
			return err
		}
	}

	inputPassportElementDriverLicense.DriverLicense = &driverLicense

	return nil
}

// GetInputPassportElementEnum return the enum type of this object
func (inputPassportElementDriverLicense *InputPassportElementDriverLicense) GetInputPassportElementEnum() InputPassportElementEnum {
	return InputPassportElementDriverLicenseType
}

// InputPassportElementIDentityCard A Telegram Passport element to be saved containing the user's identity card
type InputPassportElementIDentityCard struct {
	tdCommon
	IDentityCard *InputIDentityDocument `json:"identity_card"` // The identity card to be saved
}

// MessageType return the string telegram-type of InputPassportElementIDentityCard
func (inputPassportElementIDentityCard *InputPassportElementIDentityCard) MessageType() string {
	return "inputPassportElementIdentityCard"
}

// NewInputPassportElementIDentityCard creates a new InputPassportElementIDentityCard
//
// @param iDentityCard The identity card to be saved
func NewInputPassportElementIDentityCard(iDentityCard *InputIDentityDocument) *InputPassportElementIDentityCard {
	inputPassportElementIDentityCardTemp := InputPassportElementIDentityCard{
		tdCommon:     tdCommon{Type: "inputPassportElementIdentityCard"},
		IDentityCard: iDentityCard,
	}

	return &inputPassportElementIDentityCardTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementIDentityCard *InputPassportElementIDentityCard) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementIDentityCard.tdCommon = tempObj.tdCommon

	var identityCard InputIDentityDocument
	if objMap["identity_card"] != nil {
		err = identityCard.UnmarshalJSON(*objMap["identity_card"])
		if err != nil {
			return err
		}
	}

	inputPassportElementIDentityCard.IDentityCard = &identityCard

	return nil
}

// GetInputPassportElementEnum return the enum type of this object
func (inputPassportElementIDentityCard *InputPassportElementIDentityCard) GetInputPassportElementEnum() InputPassportElementEnum {
	return InputPassportElementIDentityCardType
}

// InputPassportElementInternalPassport A Telegram Passport element to be saved containing the user's internal passport
type InputPassportElementInternalPassport struct {
	tdCommon
	InternalPassport *InputIDentityDocument `json:"internal_passport"` // The internal passport to be saved
}

// MessageType return the string telegram-type of InputPassportElementInternalPassport
func (inputPassportElementInternalPassport *InputPassportElementInternalPassport) MessageType() string {
	return "inputPassportElementInternalPassport"
}

// NewInputPassportElementInternalPassport creates a new InputPassportElementInternalPassport
//
// @param internalPassport The internal passport to be saved
func NewInputPassportElementInternalPassport(internalPassport *InputIDentityDocument) *InputPassportElementInternalPassport {
	inputPassportElementInternalPassportTemp := InputPassportElementInternalPassport{
		tdCommon:         tdCommon{Type: "inputPassportElementInternalPassport"},
		InternalPassport: internalPassport,
	}

	return &inputPassportElementInternalPassportTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementInternalPassport *InputPassportElementInternalPassport) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementInternalPassport.tdCommon = tempObj.tdCommon

	var internalPassport InputIDentityDocument
	if objMap["internal_passport"] != nil {
		err = internalPassport.UnmarshalJSON(*objMap["internal_passport"])
		if err != nil {
			return err
		}
	}

	inputPassportElementInternalPassport.InternalPassport = &internalPassport

	return nil
}

// GetInputPassportElementEnum return the enum type of this object
func (inputPassportElementInternalPassport *InputPassportElementInternalPassport) GetInputPassportElementEnum() InputPassportElementEnum {
	return InputPassportElementInternalPassportType
}

// InputPassportElementAddress A Telegram Passport element to be saved containing the user's address
type InputPassportElementAddress struct {
	tdCommon
	Address *Address `json:"address"` // The address to be saved
}

// MessageType return the string telegram-type of InputPassportElementAddress
func (inputPassportElementAddress *InputPassportElementAddress) MessageType() string {
	return "inputPassportElementAddress"
}

// NewInputPassportElementAddress creates a new InputPassportElementAddress
//
// @param address The address to be saved
func NewInputPassportElementAddress(address *Address) *InputPassportElementAddress {
	inputPassportElementAddressTemp := InputPassportElementAddress{
		tdCommon: tdCommon{Type: "inputPassportElementAddress"},
		Address:  address,
	}

	return &inputPassportElementAddressTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementAddress *InputPassportElementAddress) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Address *Address `json:"address"` // The address to be saved
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementAddress.tdCommon = tempObj.tdCommon
	inputPassportElementAddress.Address = tempObj.Address

	return nil
}

// GetInputPassportElementEnum return the enum type of this object
func (inputPassportElementAddress *InputPassportElementAddress) GetInputPassportElementEnum() InputPassportElementEnum {
	return InputPassportElementAddressType
}

// InputPassportElementUtilityBill A Telegram Passport element to be saved containing the user's utility bill
type InputPassportElementUtilityBill struct {
	tdCommon
	UtilityBill *InputPersonalDocument `json:"utility_bill"` // The utility bill to be saved
}

// MessageType return the string telegram-type of InputPassportElementUtilityBill
func (inputPassportElementUtilityBill *InputPassportElementUtilityBill) MessageType() string {
	return "inputPassportElementUtilityBill"
}

// NewInputPassportElementUtilityBill creates a new InputPassportElementUtilityBill
//
// @param utilityBill The utility bill to be saved
func NewInputPassportElementUtilityBill(utilityBill *InputPersonalDocument) *InputPassportElementUtilityBill {
	inputPassportElementUtilityBillTemp := InputPassportElementUtilityBill{
		tdCommon:    tdCommon{Type: "inputPassportElementUtilityBill"},
		UtilityBill: utilityBill,
	}

	return &inputPassportElementUtilityBillTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementUtilityBill *InputPassportElementUtilityBill) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementUtilityBill.tdCommon = tempObj.tdCommon

	var utilityBill InputPersonalDocument
	if objMap["utility_bill"] != nil {
		err = utilityBill.UnmarshalJSON(*objMap["utility_bill"])
		if err != nil {
			return err
		}
	}

	inputPassportElementUtilityBill.UtilityBill = &utilityBill

	return nil
}

// GetInputPassportElementEnum return the enum type of this object
func (inputPassportElementUtilityBill *InputPassportElementUtilityBill) GetInputPassportElementEnum() InputPassportElementEnum {
	return InputPassportElementUtilityBillType
}

// InputPassportElementBankStatement A Telegram Passport element to be saved containing the user's bank statement
type InputPassportElementBankStatement struct {
	tdCommon
	BankStatement *InputPersonalDocument `json:"bank_statement"` // The bank statement to be saved
}

// MessageType return the string telegram-type of InputPassportElementBankStatement
func (inputPassportElementBankStatement *InputPassportElementBankStatement) MessageType() string {
	return "inputPassportElementBankStatement"
}

// NewInputPassportElementBankStatement creates a new InputPassportElementBankStatement
//
// @param bankStatement The bank statement to be saved
func NewInputPassportElementBankStatement(bankStatement *InputPersonalDocument) *InputPassportElementBankStatement {
	inputPassportElementBankStatementTemp := InputPassportElementBankStatement{
		tdCommon:      tdCommon{Type: "inputPassportElementBankStatement"},
		BankStatement: bankStatement,
	}

	return &inputPassportElementBankStatementTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementBankStatement *InputPassportElementBankStatement) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementBankStatement.tdCommon = tempObj.tdCommon

	var bankStatement InputPersonalDocument
	if objMap["bank_statement"] != nil {
		err = bankStatement.UnmarshalJSON(*objMap["bank_statement"])
		if err != nil {
			return err
		}
	}

	inputPassportElementBankStatement.BankStatement = &bankStatement

	return nil
}

// GetInputPassportElementEnum return the enum type of this object
func (inputPassportElementBankStatement *InputPassportElementBankStatement) GetInputPassportElementEnum() InputPassportElementEnum {
	return InputPassportElementBankStatementType
}

// InputPassportElementRentalAgreement A Telegram Passport element to be saved containing the user's rental agreement
type InputPassportElementRentalAgreement struct {
	tdCommon
	RentalAgreement *InputPersonalDocument `json:"rental_agreement"` // The rental agreement to be saved
}

// MessageType return the string telegram-type of InputPassportElementRentalAgreement
func (inputPassportElementRentalAgreement *InputPassportElementRentalAgreement) MessageType() string {
	return "inputPassportElementRentalAgreement"
}

// NewInputPassportElementRentalAgreement creates a new InputPassportElementRentalAgreement
//
// @param rentalAgreement The rental agreement to be saved
func NewInputPassportElementRentalAgreement(rentalAgreement *InputPersonalDocument) *InputPassportElementRentalAgreement {
	inputPassportElementRentalAgreementTemp := InputPassportElementRentalAgreement{
		tdCommon:        tdCommon{Type: "inputPassportElementRentalAgreement"},
		RentalAgreement: rentalAgreement,
	}

	return &inputPassportElementRentalAgreementTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementRentalAgreement *InputPassportElementRentalAgreement) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementRentalAgreement.tdCommon = tempObj.tdCommon

	var rentalAgreement InputPersonalDocument
	if objMap["rental_agreement"] != nil {
		err = rentalAgreement.UnmarshalJSON(*objMap["rental_agreement"])
		if err != nil {
			return err
		}
	}

	inputPassportElementRentalAgreement.RentalAgreement = &rentalAgreement

	return nil
}

// GetInputPassportElementEnum return the enum type of this object
func (inputPassportElementRentalAgreement *InputPassportElementRentalAgreement) GetInputPassportElementEnum() InputPassportElementEnum {
	return InputPassportElementRentalAgreementType
}

// InputPassportElementPassportRegistration A Telegram Passport element to be saved containing the user's passport registration
type InputPassportElementPassportRegistration struct {
	tdCommon
	PassportRegistration *InputPersonalDocument `json:"passport_registration"` // The passport registration page to be saved
}

// MessageType return the string telegram-type of InputPassportElementPassportRegistration
func (inputPassportElementPassportRegistration *InputPassportElementPassportRegistration) MessageType() string {
	return "inputPassportElementPassportRegistration"
}

// NewInputPassportElementPassportRegistration creates a new InputPassportElementPassportRegistration
//
// @param passportRegistration The passport registration page to be saved
func NewInputPassportElementPassportRegistration(passportRegistration *InputPersonalDocument) *InputPassportElementPassportRegistration {
	inputPassportElementPassportRegistrationTemp := InputPassportElementPassportRegistration{
		tdCommon:             tdCommon{Type: "inputPassportElementPassportRegistration"},
		PassportRegistration: passportRegistration,
	}

	return &inputPassportElementPassportRegistrationTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementPassportRegistration *InputPassportElementPassportRegistration) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementPassportRegistration.tdCommon = tempObj.tdCommon

	var passportRegistration InputPersonalDocument
	if objMap["passport_registration"] != nil {
		err = passportRegistration.UnmarshalJSON(*objMap["passport_registration"])
		if err != nil {
			return err
		}
	}

	inputPassportElementPassportRegistration.PassportRegistration = &passportRegistration

	return nil
}

// GetInputPassportElementEnum return the enum type of this object
func (inputPassportElementPassportRegistration *InputPassportElementPassportRegistration) GetInputPassportElementEnum() InputPassportElementEnum {
	return InputPassportElementPassportRegistrationType
}

// InputPassportElementTemporaryRegistration A Telegram Passport element to be saved containing the user's temporary registration
type InputPassportElementTemporaryRegistration struct {
	tdCommon
	TemporaryRegistration *InputPersonalDocument `json:"temporary_registration"` // The temporary registration document to be saved
}

// MessageType return the string telegram-type of InputPassportElementTemporaryRegistration
func (inputPassportElementTemporaryRegistration *InputPassportElementTemporaryRegistration) MessageType() string {
	return "inputPassportElementTemporaryRegistration"
}

// NewInputPassportElementTemporaryRegistration creates a new InputPassportElementTemporaryRegistration
//
// @param temporaryRegistration The temporary registration document to be saved
func NewInputPassportElementTemporaryRegistration(temporaryRegistration *InputPersonalDocument) *InputPassportElementTemporaryRegistration {
	inputPassportElementTemporaryRegistrationTemp := InputPassportElementTemporaryRegistration{
		tdCommon:              tdCommon{Type: "inputPassportElementTemporaryRegistration"},
		TemporaryRegistration: temporaryRegistration,
	}

	return &inputPassportElementTemporaryRegistrationTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementTemporaryRegistration *InputPassportElementTemporaryRegistration) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementTemporaryRegistration.tdCommon = tempObj.tdCommon

	var temporaryRegistration InputPersonalDocument
	if objMap["temporary_registration"] != nil {
		err = temporaryRegistration.UnmarshalJSON(*objMap["temporary_registration"])
		if err != nil {
			return err
		}
	}

	inputPassportElementTemporaryRegistration.TemporaryRegistration = &temporaryRegistration

	return nil
}

// GetInputPassportElementEnum return the enum type of this object
func (inputPassportElementTemporaryRegistration *InputPassportElementTemporaryRegistration) GetInputPassportElementEnum() InputPassportElementEnum {
	return InputPassportElementTemporaryRegistrationType
}

// InputPassportElementPhoneNumber A Telegram Passport element to be saved containing the user's phone number
type InputPassportElementPhoneNumber struct {
	tdCommon
	PhoneNumber string `json:"phone_number"` // The phone number to be saved
}

// MessageType return the string telegram-type of InputPassportElementPhoneNumber
func (inputPassportElementPhoneNumber *InputPassportElementPhoneNumber) MessageType() string {
	return "inputPassportElementPhoneNumber"
}

// NewInputPassportElementPhoneNumber creates a new InputPassportElementPhoneNumber
//
// @param phoneNumber The phone number to be saved
func NewInputPassportElementPhoneNumber(phoneNumber string) *InputPassportElementPhoneNumber {
	inputPassportElementPhoneNumberTemp := InputPassportElementPhoneNumber{
		tdCommon:    tdCommon{Type: "inputPassportElementPhoneNumber"},
		PhoneNumber: phoneNumber,
	}

	return &inputPassportElementPhoneNumberTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementPhoneNumber *InputPassportElementPhoneNumber) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PhoneNumber string `json:"phone_number"` // The phone number to be saved
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementPhoneNumber.tdCommon = tempObj.tdCommon
	inputPassportElementPhoneNumber.PhoneNumber = tempObj.PhoneNumber

	return nil
}

// GetInputPassportElementEnum return the enum type of this object
func (inputPassportElementPhoneNumber *InputPassportElementPhoneNumber) GetInputPassportElementEnum() InputPassportElementEnum {
	return InputPassportElementPhoneNumberType
}

// InputPassportElementEmailAddress A Telegram Passport element to be saved containing the user's email address
type InputPassportElementEmailAddress struct {
	tdCommon
	EmailAddress string `json:"email_address"` // The email address to be saved
}

// MessageType return the string telegram-type of InputPassportElementEmailAddress
func (inputPassportElementEmailAddress *InputPassportElementEmailAddress) MessageType() string {
	return "inputPassportElementEmailAddress"
}

// NewInputPassportElementEmailAddress creates a new InputPassportElementEmailAddress
//
// @param emailAddress The email address to be saved
func NewInputPassportElementEmailAddress(emailAddress string) *InputPassportElementEmailAddress {
	inputPassportElementEmailAddressTemp := InputPassportElementEmailAddress{
		tdCommon:     tdCommon{Type: "inputPassportElementEmailAddress"},
		EmailAddress: emailAddress,
	}

	return &inputPassportElementEmailAddressTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementEmailAddress *InputPassportElementEmailAddress) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		EmailAddress string `json:"email_address"` // The email address to be saved
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementEmailAddress.tdCommon = tempObj.tdCommon
	inputPassportElementEmailAddress.EmailAddress = tempObj.EmailAddress

	return nil
}

// GetInputPassportElementEnum return the enum type of this object
func (inputPassportElementEmailAddress *InputPassportElementEmailAddress) GetInputPassportElementEnum() InputPassportElementEnum {
	return InputPassportElementEmailAddressType
}

// PassportElements Contains information about saved Telegram Passport elements
type PassportElements struct {
	tdCommon
	Elements []PassportElement `json:"elements"` // Telegram Passport elements
}

// MessageType return the string telegram-type of PassportElements
func (passportElements *PassportElements) MessageType() string {
	return "passportElements"
}

// NewPassportElements creates a new PassportElements
//
// @param elements Telegram Passport elements
func NewPassportElements(elements []PassportElement) *PassportElements {
	passportElementsTemp := PassportElements{
		tdCommon: tdCommon{Type: "passportElements"},
		Elements: elements,
	}

	return &passportElementsTemp
}

// UnmarshalJSON unmarshal to json
func (passportElements *PassportElements) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElements.tdCommon = tempObj.tdCommon

	fieldElements, _ := unmarshalPassportElementSlice(objMap["elements"])
	passportElements.Elements = fieldElements

	return nil
}

// PassportElementErrorSourceUnspecified The element contains an error in an unspecified place. The error will be considered resolved when new data is added
type PassportElementErrorSourceUnspecified struct {
	tdCommon
}

// MessageType return the string telegram-type of PassportElementErrorSourceUnspecified
func (passportElementErrorSourceUnspecified *PassportElementErrorSourceUnspecified) MessageType() string {
	return "passportElementErrorSourceUnspecified"
}

// NewPassportElementErrorSourceUnspecified creates a new PassportElementErrorSourceUnspecified
//
func NewPassportElementErrorSourceUnspecified() *PassportElementErrorSourceUnspecified {
	passportElementErrorSourceUnspecifiedTemp := PassportElementErrorSourceUnspecified{
		tdCommon: tdCommon{Type: "passportElementErrorSourceUnspecified"},
	}

	return &passportElementErrorSourceUnspecifiedTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementErrorSourceUnspecified *PassportElementErrorSourceUnspecified) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementErrorSourceUnspecified.tdCommon = tempObj.tdCommon

	return nil
}

// GetPassportElementErrorSourceEnum return the enum type of this object
func (passportElementErrorSourceUnspecified *PassportElementErrorSourceUnspecified) GetPassportElementErrorSourceEnum() PassportElementErrorSourceEnum {
	return PassportElementErrorSourceUnspecifiedType
}

// PassportElementErrorSourceDataField One of the data fields contains an error. The error will be considered resolved when the value of the field changes
type PassportElementErrorSourceDataField struct {
	tdCommon
	FieldName string `json:"field_name"` // Field name
}

// MessageType return the string telegram-type of PassportElementErrorSourceDataField
func (passportElementErrorSourceDataField *PassportElementErrorSourceDataField) MessageType() string {
	return "passportElementErrorSourceDataField"
}

// NewPassportElementErrorSourceDataField creates a new PassportElementErrorSourceDataField
//
// @param fieldName Field name
func NewPassportElementErrorSourceDataField(fieldName string) *PassportElementErrorSourceDataField {
	passportElementErrorSourceDataFieldTemp := PassportElementErrorSourceDataField{
		tdCommon:  tdCommon{Type: "passportElementErrorSourceDataField"},
		FieldName: fieldName,
	}

	return &passportElementErrorSourceDataFieldTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementErrorSourceDataField *PassportElementErrorSourceDataField) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		FieldName string `json:"field_name"` // Field name
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementErrorSourceDataField.tdCommon = tempObj.tdCommon
	passportElementErrorSourceDataField.FieldName = tempObj.FieldName

	return nil
}

// GetPassportElementErrorSourceEnum return the enum type of this object
func (passportElementErrorSourceDataField *PassportElementErrorSourceDataField) GetPassportElementErrorSourceEnum() PassportElementErrorSourceEnum {
	return PassportElementErrorSourceDataFieldType
}

// PassportElementErrorSourceFrontSide The front side of the document contains an error. The error will be considered resolved when the file with the front side changes
type PassportElementErrorSourceFrontSide struct {
	tdCommon
}

// MessageType return the string telegram-type of PassportElementErrorSourceFrontSide
func (passportElementErrorSourceFrontSide *PassportElementErrorSourceFrontSide) MessageType() string {
	return "passportElementErrorSourceFrontSide"
}

// NewPassportElementErrorSourceFrontSide creates a new PassportElementErrorSourceFrontSide
//
func NewPassportElementErrorSourceFrontSide() *PassportElementErrorSourceFrontSide {
	passportElementErrorSourceFrontSideTemp := PassportElementErrorSourceFrontSide{
		tdCommon: tdCommon{Type: "passportElementErrorSourceFrontSide"},
	}

	return &passportElementErrorSourceFrontSideTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementErrorSourceFrontSide *PassportElementErrorSourceFrontSide) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementErrorSourceFrontSide.tdCommon = tempObj.tdCommon

	return nil
}

// GetPassportElementErrorSourceEnum return the enum type of this object
func (passportElementErrorSourceFrontSide *PassportElementErrorSourceFrontSide) GetPassportElementErrorSourceEnum() PassportElementErrorSourceEnum {
	return PassportElementErrorSourceFrontSideType
}

// PassportElementErrorSourceReverseSide The reverse side of the document contains an error. The error will be considered resolved when the file with the reverse side changes
type PassportElementErrorSourceReverseSide struct {
	tdCommon
}

// MessageType return the string telegram-type of PassportElementErrorSourceReverseSide
func (passportElementErrorSourceReverseSide *PassportElementErrorSourceReverseSide) MessageType() string {
	return "passportElementErrorSourceReverseSide"
}

// NewPassportElementErrorSourceReverseSide creates a new PassportElementErrorSourceReverseSide
//
func NewPassportElementErrorSourceReverseSide() *PassportElementErrorSourceReverseSide {
	passportElementErrorSourceReverseSideTemp := PassportElementErrorSourceReverseSide{
		tdCommon: tdCommon{Type: "passportElementErrorSourceReverseSide"},
	}

	return &passportElementErrorSourceReverseSideTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementErrorSourceReverseSide *PassportElementErrorSourceReverseSide) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementErrorSourceReverseSide.tdCommon = tempObj.tdCommon

	return nil
}

// GetPassportElementErrorSourceEnum return the enum type of this object
func (passportElementErrorSourceReverseSide *PassportElementErrorSourceReverseSide) GetPassportElementErrorSourceEnum() PassportElementErrorSourceEnum {
	return PassportElementErrorSourceReverseSideType
}

// PassportElementErrorSourceSelfie The selfie with the document contains an error. The error will be considered resolved when the file with the selfie changes
type PassportElementErrorSourceSelfie struct {
	tdCommon
}

// MessageType return the string telegram-type of PassportElementErrorSourceSelfie
func (passportElementErrorSourceSelfie *PassportElementErrorSourceSelfie) MessageType() string {
	return "passportElementErrorSourceSelfie"
}

// NewPassportElementErrorSourceSelfie creates a new PassportElementErrorSourceSelfie
//
func NewPassportElementErrorSourceSelfie() *PassportElementErrorSourceSelfie {
	passportElementErrorSourceSelfieTemp := PassportElementErrorSourceSelfie{
		tdCommon: tdCommon{Type: "passportElementErrorSourceSelfie"},
	}

	return &passportElementErrorSourceSelfieTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementErrorSourceSelfie *PassportElementErrorSourceSelfie) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementErrorSourceSelfie.tdCommon = tempObj.tdCommon

	return nil
}

// GetPassportElementErrorSourceEnum return the enum type of this object
func (passportElementErrorSourceSelfie *PassportElementErrorSourceSelfie) GetPassportElementErrorSourceEnum() PassportElementErrorSourceEnum {
	return PassportElementErrorSourceSelfieType
}

// PassportElementErrorSourceTranslationFile One of files with the translation of the document contains an error. The error will be considered resolved when the file changes
type PassportElementErrorSourceTranslationFile struct {
	tdCommon
	FileIndex int32 `json:"file_index"` // Index of a file with the error
}

// MessageType return the string telegram-type of PassportElementErrorSourceTranslationFile
func (passportElementErrorSourceTranslationFile *PassportElementErrorSourceTranslationFile) MessageType() string {
	return "passportElementErrorSourceTranslationFile"
}

// NewPassportElementErrorSourceTranslationFile creates a new PassportElementErrorSourceTranslationFile
//
// @param fileIndex Index of a file with the error
func NewPassportElementErrorSourceTranslationFile(fileIndex int32) *PassportElementErrorSourceTranslationFile {
	passportElementErrorSourceTranslationFileTemp := PassportElementErrorSourceTranslationFile{
		tdCommon:  tdCommon{Type: "passportElementErrorSourceTranslationFile"},
		FileIndex: fileIndex,
	}

	return &passportElementErrorSourceTranslationFileTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementErrorSourceTranslationFile *PassportElementErrorSourceTranslationFile) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		FileIndex int32 `json:"file_index"` // Index of a file with the error
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementErrorSourceTranslationFile.tdCommon = tempObj.tdCommon
	passportElementErrorSourceTranslationFile.FileIndex = tempObj.FileIndex

	return nil
}

// GetPassportElementErrorSourceEnum return the enum type of this object
func (passportElementErrorSourceTranslationFile *PassportElementErrorSourceTranslationFile) GetPassportElementErrorSourceEnum() PassportElementErrorSourceEnum {
	return PassportElementErrorSourceTranslationFileType
}

// PassportElementErrorSourceTranslationFiles The translation of the document contains an error. The error will be considered resolved when the list of translation files changes
type PassportElementErrorSourceTranslationFiles struct {
	tdCommon
}

// MessageType return the string telegram-type of PassportElementErrorSourceTranslationFiles
func (passportElementErrorSourceTranslationFiles *PassportElementErrorSourceTranslationFiles) MessageType() string {
	return "passportElementErrorSourceTranslationFiles"
}

// NewPassportElementErrorSourceTranslationFiles creates a new PassportElementErrorSourceTranslationFiles
//
func NewPassportElementErrorSourceTranslationFiles() *PassportElementErrorSourceTranslationFiles {
	passportElementErrorSourceTranslationFilesTemp := PassportElementErrorSourceTranslationFiles{
		tdCommon: tdCommon{Type: "passportElementErrorSourceTranslationFiles"},
	}

	return &passportElementErrorSourceTranslationFilesTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementErrorSourceTranslationFiles *PassportElementErrorSourceTranslationFiles) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementErrorSourceTranslationFiles.tdCommon = tempObj.tdCommon

	return nil
}

// GetPassportElementErrorSourceEnum return the enum type of this object
func (passportElementErrorSourceTranslationFiles *PassportElementErrorSourceTranslationFiles) GetPassportElementErrorSourceEnum() PassportElementErrorSourceEnum {
	return PassportElementErrorSourceTranslationFilesType
}

// PassportElementErrorSourceFile The file contains an error. The error will be considered resolved when the file changes
type PassportElementErrorSourceFile struct {
	tdCommon
	FileIndex int32 `json:"file_index"` // Index of a file with the error
}

// MessageType return the string telegram-type of PassportElementErrorSourceFile
func (passportElementErrorSourceFile *PassportElementErrorSourceFile) MessageType() string {
	return "passportElementErrorSourceFile"
}

// NewPassportElementErrorSourceFile creates a new PassportElementErrorSourceFile
//
// @param fileIndex Index of a file with the error
func NewPassportElementErrorSourceFile(fileIndex int32) *PassportElementErrorSourceFile {
	passportElementErrorSourceFileTemp := PassportElementErrorSourceFile{
		tdCommon:  tdCommon{Type: "passportElementErrorSourceFile"},
		FileIndex: fileIndex,
	}

	return &passportElementErrorSourceFileTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementErrorSourceFile *PassportElementErrorSourceFile) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		FileIndex int32 `json:"file_index"` // Index of a file with the error
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementErrorSourceFile.tdCommon = tempObj.tdCommon
	passportElementErrorSourceFile.FileIndex = tempObj.FileIndex

	return nil
}

// GetPassportElementErrorSourceEnum return the enum type of this object
func (passportElementErrorSourceFile *PassportElementErrorSourceFile) GetPassportElementErrorSourceEnum() PassportElementErrorSourceEnum {
	return PassportElementErrorSourceFileType
}

// PassportElementErrorSourceFiles The list of attached files contains an error. The error will be considered resolved when the list of files changes
type PassportElementErrorSourceFiles struct {
	tdCommon
}

// MessageType return the string telegram-type of PassportElementErrorSourceFiles
func (passportElementErrorSourceFiles *PassportElementErrorSourceFiles) MessageType() string {
	return "passportElementErrorSourceFiles"
}

// NewPassportElementErrorSourceFiles creates a new PassportElementErrorSourceFiles
//
func NewPassportElementErrorSourceFiles() *PassportElementErrorSourceFiles {
	passportElementErrorSourceFilesTemp := PassportElementErrorSourceFiles{
		tdCommon: tdCommon{Type: "passportElementErrorSourceFiles"},
	}

	return &passportElementErrorSourceFilesTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementErrorSourceFiles *PassportElementErrorSourceFiles) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementErrorSourceFiles.tdCommon = tempObj.tdCommon

	return nil
}

// GetPassportElementErrorSourceEnum return the enum type of this object
func (passportElementErrorSourceFiles *PassportElementErrorSourceFiles) GetPassportElementErrorSourceEnum() PassportElementErrorSourceEnum {
	return PassportElementErrorSourceFilesType
}

// PassportElementError Contains the description of an error in a Telegram Passport element
type PassportElementError struct {
	tdCommon
	Type    PassportElementType        `json:"type"`    // Type of the Telegram Passport element which has the error
	Message string                     `json:"message"` // Error message
	Source  PassportElementErrorSource `json:"source"`  // Error source
}

// MessageType return the string telegram-type of PassportElementError
func (passportElementError *PassportElementError) MessageType() string {
	return "passportElementError"
}

// NewPassportElementError creates a new PassportElementError
//
// @param typeParam Type of the Telegram Passport element which has the error
// @param message Error message
// @param source Error source
func NewPassportElementError(typeParam PassportElementType, message string, source PassportElementErrorSource) *PassportElementError {
	passportElementErrorTemp := PassportElementError{
		tdCommon: tdCommon{Type: "passportElementError"},
		Type:     typeParam,
		Message:  message,
		Source:   source,
	}

	return &passportElementErrorTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementError *PassportElementError) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Message string `json:"message"` // Error message

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementError.tdCommon = tempObj.tdCommon
	passportElementError.Message = tempObj.Message

	fieldType, _ := unmarshalPassportElementType(objMap["type"])
	passportElementError.Type = fieldType

	fieldSource, _ := unmarshalPassportElementErrorSource(objMap["source"])
	passportElementError.Source = fieldSource

	return nil
}

// PassportSuitableElement Contains information about a Telegram Passport element that was requested by a service
type PassportSuitableElement struct {
	tdCommon
	Type                  PassportElementType `json:"type"`                    // Type of the element
	IsSelfieRequired      bool                `json:"is_selfie_required"`      // True, if a selfie is required with the identity document
	IsTranslationRequired bool                `json:"is_translation_required"` // True, if a certified English translation is required with the document
	IsNativeNameRequired  bool                `json:"is_native_name_required"` // True, if personal details must include the user's name in the language of their country of residence
}

// MessageType return the string telegram-type of PassportSuitableElement
func (passportSuitableElement *PassportSuitableElement) MessageType() string {
	return "passportSuitableElement"
}

// NewPassportSuitableElement creates a new PassportSuitableElement
//
// @param typeParam Type of the element
// @param isSelfieRequired True, if a selfie is required with the identity document
// @param isTranslationRequired True, if a certified English translation is required with the document
// @param isNativeNameRequired True, if personal details must include the user's name in the language of their country of residence
func NewPassportSuitableElement(typeParam PassportElementType, isSelfieRequired bool, isTranslationRequired bool, isNativeNameRequired bool) *PassportSuitableElement {
	passportSuitableElementTemp := PassportSuitableElement{
		tdCommon:              tdCommon{Type: "passportSuitableElement"},
		Type:                  typeParam,
		IsSelfieRequired:      isSelfieRequired,
		IsTranslationRequired: isTranslationRequired,
		IsNativeNameRequired:  isNativeNameRequired,
	}

	return &passportSuitableElementTemp
}

// UnmarshalJSON unmarshal to json
func (passportSuitableElement *PassportSuitableElement) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsSelfieRequired      bool `json:"is_selfie_required"`      // True, if a selfie is required with the identity document
		IsTranslationRequired bool `json:"is_translation_required"` // True, if a certified English translation is required with the document
		IsNativeNameRequired  bool `json:"is_native_name_required"` // True, if personal details must include the user's name in the language of their country of residence
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportSuitableElement.tdCommon = tempObj.tdCommon
	passportSuitableElement.IsSelfieRequired = tempObj.IsSelfieRequired
	passportSuitableElement.IsTranslationRequired = tempObj.IsTranslationRequired
	passportSuitableElement.IsNativeNameRequired = tempObj.IsNativeNameRequired

	fieldType, _ := unmarshalPassportElementType(objMap["type"])
	passportSuitableElement.Type = fieldType

	return nil
}

// PassportRequiredElement Contains a description of the required Telegram Passport element that was requested by a service
type PassportRequiredElement struct {
	tdCommon
	SuitableElements []PassportSuitableElement `json:"suitable_elements"` // List of Telegram Passport elements any of which is enough to provide
}

// MessageType return the string telegram-type of PassportRequiredElement
func (passportRequiredElement *PassportRequiredElement) MessageType() string {
	return "passportRequiredElement"
}

// NewPassportRequiredElement creates a new PassportRequiredElement
//
// @param suitableElements List of Telegram Passport elements any of which is enough to provide
func NewPassportRequiredElement(suitableElements []PassportSuitableElement) *PassportRequiredElement {
	passportRequiredElementTemp := PassportRequiredElement{
		tdCommon:         tdCommon{Type: "passportRequiredElement"},
		SuitableElements: suitableElements,
	}

	return &passportRequiredElementTemp
}

// UnmarshalJSON unmarshal to json
func (passportRequiredElement *PassportRequiredElement) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SuitableElements []PassportSuitableElement `json:"suitable_elements"` // List of Telegram Passport elements any of which is enough to provide
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportRequiredElement.tdCommon = tempObj.tdCommon
	passportRequiredElement.SuitableElements = tempObj.SuitableElements

	return nil
}

// PassportAuthorizationForm Contains information about a Telegram Passport authorization form that was requested
type PassportAuthorizationForm struct {
	tdCommon
	ID               int32                     `json:"id"`                 // Unique identifier of the authorization form
	RequiredElements []PassportRequiredElement `json:"required_elements"`  // Telegram Passport elements that must be provided to complete the form
	PrivacyPolicyURL string                    `json:"privacy_policy_url"` // URL for the privacy policy of the service; may be empty
}

// MessageType return the string telegram-type of PassportAuthorizationForm
func (passportAuthorizationForm *PassportAuthorizationForm) MessageType() string {
	return "passportAuthorizationForm"
}

// NewPassportAuthorizationForm creates a new PassportAuthorizationForm
//
// @param iD Unique identifier of the authorization form
// @param requiredElements Telegram Passport elements that must be provided to complete the form
// @param privacyPolicyURL URL for the privacy policy of the service; may be empty
func NewPassportAuthorizationForm(iD int32, requiredElements []PassportRequiredElement, privacyPolicyURL string) *PassportAuthorizationForm {
	passportAuthorizationFormTemp := PassportAuthorizationForm{
		tdCommon:         tdCommon{Type: "passportAuthorizationForm"},
		ID:               iD,
		RequiredElements: requiredElements,
		PrivacyPolicyURL: privacyPolicyURL,
	}

	return &passportAuthorizationFormTemp
}

// UnmarshalJSON unmarshal to json
func (passportAuthorizationForm *PassportAuthorizationForm) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID               int32                     `json:"id"`                 // Unique identifier of the authorization form
		RequiredElements []PassportRequiredElement `json:"required_elements"`  // Telegram Passport elements that must be provided to complete the form
		PrivacyPolicyURL string                    `json:"privacy_policy_url"` // URL for the privacy policy of the service; may be empty
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportAuthorizationForm.tdCommon = tempObj.tdCommon
	passportAuthorizationForm.ID = tempObj.ID
	passportAuthorizationForm.RequiredElements = tempObj.RequiredElements
	passportAuthorizationForm.PrivacyPolicyURL = tempObj.PrivacyPolicyURL

	return nil
}

// PassportElementsWithErrors Contains information about a Telegram Passport elements and corresponding errors
type PassportElementsWithErrors struct {
	tdCommon
	Elements []PassportElement      `json:"elements"` // Telegram Passport elements
	Errors   []PassportElementError `json:"errors"`   // Errors in the elements that are already available
}

// MessageType return the string telegram-type of PassportElementsWithErrors
func (passportElementsWithErrors *PassportElementsWithErrors) MessageType() string {
	return "passportElementsWithErrors"
}

// NewPassportElementsWithErrors creates a new PassportElementsWithErrors
//
// @param elements Telegram Passport elements
// @param errParams Errors in the elements that are already available
func NewPassportElementsWithErrors(elements []PassportElement, errParams []PassportElementError) *PassportElementsWithErrors {
	passportElementsWithErrorsTemp := PassportElementsWithErrors{
		tdCommon: tdCommon{Type: "passportElementsWithErrors"},
		Elements: elements,
		Errors:   errParams,
	}

	return &passportElementsWithErrorsTemp
}

// UnmarshalJSON unmarshal to json
func (passportElementsWithErrors *PassportElementsWithErrors) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Errors []PassportElementError `json:"errors"` // Errors in the elements that are already available
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	passportElementsWithErrors.tdCommon = tempObj.tdCommon
	passportElementsWithErrors.Errors = tempObj.Errors

	fieldElements, _ := unmarshalPassportElementSlice(objMap["elements"])
	passportElementsWithErrors.Elements = fieldElements

	return nil
}

// EncryptedCredentials Contains encrypted Telegram Passport data credentials
type EncryptedCredentials struct {
	tdCommon
	Data   []byte `json:"data"`   // The encrypted credentials
	Hash   []byte `json:"hash"`   // The decrypted data hash
	Secret []byte `json:"secret"` // Secret for data decryption, encrypted with the service's public key
}

// MessageType return the string telegram-type of EncryptedCredentials
func (encryptedCredentials *EncryptedCredentials) MessageType() string {
	return "encryptedCredentials"
}

// NewEncryptedCredentials creates a new EncryptedCredentials
//
// @param data The encrypted credentials
// @param hash The decrypted data hash
// @param secret Secret for data decryption, encrypted with the service's public key
func NewEncryptedCredentials(data []byte, hash []byte, secret []byte) *EncryptedCredentials {
	encryptedCredentialsTemp := EncryptedCredentials{
		tdCommon: tdCommon{Type: "encryptedCredentials"},
		Data:     data,
		Hash:     hash,
		Secret:   secret,
	}

	return &encryptedCredentialsTemp
}

// UnmarshalJSON unmarshal to json
func (encryptedCredentials *EncryptedCredentials) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Data   []byte `json:"data"`   // The encrypted credentials
		Hash   []byte `json:"hash"`   // The decrypted data hash
		Secret []byte `json:"secret"` // Secret for data decryption, encrypted with the service's public key
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	encryptedCredentials.tdCommon = tempObj.tdCommon
	encryptedCredentials.Data = tempObj.Data
	encryptedCredentials.Hash = tempObj.Hash
	encryptedCredentials.Secret = tempObj.Secret

	return nil
}

// EncryptedPassportElement Contains information about an encrypted Telegram Passport element; for bots only
type EncryptedPassportElement struct {
	tdCommon
	Type        PassportElementType `json:"type"`         // Type of Telegram Passport element
	Data        []byte              `json:"data"`         // Encrypted JSON-encoded data about the user
	FrontSide   *DatedFile          `json:"front_side"`   // The front side of an identity document
	ReverseSide *DatedFile          `json:"reverse_side"` // The reverse side of an identity document; may be null
	Selfie      *DatedFile          `json:"selfie"`       // Selfie with the document; may be null
	Translation []DatedFile         `json:"translation"`  // List of files containing a certified English translation of the document
	Files       []DatedFile         `json:"files"`        // List of attached files
	Value       string              `json:"value"`        // Unencrypted data, phone number or email address
	Hash        string              `json:"hash"`         // Hash of the entire element
}

// MessageType return the string telegram-type of EncryptedPassportElement
func (encryptedPassportElement *EncryptedPassportElement) MessageType() string {
	return "encryptedPassportElement"
}

// NewEncryptedPassportElement creates a new EncryptedPassportElement
//
// @param typeParam Type of Telegram Passport element
// @param data Encrypted JSON-encoded data about the user
// @param frontSide The front side of an identity document
// @param reverseSide The reverse side of an identity document; may be null
// @param selfie Selfie with the document; may be null
// @param translation List of files containing a certified English translation of the document
// @param files List of attached files
// @param value Unencrypted data, phone number or email address
// @param hash Hash of the entire element
func NewEncryptedPassportElement(typeParam PassportElementType, data []byte, frontSide *DatedFile, reverseSide *DatedFile, selfie *DatedFile, translation []DatedFile, files []DatedFile, value string, hash string) *EncryptedPassportElement {
	encryptedPassportElementTemp := EncryptedPassportElement{
		tdCommon:    tdCommon{Type: "encryptedPassportElement"},
		Type:        typeParam,
		Data:        data,
		FrontSide:   frontSide,
		ReverseSide: reverseSide,
		Selfie:      selfie,
		Translation: translation,
		Files:       files,
		Value:       value,
		Hash:        hash,
	}

	return &encryptedPassportElementTemp
}

// UnmarshalJSON unmarshal to json
func (encryptedPassportElement *EncryptedPassportElement) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Data        []byte      `json:"data"`         // Encrypted JSON-encoded data about the user
		FrontSide   *DatedFile  `json:"front_side"`   // The front side of an identity document
		ReverseSide *DatedFile  `json:"reverse_side"` // The reverse side of an identity document; may be null
		Selfie      *DatedFile  `json:"selfie"`       // Selfie with the document; may be null
		Translation []DatedFile `json:"translation"`  // List of files containing a certified English translation of the document
		Files       []DatedFile `json:"files"`        // List of attached files
		Value       string      `json:"value"`        // Unencrypted data, phone number or email address
		Hash        string      `json:"hash"`         // Hash of the entire element
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	encryptedPassportElement.tdCommon = tempObj.tdCommon
	encryptedPassportElement.Data = tempObj.Data
	encryptedPassportElement.FrontSide = tempObj.FrontSide
	encryptedPassportElement.ReverseSide = tempObj.ReverseSide
	encryptedPassportElement.Selfie = tempObj.Selfie
	encryptedPassportElement.Translation = tempObj.Translation
	encryptedPassportElement.Files = tempObj.Files
	encryptedPassportElement.Value = tempObj.Value
	encryptedPassportElement.Hash = tempObj.Hash

	fieldType, _ := unmarshalPassportElementType(objMap["type"])
	encryptedPassportElement.Type = fieldType

	return nil
}

// InputPassportElementErrorSourceUnspecified The element contains an error in an unspecified place. The error will be considered resolved when new data is added
type InputPassportElementErrorSourceUnspecified struct {
	tdCommon
	ElementHash []byte `json:"element_hash"` // Current hash of the entire element
}

// MessageType return the string telegram-type of InputPassportElementErrorSourceUnspecified
func (inputPassportElementErrorSourceUnspecified *InputPassportElementErrorSourceUnspecified) MessageType() string {
	return "inputPassportElementErrorSourceUnspecified"
}

// NewInputPassportElementErrorSourceUnspecified creates a new InputPassportElementErrorSourceUnspecified
//
// @param elementHash Current hash of the entire element
func NewInputPassportElementErrorSourceUnspecified(elementHash []byte) *InputPassportElementErrorSourceUnspecified {
	inputPassportElementErrorSourceUnspecifiedTemp := InputPassportElementErrorSourceUnspecified{
		tdCommon:    tdCommon{Type: "inputPassportElementErrorSourceUnspecified"},
		ElementHash: elementHash,
	}

	return &inputPassportElementErrorSourceUnspecifiedTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementErrorSourceUnspecified *InputPassportElementErrorSourceUnspecified) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ElementHash []byte `json:"element_hash"` // Current hash of the entire element
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementErrorSourceUnspecified.tdCommon = tempObj.tdCommon
	inputPassportElementErrorSourceUnspecified.ElementHash = tempObj.ElementHash

	return nil
}

// GetInputPassportElementErrorSourceEnum return the enum type of this object
func (inputPassportElementErrorSourceUnspecified *InputPassportElementErrorSourceUnspecified) GetInputPassportElementErrorSourceEnum() InputPassportElementErrorSourceEnum {
	return InputPassportElementErrorSourceUnspecifiedType
}

// InputPassportElementErrorSourceDataField A data field contains an error. The error is considered resolved when the field's value changes
type InputPassportElementErrorSourceDataField struct {
	tdCommon
	FieldName string `json:"field_name"` // Field name
	DataHash  []byte `json:"data_hash"`  // Current data hash
}

// MessageType return the string telegram-type of InputPassportElementErrorSourceDataField
func (inputPassportElementErrorSourceDataField *InputPassportElementErrorSourceDataField) MessageType() string {
	return "inputPassportElementErrorSourceDataField"
}

// NewInputPassportElementErrorSourceDataField creates a new InputPassportElementErrorSourceDataField
//
// @param fieldName Field name
// @param dataHash Current data hash
func NewInputPassportElementErrorSourceDataField(fieldName string, dataHash []byte) *InputPassportElementErrorSourceDataField {
	inputPassportElementErrorSourceDataFieldTemp := InputPassportElementErrorSourceDataField{
		tdCommon:  tdCommon{Type: "inputPassportElementErrorSourceDataField"},
		FieldName: fieldName,
		DataHash:  dataHash,
	}

	return &inputPassportElementErrorSourceDataFieldTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementErrorSourceDataField *InputPassportElementErrorSourceDataField) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		FieldName string `json:"field_name"` // Field name
		DataHash  []byte `json:"data_hash"`  // Current data hash
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementErrorSourceDataField.tdCommon = tempObj.tdCommon
	inputPassportElementErrorSourceDataField.FieldName = tempObj.FieldName
	inputPassportElementErrorSourceDataField.DataHash = tempObj.DataHash

	return nil
}

// GetInputPassportElementErrorSourceEnum return the enum type of this object
func (inputPassportElementErrorSourceDataField *InputPassportElementErrorSourceDataField) GetInputPassportElementErrorSourceEnum() InputPassportElementErrorSourceEnum {
	return InputPassportElementErrorSourceDataFieldType
}

// InputPassportElementErrorSourceFrontSide The front side of the document contains an error. The error is considered resolved when the file with the front side of the document changes
type InputPassportElementErrorSourceFrontSide struct {
	tdCommon
	FileHash []byte `json:"file_hash"` // Current hash of the file containing the front side
}

// MessageType return the string telegram-type of InputPassportElementErrorSourceFrontSide
func (inputPassportElementErrorSourceFrontSide *InputPassportElementErrorSourceFrontSide) MessageType() string {
	return "inputPassportElementErrorSourceFrontSide"
}

// NewInputPassportElementErrorSourceFrontSide creates a new InputPassportElementErrorSourceFrontSide
//
// @param fileHash Current hash of the file containing the front side
func NewInputPassportElementErrorSourceFrontSide(fileHash []byte) *InputPassportElementErrorSourceFrontSide {
	inputPassportElementErrorSourceFrontSideTemp := InputPassportElementErrorSourceFrontSide{
		tdCommon: tdCommon{Type: "inputPassportElementErrorSourceFrontSide"},
		FileHash: fileHash,
	}

	return &inputPassportElementErrorSourceFrontSideTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementErrorSourceFrontSide *InputPassportElementErrorSourceFrontSide) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		FileHash []byte `json:"file_hash"` // Current hash of the file containing the front side
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementErrorSourceFrontSide.tdCommon = tempObj.tdCommon
	inputPassportElementErrorSourceFrontSide.FileHash = tempObj.FileHash

	return nil
}

// GetInputPassportElementErrorSourceEnum return the enum type of this object
func (inputPassportElementErrorSourceFrontSide *InputPassportElementErrorSourceFrontSide) GetInputPassportElementErrorSourceEnum() InputPassportElementErrorSourceEnum {
	return InputPassportElementErrorSourceFrontSideType
}

// InputPassportElementErrorSourceReverseSide The reverse side of the document contains an error. The error is considered resolved when the file with the reverse side of the document changes
type InputPassportElementErrorSourceReverseSide struct {
	tdCommon
	FileHash []byte `json:"file_hash"` // Current hash of the file containing the reverse side
}

// MessageType return the string telegram-type of InputPassportElementErrorSourceReverseSide
func (inputPassportElementErrorSourceReverseSide *InputPassportElementErrorSourceReverseSide) MessageType() string {
	return "inputPassportElementErrorSourceReverseSide"
}

// NewInputPassportElementErrorSourceReverseSide creates a new InputPassportElementErrorSourceReverseSide
//
// @param fileHash Current hash of the file containing the reverse side
func NewInputPassportElementErrorSourceReverseSide(fileHash []byte) *InputPassportElementErrorSourceReverseSide {
	inputPassportElementErrorSourceReverseSideTemp := InputPassportElementErrorSourceReverseSide{
		tdCommon: tdCommon{Type: "inputPassportElementErrorSourceReverseSide"},
		FileHash: fileHash,
	}

	return &inputPassportElementErrorSourceReverseSideTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementErrorSourceReverseSide *InputPassportElementErrorSourceReverseSide) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		FileHash []byte `json:"file_hash"` // Current hash of the file containing the reverse side
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementErrorSourceReverseSide.tdCommon = tempObj.tdCommon
	inputPassportElementErrorSourceReverseSide.FileHash = tempObj.FileHash

	return nil
}

// GetInputPassportElementErrorSourceEnum return the enum type of this object
func (inputPassportElementErrorSourceReverseSide *InputPassportElementErrorSourceReverseSide) GetInputPassportElementErrorSourceEnum() InputPassportElementErrorSourceEnum {
	return InputPassportElementErrorSourceReverseSideType
}

// InputPassportElementErrorSourceSelfie The selfie contains an error. The error is considered resolved when the file with the selfie changes
type InputPassportElementErrorSourceSelfie struct {
	tdCommon
	FileHash []byte `json:"file_hash"` // Current hash of the file containing the selfie
}

// MessageType return the string telegram-type of InputPassportElementErrorSourceSelfie
func (inputPassportElementErrorSourceSelfie *InputPassportElementErrorSourceSelfie) MessageType() string {
	return "inputPassportElementErrorSourceSelfie"
}

// NewInputPassportElementErrorSourceSelfie creates a new InputPassportElementErrorSourceSelfie
//
// @param fileHash Current hash of the file containing the selfie
func NewInputPassportElementErrorSourceSelfie(fileHash []byte) *InputPassportElementErrorSourceSelfie {
	inputPassportElementErrorSourceSelfieTemp := InputPassportElementErrorSourceSelfie{
		tdCommon: tdCommon{Type: "inputPassportElementErrorSourceSelfie"},
		FileHash: fileHash,
	}

	return &inputPassportElementErrorSourceSelfieTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementErrorSourceSelfie *InputPassportElementErrorSourceSelfie) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		FileHash []byte `json:"file_hash"` // Current hash of the file containing the selfie
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementErrorSourceSelfie.tdCommon = tempObj.tdCommon
	inputPassportElementErrorSourceSelfie.FileHash = tempObj.FileHash

	return nil
}

// GetInputPassportElementErrorSourceEnum return the enum type of this object
func (inputPassportElementErrorSourceSelfie *InputPassportElementErrorSourceSelfie) GetInputPassportElementErrorSourceEnum() InputPassportElementErrorSourceEnum {
	return InputPassportElementErrorSourceSelfieType
}

// InputPassportElementErrorSourceTranslationFile One of the files containing the translation of the document contains an error. The error is considered resolved when the file with the translation changes
type InputPassportElementErrorSourceTranslationFile struct {
	tdCommon
	FileHash []byte `json:"file_hash"` // Current hash of the file containing the translation
}

// MessageType return the string telegram-type of InputPassportElementErrorSourceTranslationFile
func (inputPassportElementErrorSourceTranslationFile *InputPassportElementErrorSourceTranslationFile) MessageType() string {
	return "inputPassportElementErrorSourceTranslationFile"
}

// NewInputPassportElementErrorSourceTranslationFile creates a new InputPassportElementErrorSourceTranslationFile
//
// @param fileHash Current hash of the file containing the translation
func NewInputPassportElementErrorSourceTranslationFile(fileHash []byte) *InputPassportElementErrorSourceTranslationFile {
	inputPassportElementErrorSourceTranslationFileTemp := InputPassportElementErrorSourceTranslationFile{
		tdCommon: tdCommon{Type: "inputPassportElementErrorSourceTranslationFile"},
		FileHash: fileHash,
	}

	return &inputPassportElementErrorSourceTranslationFileTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementErrorSourceTranslationFile *InputPassportElementErrorSourceTranslationFile) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		FileHash []byte `json:"file_hash"` // Current hash of the file containing the translation
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementErrorSourceTranslationFile.tdCommon = tempObj.tdCommon
	inputPassportElementErrorSourceTranslationFile.FileHash = tempObj.FileHash

	return nil
}

// GetInputPassportElementErrorSourceEnum return the enum type of this object
func (inputPassportElementErrorSourceTranslationFile *InputPassportElementErrorSourceTranslationFile) GetInputPassportElementErrorSourceEnum() InputPassportElementErrorSourceEnum {
	return InputPassportElementErrorSourceTranslationFileType
}

// InputPassportElementErrorSourceTranslationFiles The translation of the document contains an error. The error is considered resolved when the list of files changes
type InputPassportElementErrorSourceTranslationFiles struct {
	tdCommon
	FileHashes [][]byte `json:"file_hashes"` // Current hashes of all files with the translation
}

// MessageType return the string telegram-type of InputPassportElementErrorSourceTranslationFiles
func (inputPassportElementErrorSourceTranslationFiles *InputPassportElementErrorSourceTranslationFiles) MessageType() string {
	return "inputPassportElementErrorSourceTranslationFiles"
}

// NewInputPassportElementErrorSourceTranslationFiles creates a new InputPassportElementErrorSourceTranslationFiles
//
// @param fileHashes Current hashes of all files with the translation
func NewInputPassportElementErrorSourceTranslationFiles(fileHashes [][]byte) *InputPassportElementErrorSourceTranslationFiles {
	inputPassportElementErrorSourceTranslationFilesTemp := InputPassportElementErrorSourceTranslationFiles{
		tdCommon:   tdCommon{Type: "inputPassportElementErrorSourceTranslationFiles"},
		FileHashes: fileHashes,
	}

	return &inputPassportElementErrorSourceTranslationFilesTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementErrorSourceTranslationFiles *InputPassportElementErrorSourceTranslationFiles) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		FileHashes [][]byte `json:"file_hashes"` // Current hashes of all files with the translation
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementErrorSourceTranslationFiles.tdCommon = tempObj.tdCommon
	inputPassportElementErrorSourceTranslationFiles.FileHashes = tempObj.FileHashes

	return nil
}

// GetInputPassportElementErrorSourceEnum return the enum type of this object
func (inputPassportElementErrorSourceTranslationFiles *InputPassportElementErrorSourceTranslationFiles) GetInputPassportElementErrorSourceEnum() InputPassportElementErrorSourceEnum {
	return InputPassportElementErrorSourceTranslationFilesType
}

// InputPassportElementErrorSourceFile The file contains an error. The error is considered resolved when the file changes
type InputPassportElementErrorSourceFile struct {
	tdCommon
	FileHash []byte `json:"file_hash"` // Current hash of the file which has the error
}

// MessageType return the string telegram-type of InputPassportElementErrorSourceFile
func (inputPassportElementErrorSourceFile *InputPassportElementErrorSourceFile) MessageType() string {
	return "inputPassportElementErrorSourceFile"
}

// NewInputPassportElementErrorSourceFile creates a new InputPassportElementErrorSourceFile
//
// @param fileHash Current hash of the file which has the error
func NewInputPassportElementErrorSourceFile(fileHash []byte) *InputPassportElementErrorSourceFile {
	inputPassportElementErrorSourceFileTemp := InputPassportElementErrorSourceFile{
		tdCommon: tdCommon{Type: "inputPassportElementErrorSourceFile"},
		FileHash: fileHash,
	}

	return &inputPassportElementErrorSourceFileTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementErrorSourceFile *InputPassportElementErrorSourceFile) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		FileHash []byte `json:"file_hash"` // Current hash of the file which has the error
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementErrorSourceFile.tdCommon = tempObj.tdCommon
	inputPassportElementErrorSourceFile.FileHash = tempObj.FileHash

	return nil
}

// GetInputPassportElementErrorSourceEnum return the enum type of this object
func (inputPassportElementErrorSourceFile *InputPassportElementErrorSourceFile) GetInputPassportElementErrorSourceEnum() InputPassportElementErrorSourceEnum {
	return InputPassportElementErrorSourceFileType
}

// InputPassportElementErrorSourceFiles The list of attached files contains an error. The error is considered resolved when the file list changes
type InputPassportElementErrorSourceFiles struct {
	tdCommon
	FileHashes [][]byte `json:"file_hashes"` // Current hashes of all attached files
}

// MessageType return the string telegram-type of InputPassportElementErrorSourceFiles
func (inputPassportElementErrorSourceFiles *InputPassportElementErrorSourceFiles) MessageType() string {
	return "inputPassportElementErrorSourceFiles"
}

// NewInputPassportElementErrorSourceFiles creates a new InputPassportElementErrorSourceFiles
//
// @param fileHashes Current hashes of all attached files
func NewInputPassportElementErrorSourceFiles(fileHashes [][]byte) *InputPassportElementErrorSourceFiles {
	inputPassportElementErrorSourceFilesTemp := InputPassportElementErrorSourceFiles{
		tdCommon:   tdCommon{Type: "inputPassportElementErrorSourceFiles"},
		FileHashes: fileHashes,
	}

	return &inputPassportElementErrorSourceFilesTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementErrorSourceFiles *InputPassportElementErrorSourceFiles) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		FileHashes [][]byte `json:"file_hashes"` // Current hashes of all attached files
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementErrorSourceFiles.tdCommon = tempObj.tdCommon
	inputPassportElementErrorSourceFiles.FileHashes = tempObj.FileHashes

	return nil
}

// GetInputPassportElementErrorSourceEnum return the enum type of this object
func (inputPassportElementErrorSourceFiles *InputPassportElementErrorSourceFiles) GetInputPassportElementErrorSourceEnum() InputPassportElementErrorSourceEnum {
	return InputPassportElementErrorSourceFilesType
}

// InputPassportElementError Contains the description of an error in a Telegram Passport element; for bots only
type InputPassportElementError struct {
	tdCommon
	Type    PassportElementType             `json:"type"`    // Type of Telegram Passport element that has the error
	Message string                          `json:"message"` // Error message
	Source  InputPassportElementErrorSource `json:"source"`  // Error source
}

// MessageType return the string telegram-type of InputPassportElementError
func (inputPassportElementError *InputPassportElementError) MessageType() string {
	return "inputPassportElementError"
}

// NewInputPassportElementError creates a new InputPassportElementError
//
// @param typeParam Type of Telegram Passport element that has the error
// @param message Error message
// @param source Error source
func NewInputPassportElementError(typeParam PassportElementType, message string, source InputPassportElementErrorSource) *InputPassportElementError {
	inputPassportElementErrorTemp := InputPassportElementError{
		tdCommon: tdCommon{Type: "inputPassportElementError"},
		Type:     typeParam,
		Message:  message,
		Source:   source,
	}

	return &inputPassportElementErrorTemp
}

// UnmarshalJSON unmarshal to json
func (inputPassportElementError *InputPassportElementError) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Message string `json:"message"` // Error message

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPassportElementError.tdCommon = tempObj.tdCommon
	inputPassportElementError.Message = tempObj.Message

	fieldType, _ := unmarshalPassportElementType(objMap["type"])
	inputPassportElementError.Type = fieldType

	fieldSource, _ := unmarshalInputPassportElementErrorSource(objMap["source"])
	inputPassportElementError.Source = fieldSource

	return nil
}

// MessageText A text message
type MessageText struct {
	tdCommon
	Text               *FormattedText      `json:"text"`                 // Text of the message
	LinkPreview        *LinkPreview        `json:"link_preview"`         // A link preview attached to the message; may be null
	LinkPreviewOptions *LinkPreviewOptions `json:"link_preview_options"` // Options which were used for generation of the link preview; may be null if default options were used
}

// MessageType return the string telegram-type of MessageText
func (messageText *MessageText) MessageType() string {
	return "messageText"
}

// NewMessageText creates a new MessageText
//
// @param text Text of the message
// @param linkPreview A link preview attached to the message; may be null
// @param linkPreviewOptions Options which were used for generation of the link preview; may be null if default options were used
func NewMessageText(text *FormattedText, linkPreview *LinkPreview, linkPreviewOptions *LinkPreviewOptions) *MessageText {
	messageTextTemp := MessageText{
		tdCommon:           tdCommon{Type: "messageText"},
		Text:               text,
		LinkPreview:        linkPreview,
		LinkPreviewOptions: linkPreviewOptions,
	}

	return &messageTextTemp
}

// UnmarshalJSON unmarshal to json
func (messageText *MessageText) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Text               *FormattedText      `json:"text"`                 // Text of the message
		LinkPreviewOptions *LinkPreviewOptions `json:"link_preview_options"` // Options which were used for generation of the link preview; may be null if default options were used
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageText.tdCommon = tempObj.tdCommon
	messageText.Text = tempObj.Text
	messageText.LinkPreviewOptions = tempObj.LinkPreviewOptions

	var linkPreview LinkPreview
	if objMap["link_preview"] != nil {
		err = linkPreview.UnmarshalJSON(*objMap["link_preview"])
		if err != nil {
			return err
		}
	}

	messageText.LinkPreview = &linkPreview

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageText *MessageText) GetMessageContentEnum() MessageContentEnum {
	return MessageTextType
}

// MessageAnimation An animation message (GIF-style).
type MessageAnimation struct {
	tdCommon
	Animation             *Animation     `json:"animation"`                // The animation description
	Caption               *FormattedText `json:"caption"`                  // Animation caption
	ShowCaptionAboveMedia bool           `json:"show_caption_above_media"` // True, if the caption must be shown above the animation; otherwise, the caption must be shown below the animation
	HasSpoiler            bool           `json:"has_spoiler"`              // True, if the animation preview must be covered by a spoiler animation
	IsSecret              bool           `json:"is_secret"`                // True, if the animation thumbnail must be blurred and the animation must be shown only while tapped
}

// MessageType return the string telegram-type of MessageAnimation
func (messageAnimation *MessageAnimation) MessageType() string {
	return "messageAnimation"
}

// NewMessageAnimation creates a new MessageAnimation
//
// @param animation The animation description
// @param caption Animation caption
// @param showCaptionAboveMedia True, if the caption must be shown above the animation; otherwise, the caption must be shown below the animation
// @param hasSpoiler True, if the animation preview must be covered by a spoiler animation
// @param isSecret True, if the animation thumbnail must be blurred and the animation must be shown only while tapped
func NewMessageAnimation(animation *Animation, caption *FormattedText, showCaptionAboveMedia bool, hasSpoiler bool, isSecret bool) *MessageAnimation {
	messageAnimationTemp := MessageAnimation{
		tdCommon:              tdCommon{Type: "messageAnimation"},
		Animation:             animation,
		Caption:               caption,
		ShowCaptionAboveMedia: showCaptionAboveMedia,
		HasSpoiler:            hasSpoiler,
		IsSecret:              isSecret,
	}

	return &messageAnimationTemp
}

// UnmarshalJSON unmarshal to json
func (messageAnimation *MessageAnimation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Animation             *Animation     `json:"animation"`                // The animation description
		Caption               *FormattedText `json:"caption"`                  // Animation caption
		ShowCaptionAboveMedia bool           `json:"show_caption_above_media"` // True, if the caption must be shown above the animation; otherwise, the caption must be shown below the animation
		HasSpoiler            bool           `json:"has_spoiler"`              // True, if the animation preview must be covered by a spoiler animation
		IsSecret              bool           `json:"is_secret"`                // True, if the animation thumbnail must be blurred and the animation must be shown only while tapped
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageAnimation.tdCommon = tempObj.tdCommon
	messageAnimation.Animation = tempObj.Animation
	messageAnimation.Caption = tempObj.Caption
	messageAnimation.ShowCaptionAboveMedia = tempObj.ShowCaptionAboveMedia
	messageAnimation.HasSpoiler = tempObj.HasSpoiler
	messageAnimation.IsSecret = tempObj.IsSecret

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageAnimation *MessageAnimation) GetMessageContentEnum() MessageContentEnum {
	return MessageAnimationType
}

// MessageAudio An audio message
type MessageAudio struct {
	tdCommon
	Audio   *Audio         `json:"audio"`   // The audio description
	Caption *FormattedText `json:"caption"` // Audio caption
}

// MessageType return the string telegram-type of MessageAudio
func (messageAudio *MessageAudio) MessageType() string {
	return "messageAudio"
}

// NewMessageAudio creates a new MessageAudio
//
// @param audio The audio description
// @param caption Audio caption
func NewMessageAudio(audio *Audio, caption *FormattedText) *MessageAudio {
	messageAudioTemp := MessageAudio{
		tdCommon: tdCommon{Type: "messageAudio"},
		Audio:    audio,
		Caption:  caption,
	}

	return &messageAudioTemp
}

// UnmarshalJSON unmarshal to json
func (messageAudio *MessageAudio) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Audio   *Audio         `json:"audio"`   // The audio description
		Caption *FormattedText `json:"caption"` // Audio caption
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageAudio.tdCommon = tempObj.tdCommon
	messageAudio.Audio = tempObj.Audio
	messageAudio.Caption = tempObj.Caption

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageAudio *MessageAudio) GetMessageContentEnum() MessageContentEnum {
	return MessageAudioType
}

// MessageDocument A document message (general file)
type MessageDocument struct {
	tdCommon
	Document *Document      `json:"document"` // The document description
	Caption  *FormattedText `json:"caption"`  // Document caption
}

// MessageType return the string telegram-type of MessageDocument
func (messageDocument *MessageDocument) MessageType() string {
	return "messageDocument"
}

// NewMessageDocument creates a new MessageDocument
//
// @param document The document description
// @param caption Document caption
func NewMessageDocument(document *Document, caption *FormattedText) *MessageDocument {
	messageDocumentTemp := MessageDocument{
		tdCommon: tdCommon{Type: "messageDocument"},
		Document: document,
		Caption:  caption,
	}

	return &messageDocumentTemp
}

// UnmarshalJSON unmarshal to json
func (messageDocument *MessageDocument) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Document *Document      `json:"document"` // The document description
		Caption  *FormattedText `json:"caption"`  // Document caption
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageDocument.tdCommon = tempObj.tdCommon
	messageDocument.Document = tempObj.Document
	messageDocument.Caption = tempObj.Caption

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageDocument *MessageDocument) GetMessageContentEnum() MessageContentEnum {
	return MessageDocumentType
}

// MessagePaidMedia A message with paid media
type MessagePaidMedia struct {
	tdCommon
	StarCount             int64          `json:"star_count"`               // Number of Telegram Stars needed to buy access to the media in the message
	Media                 []PaidMedia    `json:"media"`                    // Information about the media
	Caption               *FormattedText `json:"caption"`                  // Media caption
	ShowCaptionAboveMedia bool           `json:"show_caption_above_media"` // True, if the caption must be shown above the media; otherwise, the caption must be shown below the media
}

// MessageType return the string telegram-type of MessagePaidMedia
func (messagePaidMedia *MessagePaidMedia) MessageType() string {
	return "messagePaidMedia"
}

// NewMessagePaidMedia creates a new MessagePaidMedia
//
// @param starCount Number of Telegram Stars needed to buy access to the media in the message
// @param media Information about the media
// @param caption Media caption
// @param showCaptionAboveMedia True, if the caption must be shown above the media; otherwise, the caption must be shown below the media
func NewMessagePaidMedia(starCount int64, media []PaidMedia, caption *FormattedText, showCaptionAboveMedia bool) *MessagePaidMedia {
	messagePaidMediaTemp := MessagePaidMedia{
		tdCommon:              tdCommon{Type: "messagePaidMedia"},
		StarCount:             starCount,
		Media:                 media,
		Caption:               caption,
		ShowCaptionAboveMedia: showCaptionAboveMedia,
	}

	return &messagePaidMediaTemp
}

// UnmarshalJSON unmarshal to json
func (messagePaidMedia *MessagePaidMedia) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StarCount             int64          `json:"star_count"`               // Number of Telegram Stars needed to buy access to the media in the message
		Caption               *FormattedText `json:"caption"`                  // Media caption
		ShowCaptionAboveMedia bool           `json:"show_caption_above_media"` // True, if the caption must be shown above the media; otherwise, the caption must be shown below the media
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messagePaidMedia.tdCommon = tempObj.tdCommon
	messagePaidMedia.StarCount = tempObj.StarCount
	messagePaidMedia.Caption = tempObj.Caption
	messagePaidMedia.ShowCaptionAboveMedia = tempObj.ShowCaptionAboveMedia

	fieldMedia, _ := unmarshalPaidMediaSlice(objMap["media"])
	messagePaidMedia.Media = fieldMedia

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messagePaidMedia *MessagePaidMedia) GetMessageContentEnum() MessageContentEnum {
	return MessagePaidMediaType
}

// MessagePhoto A photo message
type MessagePhoto struct {
	tdCommon
	Photo                 *Photo         `json:"photo"`                    // The photo
	Caption               *FormattedText `json:"caption"`                  // Photo caption
	ShowCaptionAboveMedia bool           `json:"show_caption_above_media"` // True, if the caption must be shown above the photo; otherwise, the caption must be shown below the photo
	HasSpoiler            bool           `json:"has_spoiler"`              // True, if the photo preview must be covered by a spoiler animation
	IsSecret              bool           `json:"is_secret"`                // True, if the photo must be blurred and must be shown only while tapped
}

// MessageType return the string telegram-type of MessagePhoto
func (messagePhoto *MessagePhoto) MessageType() string {
	return "messagePhoto"
}

// NewMessagePhoto creates a new MessagePhoto
//
// @param photo The photo
// @param caption Photo caption
// @param showCaptionAboveMedia True, if the caption must be shown above the photo; otherwise, the caption must be shown below the photo
// @param hasSpoiler True, if the photo preview must be covered by a spoiler animation
// @param isSecret True, if the photo must be blurred and must be shown only while tapped
func NewMessagePhoto(photo *Photo, caption *FormattedText, showCaptionAboveMedia bool, hasSpoiler bool, isSecret bool) *MessagePhoto {
	messagePhotoTemp := MessagePhoto{
		tdCommon:              tdCommon{Type: "messagePhoto"},
		Photo:                 photo,
		Caption:               caption,
		ShowCaptionAboveMedia: showCaptionAboveMedia,
		HasSpoiler:            hasSpoiler,
		IsSecret:              isSecret,
	}

	return &messagePhotoTemp
}

// UnmarshalJSON unmarshal to json
func (messagePhoto *MessagePhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Photo                 *Photo         `json:"photo"`                    // The photo
		Caption               *FormattedText `json:"caption"`                  // Photo caption
		ShowCaptionAboveMedia bool           `json:"show_caption_above_media"` // True, if the caption must be shown above the photo; otherwise, the caption must be shown below the photo
		HasSpoiler            bool           `json:"has_spoiler"`              // True, if the photo preview must be covered by a spoiler animation
		IsSecret              bool           `json:"is_secret"`                // True, if the photo must be blurred and must be shown only while tapped
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messagePhoto.tdCommon = tempObj.tdCommon
	messagePhoto.Photo = tempObj.Photo
	messagePhoto.Caption = tempObj.Caption
	messagePhoto.ShowCaptionAboveMedia = tempObj.ShowCaptionAboveMedia
	messagePhoto.HasSpoiler = tempObj.HasSpoiler
	messagePhoto.IsSecret = tempObj.IsSecret

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messagePhoto *MessagePhoto) GetMessageContentEnum() MessageContentEnum {
	return MessagePhotoType
}

// MessageSticker A sticker message
type MessageSticker struct {
	tdCommon
	Sticker   *Sticker `json:"sticker"`    // The sticker description
	IsPremium bool     `json:"is_premium"` // True, if premium animation of the sticker must be played
}

// MessageType return the string telegram-type of MessageSticker
func (messageSticker *MessageSticker) MessageType() string {
	return "messageSticker"
}

// NewMessageSticker creates a new MessageSticker
//
// @param sticker The sticker description
// @param isPremium True, if premium animation of the sticker must be played
func NewMessageSticker(sticker *Sticker, isPremium bool) *MessageSticker {
	messageStickerTemp := MessageSticker{
		tdCommon:  tdCommon{Type: "messageSticker"},
		Sticker:   sticker,
		IsPremium: isPremium,
	}

	return &messageStickerTemp
}

// UnmarshalJSON unmarshal to json
func (messageSticker *MessageSticker) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsPremium bool `json:"is_premium"` // True, if premium animation of the sticker must be played
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSticker.tdCommon = tempObj.tdCommon
	messageSticker.IsPremium = tempObj.IsPremium

	var sticker Sticker
	if objMap["sticker"] != nil {
		err = sticker.UnmarshalJSON(*objMap["sticker"])
		if err != nil {
			return err
		}
	}

	messageSticker.Sticker = &sticker

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageSticker *MessageSticker) GetMessageContentEnum() MessageContentEnum {
	return MessageStickerType
}

// MessageVideo A video message
type MessageVideo struct {
	tdCommon
	Video                 *Video         `json:"video"`                    // The video description
	Caption               *FormattedText `json:"caption"`                  // Video caption
	ShowCaptionAboveMedia bool           `json:"show_caption_above_media"` // True, if the caption must be shown above the video; otherwise, the caption must be shown below the video
	HasSpoiler            bool           `json:"has_spoiler"`              // True, if the video preview must be covered by a spoiler animation
	IsSecret              bool           `json:"is_secret"`                // True, if the video thumbnail must be blurred and the video must be shown only while tapped
}

// MessageType return the string telegram-type of MessageVideo
func (messageVideo *MessageVideo) MessageType() string {
	return "messageVideo"
}

// NewMessageVideo creates a new MessageVideo
//
// @param video The video description
// @param caption Video caption
// @param showCaptionAboveMedia True, if the caption must be shown above the video; otherwise, the caption must be shown below the video
// @param hasSpoiler True, if the video preview must be covered by a spoiler animation
// @param isSecret True, if the video thumbnail must be blurred and the video must be shown only while tapped
func NewMessageVideo(video *Video, caption *FormattedText, showCaptionAboveMedia bool, hasSpoiler bool, isSecret bool) *MessageVideo {
	messageVideoTemp := MessageVideo{
		tdCommon:              tdCommon{Type: "messageVideo"},
		Video:                 video,
		Caption:               caption,
		ShowCaptionAboveMedia: showCaptionAboveMedia,
		HasSpoiler:            hasSpoiler,
		IsSecret:              isSecret,
	}

	return &messageVideoTemp
}

// UnmarshalJSON unmarshal to json
func (messageVideo *MessageVideo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Video                 *Video         `json:"video"`                    // The video description
		Caption               *FormattedText `json:"caption"`                  // Video caption
		ShowCaptionAboveMedia bool           `json:"show_caption_above_media"` // True, if the caption must be shown above the video; otherwise, the caption must be shown below the video
		HasSpoiler            bool           `json:"has_spoiler"`              // True, if the video preview must be covered by a spoiler animation
		IsSecret              bool           `json:"is_secret"`                // True, if the video thumbnail must be blurred and the video must be shown only while tapped
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageVideo.tdCommon = tempObj.tdCommon
	messageVideo.Video = tempObj.Video
	messageVideo.Caption = tempObj.Caption
	messageVideo.ShowCaptionAboveMedia = tempObj.ShowCaptionAboveMedia
	messageVideo.HasSpoiler = tempObj.HasSpoiler
	messageVideo.IsSecret = tempObj.IsSecret

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageVideo *MessageVideo) GetMessageContentEnum() MessageContentEnum {
	return MessageVideoType
}

// MessageVideoNote A video note message
type MessageVideoNote struct {
	tdCommon
	VideoNote *VideoNote `json:"video_note"` // The video note description
	IsViewed  bool       `json:"is_viewed"`  // True, if at least one of the recipients has viewed the video note
	IsSecret  bool       `json:"is_secret"`  // True, if the video note thumbnail must be blurred and the video note must be shown only while tapped
}

// MessageType return the string telegram-type of MessageVideoNote
func (messageVideoNote *MessageVideoNote) MessageType() string {
	return "messageVideoNote"
}

// NewMessageVideoNote creates a new MessageVideoNote
//
// @param videoNote The video note description
// @param isViewed True, if at least one of the recipients has viewed the video note
// @param isSecret True, if the video note thumbnail must be blurred and the video note must be shown only while tapped
func NewMessageVideoNote(videoNote *VideoNote, isViewed bool, isSecret bool) *MessageVideoNote {
	messageVideoNoteTemp := MessageVideoNote{
		tdCommon:  tdCommon{Type: "messageVideoNote"},
		VideoNote: videoNote,
		IsViewed:  isViewed,
		IsSecret:  isSecret,
	}

	return &messageVideoNoteTemp
}

// UnmarshalJSON unmarshal to json
func (messageVideoNote *MessageVideoNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsViewed bool `json:"is_viewed"` // True, if at least one of the recipients has viewed the video note
		IsSecret bool `json:"is_secret"` // True, if the video note thumbnail must be blurred and the video note must be shown only while tapped
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageVideoNote.tdCommon = tempObj.tdCommon
	messageVideoNote.IsViewed = tempObj.IsViewed
	messageVideoNote.IsSecret = tempObj.IsSecret

	var videoNote VideoNote
	if objMap["video_note"] != nil {
		err = videoNote.UnmarshalJSON(*objMap["video_note"])
		if err != nil {
			return err
		}
	}

	messageVideoNote.VideoNote = &videoNote

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageVideoNote *MessageVideoNote) GetMessageContentEnum() MessageContentEnum {
	return MessageVideoNoteType
}

// MessageVoiceNote A voice note message
type MessageVoiceNote struct {
	tdCommon
	VoiceNote  *VoiceNote     `json:"voice_note"`  // The voice note description
	Caption    *FormattedText `json:"caption"`     // Voice note caption
	IsListened bool           `json:"is_listened"` // True, if at least one of the recipients has listened to the voice note
}

// MessageType return the string telegram-type of MessageVoiceNote
func (messageVoiceNote *MessageVoiceNote) MessageType() string {
	return "messageVoiceNote"
}

// NewMessageVoiceNote creates a new MessageVoiceNote
//
// @param voiceNote The voice note description
// @param caption Voice note caption
// @param isListened True, if at least one of the recipients has listened to the voice note
func NewMessageVoiceNote(voiceNote *VoiceNote, caption *FormattedText, isListened bool) *MessageVoiceNote {
	messageVoiceNoteTemp := MessageVoiceNote{
		tdCommon:   tdCommon{Type: "messageVoiceNote"},
		VoiceNote:  voiceNote,
		Caption:    caption,
		IsListened: isListened,
	}

	return &messageVoiceNoteTemp
}

// UnmarshalJSON unmarshal to json
func (messageVoiceNote *MessageVoiceNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Caption    *FormattedText `json:"caption"`     // Voice note caption
		IsListened bool           `json:"is_listened"` // True, if at least one of the recipients has listened to the voice note
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageVoiceNote.tdCommon = tempObj.tdCommon
	messageVoiceNote.Caption = tempObj.Caption
	messageVoiceNote.IsListened = tempObj.IsListened

	var voiceNote VoiceNote
	if objMap["voice_note"] != nil {
		err = voiceNote.UnmarshalJSON(*objMap["voice_note"])
		if err != nil {
			return err
		}
	}

	messageVoiceNote.VoiceNote = &voiceNote

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageVoiceNote *MessageVoiceNote) GetMessageContentEnum() MessageContentEnum {
	return MessageVoiceNoteType
}

// MessageExpiredPhoto A self-destructed photo message
type MessageExpiredPhoto struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageExpiredPhoto
func (messageExpiredPhoto *MessageExpiredPhoto) MessageType() string {
	return "messageExpiredPhoto"
}

// NewMessageExpiredPhoto creates a new MessageExpiredPhoto
//
func NewMessageExpiredPhoto() *MessageExpiredPhoto {
	messageExpiredPhotoTemp := MessageExpiredPhoto{
		tdCommon: tdCommon{Type: "messageExpiredPhoto"},
	}

	return &messageExpiredPhotoTemp
}

// UnmarshalJSON unmarshal to json
func (messageExpiredPhoto *MessageExpiredPhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageExpiredPhoto.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageExpiredPhoto *MessageExpiredPhoto) GetMessageContentEnum() MessageContentEnum {
	return MessageExpiredPhotoType
}

// MessageExpiredVideo A self-destructed video message
type MessageExpiredVideo struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageExpiredVideo
func (messageExpiredVideo *MessageExpiredVideo) MessageType() string {
	return "messageExpiredVideo"
}

// NewMessageExpiredVideo creates a new MessageExpiredVideo
//
func NewMessageExpiredVideo() *MessageExpiredVideo {
	messageExpiredVideoTemp := MessageExpiredVideo{
		tdCommon: tdCommon{Type: "messageExpiredVideo"},
	}

	return &messageExpiredVideoTemp
}

// UnmarshalJSON unmarshal to json
func (messageExpiredVideo *MessageExpiredVideo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageExpiredVideo.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageExpiredVideo *MessageExpiredVideo) GetMessageContentEnum() MessageContentEnum {
	return MessageExpiredVideoType
}

// MessageExpiredVideoNote A self-destructed video note message
type MessageExpiredVideoNote struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageExpiredVideoNote
func (messageExpiredVideoNote *MessageExpiredVideoNote) MessageType() string {
	return "messageExpiredVideoNote"
}

// NewMessageExpiredVideoNote creates a new MessageExpiredVideoNote
//
func NewMessageExpiredVideoNote() *MessageExpiredVideoNote {
	messageExpiredVideoNoteTemp := MessageExpiredVideoNote{
		tdCommon: tdCommon{Type: "messageExpiredVideoNote"},
	}

	return &messageExpiredVideoNoteTemp
}

// UnmarshalJSON unmarshal to json
func (messageExpiredVideoNote *MessageExpiredVideoNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageExpiredVideoNote.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageExpiredVideoNote *MessageExpiredVideoNote) GetMessageContentEnum() MessageContentEnum {
	return MessageExpiredVideoNoteType
}

// MessageExpiredVoiceNote A self-destructed voice note message
type MessageExpiredVoiceNote struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageExpiredVoiceNote
func (messageExpiredVoiceNote *MessageExpiredVoiceNote) MessageType() string {
	return "messageExpiredVoiceNote"
}

// NewMessageExpiredVoiceNote creates a new MessageExpiredVoiceNote
//
func NewMessageExpiredVoiceNote() *MessageExpiredVoiceNote {
	messageExpiredVoiceNoteTemp := MessageExpiredVoiceNote{
		tdCommon: tdCommon{Type: "messageExpiredVoiceNote"},
	}

	return &messageExpiredVoiceNoteTemp
}

// UnmarshalJSON unmarshal to json
func (messageExpiredVoiceNote *MessageExpiredVoiceNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageExpiredVoiceNote.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageExpiredVoiceNote *MessageExpiredVoiceNote) GetMessageContentEnum() MessageContentEnum {
	return MessageExpiredVoiceNoteType
}

// MessageLocation A message with a location
type MessageLocation struct {
	tdCommon
	Location             *Location `json:"location"`               // The location description
	LivePeriod           int32     `json:"live_period"`            // Time relative to the message send date, for which the location can be updated, in seconds; if 0x7FFFFFFF, then location can be updated forever
	ExpiresIn            int32     `json:"expires_in"`             // Left time for which the location can be updated, in seconds. If 0, then the location can't be updated anymore. The update updateMessageContent is not sent when this field changes
	Heading              int32     `json:"heading"`                // For live locations, a direction in which the location moves, in degrees; 1-360. If 0 the direction is unknown
	ProximityAlertRadius int32     `json:"proximity_alert_radius"` // For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). 0 if the notification is disabled. Available only to the message sender
}

// MessageType return the string telegram-type of MessageLocation
func (messageLocation *MessageLocation) MessageType() string {
	return "messageLocation"
}

// NewMessageLocation creates a new MessageLocation
//
// @param location The location description
// @param livePeriod Time relative to the message send date, for which the location can be updated, in seconds; if 0x7FFFFFFF, then location can be updated forever
// @param expiresIn Left time for which the location can be updated, in seconds. If 0, then the location can't be updated anymore. The update updateMessageContent is not sent when this field changes
// @param heading For live locations, a direction in which the location moves, in degrees; 1-360. If 0 the direction is unknown
// @param proximityAlertRadius For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). 0 if the notification is disabled. Available only to the message sender
func NewMessageLocation(location *Location, livePeriod int32, expiresIn int32, heading int32, proximityAlertRadius int32) *MessageLocation {
	messageLocationTemp := MessageLocation{
		tdCommon:             tdCommon{Type: "messageLocation"},
		Location:             location,
		LivePeriod:           livePeriod,
		ExpiresIn:            expiresIn,
		Heading:              heading,
		ProximityAlertRadius: proximityAlertRadius,
	}

	return &messageLocationTemp
}

// UnmarshalJSON unmarshal to json
func (messageLocation *MessageLocation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Location             *Location `json:"location"`               // The location description
		LivePeriod           int32     `json:"live_period"`            // Time relative to the message send date, for which the location can be updated, in seconds; if 0x7FFFFFFF, then location can be updated forever
		ExpiresIn            int32     `json:"expires_in"`             // Left time for which the location can be updated, in seconds. If 0, then the location can't be updated anymore. The update updateMessageContent is not sent when this field changes
		Heading              int32     `json:"heading"`                // For live locations, a direction in which the location moves, in degrees; 1-360. If 0 the direction is unknown
		ProximityAlertRadius int32     `json:"proximity_alert_radius"` // For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). 0 if the notification is disabled. Available only to the message sender
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageLocation.tdCommon = tempObj.tdCommon
	messageLocation.Location = tempObj.Location
	messageLocation.LivePeriod = tempObj.LivePeriod
	messageLocation.ExpiresIn = tempObj.ExpiresIn
	messageLocation.Heading = tempObj.Heading
	messageLocation.ProximityAlertRadius = tempObj.ProximityAlertRadius

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageLocation *MessageLocation) GetMessageContentEnum() MessageContentEnum {
	return MessageLocationType
}

// MessageVenue A message with information about a venue
type MessageVenue struct {
	tdCommon
	Venue *Venue `json:"venue"` // The venue description
}

// MessageType return the string telegram-type of MessageVenue
func (messageVenue *MessageVenue) MessageType() string {
	return "messageVenue"
}

// NewMessageVenue creates a new MessageVenue
//
// @param venue The venue description
func NewMessageVenue(venue *Venue) *MessageVenue {
	messageVenueTemp := MessageVenue{
		tdCommon: tdCommon{Type: "messageVenue"},
		Venue:    venue,
	}

	return &messageVenueTemp
}

// UnmarshalJSON unmarshal to json
func (messageVenue *MessageVenue) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Venue *Venue `json:"venue"` // The venue description
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageVenue.tdCommon = tempObj.tdCommon
	messageVenue.Venue = tempObj.Venue

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageVenue *MessageVenue) GetMessageContentEnum() MessageContentEnum {
	return MessageVenueType
}

// MessageContact A message with a user contact
type MessageContact struct {
	tdCommon
	Contact *Contact `json:"contact"` // The contact description
}

// MessageType return the string telegram-type of MessageContact
func (messageContact *MessageContact) MessageType() string {
	return "messageContact"
}

// NewMessageContact creates a new MessageContact
//
// @param contact The contact description
func NewMessageContact(contact *Contact) *MessageContact {
	messageContactTemp := MessageContact{
		tdCommon: tdCommon{Type: "messageContact"},
		Contact:  contact,
	}

	return &messageContactTemp
}

// UnmarshalJSON unmarshal to json
func (messageContact *MessageContact) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Contact *Contact `json:"contact"` // The contact description
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageContact.tdCommon = tempObj.tdCommon
	messageContact.Contact = tempObj.Contact

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageContact *MessageContact) GetMessageContentEnum() MessageContentEnum {
	return MessageContactType
}

// MessageAnimatedEmoji A message with an animated emoji
type MessageAnimatedEmoji struct {
	tdCommon
	AnimatedEmoji *AnimatedEmoji `json:"animated_emoji"` // The animated emoji
	Emoji         string         `json:"emoji"`          // The corresponding emoji
}

// MessageType return the string telegram-type of MessageAnimatedEmoji
func (messageAnimatedEmoji *MessageAnimatedEmoji) MessageType() string {
	return "messageAnimatedEmoji"
}

// NewMessageAnimatedEmoji creates a new MessageAnimatedEmoji
//
// @param animatedEmoji The animated emoji
// @param emoji The corresponding emoji
func NewMessageAnimatedEmoji(animatedEmoji *AnimatedEmoji, emoji string) *MessageAnimatedEmoji {
	messageAnimatedEmojiTemp := MessageAnimatedEmoji{
		tdCommon:      tdCommon{Type: "messageAnimatedEmoji"},
		AnimatedEmoji: animatedEmoji,
		Emoji:         emoji,
	}

	return &messageAnimatedEmojiTemp
}

// UnmarshalJSON unmarshal to json
func (messageAnimatedEmoji *MessageAnimatedEmoji) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		AnimatedEmoji *AnimatedEmoji `json:"animated_emoji"` // The animated emoji
		Emoji         string         `json:"emoji"`          // The corresponding emoji
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageAnimatedEmoji.tdCommon = tempObj.tdCommon
	messageAnimatedEmoji.AnimatedEmoji = tempObj.AnimatedEmoji
	messageAnimatedEmoji.Emoji = tempObj.Emoji

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageAnimatedEmoji *MessageAnimatedEmoji) GetMessageContentEnum() MessageContentEnum {
	return MessageAnimatedEmojiType
}

// MessageDice A dice message. The dice value is randomly generated by the server
type MessageDice struct {
	tdCommon
	InitialState                *DiceStickers `json:"initial_state"`                  // The animated stickers with the initial dice animation; may be null if unknown. The update updateMessageContent will be sent when the sticker became known
	FinalState                  *DiceStickers `json:"final_state"`                    // The animated stickers with the final dice animation; may be null if unknown. The update updateMessageContent will be sent when the sticker became known
	Emoji                       string        `json:"emoji"`                          // Emoji on which the dice throw animation is based
	Value                       int32         `json:"value"`                          // The dice value. If the value is 0, the dice don't have final state yet
	SuccessAnimationFrameNumber int32         `json:"success_animation_frame_number"` // Number of frame after which a success animation like a shower of confetti needs to be shown on updateMessageSendSucceeded
}

// MessageType return the string telegram-type of MessageDice
func (messageDice *MessageDice) MessageType() string {
	return "messageDice"
}

// NewMessageDice creates a new MessageDice
//
// @param initialState The animated stickers with the initial dice animation; may be null if unknown. The update updateMessageContent will be sent when the sticker became known
// @param finalState The animated stickers with the final dice animation; may be null if unknown. The update updateMessageContent will be sent when the sticker became known
// @param emoji Emoji on which the dice throw animation is based
// @param value The dice value. If the value is 0, the dice don't have final state yet
// @param successAnimationFrameNumber Number of frame after which a success animation like a shower of confetti needs to be shown on updateMessageSendSucceeded
func NewMessageDice(initialState *DiceStickers, finalState *DiceStickers, emoji string, value int32, successAnimationFrameNumber int32) *MessageDice {
	messageDiceTemp := MessageDice{
		tdCommon:                    tdCommon{Type: "messageDice"},
		InitialState:                initialState,
		FinalState:                  finalState,
		Emoji:                       emoji,
		Value:                       value,
		SuccessAnimationFrameNumber: successAnimationFrameNumber,
	}

	return &messageDiceTemp
}

// UnmarshalJSON unmarshal to json
func (messageDice *MessageDice) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Emoji                       string `json:"emoji"`                          // Emoji on which the dice throw animation is based
		Value                       int32  `json:"value"`                          // The dice value. If the value is 0, the dice don't have final state yet
		SuccessAnimationFrameNumber int32  `json:"success_animation_frame_number"` // Number of frame after which a success animation like a shower of confetti needs to be shown on updateMessageSendSucceeded
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageDice.tdCommon = tempObj.tdCommon
	messageDice.Emoji = tempObj.Emoji
	messageDice.Value = tempObj.Value
	messageDice.SuccessAnimationFrameNumber = tempObj.SuccessAnimationFrameNumber

	fieldInitialState, _ := unmarshalDiceStickers(objMap["initial_state"])
	messageDice.InitialState = &fieldInitialState

	fieldFinalState, _ := unmarshalDiceStickers(objMap["final_state"])
	messageDice.FinalState = &fieldFinalState

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageDice *MessageDice) GetMessageContentEnum() MessageContentEnum {
	return MessageDiceType
}

// MessageGame A message with a game
type MessageGame struct {
	tdCommon
	Game *Game `json:"game"` // The game description
}

// MessageType return the string telegram-type of MessageGame
func (messageGame *MessageGame) MessageType() string {
	return "messageGame"
}

// NewMessageGame creates a new MessageGame
//
// @param game The game description
func NewMessageGame(game *Game) *MessageGame {
	messageGameTemp := MessageGame{
		tdCommon: tdCommon{Type: "messageGame"},
		Game:     game,
	}

	return &messageGameTemp
}

// UnmarshalJSON unmarshal to json
func (messageGame *MessageGame) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Game *Game `json:"game"` // The game description
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageGame.tdCommon = tempObj.tdCommon
	messageGame.Game = tempObj.Game

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageGame *MessageGame) GetMessageContentEnum() MessageContentEnum {
	return MessageGameType
}

// MessagePoll A message with a poll
type MessagePoll struct {
	tdCommon
	Poll *Poll `json:"poll"` // The poll description
}

// MessageType return the string telegram-type of MessagePoll
func (messagePoll *MessagePoll) MessageType() string {
	return "messagePoll"
}

// NewMessagePoll creates a new MessagePoll
//
// @param poll The poll description
func NewMessagePoll(poll *Poll) *MessagePoll {
	messagePollTemp := MessagePoll{
		tdCommon: tdCommon{Type: "messagePoll"},
		Poll:     poll,
	}

	return &messagePollTemp
}

// UnmarshalJSON unmarshal to json
func (messagePoll *MessagePoll) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messagePoll.tdCommon = tempObj.tdCommon

	var poll Poll
	if objMap["poll"] != nil {
		err = poll.UnmarshalJSON(*objMap["poll"])
		if err != nil {
			return err
		}
	}

	messagePoll.Poll = &poll

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messagePoll *MessagePoll) GetMessageContentEnum() MessageContentEnum {
	return MessagePollType
}

// MessageStory A message with a forwarded story
type MessageStory struct {
	tdCommon
	StorySenderChatID int64 `json:"story_sender_chat_id"` // Identifier of the chat that posted the story
	StoryID           int32 `json:"story_id"`             // Story identifier
	ViaMention        bool  `json:"via_mention"`          // True, if the story was automatically forwarded because of a mention of the user
}

// MessageType return the string telegram-type of MessageStory
func (messageStory *MessageStory) MessageType() string {
	return "messageStory"
}

// NewMessageStory creates a new MessageStory
//
// @param storySenderChatID Identifier of the chat that posted the story
// @param storyID Story identifier
// @param viaMention True, if the story was automatically forwarded because of a mention of the user
func NewMessageStory(storySenderChatID int64, storyID int32, viaMention bool) *MessageStory {
	messageStoryTemp := MessageStory{
		tdCommon:          tdCommon{Type: "messageStory"},
		StorySenderChatID: storySenderChatID,
		StoryID:           storyID,
		ViaMention:        viaMention,
	}

	return &messageStoryTemp
}

// UnmarshalJSON unmarshal to json
func (messageStory *MessageStory) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StorySenderChatID int64 `json:"story_sender_chat_id"` // Identifier of the chat that posted the story
		StoryID           int32 `json:"story_id"`             // Story identifier
		ViaMention        bool  `json:"via_mention"`          // True, if the story was automatically forwarded because of a mention of the user
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageStory.tdCommon = tempObj.tdCommon
	messageStory.StorySenderChatID = tempObj.StorySenderChatID
	messageStory.StoryID = tempObj.StoryID
	messageStory.ViaMention = tempObj.ViaMention

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageStory *MessageStory) GetMessageContentEnum() MessageContentEnum {
	return MessageStoryType
}

// MessageInvoice A message with an invoice from a bot. Use getInternalLink with internalLinkTypeBotStart to share the invoice
type MessageInvoice struct {
	tdCommon
	ProductInfo         *ProductInfo   `json:"product_info"`          // Information about the product
	Currency            string         `json:"currency"`              // Currency for the product price
	TotalAmount         int64          `json:"total_amount"`          // Product total price in the smallest units of the currency
	StartParameter      string         `json:"start_parameter"`       // Unique invoice bot start_parameter to be passed to getInternalLink
	IsTest              bool           `json:"is_test"`               // True, if the invoice is a test invoice
	NeedShippingAddress bool           `json:"need_shipping_address"` // True, if the shipping address must be specified
	ReceiptMessageID    int64          `json:"receipt_message_id"`    // The identifier of the message with the receipt, after the product has been purchased
	PaidMedia           *PaidMedia     `json:"paid_media"`            // Extended media attached to the invoice; may be null if none
	PaidMediaCaption    *FormattedText `json:"paid_media_caption"`    // Extended media caption; may be null if none
}

// MessageType return the string telegram-type of MessageInvoice
func (messageInvoice *MessageInvoice) MessageType() string {
	return "messageInvoice"
}

// NewMessageInvoice creates a new MessageInvoice
//
// @param productInfo Information about the product
// @param currency Currency for the product price
// @param totalAmount Product total price in the smallest units of the currency
// @param startParameter Unique invoice bot start_parameter to be passed to getInternalLink
// @param isTest True, if the invoice is a test invoice
// @param needShippingAddress True, if the shipping address must be specified
// @param receiptMessageID The identifier of the message with the receipt, after the product has been purchased
// @param paidMedia Extended media attached to the invoice; may be null if none
// @param paidMediaCaption Extended media caption; may be null if none
func NewMessageInvoice(productInfo *ProductInfo, currency string, totalAmount int64, startParameter string, isTest bool, needShippingAddress bool, receiptMessageID int64, paidMedia *PaidMedia, paidMediaCaption *FormattedText) *MessageInvoice {
	messageInvoiceTemp := MessageInvoice{
		tdCommon:            tdCommon{Type: "messageInvoice"},
		ProductInfo:         productInfo,
		Currency:            currency,
		TotalAmount:         totalAmount,
		StartParameter:      startParameter,
		IsTest:              isTest,
		NeedShippingAddress: needShippingAddress,
		ReceiptMessageID:    receiptMessageID,
		PaidMedia:           paidMedia,
		PaidMediaCaption:    paidMediaCaption,
	}

	return &messageInvoiceTemp
}

// UnmarshalJSON unmarshal to json
func (messageInvoice *MessageInvoice) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ProductInfo         *ProductInfo   `json:"product_info"`          // Information about the product
		Currency            string         `json:"currency"`              // Currency for the product price
		TotalAmount         int64          `json:"total_amount"`          // Product total price in the smallest units of the currency
		StartParameter      string         `json:"start_parameter"`       // Unique invoice bot start_parameter to be passed to getInternalLink
		IsTest              bool           `json:"is_test"`               // True, if the invoice is a test invoice
		NeedShippingAddress bool           `json:"need_shipping_address"` // True, if the shipping address must be specified
		ReceiptMessageID    int64          `json:"receipt_message_id"`    // The identifier of the message with the receipt, after the product has been purchased
		PaidMediaCaption    *FormattedText `json:"paid_media_caption"`    // Extended media caption; may be null if none
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageInvoice.tdCommon = tempObj.tdCommon
	messageInvoice.ProductInfo = tempObj.ProductInfo
	messageInvoice.Currency = tempObj.Currency
	messageInvoice.TotalAmount = tempObj.TotalAmount
	messageInvoice.StartParameter = tempObj.StartParameter
	messageInvoice.IsTest = tempObj.IsTest
	messageInvoice.NeedShippingAddress = tempObj.NeedShippingAddress
	messageInvoice.ReceiptMessageID = tempObj.ReceiptMessageID
	messageInvoice.PaidMediaCaption = tempObj.PaidMediaCaption

	fieldPaidMedia, _ := unmarshalPaidMedia(objMap["paid_media"])
	messageInvoice.PaidMedia = &fieldPaidMedia

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageInvoice *MessageInvoice) GetMessageContentEnum() MessageContentEnum {
	return MessageInvoiceType
}

// MessageCall A message with information about an ended call
type MessageCall struct {
	tdCommon
	IsVideo       bool              `json:"is_video"`       // True, if the call was a video call
	DiscardReason CallDiscardReason `json:"discard_reason"` // Reason why the call was discarded
	Duration      int32             `json:"duration"`       // Call duration, in seconds
}

// MessageType return the string telegram-type of MessageCall
func (messageCall *MessageCall) MessageType() string {
	return "messageCall"
}

// NewMessageCall creates a new MessageCall
//
// @param isVideo True, if the call was a video call
// @param discardReason Reason why the call was discarded
// @param duration Call duration, in seconds
func NewMessageCall(isVideo bool, discardReason CallDiscardReason, duration int32) *MessageCall {
	messageCallTemp := MessageCall{
		tdCommon:      tdCommon{Type: "messageCall"},
		IsVideo:       isVideo,
		DiscardReason: discardReason,
		Duration:      duration,
	}

	return &messageCallTemp
}

// UnmarshalJSON unmarshal to json
func (messageCall *MessageCall) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsVideo  bool  `json:"is_video"` // True, if the call was a video call
		Duration int32 `json:"duration"` // Call duration, in seconds
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageCall.tdCommon = tempObj.tdCommon
	messageCall.IsVideo = tempObj.IsVideo
	messageCall.Duration = tempObj.Duration

	fieldDiscardReason, _ := unmarshalCallDiscardReason(objMap["discard_reason"])
	messageCall.DiscardReason = fieldDiscardReason

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageCall *MessageCall) GetMessageContentEnum() MessageContentEnum {
	return MessageCallType
}

// MessageVideoChatScheduled A new video chat was scheduled
type MessageVideoChatScheduled struct {
	tdCommon
	GroupCallID int32 `json:"group_call_id"` // Identifier of the video chat. The video chat can be received through the method getGroupCall
	StartDate   int32 `json:"start_date"`    // Point in time (Unix timestamp) when the group call is supposed to be started by an administrator
}

// MessageType return the string telegram-type of MessageVideoChatScheduled
func (messageVideoChatScheduled *MessageVideoChatScheduled) MessageType() string {
	return "messageVideoChatScheduled"
}

// NewMessageVideoChatScheduled creates a new MessageVideoChatScheduled
//
// @param groupCallID Identifier of the video chat. The video chat can be received through the method getGroupCall
// @param startDate Point in time (Unix timestamp) when the group call is supposed to be started by an administrator
func NewMessageVideoChatScheduled(groupCallID int32, startDate int32) *MessageVideoChatScheduled {
	messageVideoChatScheduledTemp := MessageVideoChatScheduled{
		tdCommon:    tdCommon{Type: "messageVideoChatScheduled"},
		GroupCallID: groupCallID,
		StartDate:   startDate,
	}

	return &messageVideoChatScheduledTemp
}

// UnmarshalJSON unmarshal to json
func (messageVideoChatScheduled *MessageVideoChatScheduled) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		GroupCallID int32 `json:"group_call_id"` // Identifier of the video chat. The video chat can be received through the method getGroupCall
		StartDate   int32 `json:"start_date"`    // Point in time (Unix timestamp) when the group call is supposed to be started by an administrator
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageVideoChatScheduled.tdCommon = tempObj.tdCommon
	messageVideoChatScheduled.GroupCallID = tempObj.GroupCallID
	messageVideoChatScheduled.StartDate = tempObj.StartDate

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageVideoChatScheduled *MessageVideoChatScheduled) GetMessageContentEnum() MessageContentEnum {
	return MessageVideoChatScheduledType
}

// MessageVideoChatStarted A newly created video chat
type MessageVideoChatStarted struct {
	tdCommon
	GroupCallID int32 `json:"group_call_id"` // Identifier of the video chat. The video chat can be received through the method getGroupCall
}

// MessageType return the string telegram-type of MessageVideoChatStarted
func (messageVideoChatStarted *MessageVideoChatStarted) MessageType() string {
	return "messageVideoChatStarted"
}

// NewMessageVideoChatStarted creates a new MessageVideoChatStarted
//
// @param groupCallID Identifier of the video chat. The video chat can be received through the method getGroupCall
func NewMessageVideoChatStarted(groupCallID int32) *MessageVideoChatStarted {
	messageVideoChatStartedTemp := MessageVideoChatStarted{
		tdCommon:    tdCommon{Type: "messageVideoChatStarted"},
		GroupCallID: groupCallID,
	}

	return &messageVideoChatStartedTemp
}

// UnmarshalJSON unmarshal to json
func (messageVideoChatStarted *MessageVideoChatStarted) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		GroupCallID int32 `json:"group_call_id"` // Identifier of the video chat. The video chat can be received through the method getGroupCall
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageVideoChatStarted.tdCommon = tempObj.tdCommon
	messageVideoChatStarted.GroupCallID = tempObj.GroupCallID

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageVideoChatStarted *MessageVideoChatStarted) GetMessageContentEnum() MessageContentEnum {
	return MessageVideoChatStartedType
}

// MessageVideoChatEnded A message with information about an ended video chat
type MessageVideoChatEnded struct {
	tdCommon
	Duration int32 `json:"duration"` // Call duration, in seconds
}

// MessageType return the string telegram-type of MessageVideoChatEnded
func (messageVideoChatEnded *MessageVideoChatEnded) MessageType() string {
	return "messageVideoChatEnded"
}

// NewMessageVideoChatEnded creates a new MessageVideoChatEnded
//
// @param duration Call duration, in seconds
func NewMessageVideoChatEnded(duration int32) *MessageVideoChatEnded {
	messageVideoChatEndedTemp := MessageVideoChatEnded{
		tdCommon: tdCommon{Type: "messageVideoChatEnded"},
		Duration: duration,
	}

	return &messageVideoChatEndedTemp
}

// UnmarshalJSON unmarshal to json
func (messageVideoChatEnded *MessageVideoChatEnded) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Duration int32 `json:"duration"` // Call duration, in seconds
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageVideoChatEnded.tdCommon = tempObj.tdCommon
	messageVideoChatEnded.Duration = tempObj.Duration

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageVideoChatEnded *MessageVideoChatEnded) GetMessageContentEnum() MessageContentEnum {
	return MessageVideoChatEndedType
}

// MessageInviteVideoChatParticipants A message with information about an invitation to a video chat
type MessageInviteVideoChatParticipants struct {
	tdCommon
	GroupCallID int32   `json:"group_call_id"` // Identifier of the video chat. The video chat can be received through the method getGroupCall
	UserIDs     []int64 `json:"user_ids"`      // Invited user identifiers
}

// MessageType return the string telegram-type of MessageInviteVideoChatParticipants
func (messageInviteVideoChatParticipants *MessageInviteVideoChatParticipants) MessageType() string {
	return "messageInviteVideoChatParticipants"
}

// NewMessageInviteVideoChatParticipants creates a new MessageInviteVideoChatParticipants
//
// @param groupCallID Identifier of the video chat. The video chat can be received through the method getGroupCall
// @param userIDs Invited user identifiers
func NewMessageInviteVideoChatParticipants(groupCallID int32, userIDs []int64) *MessageInviteVideoChatParticipants {
	messageInviteVideoChatParticipantsTemp := MessageInviteVideoChatParticipants{
		tdCommon:    tdCommon{Type: "messageInviteVideoChatParticipants"},
		GroupCallID: groupCallID,
		UserIDs:     userIDs,
	}

	return &messageInviteVideoChatParticipantsTemp
}

// UnmarshalJSON unmarshal to json
func (messageInviteVideoChatParticipants *MessageInviteVideoChatParticipants) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		GroupCallID int32   `json:"group_call_id"` // Identifier of the video chat. The video chat can be received through the method getGroupCall
		UserIDs     []int64 `json:"user_ids"`      // Invited user identifiers
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageInviteVideoChatParticipants.tdCommon = tempObj.tdCommon
	messageInviteVideoChatParticipants.GroupCallID = tempObj.GroupCallID
	messageInviteVideoChatParticipants.UserIDs = tempObj.UserIDs

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageInviteVideoChatParticipants *MessageInviteVideoChatParticipants) GetMessageContentEnum() MessageContentEnum {
	return MessageInviteVideoChatParticipantsType
}

// MessageBasicGroupChatCreate A newly created basic group
type MessageBasicGroupChatCreate struct {
	tdCommon
	Title         string  `json:"title"`           // Title of the basic group
	MemberUserIDs []int64 `json:"member_user_ids"` // User identifiers of members in the basic group
}

// MessageType return the string telegram-type of MessageBasicGroupChatCreate
func (messageBasicGroupChatCreate *MessageBasicGroupChatCreate) MessageType() string {
	return "messageBasicGroupChatCreate"
}

// NewMessageBasicGroupChatCreate creates a new MessageBasicGroupChatCreate
//
// @param title Title of the basic group
// @param memberUserIDs User identifiers of members in the basic group
func NewMessageBasicGroupChatCreate(title string, memberUserIDs []int64) *MessageBasicGroupChatCreate {
	messageBasicGroupChatCreateTemp := MessageBasicGroupChatCreate{
		tdCommon:      tdCommon{Type: "messageBasicGroupChatCreate"},
		Title:         title,
		MemberUserIDs: memberUserIDs,
	}

	return &messageBasicGroupChatCreateTemp
}

// UnmarshalJSON unmarshal to json
func (messageBasicGroupChatCreate *MessageBasicGroupChatCreate) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Title         string  `json:"title"`           // Title of the basic group
		MemberUserIDs []int64 `json:"member_user_ids"` // User identifiers of members in the basic group
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageBasicGroupChatCreate.tdCommon = tempObj.tdCommon
	messageBasicGroupChatCreate.Title = tempObj.Title
	messageBasicGroupChatCreate.MemberUserIDs = tempObj.MemberUserIDs

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageBasicGroupChatCreate *MessageBasicGroupChatCreate) GetMessageContentEnum() MessageContentEnum {
	return MessageBasicGroupChatCreateType
}

// MessageSupergroupChatCreate A newly created supergroup or channel
type MessageSupergroupChatCreate struct {
	tdCommon
	Title string `json:"title"` // Title of the supergroup or channel
}

// MessageType return the string telegram-type of MessageSupergroupChatCreate
func (messageSupergroupChatCreate *MessageSupergroupChatCreate) MessageType() string {
	return "messageSupergroupChatCreate"
}

// NewMessageSupergroupChatCreate creates a new MessageSupergroupChatCreate
//
// @param title Title of the supergroup or channel
func NewMessageSupergroupChatCreate(title string) *MessageSupergroupChatCreate {
	messageSupergroupChatCreateTemp := MessageSupergroupChatCreate{
		tdCommon: tdCommon{Type: "messageSupergroupChatCreate"},
		Title:    title,
	}

	return &messageSupergroupChatCreateTemp
}

// UnmarshalJSON unmarshal to json
func (messageSupergroupChatCreate *MessageSupergroupChatCreate) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Title string `json:"title"` // Title of the supergroup or channel
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSupergroupChatCreate.tdCommon = tempObj.tdCommon
	messageSupergroupChatCreate.Title = tempObj.Title

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageSupergroupChatCreate *MessageSupergroupChatCreate) GetMessageContentEnum() MessageContentEnum {
	return MessageSupergroupChatCreateType
}

// MessageChatChangeTitle An updated chat title
type MessageChatChangeTitle struct {
	tdCommon
	Title string `json:"title"` // New chat title
}

// MessageType return the string telegram-type of MessageChatChangeTitle
func (messageChatChangeTitle *MessageChatChangeTitle) MessageType() string {
	return "messageChatChangeTitle"
}

// NewMessageChatChangeTitle creates a new MessageChatChangeTitle
//
// @param title New chat title
func NewMessageChatChangeTitle(title string) *MessageChatChangeTitle {
	messageChatChangeTitleTemp := MessageChatChangeTitle{
		tdCommon: tdCommon{Type: "messageChatChangeTitle"},
		Title:    title,
	}

	return &messageChatChangeTitleTemp
}

// UnmarshalJSON unmarshal to json
func (messageChatChangeTitle *MessageChatChangeTitle) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Title string `json:"title"` // New chat title
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageChatChangeTitle.tdCommon = tempObj.tdCommon
	messageChatChangeTitle.Title = tempObj.Title

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageChatChangeTitle *MessageChatChangeTitle) GetMessageContentEnum() MessageContentEnum {
	return MessageChatChangeTitleType
}

// MessageChatChangePhoto An updated chat photo
type MessageChatChangePhoto struct {
	tdCommon
	Photo *ChatPhoto `json:"photo"` // New chat photo
}

// MessageType return the string telegram-type of MessageChatChangePhoto
func (messageChatChangePhoto *MessageChatChangePhoto) MessageType() string {
	return "messageChatChangePhoto"
}

// NewMessageChatChangePhoto creates a new MessageChatChangePhoto
//
// @param photo New chat photo
func NewMessageChatChangePhoto(photo *ChatPhoto) *MessageChatChangePhoto {
	messageChatChangePhotoTemp := MessageChatChangePhoto{
		tdCommon: tdCommon{Type: "messageChatChangePhoto"},
		Photo:    photo,
	}

	return &messageChatChangePhotoTemp
}

// UnmarshalJSON unmarshal to json
func (messageChatChangePhoto *MessageChatChangePhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Photo *ChatPhoto `json:"photo"` // New chat photo
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageChatChangePhoto.tdCommon = tempObj.tdCommon
	messageChatChangePhoto.Photo = tempObj.Photo

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageChatChangePhoto *MessageChatChangePhoto) GetMessageContentEnum() MessageContentEnum {
	return MessageChatChangePhotoType
}

// MessageChatDeletePhoto A deleted chat photo
type MessageChatDeletePhoto struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageChatDeletePhoto
func (messageChatDeletePhoto *MessageChatDeletePhoto) MessageType() string {
	return "messageChatDeletePhoto"
}

// NewMessageChatDeletePhoto creates a new MessageChatDeletePhoto
//
func NewMessageChatDeletePhoto() *MessageChatDeletePhoto {
	messageChatDeletePhotoTemp := MessageChatDeletePhoto{
		tdCommon: tdCommon{Type: "messageChatDeletePhoto"},
	}

	return &messageChatDeletePhotoTemp
}

// UnmarshalJSON unmarshal to json
func (messageChatDeletePhoto *MessageChatDeletePhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageChatDeletePhoto.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageChatDeletePhoto *MessageChatDeletePhoto) GetMessageContentEnum() MessageContentEnum {
	return MessageChatDeletePhotoType
}

// MessageChatAddMembers New chat members were added
type MessageChatAddMembers struct {
	tdCommon
	MemberUserIDs []int64 `json:"member_user_ids"` // User identifiers of the new members
}

// MessageType return the string telegram-type of MessageChatAddMembers
func (messageChatAddMembers *MessageChatAddMembers) MessageType() string {
	return "messageChatAddMembers"
}

// NewMessageChatAddMembers creates a new MessageChatAddMembers
//
// @param memberUserIDs User identifiers of the new members
func NewMessageChatAddMembers(memberUserIDs []int64) *MessageChatAddMembers {
	messageChatAddMembersTemp := MessageChatAddMembers{
		tdCommon:      tdCommon{Type: "messageChatAddMembers"},
		MemberUserIDs: memberUserIDs,
	}

	return &messageChatAddMembersTemp
}

// UnmarshalJSON unmarshal to json
func (messageChatAddMembers *MessageChatAddMembers) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MemberUserIDs []int64 `json:"member_user_ids"` // User identifiers of the new members
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageChatAddMembers.tdCommon = tempObj.tdCommon
	messageChatAddMembers.MemberUserIDs = tempObj.MemberUserIDs

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageChatAddMembers *MessageChatAddMembers) GetMessageContentEnum() MessageContentEnum {
	return MessageChatAddMembersType
}

// MessageChatJoinByLink A new member joined the chat via an invite link
type MessageChatJoinByLink struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageChatJoinByLink
func (messageChatJoinByLink *MessageChatJoinByLink) MessageType() string {
	return "messageChatJoinByLink"
}

// NewMessageChatJoinByLink creates a new MessageChatJoinByLink
//
func NewMessageChatJoinByLink() *MessageChatJoinByLink {
	messageChatJoinByLinkTemp := MessageChatJoinByLink{
		tdCommon: tdCommon{Type: "messageChatJoinByLink"},
	}

	return &messageChatJoinByLinkTemp
}

// UnmarshalJSON unmarshal to json
func (messageChatJoinByLink *MessageChatJoinByLink) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageChatJoinByLink.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageChatJoinByLink *MessageChatJoinByLink) GetMessageContentEnum() MessageContentEnum {
	return MessageChatJoinByLinkType
}

// MessageChatJoinByRequest A new member was accepted to the chat by an administrator
type MessageChatJoinByRequest struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageChatJoinByRequest
func (messageChatJoinByRequest *MessageChatJoinByRequest) MessageType() string {
	return "messageChatJoinByRequest"
}

// NewMessageChatJoinByRequest creates a new MessageChatJoinByRequest
//
func NewMessageChatJoinByRequest() *MessageChatJoinByRequest {
	messageChatJoinByRequestTemp := MessageChatJoinByRequest{
		tdCommon: tdCommon{Type: "messageChatJoinByRequest"},
	}

	return &messageChatJoinByRequestTemp
}

// UnmarshalJSON unmarshal to json
func (messageChatJoinByRequest *MessageChatJoinByRequest) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageChatJoinByRequest.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageChatJoinByRequest *MessageChatJoinByRequest) GetMessageContentEnum() MessageContentEnum {
	return MessageChatJoinByRequestType
}

// MessageChatDeleteMember A chat member was deleted
type MessageChatDeleteMember struct {
	tdCommon
	UserID int64 `json:"user_id"` // User identifier of the deleted chat member
}

// MessageType return the string telegram-type of MessageChatDeleteMember
func (messageChatDeleteMember *MessageChatDeleteMember) MessageType() string {
	return "messageChatDeleteMember"
}

// NewMessageChatDeleteMember creates a new MessageChatDeleteMember
//
// @param userID User identifier of the deleted chat member
func NewMessageChatDeleteMember(userID int64) *MessageChatDeleteMember {
	messageChatDeleteMemberTemp := MessageChatDeleteMember{
		tdCommon: tdCommon{Type: "messageChatDeleteMember"},
		UserID:   userID,
	}

	return &messageChatDeleteMemberTemp
}

// UnmarshalJSON unmarshal to json
func (messageChatDeleteMember *MessageChatDeleteMember) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID int64 `json:"user_id"` // User identifier of the deleted chat member
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageChatDeleteMember.tdCommon = tempObj.tdCommon
	messageChatDeleteMember.UserID = tempObj.UserID

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageChatDeleteMember *MessageChatDeleteMember) GetMessageContentEnum() MessageContentEnum {
	return MessageChatDeleteMemberType
}

// MessageChatUpgradeTo A basic group was upgraded to a supergroup and was deactivated as the result
type MessageChatUpgradeTo struct {
	tdCommon
	SupergroupID int64 `json:"supergroup_id"` // Identifier of the supergroup to which the basic group was upgraded
}

// MessageType return the string telegram-type of MessageChatUpgradeTo
func (messageChatUpgradeTo *MessageChatUpgradeTo) MessageType() string {
	return "messageChatUpgradeTo"
}

// NewMessageChatUpgradeTo creates a new MessageChatUpgradeTo
//
// @param supergroupID Identifier of the supergroup to which the basic group was upgraded
func NewMessageChatUpgradeTo(supergroupID int64) *MessageChatUpgradeTo {
	messageChatUpgradeToTemp := MessageChatUpgradeTo{
		tdCommon:     tdCommon{Type: "messageChatUpgradeTo"},
		SupergroupID: supergroupID,
	}

	return &messageChatUpgradeToTemp
}

// UnmarshalJSON unmarshal to json
func (messageChatUpgradeTo *MessageChatUpgradeTo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SupergroupID int64 `json:"supergroup_id"` // Identifier of the supergroup to which the basic group was upgraded
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageChatUpgradeTo.tdCommon = tempObj.tdCommon
	messageChatUpgradeTo.SupergroupID = tempObj.SupergroupID

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageChatUpgradeTo *MessageChatUpgradeTo) GetMessageContentEnum() MessageContentEnum {
	return MessageChatUpgradeToType
}

// MessageChatUpgradeFrom A supergroup has been created from a basic group
type MessageChatUpgradeFrom struct {
	tdCommon
	Title        string `json:"title"`          // Title of the newly created supergroup
	BasicGroupID int64  `json:"basic_group_id"` // The identifier of the original basic group
}

// MessageType return the string telegram-type of MessageChatUpgradeFrom
func (messageChatUpgradeFrom *MessageChatUpgradeFrom) MessageType() string {
	return "messageChatUpgradeFrom"
}

// NewMessageChatUpgradeFrom creates a new MessageChatUpgradeFrom
//
// @param title Title of the newly created supergroup
// @param basicGroupID The identifier of the original basic group
func NewMessageChatUpgradeFrom(title string, basicGroupID int64) *MessageChatUpgradeFrom {
	messageChatUpgradeFromTemp := MessageChatUpgradeFrom{
		tdCommon:     tdCommon{Type: "messageChatUpgradeFrom"},
		Title:        title,
		BasicGroupID: basicGroupID,
	}

	return &messageChatUpgradeFromTemp
}

// UnmarshalJSON unmarshal to json
func (messageChatUpgradeFrom *MessageChatUpgradeFrom) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Title        string `json:"title"`          // Title of the newly created supergroup
		BasicGroupID int64  `json:"basic_group_id"` // The identifier of the original basic group
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageChatUpgradeFrom.tdCommon = tempObj.tdCommon
	messageChatUpgradeFrom.Title = tempObj.Title
	messageChatUpgradeFrom.BasicGroupID = tempObj.BasicGroupID

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageChatUpgradeFrom *MessageChatUpgradeFrom) GetMessageContentEnum() MessageContentEnum {
	return MessageChatUpgradeFromType
}

// MessagePinMessage A message has been pinned
type MessagePinMessage struct {
	tdCommon
	MessageID int64 `json:"message_id"` // Identifier of the pinned message, can be an identifier of a deleted message or 0
}

// MessageType return the string telegram-type of MessagePinMessage
func (messagePinMessage *MessagePinMessage) MessageType() string {
	return "messagePinMessage"
}

// NewMessagePinMessage creates a new MessagePinMessage
//
// @param messageID Identifier of the pinned message, can be an identifier of a deleted message or 0
func NewMessagePinMessage(messageID int64) *MessagePinMessage {
	messagePinMessageTemp := MessagePinMessage{
		tdCommon:  tdCommon{Type: "messagePinMessage"},
		MessageID: messageID,
	}

	return &messagePinMessageTemp
}

// UnmarshalJSON unmarshal to json
func (messagePinMessage *MessagePinMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MessageID int64 `json:"message_id"` // Identifier of the pinned message, can be an identifier of a deleted message or 0
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messagePinMessage.tdCommon = tempObj.tdCommon
	messagePinMessage.MessageID = tempObj.MessageID

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messagePinMessage *MessagePinMessage) GetMessageContentEnum() MessageContentEnum {
	return MessagePinMessageType
}

// MessageScreenshotTaken A screenshot of a message in the chat has been taken
type MessageScreenshotTaken struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageScreenshotTaken
func (messageScreenshotTaken *MessageScreenshotTaken) MessageType() string {
	return "messageScreenshotTaken"
}

// NewMessageScreenshotTaken creates a new MessageScreenshotTaken
//
func NewMessageScreenshotTaken() *MessageScreenshotTaken {
	messageScreenshotTakenTemp := MessageScreenshotTaken{
		tdCommon: tdCommon{Type: "messageScreenshotTaken"},
	}

	return &messageScreenshotTakenTemp
}

// UnmarshalJSON unmarshal to json
func (messageScreenshotTaken *MessageScreenshotTaken) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageScreenshotTaken.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageScreenshotTaken *MessageScreenshotTaken) GetMessageContentEnum() MessageContentEnum {
	return MessageScreenshotTakenType
}

// MessageChatSetBackground A new background was set in the chat
type MessageChatSetBackground struct {
	tdCommon
	OldBackgroundMessageID int64           `json:"old_background_message_id"` // Identifier of the message with a previously set same background; 0 if none. Can be an identifier of a deleted message
	Background             *ChatBackground `json:"background"`                // The new background
	OnlyForSelf            bool            `json:"only_for_self"`             // True, if the background was set only for self
}

// MessageType return the string telegram-type of MessageChatSetBackground
func (messageChatSetBackground *MessageChatSetBackground) MessageType() string {
	return "messageChatSetBackground"
}

// NewMessageChatSetBackground creates a new MessageChatSetBackground
//
// @param oldBackgroundMessageID Identifier of the message with a previously set same background; 0 if none. Can be an identifier of a deleted message
// @param background The new background
// @param onlyForSelf True, if the background was set only for self
func NewMessageChatSetBackground(oldBackgroundMessageID int64, background *ChatBackground, onlyForSelf bool) *MessageChatSetBackground {
	messageChatSetBackgroundTemp := MessageChatSetBackground{
		tdCommon:               tdCommon{Type: "messageChatSetBackground"},
		OldBackgroundMessageID: oldBackgroundMessageID,
		Background:             background,
		OnlyForSelf:            onlyForSelf,
	}

	return &messageChatSetBackgroundTemp
}

// UnmarshalJSON unmarshal to json
func (messageChatSetBackground *MessageChatSetBackground) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OldBackgroundMessageID int64           `json:"old_background_message_id"` // Identifier of the message with a previously set same background; 0 if none. Can be an identifier of a deleted message
		Background             *ChatBackground `json:"background"`                // The new background
		OnlyForSelf            bool            `json:"only_for_self"`             // True, if the background was set only for self
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageChatSetBackground.tdCommon = tempObj.tdCommon
	messageChatSetBackground.OldBackgroundMessageID = tempObj.OldBackgroundMessageID
	messageChatSetBackground.Background = tempObj.Background
	messageChatSetBackground.OnlyForSelf = tempObj.OnlyForSelf

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageChatSetBackground *MessageChatSetBackground) GetMessageContentEnum() MessageContentEnum {
	return MessageChatSetBackgroundType
}

// MessageChatSetTheme A theme in the chat has been changed
type MessageChatSetTheme struct {
	tdCommon
	ThemeName string `json:"theme_name"` // If non-empty, name of a new theme, set for the chat. Otherwise, chat theme was reset to the default one
}

// MessageType return the string telegram-type of MessageChatSetTheme
func (messageChatSetTheme *MessageChatSetTheme) MessageType() string {
	return "messageChatSetTheme"
}

// NewMessageChatSetTheme creates a new MessageChatSetTheme
//
// @param themeName If non-empty, name of a new theme, set for the chat. Otherwise, chat theme was reset to the default one
func NewMessageChatSetTheme(themeName string) *MessageChatSetTheme {
	messageChatSetThemeTemp := MessageChatSetTheme{
		tdCommon:  tdCommon{Type: "messageChatSetTheme"},
		ThemeName: themeName,
	}

	return &messageChatSetThemeTemp
}

// UnmarshalJSON unmarshal to json
func (messageChatSetTheme *MessageChatSetTheme) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ThemeName string `json:"theme_name"` // If non-empty, name of a new theme, set for the chat. Otherwise, chat theme was reset to the default one
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageChatSetTheme.tdCommon = tempObj.tdCommon
	messageChatSetTheme.ThemeName = tempObj.ThemeName

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageChatSetTheme *MessageChatSetTheme) GetMessageContentEnum() MessageContentEnum {
	return MessageChatSetThemeType
}

// MessageChatSetMessageAutoDeleteTime The auto-delete or self-destruct timer for messages in the chat has been changed
type MessageChatSetMessageAutoDeleteTime struct {
	tdCommon
	MessageAutoDeleteTime int32 `json:"message_auto_delete_time"` // New value auto-delete or self-destruct time, in seconds; 0 if disabled
	FromUserID            int64 `json:"from_user_id"`             // If not 0, a user identifier, which default setting was automatically applied
}

// MessageType return the string telegram-type of MessageChatSetMessageAutoDeleteTime
func (messageChatSetMessageAutoDeleteTime *MessageChatSetMessageAutoDeleteTime) MessageType() string {
	return "messageChatSetMessageAutoDeleteTime"
}

// NewMessageChatSetMessageAutoDeleteTime creates a new MessageChatSetMessageAutoDeleteTime
//
// @param messageAutoDeleteTime New value auto-delete or self-destruct time, in seconds; 0 if disabled
// @param fromUserID If not 0, a user identifier, which default setting was automatically applied
func NewMessageChatSetMessageAutoDeleteTime(messageAutoDeleteTime int32, fromUserID int64) *MessageChatSetMessageAutoDeleteTime {
	messageChatSetMessageAutoDeleteTimeTemp := MessageChatSetMessageAutoDeleteTime{
		tdCommon:              tdCommon{Type: "messageChatSetMessageAutoDeleteTime"},
		MessageAutoDeleteTime: messageAutoDeleteTime,
		FromUserID:            fromUserID,
	}

	return &messageChatSetMessageAutoDeleteTimeTemp
}

// UnmarshalJSON unmarshal to json
func (messageChatSetMessageAutoDeleteTime *MessageChatSetMessageAutoDeleteTime) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MessageAutoDeleteTime int32 `json:"message_auto_delete_time"` // New value auto-delete or self-destruct time, in seconds; 0 if disabled
		FromUserID            int64 `json:"from_user_id"`             // If not 0, a user identifier, which default setting was automatically applied
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageChatSetMessageAutoDeleteTime.tdCommon = tempObj.tdCommon
	messageChatSetMessageAutoDeleteTime.MessageAutoDeleteTime = tempObj.MessageAutoDeleteTime
	messageChatSetMessageAutoDeleteTime.FromUserID = tempObj.FromUserID

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageChatSetMessageAutoDeleteTime *MessageChatSetMessageAutoDeleteTime) GetMessageContentEnum() MessageContentEnum {
	return MessageChatSetMessageAutoDeleteTimeType
}

// MessageChatBoost The chat was boosted by the sender of the message
type MessageChatBoost struct {
	tdCommon
	BoostCount int32 `json:"boost_count"` // Number of times the chat was boosted
}

// MessageType return the string telegram-type of MessageChatBoost
func (messageChatBoost *MessageChatBoost) MessageType() string {
	return "messageChatBoost"
}

// NewMessageChatBoost creates a new MessageChatBoost
//
// @param boostCount Number of times the chat was boosted
func NewMessageChatBoost(boostCount int32) *MessageChatBoost {
	messageChatBoostTemp := MessageChatBoost{
		tdCommon:   tdCommon{Type: "messageChatBoost"},
		BoostCount: boostCount,
	}

	return &messageChatBoostTemp
}

// UnmarshalJSON unmarshal to json
func (messageChatBoost *MessageChatBoost) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BoostCount int32 `json:"boost_count"` // Number of times the chat was boosted
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageChatBoost.tdCommon = tempObj.tdCommon
	messageChatBoost.BoostCount = tempObj.BoostCount

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageChatBoost *MessageChatBoost) GetMessageContentEnum() MessageContentEnum {
	return MessageChatBoostType
}

// MessageForumTopicCreated A forum topic has been created
type MessageForumTopicCreated struct {
	tdCommon
	Name string          `json:"name"` // Name of the topic
	Icon *ForumTopicIcon `json:"icon"` // Icon of the topic
}

// MessageType return the string telegram-type of MessageForumTopicCreated
func (messageForumTopicCreated *MessageForumTopicCreated) MessageType() string {
	return "messageForumTopicCreated"
}

// NewMessageForumTopicCreated creates a new MessageForumTopicCreated
//
// @param name Name of the topic
// @param icon Icon of the topic
func NewMessageForumTopicCreated(name string, icon *ForumTopicIcon) *MessageForumTopicCreated {
	messageForumTopicCreatedTemp := MessageForumTopicCreated{
		tdCommon: tdCommon{Type: "messageForumTopicCreated"},
		Name:     name,
		Icon:     icon,
	}

	return &messageForumTopicCreatedTemp
}

// UnmarshalJSON unmarshal to json
func (messageForumTopicCreated *MessageForumTopicCreated) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Name string          `json:"name"` // Name of the topic
		Icon *ForumTopicIcon `json:"icon"` // Icon of the topic
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageForumTopicCreated.tdCommon = tempObj.tdCommon
	messageForumTopicCreated.Name = tempObj.Name
	messageForumTopicCreated.Icon = tempObj.Icon

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageForumTopicCreated *MessageForumTopicCreated) GetMessageContentEnum() MessageContentEnum {
	return MessageForumTopicCreatedType
}

// MessageForumTopicEdited A forum topic has been edited
type MessageForumTopicEdited struct {
	tdCommon
	Name                  string    `json:"name"`                      // If non-empty, the new name of the topic
	EditIconCustomEmojiID bool      `json:"edit_icon_custom_emoji_id"` // True, if icon's custom_emoji_id is changed
	IconCustomEmojiID     JSONInt64 `json:"icon_custom_emoji_id"`      // New unique identifier of the custom emoji shown on the topic icon; 0 if none. Must be ignored if edit_icon_custom_emoji_id is false
}

// MessageType return the string telegram-type of MessageForumTopicEdited
func (messageForumTopicEdited *MessageForumTopicEdited) MessageType() string {
	return "messageForumTopicEdited"
}

// NewMessageForumTopicEdited creates a new MessageForumTopicEdited
//
// @param name If non-empty, the new name of the topic
// @param editIconCustomEmojiID True, if icon's custom_emoji_id is changed
// @param iconCustomEmojiID New unique identifier of the custom emoji shown on the topic icon; 0 if none. Must be ignored if edit_icon_custom_emoji_id is false
func NewMessageForumTopicEdited(name string, editIconCustomEmojiID bool, iconCustomEmojiID JSONInt64) *MessageForumTopicEdited {
	messageForumTopicEditedTemp := MessageForumTopicEdited{
		tdCommon:              tdCommon{Type: "messageForumTopicEdited"},
		Name:                  name,
		EditIconCustomEmojiID: editIconCustomEmojiID,
		IconCustomEmojiID:     iconCustomEmojiID,
	}

	return &messageForumTopicEditedTemp
}

// UnmarshalJSON unmarshal to json
func (messageForumTopicEdited *MessageForumTopicEdited) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Name                  string    `json:"name"`                      // If non-empty, the new name of the topic
		EditIconCustomEmojiID bool      `json:"edit_icon_custom_emoji_id"` // True, if icon's custom_emoji_id is changed
		IconCustomEmojiID     JSONInt64 `json:"icon_custom_emoji_id"`      // New unique identifier of the custom emoji shown on the topic icon; 0 if none. Must be ignored if edit_icon_custom_emoji_id is false
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageForumTopicEdited.tdCommon = tempObj.tdCommon
	messageForumTopicEdited.Name = tempObj.Name
	messageForumTopicEdited.EditIconCustomEmojiID = tempObj.EditIconCustomEmojiID
	messageForumTopicEdited.IconCustomEmojiID = tempObj.IconCustomEmojiID

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageForumTopicEdited *MessageForumTopicEdited) GetMessageContentEnum() MessageContentEnum {
	return MessageForumTopicEditedType
}

// MessageForumTopicIsClosedToggled A forum topic has been closed or opened
type MessageForumTopicIsClosedToggled struct {
	tdCommon
	IsClosed bool `json:"is_closed"` // True, if the topic was closed; otherwise, the topic was reopened
}

// MessageType return the string telegram-type of MessageForumTopicIsClosedToggled
func (messageForumTopicIsClosedToggled *MessageForumTopicIsClosedToggled) MessageType() string {
	return "messageForumTopicIsClosedToggled"
}

// NewMessageForumTopicIsClosedToggled creates a new MessageForumTopicIsClosedToggled
//
// @param isClosed True, if the topic was closed; otherwise, the topic was reopened
func NewMessageForumTopicIsClosedToggled(isClosed bool) *MessageForumTopicIsClosedToggled {
	messageForumTopicIsClosedToggledTemp := MessageForumTopicIsClosedToggled{
		tdCommon: tdCommon{Type: "messageForumTopicIsClosedToggled"},
		IsClosed: isClosed,
	}

	return &messageForumTopicIsClosedToggledTemp
}

// UnmarshalJSON unmarshal to json
func (messageForumTopicIsClosedToggled *MessageForumTopicIsClosedToggled) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsClosed bool `json:"is_closed"` // True, if the topic was closed; otherwise, the topic was reopened
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageForumTopicIsClosedToggled.tdCommon = tempObj.tdCommon
	messageForumTopicIsClosedToggled.IsClosed = tempObj.IsClosed

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageForumTopicIsClosedToggled *MessageForumTopicIsClosedToggled) GetMessageContentEnum() MessageContentEnum {
	return MessageForumTopicIsClosedToggledType
}

// MessageForumTopicIsHiddenToggled A General forum topic has been hidden or unhidden
type MessageForumTopicIsHiddenToggled struct {
	tdCommon
	IsHidden bool `json:"is_hidden"` // True, if the topic was hidden; otherwise, the topic was unhidden
}

// MessageType return the string telegram-type of MessageForumTopicIsHiddenToggled
func (messageForumTopicIsHiddenToggled *MessageForumTopicIsHiddenToggled) MessageType() string {
	return "messageForumTopicIsHiddenToggled"
}

// NewMessageForumTopicIsHiddenToggled creates a new MessageForumTopicIsHiddenToggled
//
// @param isHidden True, if the topic was hidden; otherwise, the topic was unhidden
func NewMessageForumTopicIsHiddenToggled(isHidden bool) *MessageForumTopicIsHiddenToggled {
	messageForumTopicIsHiddenToggledTemp := MessageForumTopicIsHiddenToggled{
		tdCommon: tdCommon{Type: "messageForumTopicIsHiddenToggled"},
		IsHidden: isHidden,
	}

	return &messageForumTopicIsHiddenToggledTemp
}

// UnmarshalJSON unmarshal to json
func (messageForumTopicIsHiddenToggled *MessageForumTopicIsHiddenToggled) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsHidden bool `json:"is_hidden"` // True, if the topic was hidden; otherwise, the topic was unhidden
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageForumTopicIsHiddenToggled.tdCommon = tempObj.tdCommon
	messageForumTopicIsHiddenToggled.IsHidden = tempObj.IsHidden

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageForumTopicIsHiddenToggled *MessageForumTopicIsHiddenToggled) GetMessageContentEnum() MessageContentEnum {
	return MessageForumTopicIsHiddenToggledType
}

// MessageSuggestProfilePhoto A profile photo was suggested to a user in a private chat
type MessageSuggestProfilePhoto struct {
	tdCommon
	Photo *ChatPhoto `json:"photo"` // The suggested chat photo. Use the method setProfilePhoto with inputChatPhotoPrevious to apply the photo
}

// MessageType return the string telegram-type of MessageSuggestProfilePhoto
func (messageSuggestProfilePhoto *MessageSuggestProfilePhoto) MessageType() string {
	return "messageSuggestProfilePhoto"
}

// NewMessageSuggestProfilePhoto creates a new MessageSuggestProfilePhoto
//
// @param photo The suggested chat photo. Use the method setProfilePhoto with inputChatPhotoPrevious to apply the photo
func NewMessageSuggestProfilePhoto(photo *ChatPhoto) *MessageSuggestProfilePhoto {
	messageSuggestProfilePhotoTemp := MessageSuggestProfilePhoto{
		tdCommon: tdCommon{Type: "messageSuggestProfilePhoto"},
		Photo:    photo,
	}

	return &messageSuggestProfilePhotoTemp
}

// UnmarshalJSON unmarshal to json
func (messageSuggestProfilePhoto *MessageSuggestProfilePhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Photo *ChatPhoto `json:"photo"` // The suggested chat photo. Use the method setProfilePhoto with inputChatPhotoPrevious to apply the photo
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSuggestProfilePhoto.tdCommon = tempObj.tdCommon
	messageSuggestProfilePhoto.Photo = tempObj.Photo

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageSuggestProfilePhoto *MessageSuggestProfilePhoto) GetMessageContentEnum() MessageContentEnum {
	return MessageSuggestProfilePhotoType
}

// MessageCustomServiceAction A non-standard action has happened in the chat
type MessageCustomServiceAction struct {
	tdCommon
	Text string `json:"text"` // Message text to be shown in the chat
}

// MessageType return the string telegram-type of MessageCustomServiceAction
func (messageCustomServiceAction *MessageCustomServiceAction) MessageType() string {
	return "messageCustomServiceAction"
}

// NewMessageCustomServiceAction creates a new MessageCustomServiceAction
//
// @param text Message text to be shown in the chat
func NewMessageCustomServiceAction(text string) *MessageCustomServiceAction {
	messageCustomServiceActionTemp := MessageCustomServiceAction{
		tdCommon: tdCommon{Type: "messageCustomServiceAction"},
		Text:     text,
	}

	return &messageCustomServiceActionTemp
}

// UnmarshalJSON unmarshal to json
func (messageCustomServiceAction *MessageCustomServiceAction) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Text string `json:"text"` // Message text to be shown in the chat
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageCustomServiceAction.tdCommon = tempObj.tdCommon
	messageCustomServiceAction.Text = tempObj.Text

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageCustomServiceAction *MessageCustomServiceAction) GetMessageContentEnum() MessageContentEnum {
	return MessageCustomServiceActionType
}

// MessageGameScore A new high score was achieved in a game
type MessageGameScore struct {
	tdCommon
	GameMessageID int64     `json:"game_message_id"` // Identifier of the message with the game, can be an identifier of a deleted message
	GameID        JSONInt64 `json:"game_id"`         // Identifier of the game; may be different from the games presented in the message with the game
	Score         int32     `json:"score"`           // New score
}

// MessageType return the string telegram-type of MessageGameScore
func (messageGameScore *MessageGameScore) MessageType() string {
	return "messageGameScore"
}

// NewMessageGameScore creates a new MessageGameScore
//
// @param gameMessageID Identifier of the message with the game, can be an identifier of a deleted message
// @param gameID Identifier of the game; may be different from the games presented in the message with the game
// @param score New score
func NewMessageGameScore(gameMessageID int64, gameID JSONInt64, score int32) *MessageGameScore {
	messageGameScoreTemp := MessageGameScore{
		tdCommon:      tdCommon{Type: "messageGameScore"},
		GameMessageID: gameMessageID,
		GameID:        gameID,
		Score:         score,
	}

	return &messageGameScoreTemp
}

// UnmarshalJSON unmarshal to json
func (messageGameScore *MessageGameScore) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		GameMessageID int64     `json:"game_message_id"` // Identifier of the message with the game, can be an identifier of a deleted message
		GameID        JSONInt64 `json:"game_id"`         // Identifier of the game; may be different from the games presented in the message with the game
		Score         int32     `json:"score"`           // New score
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageGameScore.tdCommon = tempObj.tdCommon
	messageGameScore.GameMessageID = tempObj.GameMessageID
	messageGameScore.GameID = tempObj.GameID
	messageGameScore.Score = tempObj.Score

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageGameScore *MessageGameScore) GetMessageContentEnum() MessageContentEnum {
	return MessageGameScoreType
}

// MessagePaymentSuccessful A payment has been completed
type MessagePaymentSuccessful struct {
	tdCommon
	InvoiceChatID    int64  `json:"invoice_chat_id"`    // Identifier of the chat, containing the corresponding invoice message
	InvoiceMessageID int64  `json:"invoice_message_id"` // Identifier of the message with the corresponding invoice; can be 0 or an identifier of a deleted message
	Currency         string `json:"currency"`           // Currency for the price of the product
	TotalAmount      int64  `json:"total_amount"`       // Total price for the product, in the smallest units of the currency
	IsRecurring      bool   `json:"is_recurring"`       // True, if this is a recurring payment
	IsFirstRecurring bool   `json:"is_first_recurring"` // True, if this is the first recurring payment
	InvoiceName      string `json:"invoice_name"`       // Name of the invoice; may be empty if unknown
}

// MessageType return the string telegram-type of MessagePaymentSuccessful
func (messagePaymentSuccessful *MessagePaymentSuccessful) MessageType() string {
	return "messagePaymentSuccessful"
}

// NewMessagePaymentSuccessful creates a new MessagePaymentSuccessful
//
// @param invoiceChatID Identifier of the chat, containing the corresponding invoice message
// @param invoiceMessageID Identifier of the message with the corresponding invoice; can be 0 or an identifier of a deleted message
// @param currency Currency for the price of the product
// @param totalAmount Total price for the product, in the smallest units of the currency
// @param isRecurring True, if this is a recurring payment
// @param isFirstRecurring True, if this is the first recurring payment
// @param invoiceName Name of the invoice; may be empty if unknown
func NewMessagePaymentSuccessful(invoiceChatID int64, invoiceMessageID int64, currency string, totalAmount int64, isRecurring bool, isFirstRecurring bool, invoiceName string) *MessagePaymentSuccessful {
	messagePaymentSuccessfulTemp := MessagePaymentSuccessful{
		tdCommon:         tdCommon{Type: "messagePaymentSuccessful"},
		InvoiceChatID:    invoiceChatID,
		InvoiceMessageID: invoiceMessageID,
		Currency:         currency,
		TotalAmount:      totalAmount,
		IsRecurring:      isRecurring,
		IsFirstRecurring: isFirstRecurring,
		InvoiceName:      invoiceName,
	}

	return &messagePaymentSuccessfulTemp
}

// UnmarshalJSON unmarshal to json
func (messagePaymentSuccessful *MessagePaymentSuccessful) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		InvoiceChatID    int64  `json:"invoice_chat_id"`    // Identifier of the chat, containing the corresponding invoice message
		InvoiceMessageID int64  `json:"invoice_message_id"` // Identifier of the message with the corresponding invoice; can be 0 or an identifier of a deleted message
		Currency         string `json:"currency"`           // Currency for the price of the product
		TotalAmount      int64  `json:"total_amount"`       // Total price for the product, in the smallest units of the currency
		IsRecurring      bool   `json:"is_recurring"`       // True, if this is a recurring payment
		IsFirstRecurring bool   `json:"is_first_recurring"` // True, if this is the first recurring payment
		InvoiceName      string `json:"invoice_name"`       // Name of the invoice; may be empty if unknown
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messagePaymentSuccessful.tdCommon = tempObj.tdCommon
	messagePaymentSuccessful.InvoiceChatID = tempObj.InvoiceChatID
	messagePaymentSuccessful.InvoiceMessageID = tempObj.InvoiceMessageID
	messagePaymentSuccessful.Currency = tempObj.Currency
	messagePaymentSuccessful.TotalAmount = tempObj.TotalAmount
	messagePaymentSuccessful.IsRecurring = tempObj.IsRecurring
	messagePaymentSuccessful.IsFirstRecurring = tempObj.IsFirstRecurring
	messagePaymentSuccessful.InvoiceName = tempObj.InvoiceName

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messagePaymentSuccessful *MessagePaymentSuccessful) GetMessageContentEnum() MessageContentEnum {
	return MessagePaymentSuccessfulType
}

// MessagePaymentSuccessfulBot A payment has been completed; for bots only
type MessagePaymentSuccessfulBot struct {
	tdCommon
	Currency                string     `json:"currency"`                   // Currency for price of the product
	TotalAmount             int64      `json:"total_amount"`               // Total price for the product, in the smallest units of the currency
	IsRecurring             bool       `json:"is_recurring"`               // True, if this is a recurring payment
	IsFirstRecurring        bool       `json:"is_first_recurring"`         // True, if this is the first recurring payment
	InvoicePayload          []byte     `json:"invoice_payload"`            // Invoice payload
	ShippingOptionID        string     `json:"shipping_option_id"`         // Identifier of the shipping option chosen by the user; may be empty if not applicable
	OrderInfo               *OrderInfo `json:"order_info"`                 // Information about the order; may be null
	TelegramPaymentChargeID string     `json:"telegram_payment_charge_id"` // Telegram payment identifier
	ProviderPaymentChargeID string     `json:"provider_payment_charge_id"` // Provider payment identifier
}

// MessageType return the string telegram-type of MessagePaymentSuccessfulBot
func (messagePaymentSuccessfulBot *MessagePaymentSuccessfulBot) MessageType() string {
	return "messagePaymentSuccessfulBot"
}

// NewMessagePaymentSuccessfulBot creates a new MessagePaymentSuccessfulBot
//
// @param currency Currency for price of the product
// @param totalAmount Total price for the product, in the smallest units of the currency
// @param isRecurring True, if this is a recurring payment
// @param isFirstRecurring True, if this is the first recurring payment
// @param invoicePayload Invoice payload
// @param shippingOptionID Identifier of the shipping option chosen by the user; may be empty if not applicable
// @param orderInfo Information about the order; may be null
// @param telegramPaymentChargeID Telegram payment identifier
// @param providerPaymentChargeID Provider payment identifier
func NewMessagePaymentSuccessfulBot(currency string, totalAmount int64, isRecurring bool, isFirstRecurring bool, invoicePayload []byte, shippingOptionID string, orderInfo *OrderInfo, telegramPaymentChargeID string, providerPaymentChargeID string) *MessagePaymentSuccessfulBot {
	messagePaymentSuccessfulBotTemp := MessagePaymentSuccessfulBot{
		tdCommon:                tdCommon{Type: "messagePaymentSuccessfulBot"},
		Currency:                currency,
		TotalAmount:             totalAmount,
		IsRecurring:             isRecurring,
		IsFirstRecurring:        isFirstRecurring,
		InvoicePayload:          invoicePayload,
		ShippingOptionID:        shippingOptionID,
		OrderInfo:               orderInfo,
		TelegramPaymentChargeID: telegramPaymentChargeID,
		ProviderPaymentChargeID: providerPaymentChargeID,
	}

	return &messagePaymentSuccessfulBotTemp
}

// UnmarshalJSON unmarshal to json
func (messagePaymentSuccessfulBot *MessagePaymentSuccessfulBot) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Currency                string     `json:"currency"`                   // Currency for price of the product
		TotalAmount             int64      `json:"total_amount"`               // Total price for the product, in the smallest units of the currency
		IsRecurring             bool       `json:"is_recurring"`               // True, if this is a recurring payment
		IsFirstRecurring        bool       `json:"is_first_recurring"`         // True, if this is the first recurring payment
		InvoicePayload          []byte     `json:"invoice_payload"`            // Invoice payload
		ShippingOptionID        string     `json:"shipping_option_id"`         // Identifier of the shipping option chosen by the user; may be empty if not applicable
		OrderInfo               *OrderInfo `json:"order_info"`                 // Information about the order; may be null
		TelegramPaymentChargeID string     `json:"telegram_payment_charge_id"` // Telegram payment identifier
		ProviderPaymentChargeID string     `json:"provider_payment_charge_id"` // Provider payment identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messagePaymentSuccessfulBot.tdCommon = tempObj.tdCommon
	messagePaymentSuccessfulBot.Currency = tempObj.Currency
	messagePaymentSuccessfulBot.TotalAmount = tempObj.TotalAmount
	messagePaymentSuccessfulBot.IsRecurring = tempObj.IsRecurring
	messagePaymentSuccessfulBot.IsFirstRecurring = tempObj.IsFirstRecurring
	messagePaymentSuccessfulBot.InvoicePayload = tempObj.InvoicePayload
	messagePaymentSuccessfulBot.ShippingOptionID = tempObj.ShippingOptionID
	messagePaymentSuccessfulBot.OrderInfo = tempObj.OrderInfo
	messagePaymentSuccessfulBot.TelegramPaymentChargeID = tempObj.TelegramPaymentChargeID
	messagePaymentSuccessfulBot.ProviderPaymentChargeID = tempObj.ProviderPaymentChargeID

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messagePaymentSuccessfulBot *MessagePaymentSuccessfulBot) GetMessageContentEnum() MessageContentEnum {
	return MessagePaymentSuccessfulBotType
}

// MessagePaymentRefunded A payment has been refunded
type MessagePaymentRefunded struct {
	tdCommon
	OwnerID                 MessageSender `json:"owner_id"`                   // Identifier of the previous owner of the Telegram Stars that refunds them
	Currency                string        `json:"currency"`                   // Currency for the price of the product
	TotalAmount             int64         `json:"total_amount"`               // Total price for the product, in the smallest units of the currency
	InvoicePayload          []byte        `json:"invoice_payload"`            // Invoice payload; only for bots
	TelegramPaymentChargeID string        `json:"telegram_payment_charge_id"` // Telegram payment identifier
	ProviderPaymentChargeID string        `json:"provider_payment_charge_id"` // Provider payment identifier
}

// MessageType return the string telegram-type of MessagePaymentRefunded
func (messagePaymentRefunded *MessagePaymentRefunded) MessageType() string {
	return "messagePaymentRefunded"
}

// NewMessagePaymentRefunded creates a new MessagePaymentRefunded
//
// @param ownerID Identifier of the previous owner of the Telegram Stars that refunds them
// @param currency Currency for the price of the product
// @param totalAmount Total price for the product, in the smallest units of the currency
// @param invoicePayload Invoice payload; only for bots
// @param telegramPaymentChargeID Telegram payment identifier
// @param providerPaymentChargeID Provider payment identifier
func NewMessagePaymentRefunded(ownerID MessageSender, currency string, totalAmount int64, invoicePayload []byte, telegramPaymentChargeID string, providerPaymentChargeID string) *MessagePaymentRefunded {
	messagePaymentRefundedTemp := MessagePaymentRefunded{
		tdCommon:                tdCommon{Type: "messagePaymentRefunded"},
		OwnerID:                 ownerID,
		Currency:                currency,
		TotalAmount:             totalAmount,
		InvoicePayload:          invoicePayload,
		TelegramPaymentChargeID: telegramPaymentChargeID,
		ProviderPaymentChargeID: providerPaymentChargeID,
	}

	return &messagePaymentRefundedTemp
}

// UnmarshalJSON unmarshal to json
func (messagePaymentRefunded *MessagePaymentRefunded) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Currency                string `json:"currency"`                   // Currency for the price of the product
		TotalAmount             int64  `json:"total_amount"`               // Total price for the product, in the smallest units of the currency
		InvoicePayload          []byte `json:"invoice_payload"`            // Invoice payload; only for bots
		TelegramPaymentChargeID string `json:"telegram_payment_charge_id"` // Telegram payment identifier
		ProviderPaymentChargeID string `json:"provider_payment_charge_id"` // Provider payment identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messagePaymentRefunded.tdCommon = tempObj.tdCommon
	messagePaymentRefunded.Currency = tempObj.Currency
	messagePaymentRefunded.TotalAmount = tempObj.TotalAmount
	messagePaymentRefunded.InvoicePayload = tempObj.InvoicePayload
	messagePaymentRefunded.TelegramPaymentChargeID = tempObj.TelegramPaymentChargeID
	messagePaymentRefunded.ProviderPaymentChargeID = tempObj.ProviderPaymentChargeID

	fieldOwnerID, _ := unmarshalMessageSender(objMap["owner_id"])
	messagePaymentRefunded.OwnerID = fieldOwnerID

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messagePaymentRefunded *MessagePaymentRefunded) GetMessageContentEnum() MessageContentEnum {
	return MessagePaymentRefundedType
}

// MessageGiftedPremium Telegram Premium was gifted to a user
type MessageGiftedPremium struct {
	tdCommon
	GifterUserID         int64     `json:"gifter_user_id"`        // The identifier of a user that gifted Telegram Premium; 0 if the gift was anonymous or is outgoing
	ReceiverUserID       int64     `json:"receiver_user_id"`      // The identifier of a user that received Telegram Premium; 0 if the gift is incoming
	Currency             string    `json:"currency"`              // Currency for the paid amount
	Amount               int64     `json:"amount"`                // The paid amount, in the smallest units of the currency
	Cryptocurrency       string    `json:"cryptocurrency"`        // Cryptocurrency used to pay for the gift; may be empty if none
	CryptocurrencyAmount JSONInt64 `json:"cryptocurrency_amount"` // The paid amount, in the smallest units of the cryptocurrency; 0 if none
	MonthCount           int32     `json:"month_count"`           // Number of months the Telegram Premium subscription will be active
	Sticker              *Sticker  `json:"sticker"`               // A sticker to be shown in the message; may be null if unknown
}

// MessageType return the string telegram-type of MessageGiftedPremium
func (messageGiftedPremium *MessageGiftedPremium) MessageType() string {
	return "messageGiftedPremium"
}

// NewMessageGiftedPremium creates a new MessageGiftedPremium
//
// @param gifterUserID The identifier of a user that gifted Telegram Premium; 0 if the gift was anonymous or is outgoing
// @param receiverUserID The identifier of a user that received Telegram Premium; 0 if the gift is incoming
// @param currency Currency for the paid amount
// @param amount The paid amount, in the smallest units of the currency
// @param cryptocurrency Cryptocurrency used to pay for the gift; may be empty if none
// @param cryptocurrencyAmount The paid amount, in the smallest units of the cryptocurrency; 0 if none
// @param monthCount Number of months the Telegram Premium subscription will be active
// @param sticker A sticker to be shown in the message; may be null if unknown
func NewMessageGiftedPremium(gifterUserID int64, receiverUserID int64, currency string, amount int64, cryptocurrency string, cryptocurrencyAmount JSONInt64, monthCount int32, sticker *Sticker) *MessageGiftedPremium {
	messageGiftedPremiumTemp := MessageGiftedPremium{
		tdCommon:             tdCommon{Type: "messageGiftedPremium"},
		GifterUserID:         gifterUserID,
		ReceiverUserID:       receiverUserID,
		Currency:             currency,
		Amount:               amount,
		Cryptocurrency:       cryptocurrency,
		CryptocurrencyAmount: cryptocurrencyAmount,
		MonthCount:           monthCount,
		Sticker:              sticker,
	}

	return &messageGiftedPremiumTemp
}

// UnmarshalJSON unmarshal to json
func (messageGiftedPremium *MessageGiftedPremium) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		GifterUserID         int64     `json:"gifter_user_id"`        // The identifier of a user that gifted Telegram Premium; 0 if the gift was anonymous or is outgoing
		ReceiverUserID       int64     `json:"receiver_user_id"`      // The identifier of a user that received Telegram Premium; 0 if the gift is incoming
		Currency             string    `json:"currency"`              // Currency for the paid amount
		Amount               int64     `json:"amount"`                // The paid amount, in the smallest units of the currency
		Cryptocurrency       string    `json:"cryptocurrency"`        // Cryptocurrency used to pay for the gift; may be empty if none
		CryptocurrencyAmount JSONInt64 `json:"cryptocurrency_amount"` // The paid amount, in the smallest units of the cryptocurrency; 0 if none
		MonthCount           int32     `json:"month_count"`           // Number of months the Telegram Premium subscription will be active

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageGiftedPremium.tdCommon = tempObj.tdCommon
	messageGiftedPremium.GifterUserID = tempObj.GifterUserID
	messageGiftedPremium.ReceiverUserID = tempObj.ReceiverUserID
	messageGiftedPremium.Currency = tempObj.Currency
	messageGiftedPremium.Amount = tempObj.Amount
	messageGiftedPremium.Cryptocurrency = tempObj.Cryptocurrency
	messageGiftedPremium.CryptocurrencyAmount = tempObj.CryptocurrencyAmount
	messageGiftedPremium.MonthCount = tempObj.MonthCount

	var sticker Sticker
	if objMap["sticker"] != nil {
		err = sticker.UnmarshalJSON(*objMap["sticker"])
		if err != nil {
			return err
		}
	}

	messageGiftedPremium.Sticker = &sticker

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageGiftedPremium *MessageGiftedPremium) GetMessageContentEnum() MessageContentEnum {
	return MessageGiftedPremiumType
}

// MessagePremiumGiftCode A Telegram Premium gift code was created for the user
type MessagePremiumGiftCode struct {
	tdCommon
	CreatorID            *MessageSender `json:"creator_id"`            // Identifier of a chat or a user that created the gift code; may be null if unknown
	IsFromGiveaway       bool           `json:"is_from_giveaway"`      // True, if the gift code was created for a giveaway
	IsUnclaimed          bool           `json:"is_unclaimed"`          // True, if the winner for the corresponding Telegram Premium subscription wasn't chosen
	Currency             string         `json:"currency"`              // Currency for the paid amount; empty if unknown
	Amount               int64          `json:"amount"`                // The paid amount, in the smallest units of the currency; 0 if unknown
	Cryptocurrency       string         `json:"cryptocurrency"`        // Cryptocurrency used to pay for the gift; may be empty if none or unknown
	CryptocurrencyAmount JSONInt64      `json:"cryptocurrency_amount"` // The paid amount, in the smallest units of the cryptocurrency; 0 if unknown
	MonthCount           int32          `json:"month_count"`           // Number of months the Telegram Premium subscription will be active after code activation
	Sticker              *Sticker       `json:"sticker"`               // A sticker to be shown in the message; may be null if unknown
	Code                 string         `json:"code"`                  // The gift code
}

// MessageType return the string telegram-type of MessagePremiumGiftCode
func (messagePremiumGiftCode *MessagePremiumGiftCode) MessageType() string {
	return "messagePremiumGiftCode"
}

// NewMessagePremiumGiftCode creates a new MessagePremiumGiftCode
//
// @param creatorID Identifier of a chat or a user that created the gift code; may be null if unknown
// @param isFromGiveaway True, if the gift code was created for a giveaway
// @param isUnclaimed True, if the winner for the corresponding Telegram Premium subscription wasn't chosen
// @param currency Currency for the paid amount; empty if unknown
// @param amount The paid amount, in the smallest units of the currency; 0 if unknown
// @param cryptocurrency Cryptocurrency used to pay for the gift; may be empty if none or unknown
// @param cryptocurrencyAmount The paid amount, in the smallest units of the cryptocurrency; 0 if unknown
// @param monthCount Number of months the Telegram Premium subscription will be active after code activation
// @param sticker A sticker to be shown in the message; may be null if unknown
// @param code The gift code
func NewMessagePremiumGiftCode(creatorID *MessageSender, isFromGiveaway bool, isUnclaimed bool, currency string, amount int64, cryptocurrency string, cryptocurrencyAmount JSONInt64, monthCount int32, sticker *Sticker, code string) *MessagePremiumGiftCode {
	messagePremiumGiftCodeTemp := MessagePremiumGiftCode{
		tdCommon:             tdCommon{Type: "messagePremiumGiftCode"},
		CreatorID:            creatorID,
		IsFromGiveaway:       isFromGiveaway,
		IsUnclaimed:          isUnclaimed,
		Currency:             currency,
		Amount:               amount,
		Cryptocurrency:       cryptocurrency,
		CryptocurrencyAmount: cryptocurrencyAmount,
		MonthCount:           monthCount,
		Sticker:              sticker,
		Code:                 code,
	}

	return &messagePremiumGiftCodeTemp
}

// UnmarshalJSON unmarshal to json
func (messagePremiumGiftCode *MessagePremiumGiftCode) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsFromGiveaway       bool      `json:"is_from_giveaway"`      // True, if the gift code was created for a giveaway
		IsUnclaimed          bool      `json:"is_unclaimed"`          // True, if the winner for the corresponding Telegram Premium subscription wasn't chosen
		Currency             string    `json:"currency"`              // Currency for the paid amount; empty if unknown
		Amount               int64     `json:"amount"`                // The paid amount, in the smallest units of the currency; 0 if unknown
		Cryptocurrency       string    `json:"cryptocurrency"`        // Cryptocurrency used to pay for the gift; may be empty if none or unknown
		CryptocurrencyAmount JSONInt64 `json:"cryptocurrency_amount"` // The paid amount, in the smallest units of the cryptocurrency; 0 if unknown
		MonthCount           int32     `json:"month_count"`           // Number of months the Telegram Premium subscription will be active after code activation
		Code                 string    `json:"code"`                  // The gift code
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messagePremiumGiftCode.tdCommon = tempObj.tdCommon
	messagePremiumGiftCode.IsFromGiveaway = tempObj.IsFromGiveaway
	messagePremiumGiftCode.IsUnclaimed = tempObj.IsUnclaimed
	messagePremiumGiftCode.Currency = tempObj.Currency
	messagePremiumGiftCode.Amount = tempObj.Amount
	messagePremiumGiftCode.Cryptocurrency = tempObj.Cryptocurrency
	messagePremiumGiftCode.CryptocurrencyAmount = tempObj.CryptocurrencyAmount
	messagePremiumGiftCode.MonthCount = tempObj.MonthCount
	messagePremiumGiftCode.Code = tempObj.Code

	fieldCreatorID, _ := unmarshalMessageSender(objMap["creator_id"])
	messagePremiumGiftCode.CreatorID = &fieldCreatorID

	var sticker Sticker
	if objMap["sticker"] != nil {
		err = sticker.UnmarshalJSON(*objMap["sticker"])
		if err != nil {
			return err
		}
	}

	messagePremiumGiftCode.Sticker = &sticker

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messagePremiumGiftCode *MessagePremiumGiftCode) GetMessageContentEnum() MessageContentEnum {
	return MessagePremiumGiftCodeType
}

// MessageGiveawayCreated A giveaway was created for the chat. Use telegramPaymentPurposePremiumGiveaway, storePaymentPurposePremiumGiveaway, telegramPaymentPurposeStarGiveaway, or storePaymentPurposeStarGiveaway to create a giveaway
type MessageGiveawayCreated struct {
	tdCommon
	StarCount int64 `json:"star_count"` // Number of Telegram Stars that will be shared by winners of the giveaway; 0 for Telegram Premium giveaways
}

// MessageType return the string telegram-type of MessageGiveawayCreated
func (messageGiveawayCreated *MessageGiveawayCreated) MessageType() string {
	return "messageGiveawayCreated"
}

// NewMessageGiveawayCreated creates a new MessageGiveawayCreated
//
// @param starCount Number of Telegram Stars that will be shared by winners of the giveaway; 0 for Telegram Premium giveaways
func NewMessageGiveawayCreated(starCount int64) *MessageGiveawayCreated {
	messageGiveawayCreatedTemp := MessageGiveawayCreated{
		tdCommon:  tdCommon{Type: "messageGiveawayCreated"},
		StarCount: starCount,
	}

	return &messageGiveawayCreatedTemp
}

// UnmarshalJSON unmarshal to json
func (messageGiveawayCreated *MessageGiveawayCreated) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StarCount int64 `json:"star_count"` // Number of Telegram Stars that will be shared by winners of the giveaway; 0 for Telegram Premium giveaways
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageGiveawayCreated.tdCommon = tempObj.tdCommon
	messageGiveawayCreated.StarCount = tempObj.StarCount

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageGiveawayCreated *MessageGiveawayCreated) GetMessageContentEnum() MessageContentEnum {
	return MessageGiveawayCreatedType
}

// MessageGiveaway A giveaway
type MessageGiveaway struct {
	tdCommon
	Parameters  *GiveawayParameters `json:"parameters"`   // Giveaway parameters
	WinnerCount int32               `json:"winner_count"` // Number of users which will receive Telegram Premium subscription gift codes
	Prize       GiveawayPrize       `json:"prize"`        // Prize of the giveaway
	Sticker     *Sticker            `json:"sticker"`      // A sticker to be shown in the message; may be null if unknown
}

// MessageType return the string telegram-type of MessageGiveaway
func (messageGiveaway *MessageGiveaway) MessageType() string {
	return "messageGiveaway"
}

// NewMessageGiveaway creates a new MessageGiveaway
//
// @param parameters Giveaway parameters
// @param winnerCount Number of users which will receive Telegram Premium subscription gift codes
// @param prize Prize of the giveaway
// @param sticker A sticker to be shown in the message; may be null if unknown
func NewMessageGiveaway(parameters *GiveawayParameters, winnerCount int32, prize GiveawayPrize, sticker *Sticker) *MessageGiveaway {
	messageGiveawayTemp := MessageGiveaway{
		tdCommon:    tdCommon{Type: "messageGiveaway"},
		Parameters:  parameters,
		WinnerCount: winnerCount,
		Prize:       prize,
		Sticker:     sticker,
	}

	return &messageGiveawayTemp
}

// UnmarshalJSON unmarshal to json
func (messageGiveaway *MessageGiveaway) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Parameters  *GiveawayParameters `json:"parameters"`   // Giveaway parameters
		WinnerCount int32               `json:"winner_count"` // Number of users which will receive Telegram Premium subscription gift codes

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageGiveaway.tdCommon = tempObj.tdCommon
	messageGiveaway.Parameters = tempObj.Parameters
	messageGiveaway.WinnerCount = tempObj.WinnerCount

	fieldPrize, _ := unmarshalGiveawayPrize(objMap["prize"])
	messageGiveaway.Prize = fieldPrize

	var sticker Sticker
	if objMap["sticker"] != nil {
		err = sticker.UnmarshalJSON(*objMap["sticker"])
		if err != nil {
			return err
		}
	}

	messageGiveaway.Sticker = &sticker

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageGiveaway *MessageGiveaway) GetMessageContentEnum() MessageContentEnum {
	return MessageGiveawayType
}

// MessageGiveawayCompleted A giveaway without public winners has been completed for the chat
type MessageGiveawayCompleted struct {
	tdCommon
	GiveawayMessageID   int64 `json:"giveaway_message_id"`   // Identifier of the message with the giveaway; can be 0 if the message was deleted
	WinnerCount         int32 `json:"winner_count"`          // Number of winners in the giveaway
	IsStarGiveaway      bool  `json:"is_star_giveaway"`      // True, if the giveaway is a Telegram Star giveaway
	UnclaimedPrizeCount int32 `json:"unclaimed_prize_count"` // Number of undistributed prizes; for Telegram Premium giveaways only
}

// MessageType return the string telegram-type of MessageGiveawayCompleted
func (messageGiveawayCompleted *MessageGiveawayCompleted) MessageType() string {
	return "messageGiveawayCompleted"
}

// NewMessageGiveawayCompleted creates a new MessageGiveawayCompleted
//
// @param giveawayMessageID Identifier of the message with the giveaway; can be 0 if the message was deleted
// @param winnerCount Number of winners in the giveaway
// @param isStarGiveaway True, if the giveaway is a Telegram Star giveaway
// @param unclaimedPrizeCount Number of undistributed prizes; for Telegram Premium giveaways only
func NewMessageGiveawayCompleted(giveawayMessageID int64, winnerCount int32, isStarGiveaway bool, unclaimedPrizeCount int32) *MessageGiveawayCompleted {
	messageGiveawayCompletedTemp := MessageGiveawayCompleted{
		tdCommon:            tdCommon{Type: "messageGiveawayCompleted"},
		GiveawayMessageID:   giveawayMessageID,
		WinnerCount:         winnerCount,
		IsStarGiveaway:      isStarGiveaway,
		UnclaimedPrizeCount: unclaimedPrizeCount,
	}

	return &messageGiveawayCompletedTemp
}

// UnmarshalJSON unmarshal to json
func (messageGiveawayCompleted *MessageGiveawayCompleted) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		GiveawayMessageID   int64 `json:"giveaway_message_id"`   // Identifier of the message with the giveaway; can be 0 if the message was deleted
		WinnerCount         int32 `json:"winner_count"`          // Number of winners in the giveaway
		IsStarGiveaway      bool  `json:"is_star_giveaway"`      // True, if the giveaway is a Telegram Star giveaway
		UnclaimedPrizeCount int32 `json:"unclaimed_prize_count"` // Number of undistributed prizes; for Telegram Premium giveaways only
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageGiveawayCompleted.tdCommon = tempObj.tdCommon
	messageGiveawayCompleted.GiveawayMessageID = tempObj.GiveawayMessageID
	messageGiveawayCompleted.WinnerCount = tempObj.WinnerCount
	messageGiveawayCompleted.IsStarGiveaway = tempObj.IsStarGiveaway
	messageGiveawayCompleted.UnclaimedPrizeCount = tempObj.UnclaimedPrizeCount

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageGiveawayCompleted *MessageGiveawayCompleted) GetMessageContentEnum() MessageContentEnum {
	return MessageGiveawayCompletedType
}

// MessageGiveawayWinners A giveaway with public winners has been completed for the chat
type MessageGiveawayWinners struct {
	tdCommon
	BoostedChatID              int64         `json:"boosted_chat_id"`               // Identifier of the supergroup or channel chat, which was automatically boosted by the winners of the giveaway
	GiveawayMessageID          int64         `json:"giveaway_message_id"`           // Identifier of the message with the giveaway in the boosted chat
	AdditionalChatCount        int32         `json:"additional_chat_count"`         // Number of other chats that participated in the giveaway
	ActualWinnersSelectionDate int32         `json:"actual_winners_selection_date"` // Point in time (Unix timestamp) when the winners were selected. May be bigger than winners selection date specified in parameters of the giveaway
	OnlyNewMembers             bool          `json:"only_new_members"`              // True, if only new members of the chats were eligible for the giveaway
	WasRefunded                bool          `json:"was_refunded"`                  // True, if the giveaway was canceled and was fully refunded
	Prize                      GiveawayPrize `json:"prize"`                         // Prize of the giveaway
	PrizeDescription           string        `json:"prize_description"`             // Additional description of the giveaway prize
	WinnerCount                int32         `json:"winner_count"`                  // Total number of winners in the giveaway
	WinnerUserIDs              []int64       `json:"winner_user_ids"`               // Up to 100 user identifiers of the winners of the giveaway
	UnclaimedPrizeCount        int32         `json:"unclaimed_prize_count"`         // Number of undistributed prizes; for Telegram Premium giveaways only
}

// MessageType return the string telegram-type of MessageGiveawayWinners
func (messageGiveawayWinners *MessageGiveawayWinners) MessageType() string {
	return "messageGiveawayWinners"
}

// NewMessageGiveawayWinners creates a new MessageGiveawayWinners
//
// @param boostedChatID Identifier of the supergroup or channel chat, which was automatically boosted by the winners of the giveaway
// @param giveawayMessageID Identifier of the message with the giveaway in the boosted chat
// @param additionalChatCount Number of other chats that participated in the giveaway
// @param actualWinnersSelectionDate Point in time (Unix timestamp) when the winners were selected. May be bigger than winners selection date specified in parameters of the giveaway
// @param onlyNewMembers True, if only new members of the chats were eligible for the giveaway
// @param wasRefunded True, if the giveaway was canceled and was fully refunded
// @param prize Prize of the giveaway
// @param prizeDescription Additional description of the giveaway prize
// @param winnerCount Total number of winners in the giveaway
// @param winnerUserIDs Up to 100 user identifiers of the winners of the giveaway
// @param unclaimedPrizeCount Number of undistributed prizes; for Telegram Premium giveaways only
func NewMessageGiveawayWinners(boostedChatID int64, giveawayMessageID int64, additionalChatCount int32, actualWinnersSelectionDate int32, onlyNewMembers bool, wasRefunded bool, prize GiveawayPrize, prizeDescription string, winnerCount int32, winnerUserIDs []int64, unclaimedPrizeCount int32) *MessageGiveawayWinners {
	messageGiveawayWinnersTemp := MessageGiveawayWinners{
		tdCommon:                   tdCommon{Type: "messageGiveawayWinners"},
		BoostedChatID:              boostedChatID,
		GiveawayMessageID:          giveawayMessageID,
		AdditionalChatCount:        additionalChatCount,
		ActualWinnersSelectionDate: actualWinnersSelectionDate,
		OnlyNewMembers:             onlyNewMembers,
		WasRefunded:                wasRefunded,
		Prize:                      prize,
		PrizeDescription:           prizeDescription,
		WinnerCount:                winnerCount,
		WinnerUserIDs:              winnerUserIDs,
		UnclaimedPrizeCount:        unclaimedPrizeCount,
	}

	return &messageGiveawayWinnersTemp
}

// UnmarshalJSON unmarshal to json
func (messageGiveawayWinners *MessageGiveawayWinners) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BoostedChatID              int64   `json:"boosted_chat_id"`               // Identifier of the supergroup or channel chat, which was automatically boosted by the winners of the giveaway
		GiveawayMessageID          int64   `json:"giveaway_message_id"`           // Identifier of the message with the giveaway in the boosted chat
		AdditionalChatCount        int32   `json:"additional_chat_count"`         // Number of other chats that participated in the giveaway
		ActualWinnersSelectionDate int32   `json:"actual_winners_selection_date"` // Point in time (Unix timestamp) when the winners were selected. May be bigger than winners selection date specified in parameters of the giveaway
		OnlyNewMembers             bool    `json:"only_new_members"`              // True, if only new members of the chats were eligible for the giveaway
		WasRefunded                bool    `json:"was_refunded"`                  // True, if the giveaway was canceled and was fully refunded
		PrizeDescription           string  `json:"prize_description"`             // Additional description of the giveaway prize
		WinnerCount                int32   `json:"winner_count"`                  // Total number of winners in the giveaway
		WinnerUserIDs              []int64 `json:"winner_user_ids"`               // Up to 100 user identifiers of the winners of the giveaway
		UnclaimedPrizeCount        int32   `json:"unclaimed_prize_count"`         // Number of undistributed prizes; for Telegram Premium giveaways only
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageGiveawayWinners.tdCommon = tempObj.tdCommon
	messageGiveawayWinners.BoostedChatID = tempObj.BoostedChatID
	messageGiveawayWinners.GiveawayMessageID = tempObj.GiveawayMessageID
	messageGiveawayWinners.AdditionalChatCount = tempObj.AdditionalChatCount
	messageGiveawayWinners.ActualWinnersSelectionDate = tempObj.ActualWinnersSelectionDate
	messageGiveawayWinners.OnlyNewMembers = tempObj.OnlyNewMembers
	messageGiveawayWinners.WasRefunded = tempObj.WasRefunded
	messageGiveawayWinners.PrizeDescription = tempObj.PrizeDescription
	messageGiveawayWinners.WinnerCount = tempObj.WinnerCount
	messageGiveawayWinners.WinnerUserIDs = tempObj.WinnerUserIDs
	messageGiveawayWinners.UnclaimedPrizeCount = tempObj.UnclaimedPrizeCount

	fieldPrize, _ := unmarshalGiveawayPrize(objMap["prize"])
	messageGiveawayWinners.Prize = fieldPrize

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageGiveawayWinners *MessageGiveawayWinners) GetMessageContentEnum() MessageContentEnum {
	return MessageGiveawayWinnersType
}

// MessageGiftedStars Telegram Stars were gifted to a user
type MessageGiftedStars struct {
	tdCommon
	GifterUserID         int64     `json:"gifter_user_id"`        // The identifier of a user that gifted Telegram Stars; 0 if the gift was anonymous or is outgoing
	ReceiverUserID       int64     `json:"receiver_user_id"`      // The identifier of a user that received Telegram Stars; 0 if the gift is incoming
	Currency             string    `json:"currency"`              // Currency for the paid amount
	Amount               int64     `json:"amount"`                // The paid amount, in the smallest units of the currency
	Cryptocurrency       string    `json:"cryptocurrency"`        // Cryptocurrency used to pay for the gift; may be empty if none
	CryptocurrencyAmount JSONInt64 `json:"cryptocurrency_amount"` // The paid amount, in the smallest units of the cryptocurrency; 0 if none
	StarCount            int64     `json:"star_count"`            // Number of Telegram Stars that were gifted
	TransactionID        string    `json:"transaction_id"`        // Identifier of the transaction for Telegram Stars purchase; for receiver only
	Sticker              *Sticker  `json:"sticker"`               // A sticker to be shown in the message; may be null if unknown
}

// MessageType return the string telegram-type of MessageGiftedStars
func (messageGiftedStars *MessageGiftedStars) MessageType() string {
	return "messageGiftedStars"
}

// NewMessageGiftedStars creates a new MessageGiftedStars
//
// @param gifterUserID The identifier of a user that gifted Telegram Stars; 0 if the gift was anonymous or is outgoing
// @param receiverUserID The identifier of a user that received Telegram Stars; 0 if the gift is incoming
// @param currency Currency for the paid amount
// @param amount The paid amount, in the smallest units of the currency
// @param cryptocurrency Cryptocurrency used to pay for the gift; may be empty if none
// @param cryptocurrencyAmount The paid amount, in the smallest units of the cryptocurrency; 0 if none
// @param starCount Number of Telegram Stars that were gifted
// @param transactionID Identifier of the transaction for Telegram Stars purchase; for receiver only
// @param sticker A sticker to be shown in the message; may be null if unknown
func NewMessageGiftedStars(gifterUserID int64, receiverUserID int64, currency string, amount int64, cryptocurrency string, cryptocurrencyAmount JSONInt64, starCount int64, transactionID string, sticker *Sticker) *MessageGiftedStars {
	messageGiftedStarsTemp := MessageGiftedStars{
		tdCommon:             tdCommon{Type: "messageGiftedStars"},
		GifterUserID:         gifterUserID,
		ReceiverUserID:       receiverUserID,
		Currency:             currency,
		Amount:               amount,
		Cryptocurrency:       cryptocurrency,
		CryptocurrencyAmount: cryptocurrencyAmount,
		StarCount:            starCount,
		TransactionID:        transactionID,
		Sticker:              sticker,
	}

	return &messageGiftedStarsTemp
}

// UnmarshalJSON unmarshal to json
func (messageGiftedStars *MessageGiftedStars) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		GifterUserID         int64     `json:"gifter_user_id"`        // The identifier of a user that gifted Telegram Stars; 0 if the gift was anonymous or is outgoing
		ReceiverUserID       int64     `json:"receiver_user_id"`      // The identifier of a user that received Telegram Stars; 0 if the gift is incoming
		Currency             string    `json:"currency"`              // Currency for the paid amount
		Amount               int64     `json:"amount"`                // The paid amount, in the smallest units of the currency
		Cryptocurrency       string    `json:"cryptocurrency"`        // Cryptocurrency used to pay for the gift; may be empty if none
		CryptocurrencyAmount JSONInt64 `json:"cryptocurrency_amount"` // The paid amount, in the smallest units of the cryptocurrency; 0 if none
		StarCount            int64     `json:"star_count"`            // Number of Telegram Stars that were gifted
		TransactionID        string    `json:"transaction_id"`        // Identifier of the transaction for Telegram Stars purchase; for receiver only

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageGiftedStars.tdCommon = tempObj.tdCommon
	messageGiftedStars.GifterUserID = tempObj.GifterUserID
	messageGiftedStars.ReceiverUserID = tempObj.ReceiverUserID
	messageGiftedStars.Currency = tempObj.Currency
	messageGiftedStars.Amount = tempObj.Amount
	messageGiftedStars.Cryptocurrency = tempObj.Cryptocurrency
	messageGiftedStars.CryptocurrencyAmount = tempObj.CryptocurrencyAmount
	messageGiftedStars.StarCount = tempObj.StarCount
	messageGiftedStars.TransactionID = tempObj.TransactionID

	var sticker Sticker
	if objMap["sticker"] != nil {
		err = sticker.UnmarshalJSON(*objMap["sticker"])
		if err != nil {
			return err
		}
	}

	messageGiftedStars.Sticker = &sticker

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageGiftedStars *MessageGiftedStars) GetMessageContentEnum() MessageContentEnum {
	return MessageGiftedStarsType
}

// MessageGiveawayPrizeStars A Telegram Stars were received by the cuurent user from a giveaway
type MessageGiveawayPrizeStars struct {
	tdCommon
	StarCount         int64    `json:"star_count"`          // Number of Telegram Stars that were received
	TransactionID     string   `json:"transaction_id"`      // Identifier of the transaction for Telegram Stars credit
	BoostedChatID     int64    `json:"boosted_chat_id"`     // Identifier of the supergroup or channel chat, which was automatically boosted by the winners of the giveaway
	GiveawayMessageID int64    `json:"giveaway_message_id"` // Identifier of the message with the giveaway in the boosted chat; can be 0 if the message was deleted
	IsUnclaimed       bool     `json:"is_unclaimed"`        // True, if the corresponding winner wasn't chosen and the Telegram Stars were received by the owner of the boosted chat
	Sticker           *Sticker `json:"sticker"`             // A sticker to be shown in the message; may be null if unknown
}

// MessageType return the string telegram-type of MessageGiveawayPrizeStars
func (messageGiveawayPrizeStars *MessageGiveawayPrizeStars) MessageType() string {
	return "messageGiveawayPrizeStars"
}

// NewMessageGiveawayPrizeStars creates a new MessageGiveawayPrizeStars
//
// @param starCount Number of Telegram Stars that were received
// @param transactionID Identifier of the transaction for Telegram Stars credit
// @param boostedChatID Identifier of the supergroup or channel chat, which was automatically boosted by the winners of the giveaway
// @param giveawayMessageID Identifier of the message with the giveaway in the boosted chat; can be 0 if the message was deleted
// @param isUnclaimed True, if the corresponding winner wasn't chosen and the Telegram Stars were received by the owner of the boosted chat
// @param sticker A sticker to be shown in the message; may be null if unknown
func NewMessageGiveawayPrizeStars(starCount int64, transactionID string, boostedChatID int64, giveawayMessageID int64, isUnclaimed bool, sticker *Sticker) *MessageGiveawayPrizeStars {
	messageGiveawayPrizeStarsTemp := MessageGiveawayPrizeStars{
		tdCommon:          tdCommon{Type: "messageGiveawayPrizeStars"},
		StarCount:         starCount,
		TransactionID:     transactionID,
		BoostedChatID:     boostedChatID,
		GiveawayMessageID: giveawayMessageID,
		IsUnclaimed:       isUnclaimed,
		Sticker:           sticker,
	}

	return &messageGiveawayPrizeStarsTemp
}

// UnmarshalJSON unmarshal to json
func (messageGiveawayPrizeStars *MessageGiveawayPrizeStars) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StarCount         int64  `json:"star_count"`          // Number of Telegram Stars that were received
		TransactionID     string `json:"transaction_id"`      // Identifier of the transaction for Telegram Stars credit
		BoostedChatID     int64  `json:"boosted_chat_id"`     // Identifier of the supergroup or channel chat, which was automatically boosted by the winners of the giveaway
		GiveawayMessageID int64  `json:"giveaway_message_id"` // Identifier of the message with the giveaway in the boosted chat; can be 0 if the message was deleted
		IsUnclaimed       bool   `json:"is_unclaimed"`        // True, if the corresponding winner wasn't chosen and the Telegram Stars were received by the owner of the boosted chat

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageGiveawayPrizeStars.tdCommon = tempObj.tdCommon
	messageGiveawayPrizeStars.StarCount = tempObj.StarCount
	messageGiveawayPrizeStars.TransactionID = tempObj.TransactionID
	messageGiveawayPrizeStars.BoostedChatID = tempObj.BoostedChatID
	messageGiveawayPrizeStars.GiveawayMessageID = tempObj.GiveawayMessageID
	messageGiveawayPrizeStars.IsUnclaimed = tempObj.IsUnclaimed

	var sticker Sticker
	if objMap["sticker"] != nil {
		err = sticker.UnmarshalJSON(*objMap["sticker"])
		if err != nil {
			return err
		}
	}

	messageGiveawayPrizeStars.Sticker = &sticker

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageGiveawayPrizeStars *MessageGiveawayPrizeStars) GetMessageContentEnum() MessageContentEnum {
	return MessageGiveawayPrizeStarsType
}

// MessageContactRegistered A contact has registered with Telegram
type MessageContactRegistered struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageContactRegistered
func (messageContactRegistered *MessageContactRegistered) MessageType() string {
	return "messageContactRegistered"
}

// NewMessageContactRegistered creates a new MessageContactRegistered
//
func NewMessageContactRegistered() *MessageContactRegistered {
	messageContactRegisteredTemp := MessageContactRegistered{
		tdCommon: tdCommon{Type: "messageContactRegistered"},
	}

	return &messageContactRegisteredTemp
}

// UnmarshalJSON unmarshal to json
func (messageContactRegistered *MessageContactRegistered) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageContactRegistered.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageContactRegistered *MessageContactRegistered) GetMessageContentEnum() MessageContentEnum {
	return MessageContactRegisteredType
}

// MessageUsersShared The current user shared users, which were requested by the bot
type MessageUsersShared struct {
	tdCommon
	Users    []SharedUser `json:"users"`     // The shared users
	ButtonID int32        `json:"button_id"` // Identifier of the keyboard button with the request
}

// MessageType return the string telegram-type of MessageUsersShared
func (messageUsersShared *MessageUsersShared) MessageType() string {
	return "messageUsersShared"
}

// NewMessageUsersShared creates a new MessageUsersShared
//
// @param users The shared users
// @param buttonID Identifier of the keyboard button with the request
func NewMessageUsersShared(users []SharedUser, buttonID int32) *MessageUsersShared {
	messageUsersSharedTemp := MessageUsersShared{
		tdCommon: tdCommon{Type: "messageUsersShared"},
		Users:    users,
		ButtonID: buttonID,
	}

	return &messageUsersSharedTemp
}

// UnmarshalJSON unmarshal to json
func (messageUsersShared *MessageUsersShared) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Users    []SharedUser `json:"users"`     // The shared users
		ButtonID int32        `json:"button_id"` // Identifier of the keyboard button with the request
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageUsersShared.tdCommon = tempObj.tdCommon
	messageUsersShared.Users = tempObj.Users
	messageUsersShared.ButtonID = tempObj.ButtonID

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageUsersShared *MessageUsersShared) GetMessageContentEnum() MessageContentEnum {
	return MessageUsersSharedType
}

// MessageChatShared The current user shared a chat, which was requested by the bot
type MessageChatShared struct {
	tdCommon
	Chat     *SharedChat `json:"chat"`      // The shared chat
	ButtonID int32       `json:"button_id"` // Identifier of the keyboard button with the request
}

// MessageType return the string telegram-type of MessageChatShared
func (messageChatShared *MessageChatShared) MessageType() string {
	return "messageChatShared"
}

// NewMessageChatShared creates a new MessageChatShared
//
// @param chat The shared chat
// @param buttonID Identifier of the keyboard button with the request
func NewMessageChatShared(chat *SharedChat, buttonID int32) *MessageChatShared {
	messageChatSharedTemp := MessageChatShared{
		tdCommon: tdCommon{Type: "messageChatShared"},
		Chat:     chat,
		ButtonID: buttonID,
	}

	return &messageChatSharedTemp
}

// UnmarshalJSON unmarshal to json
func (messageChatShared *MessageChatShared) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Chat     *SharedChat `json:"chat"`      // The shared chat
		ButtonID int32       `json:"button_id"` // Identifier of the keyboard button with the request
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageChatShared.tdCommon = tempObj.tdCommon
	messageChatShared.Chat = tempObj.Chat
	messageChatShared.ButtonID = tempObj.ButtonID

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageChatShared *MessageChatShared) GetMessageContentEnum() MessageContentEnum {
	return MessageChatSharedType
}

// MessageBotWriteAccessAllowed The user allowed the bot to send messages
type MessageBotWriteAccessAllowed struct {
	tdCommon
	Reason BotWriteAccessAllowReason `json:"reason"` // The reason why the bot was allowed to write messages
}

// MessageType return the string telegram-type of MessageBotWriteAccessAllowed
func (messageBotWriteAccessAllowed *MessageBotWriteAccessAllowed) MessageType() string {
	return "messageBotWriteAccessAllowed"
}

// NewMessageBotWriteAccessAllowed creates a new MessageBotWriteAccessAllowed
//
// @param reason The reason why the bot was allowed to write messages
func NewMessageBotWriteAccessAllowed(reason BotWriteAccessAllowReason) *MessageBotWriteAccessAllowed {
	messageBotWriteAccessAllowedTemp := MessageBotWriteAccessAllowed{
		tdCommon: tdCommon{Type: "messageBotWriteAccessAllowed"},
		Reason:   reason,
	}

	return &messageBotWriteAccessAllowedTemp
}

// UnmarshalJSON unmarshal to json
func (messageBotWriteAccessAllowed *MessageBotWriteAccessAllowed) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageBotWriteAccessAllowed.tdCommon = tempObj.tdCommon

	fieldReason, _ := unmarshalBotWriteAccessAllowReason(objMap["reason"])
	messageBotWriteAccessAllowed.Reason = fieldReason

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageBotWriteAccessAllowed *MessageBotWriteAccessAllowed) GetMessageContentEnum() MessageContentEnum {
	return MessageBotWriteAccessAllowedType
}

// MessageWebAppDataSent Data from a Web App has been sent to a bot
type MessageWebAppDataSent struct {
	tdCommon
	ButtonText string `json:"button_text"` // Text of the keyboardButtonTypeWebApp button, which opened the Web App
}

// MessageType return the string telegram-type of MessageWebAppDataSent
func (messageWebAppDataSent *MessageWebAppDataSent) MessageType() string {
	return "messageWebAppDataSent"
}

// NewMessageWebAppDataSent creates a new MessageWebAppDataSent
//
// @param buttonText Text of the keyboardButtonTypeWebApp button, which opened the Web App
func NewMessageWebAppDataSent(buttonText string) *MessageWebAppDataSent {
	messageWebAppDataSentTemp := MessageWebAppDataSent{
		tdCommon:   tdCommon{Type: "messageWebAppDataSent"},
		ButtonText: buttonText,
	}

	return &messageWebAppDataSentTemp
}

// UnmarshalJSON unmarshal to json
func (messageWebAppDataSent *MessageWebAppDataSent) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ButtonText string `json:"button_text"` // Text of the keyboardButtonTypeWebApp button, which opened the Web App
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageWebAppDataSent.tdCommon = tempObj.tdCommon
	messageWebAppDataSent.ButtonText = tempObj.ButtonText

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageWebAppDataSent *MessageWebAppDataSent) GetMessageContentEnum() MessageContentEnum {
	return MessageWebAppDataSentType
}

// MessageWebAppDataReceived Data from a Web App has been received; for bots only
type MessageWebAppDataReceived struct {
	tdCommon
	ButtonText string `json:"button_text"` // Text of the keyboardButtonTypeWebApp button, which opened the Web App
	Data       string `json:"data"`        // The data
}

// MessageType return the string telegram-type of MessageWebAppDataReceived
func (messageWebAppDataReceived *MessageWebAppDataReceived) MessageType() string {
	return "messageWebAppDataReceived"
}

// NewMessageWebAppDataReceived creates a new MessageWebAppDataReceived
//
// @param buttonText Text of the keyboardButtonTypeWebApp button, which opened the Web App
// @param data The data
func NewMessageWebAppDataReceived(buttonText string, data string) *MessageWebAppDataReceived {
	messageWebAppDataReceivedTemp := MessageWebAppDataReceived{
		tdCommon:   tdCommon{Type: "messageWebAppDataReceived"},
		ButtonText: buttonText,
		Data:       data,
	}

	return &messageWebAppDataReceivedTemp
}

// UnmarshalJSON unmarshal to json
func (messageWebAppDataReceived *MessageWebAppDataReceived) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ButtonText string `json:"button_text"` // Text of the keyboardButtonTypeWebApp button, which opened the Web App
		Data       string `json:"data"`        // The data
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageWebAppDataReceived.tdCommon = tempObj.tdCommon
	messageWebAppDataReceived.ButtonText = tempObj.ButtonText
	messageWebAppDataReceived.Data = tempObj.Data

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageWebAppDataReceived *MessageWebAppDataReceived) GetMessageContentEnum() MessageContentEnum {
	return MessageWebAppDataReceivedType
}

// MessagePassportDataSent Telegram Passport data has been sent to a bot
type MessagePassportDataSent struct {
	tdCommon
	Types []PassportElementType `json:"types"` // List of Telegram Passport element types sent
}

// MessageType return the string telegram-type of MessagePassportDataSent
func (messagePassportDataSent *MessagePassportDataSent) MessageType() string {
	return "messagePassportDataSent"
}

// NewMessagePassportDataSent creates a new MessagePassportDataSent
//
// @param typeParams List of Telegram Passport element types sent
func NewMessagePassportDataSent(typeParams []PassportElementType) *MessagePassportDataSent {
	messagePassportDataSentTemp := MessagePassportDataSent{
		tdCommon: tdCommon{Type: "messagePassportDataSent"},
		Types:    typeParams,
	}

	return &messagePassportDataSentTemp
}

// UnmarshalJSON unmarshal to json
func (messagePassportDataSent *MessagePassportDataSent) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messagePassportDataSent.tdCommon = tempObj.tdCommon

	fieldTypes, _ := unmarshalPassportElementTypeSlice(objMap["types"])
	messagePassportDataSent.Types = fieldTypes

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messagePassportDataSent *MessagePassportDataSent) GetMessageContentEnum() MessageContentEnum {
	return MessagePassportDataSentType
}

// MessagePassportDataReceived Telegram Passport data has been received; for bots only
type MessagePassportDataReceived struct {
	tdCommon
	Elements    []EncryptedPassportElement `json:"elements"`    // List of received Telegram Passport elements
	Credentials *EncryptedCredentials      `json:"credentials"` // Encrypted data credentials
}

// MessageType return the string telegram-type of MessagePassportDataReceived
func (messagePassportDataReceived *MessagePassportDataReceived) MessageType() string {
	return "messagePassportDataReceived"
}

// NewMessagePassportDataReceived creates a new MessagePassportDataReceived
//
// @param elements List of received Telegram Passport elements
// @param credentials Encrypted data credentials
func NewMessagePassportDataReceived(elements []EncryptedPassportElement, credentials *EncryptedCredentials) *MessagePassportDataReceived {
	messagePassportDataReceivedTemp := MessagePassportDataReceived{
		tdCommon:    tdCommon{Type: "messagePassportDataReceived"},
		Elements:    elements,
		Credentials: credentials,
	}

	return &messagePassportDataReceivedTemp
}

// UnmarshalJSON unmarshal to json
func (messagePassportDataReceived *MessagePassportDataReceived) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Elements    []EncryptedPassportElement `json:"elements"`    // List of received Telegram Passport elements
		Credentials *EncryptedCredentials      `json:"credentials"` // Encrypted data credentials
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messagePassportDataReceived.tdCommon = tempObj.tdCommon
	messagePassportDataReceived.Elements = tempObj.Elements
	messagePassportDataReceived.Credentials = tempObj.Credentials

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messagePassportDataReceived *MessagePassportDataReceived) GetMessageContentEnum() MessageContentEnum {
	return MessagePassportDataReceivedType
}

// MessageProximityAlertTriggered A user in the chat came within proximity alert range
type MessageProximityAlertTriggered struct {
	tdCommon
	TravelerID MessageSender `json:"traveler_id"` // The identifier of a user or chat that triggered the proximity alert
	WatcherID  MessageSender `json:"watcher_id"`  // The identifier of a user or chat that subscribed for the proximity alert
	Distance   int32         `json:"distance"`    // The distance between the users
}

// MessageType return the string telegram-type of MessageProximityAlertTriggered
func (messageProximityAlertTriggered *MessageProximityAlertTriggered) MessageType() string {
	return "messageProximityAlertTriggered"
}

// NewMessageProximityAlertTriggered creates a new MessageProximityAlertTriggered
//
// @param travelerID The identifier of a user or chat that triggered the proximity alert
// @param watcherID The identifier of a user or chat that subscribed for the proximity alert
// @param distance The distance between the users
func NewMessageProximityAlertTriggered(travelerID MessageSender, watcherID MessageSender, distance int32) *MessageProximityAlertTriggered {
	messageProximityAlertTriggeredTemp := MessageProximityAlertTriggered{
		tdCommon:   tdCommon{Type: "messageProximityAlertTriggered"},
		TravelerID: travelerID,
		WatcherID:  watcherID,
		Distance:   distance,
	}

	return &messageProximityAlertTriggeredTemp
}

// UnmarshalJSON unmarshal to json
func (messageProximityAlertTriggered *MessageProximityAlertTriggered) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Distance int32 `json:"distance"` // The distance between the users
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageProximityAlertTriggered.tdCommon = tempObj.tdCommon
	messageProximityAlertTriggered.Distance = tempObj.Distance

	fieldTravelerID, _ := unmarshalMessageSender(objMap["traveler_id"])
	messageProximityAlertTriggered.TravelerID = fieldTravelerID

	fieldWatcherID, _ := unmarshalMessageSender(objMap["watcher_id"])
	messageProximityAlertTriggered.WatcherID = fieldWatcherID

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageProximityAlertTriggered *MessageProximityAlertTriggered) GetMessageContentEnum() MessageContentEnum {
	return MessageProximityAlertTriggeredType
}

// MessageUnsupported A message content that is not supported in the current TDLib version
type MessageUnsupported struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageUnsupported
func (messageUnsupported *MessageUnsupported) MessageType() string {
	return "messageUnsupported"
}

// NewMessageUnsupported creates a new MessageUnsupported
//
func NewMessageUnsupported() *MessageUnsupported {
	messageUnsupportedTemp := MessageUnsupported{
		tdCommon: tdCommon{Type: "messageUnsupported"},
	}

	return &messageUnsupportedTemp
}

// UnmarshalJSON unmarshal to json
func (messageUnsupported *MessageUnsupported) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageUnsupported.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageContentEnum return the enum type of this object
func (messageUnsupported *MessageUnsupported) GetMessageContentEnum() MessageContentEnum {
	return MessageUnsupportedType
}

// TextEntityTypeMention A mention of a user, a supergroup, or a channel by their username
type TextEntityTypeMention struct {
	tdCommon
}

// MessageType return the string telegram-type of TextEntityTypeMention
func (textEntityTypeMention *TextEntityTypeMention) MessageType() string {
	return "textEntityTypeMention"
}

// NewTextEntityTypeMention creates a new TextEntityTypeMention
//
func NewTextEntityTypeMention() *TextEntityTypeMention {
	textEntityTypeMentionTemp := TextEntityTypeMention{
		tdCommon: tdCommon{Type: "textEntityTypeMention"},
	}

	return &textEntityTypeMentionTemp
}

// UnmarshalJSON unmarshal to json
func (textEntityTypeMention *TextEntityTypeMention) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntityTypeMention.tdCommon = tempObj.tdCommon

	return nil
}

// GetTextEntityTypeEnum return the enum type of this object
func (textEntityTypeMention *TextEntityTypeMention) GetTextEntityTypeEnum() TextEntityTypeEnum {
	return TextEntityTypeMentionType
}

// TextEntityTypeHashtag A hashtag text, beginning with "#"
type TextEntityTypeHashtag struct {
	tdCommon
}

// MessageType return the string telegram-type of TextEntityTypeHashtag
func (textEntityTypeHashtag *TextEntityTypeHashtag) MessageType() string {
	return "textEntityTypeHashtag"
}

// NewTextEntityTypeHashtag creates a new TextEntityTypeHashtag
//
func NewTextEntityTypeHashtag() *TextEntityTypeHashtag {
	textEntityTypeHashtagTemp := TextEntityTypeHashtag{
		tdCommon: tdCommon{Type: "textEntityTypeHashtag"},
	}

	return &textEntityTypeHashtagTemp
}

// UnmarshalJSON unmarshal to json
func (textEntityTypeHashtag *TextEntityTypeHashtag) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntityTypeHashtag.tdCommon = tempObj.tdCommon

	return nil
}

// GetTextEntityTypeEnum return the enum type of this object
func (textEntityTypeHashtag *TextEntityTypeHashtag) GetTextEntityTypeEnum() TextEntityTypeEnum {
	return TextEntityTypeHashtagType
}

// TextEntityTypeCashtag A cashtag text, beginning with "$" and consisting of capital English letters (e.g., "$USD")
type TextEntityTypeCashtag struct {
	tdCommon
}

// MessageType return the string telegram-type of TextEntityTypeCashtag
func (textEntityTypeCashtag *TextEntityTypeCashtag) MessageType() string {
	return "textEntityTypeCashtag"
}

// NewTextEntityTypeCashtag creates a new TextEntityTypeCashtag
//
func NewTextEntityTypeCashtag() *TextEntityTypeCashtag {
	textEntityTypeCashtagTemp := TextEntityTypeCashtag{
		tdCommon: tdCommon{Type: "textEntityTypeCashtag"},
	}

	return &textEntityTypeCashtagTemp
}

// UnmarshalJSON unmarshal to json
func (textEntityTypeCashtag *TextEntityTypeCashtag) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntityTypeCashtag.tdCommon = tempObj.tdCommon

	return nil
}

// GetTextEntityTypeEnum return the enum type of this object
func (textEntityTypeCashtag *TextEntityTypeCashtag) GetTextEntityTypeEnum() TextEntityTypeEnum {
	return TextEntityTypeCashtagType
}

// TextEntityTypeBotCommand A bot command, beginning with "/"
type TextEntityTypeBotCommand struct {
	tdCommon
}

// MessageType return the string telegram-type of TextEntityTypeBotCommand
func (textEntityTypeBotCommand *TextEntityTypeBotCommand) MessageType() string {
	return "textEntityTypeBotCommand"
}

// NewTextEntityTypeBotCommand creates a new TextEntityTypeBotCommand
//
func NewTextEntityTypeBotCommand() *TextEntityTypeBotCommand {
	textEntityTypeBotCommandTemp := TextEntityTypeBotCommand{
		tdCommon: tdCommon{Type: "textEntityTypeBotCommand"},
	}

	return &textEntityTypeBotCommandTemp
}

// UnmarshalJSON unmarshal to json
func (textEntityTypeBotCommand *TextEntityTypeBotCommand) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntityTypeBotCommand.tdCommon = tempObj.tdCommon

	return nil
}

// GetTextEntityTypeEnum return the enum type of this object
func (textEntityTypeBotCommand *TextEntityTypeBotCommand) GetTextEntityTypeEnum() TextEntityTypeEnum {
	return TextEntityTypeBotCommandType
}

// TextEntityTypeURL An HTTP URL
type TextEntityTypeURL struct {
	tdCommon
}

// MessageType return the string telegram-type of TextEntityTypeURL
func (textEntityTypeURL *TextEntityTypeURL) MessageType() string {
	return "textEntityTypeUrl"
}

// NewTextEntityTypeURL creates a new TextEntityTypeURL
//
func NewTextEntityTypeURL() *TextEntityTypeURL {
	textEntityTypeURLTemp := TextEntityTypeURL{
		tdCommon: tdCommon{Type: "textEntityTypeUrl"},
	}

	return &textEntityTypeURLTemp
}

// UnmarshalJSON unmarshal to json
func (textEntityTypeURL *TextEntityTypeURL) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntityTypeURL.tdCommon = tempObj.tdCommon

	return nil
}

// GetTextEntityTypeEnum return the enum type of this object
func (textEntityTypeURL *TextEntityTypeURL) GetTextEntityTypeEnum() TextEntityTypeEnum {
	return TextEntityTypeURLType
}

// TextEntityTypeEmailAddress An email address
type TextEntityTypeEmailAddress struct {
	tdCommon
}

// MessageType return the string telegram-type of TextEntityTypeEmailAddress
func (textEntityTypeEmailAddress *TextEntityTypeEmailAddress) MessageType() string {
	return "textEntityTypeEmailAddress"
}

// NewTextEntityTypeEmailAddress creates a new TextEntityTypeEmailAddress
//
func NewTextEntityTypeEmailAddress() *TextEntityTypeEmailAddress {
	textEntityTypeEmailAddressTemp := TextEntityTypeEmailAddress{
		tdCommon: tdCommon{Type: "textEntityTypeEmailAddress"},
	}

	return &textEntityTypeEmailAddressTemp
}

// UnmarshalJSON unmarshal to json
func (textEntityTypeEmailAddress *TextEntityTypeEmailAddress) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntityTypeEmailAddress.tdCommon = tempObj.tdCommon

	return nil
}

// GetTextEntityTypeEnum return the enum type of this object
func (textEntityTypeEmailAddress *TextEntityTypeEmailAddress) GetTextEntityTypeEnum() TextEntityTypeEnum {
	return TextEntityTypeEmailAddressType
}

// TextEntityTypePhoneNumber A phone number
type TextEntityTypePhoneNumber struct {
	tdCommon
}

// MessageType return the string telegram-type of TextEntityTypePhoneNumber
func (textEntityTypePhoneNumber *TextEntityTypePhoneNumber) MessageType() string {
	return "textEntityTypePhoneNumber"
}

// NewTextEntityTypePhoneNumber creates a new TextEntityTypePhoneNumber
//
func NewTextEntityTypePhoneNumber() *TextEntityTypePhoneNumber {
	textEntityTypePhoneNumberTemp := TextEntityTypePhoneNumber{
		tdCommon: tdCommon{Type: "textEntityTypePhoneNumber"},
	}

	return &textEntityTypePhoneNumberTemp
}

// UnmarshalJSON unmarshal to json
func (textEntityTypePhoneNumber *TextEntityTypePhoneNumber) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntityTypePhoneNumber.tdCommon = tempObj.tdCommon

	return nil
}

// GetTextEntityTypeEnum return the enum type of this object
func (textEntityTypePhoneNumber *TextEntityTypePhoneNumber) GetTextEntityTypeEnum() TextEntityTypeEnum {
	return TextEntityTypePhoneNumberType
}

// TextEntityTypeBankCardNumber A bank card number. The getBankCardInfo method can be used to get information about the bank card
type TextEntityTypeBankCardNumber struct {
	tdCommon
}

// MessageType return the string telegram-type of TextEntityTypeBankCardNumber
func (textEntityTypeBankCardNumber *TextEntityTypeBankCardNumber) MessageType() string {
	return "textEntityTypeBankCardNumber"
}

// NewTextEntityTypeBankCardNumber creates a new TextEntityTypeBankCardNumber
//
func NewTextEntityTypeBankCardNumber() *TextEntityTypeBankCardNumber {
	textEntityTypeBankCardNumberTemp := TextEntityTypeBankCardNumber{
		tdCommon: tdCommon{Type: "textEntityTypeBankCardNumber"},
	}

	return &textEntityTypeBankCardNumberTemp
}

// UnmarshalJSON unmarshal to json
func (textEntityTypeBankCardNumber *TextEntityTypeBankCardNumber) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntityTypeBankCardNumber.tdCommon = tempObj.tdCommon

	return nil
}

// GetTextEntityTypeEnum return the enum type of this object
func (textEntityTypeBankCardNumber *TextEntityTypeBankCardNumber) GetTextEntityTypeEnum() TextEntityTypeEnum {
	return TextEntityTypeBankCardNumberType
}

// TextEntityTypeBold A bold text
type TextEntityTypeBold struct {
	tdCommon
}

// MessageType return the string telegram-type of TextEntityTypeBold
func (textEntityTypeBold *TextEntityTypeBold) MessageType() string {
	return "textEntityTypeBold"
}

// NewTextEntityTypeBold creates a new TextEntityTypeBold
//
func NewTextEntityTypeBold() *TextEntityTypeBold {
	textEntityTypeBoldTemp := TextEntityTypeBold{
		tdCommon: tdCommon{Type: "textEntityTypeBold"},
	}

	return &textEntityTypeBoldTemp
}

// UnmarshalJSON unmarshal to json
func (textEntityTypeBold *TextEntityTypeBold) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntityTypeBold.tdCommon = tempObj.tdCommon

	return nil
}

// GetTextEntityTypeEnum return the enum type of this object
func (textEntityTypeBold *TextEntityTypeBold) GetTextEntityTypeEnum() TextEntityTypeEnum {
	return TextEntityTypeBoldType
}

// TextEntityTypeItalic An italic text
type TextEntityTypeItalic struct {
	tdCommon
}

// MessageType return the string telegram-type of TextEntityTypeItalic
func (textEntityTypeItalic *TextEntityTypeItalic) MessageType() string {
	return "textEntityTypeItalic"
}

// NewTextEntityTypeItalic creates a new TextEntityTypeItalic
//
func NewTextEntityTypeItalic() *TextEntityTypeItalic {
	textEntityTypeItalicTemp := TextEntityTypeItalic{
		tdCommon: tdCommon{Type: "textEntityTypeItalic"},
	}

	return &textEntityTypeItalicTemp
}

// UnmarshalJSON unmarshal to json
func (textEntityTypeItalic *TextEntityTypeItalic) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntityTypeItalic.tdCommon = tempObj.tdCommon

	return nil
}

// GetTextEntityTypeEnum return the enum type of this object
func (textEntityTypeItalic *TextEntityTypeItalic) GetTextEntityTypeEnum() TextEntityTypeEnum {
	return TextEntityTypeItalicType
}

// TextEntityTypeUnderline An underlined text
type TextEntityTypeUnderline struct {
	tdCommon
}

// MessageType return the string telegram-type of TextEntityTypeUnderline
func (textEntityTypeUnderline *TextEntityTypeUnderline) MessageType() string {
	return "textEntityTypeUnderline"
}

// NewTextEntityTypeUnderline creates a new TextEntityTypeUnderline
//
func NewTextEntityTypeUnderline() *TextEntityTypeUnderline {
	textEntityTypeUnderlineTemp := TextEntityTypeUnderline{
		tdCommon: tdCommon{Type: "textEntityTypeUnderline"},
	}

	return &textEntityTypeUnderlineTemp
}

// UnmarshalJSON unmarshal to json
func (textEntityTypeUnderline *TextEntityTypeUnderline) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntityTypeUnderline.tdCommon = tempObj.tdCommon

	return nil
}

// GetTextEntityTypeEnum return the enum type of this object
func (textEntityTypeUnderline *TextEntityTypeUnderline) GetTextEntityTypeEnum() TextEntityTypeEnum {
	return TextEntityTypeUnderlineType
}

// TextEntityTypeStrikethrough A strikethrough text
type TextEntityTypeStrikethrough struct {
	tdCommon
}

// MessageType return the string telegram-type of TextEntityTypeStrikethrough
func (textEntityTypeStrikethrough *TextEntityTypeStrikethrough) MessageType() string {
	return "textEntityTypeStrikethrough"
}

// NewTextEntityTypeStrikethrough creates a new TextEntityTypeStrikethrough
//
func NewTextEntityTypeStrikethrough() *TextEntityTypeStrikethrough {
	textEntityTypeStrikethroughTemp := TextEntityTypeStrikethrough{
		tdCommon: tdCommon{Type: "textEntityTypeStrikethrough"},
	}

	return &textEntityTypeStrikethroughTemp
}

// UnmarshalJSON unmarshal to json
func (textEntityTypeStrikethrough *TextEntityTypeStrikethrough) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntityTypeStrikethrough.tdCommon = tempObj.tdCommon

	return nil
}

// GetTextEntityTypeEnum return the enum type of this object
func (textEntityTypeStrikethrough *TextEntityTypeStrikethrough) GetTextEntityTypeEnum() TextEntityTypeEnum {
	return TextEntityTypeStrikethroughType
}

// TextEntityTypeSpoiler A spoiler text
type TextEntityTypeSpoiler struct {
	tdCommon
}

// MessageType return the string telegram-type of TextEntityTypeSpoiler
func (textEntityTypeSpoiler *TextEntityTypeSpoiler) MessageType() string {
	return "textEntityTypeSpoiler"
}

// NewTextEntityTypeSpoiler creates a new TextEntityTypeSpoiler
//
func NewTextEntityTypeSpoiler() *TextEntityTypeSpoiler {
	textEntityTypeSpoilerTemp := TextEntityTypeSpoiler{
		tdCommon: tdCommon{Type: "textEntityTypeSpoiler"},
	}

	return &textEntityTypeSpoilerTemp
}

// UnmarshalJSON unmarshal to json
func (textEntityTypeSpoiler *TextEntityTypeSpoiler) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntityTypeSpoiler.tdCommon = tempObj.tdCommon

	return nil
}

// GetTextEntityTypeEnum return the enum type of this object
func (textEntityTypeSpoiler *TextEntityTypeSpoiler) GetTextEntityTypeEnum() TextEntityTypeEnum {
	return TextEntityTypeSpoilerType
}

// TextEntityTypeCode Text that must be formatted as if inside a code HTML tag
type TextEntityTypeCode struct {
	tdCommon
}

// MessageType return the string telegram-type of TextEntityTypeCode
func (textEntityTypeCode *TextEntityTypeCode) MessageType() string {
	return "textEntityTypeCode"
}

// NewTextEntityTypeCode creates a new TextEntityTypeCode
//
func NewTextEntityTypeCode() *TextEntityTypeCode {
	textEntityTypeCodeTemp := TextEntityTypeCode{
		tdCommon: tdCommon{Type: "textEntityTypeCode"},
	}

	return &textEntityTypeCodeTemp
}

// UnmarshalJSON unmarshal to json
func (textEntityTypeCode *TextEntityTypeCode) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntityTypeCode.tdCommon = tempObj.tdCommon

	return nil
}

// GetTextEntityTypeEnum return the enum type of this object
func (textEntityTypeCode *TextEntityTypeCode) GetTextEntityTypeEnum() TextEntityTypeEnum {
	return TextEntityTypeCodeType
}

// TextEntityTypePre Text that must be formatted as if inside a pre HTML tag
type TextEntityTypePre struct {
	tdCommon
}

// MessageType return the string telegram-type of TextEntityTypePre
func (textEntityTypePre *TextEntityTypePre) MessageType() string {
	return "textEntityTypePre"
}

// NewTextEntityTypePre creates a new TextEntityTypePre
//
func NewTextEntityTypePre() *TextEntityTypePre {
	textEntityTypePreTemp := TextEntityTypePre{
		tdCommon: tdCommon{Type: "textEntityTypePre"},
	}

	return &textEntityTypePreTemp
}

// UnmarshalJSON unmarshal to json
func (textEntityTypePre *TextEntityTypePre) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntityTypePre.tdCommon = tempObj.tdCommon

	return nil
}

// GetTextEntityTypeEnum return the enum type of this object
func (textEntityTypePre *TextEntityTypePre) GetTextEntityTypeEnum() TextEntityTypeEnum {
	return TextEntityTypePreType
}

// TextEntityTypePreCode Text that must be formatted as if inside pre, and code HTML tags
type TextEntityTypePreCode struct {
	tdCommon
	Language string `json:"language"` // Programming language of the code; as defined by the sender
}

// MessageType return the string telegram-type of TextEntityTypePreCode
func (textEntityTypePreCode *TextEntityTypePreCode) MessageType() string {
	return "textEntityTypePreCode"
}

// NewTextEntityTypePreCode creates a new TextEntityTypePreCode
//
// @param language Programming language of the code; as defined by the sender
func NewTextEntityTypePreCode(language string) *TextEntityTypePreCode {
	textEntityTypePreCodeTemp := TextEntityTypePreCode{
		tdCommon: tdCommon{Type: "textEntityTypePreCode"},
		Language: language,
	}

	return &textEntityTypePreCodeTemp
}

// UnmarshalJSON unmarshal to json
func (textEntityTypePreCode *TextEntityTypePreCode) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Language string `json:"language"` // Programming language of the code; as defined by the sender
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntityTypePreCode.tdCommon = tempObj.tdCommon
	textEntityTypePreCode.Language = tempObj.Language

	return nil
}

// GetTextEntityTypeEnum return the enum type of this object
func (textEntityTypePreCode *TextEntityTypePreCode) GetTextEntityTypeEnum() TextEntityTypeEnum {
	return TextEntityTypePreCodeType
}

// TextEntityTypeBlockQuote Text that must be formatted as if inside a blockquote HTML tag; not supported in secret chats
type TextEntityTypeBlockQuote struct {
	tdCommon
}

// MessageType return the string telegram-type of TextEntityTypeBlockQuote
func (textEntityTypeBlockQuote *TextEntityTypeBlockQuote) MessageType() string {
	return "textEntityTypeBlockQuote"
}

// NewTextEntityTypeBlockQuote creates a new TextEntityTypeBlockQuote
//
func NewTextEntityTypeBlockQuote() *TextEntityTypeBlockQuote {
	textEntityTypeBlockQuoteTemp := TextEntityTypeBlockQuote{
		tdCommon: tdCommon{Type: "textEntityTypeBlockQuote"},
	}

	return &textEntityTypeBlockQuoteTemp
}

// UnmarshalJSON unmarshal to json
func (textEntityTypeBlockQuote *TextEntityTypeBlockQuote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntityTypeBlockQuote.tdCommon = tempObj.tdCommon

	return nil
}

// GetTextEntityTypeEnum return the enum type of this object
func (textEntityTypeBlockQuote *TextEntityTypeBlockQuote) GetTextEntityTypeEnum() TextEntityTypeEnum {
	return TextEntityTypeBlockQuoteType
}

// TextEntityTypeExpandableBlockQuote Text that must be formatted as if inside a blockquote HTML tag and collapsed by default to 3 lines with the ability to show full text; not supported in secret chats
type TextEntityTypeExpandableBlockQuote struct {
	tdCommon
}

// MessageType return the string telegram-type of TextEntityTypeExpandableBlockQuote
func (textEntityTypeExpandableBlockQuote *TextEntityTypeExpandableBlockQuote) MessageType() string {
	return "textEntityTypeExpandableBlockQuote"
}

// NewTextEntityTypeExpandableBlockQuote creates a new TextEntityTypeExpandableBlockQuote
//
func NewTextEntityTypeExpandableBlockQuote() *TextEntityTypeExpandableBlockQuote {
	textEntityTypeExpandableBlockQuoteTemp := TextEntityTypeExpandableBlockQuote{
		tdCommon: tdCommon{Type: "textEntityTypeExpandableBlockQuote"},
	}

	return &textEntityTypeExpandableBlockQuoteTemp
}

// UnmarshalJSON unmarshal to json
func (textEntityTypeExpandableBlockQuote *TextEntityTypeExpandableBlockQuote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntityTypeExpandableBlockQuote.tdCommon = tempObj.tdCommon

	return nil
}

// GetTextEntityTypeEnum return the enum type of this object
func (textEntityTypeExpandableBlockQuote *TextEntityTypeExpandableBlockQuote) GetTextEntityTypeEnum() TextEntityTypeEnum {
	return TextEntityTypeExpandableBlockQuoteType
}

// TextEntityTypeTextURL A text description shown instead of a raw URL
type TextEntityTypeTextURL struct {
	tdCommon
	URL string `json:"url"` // HTTP or tg:// URL to be opened when the link is clicked
}

// MessageType return the string telegram-type of TextEntityTypeTextURL
func (textEntityTypeTextURL *TextEntityTypeTextURL) MessageType() string {
	return "textEntityTypeTextUrl"
}

// NewTextEntityTypeTextURL creates a new TextEntityTypeTextURL
//
// @param uRL HTTP or tg:// URL to be opened when the link is clicked
func NewTextEntityTypeTextURL(uRL string) *TextEntityTypeTextURL {
	textEntityTypeTextURLTemp := TextEntityTypeTextURL{
		tdCommon: tdCommon{Type: "textEntityTypeTextUrl"},
		URL:      uRL,
	}

	return &textEntityTypeTextURLTemp
}

// UnmarshalJSON unmarshal to json
func (textEntityTypeTextURL *TextEntityTypeTextURL) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL string `json:"url"` // HTTP or tg:// URL to be opened when the link is clicked
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntityTypeTextURL.tdCommon = tempObj.tdCommon
	textEntityTypeTextURL.URL = tempObj.URL

	return nil
}

// GetTextEntityTypeEnum return the enum type of this object
func (textEntityTypeTextURL *TextEntityTypeTextURL) GetTextEntityTypeEnum() TextEntityTypeEnum {
	return TextEntityTypeTextURLType
}

// TextEntityTypeMentionName A text shows instead of a raw mention of the user (e.g., when the user has no username)
type TextEntityTypeMentionName struct {
	tdCommon
	UserID int64 `json:"user_id"` // Identifier of the mentioned user
}

// MessageType return the string telegram-type of TextEntityTypeMentionName
func (textEntityTypeMentionName *TextEntityTypeMentionName) MessageType() string {
	return "textEntityTypeMentionName"
}

// NewTextEntityTypeMentionName creates a new TextEntityTypeMentionName
//
// @param userID Identifier of the mentioned user
func NewTextEntityTypeMentionName(userID int64) *TextEntityTypeMentionName {
	textEntityTypeMentionNameTemp := TextEntityTypeMentionName{
		tdCommon: tdCommon{Type: "textEntityTypeMentionName"},
		UserID:   userID,
	}

	return &textEntityTypeMentionNameTemp
}

// UnmarshalJSON unmarshal to json
func (textEntityTypeMentionName *TextEntityTypeMentionName) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID int64 `json:"user_id"` // Identifier of the mentioned user
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntityTypeMentionName.tdCommon = tempObj.tdCommon
	textEntityTypeMentionName.UserID = tempObj.UserID

	return nil
}

// GetTextEntityTypeEnum return the enum type of this object
func (textEntityTypeMentionName *TextEntityTypeMentionName) GetTextEntityTypeEnum() TextEntityTypeEnum {
	return TextEntityTypeMentionNameType
}

// TextEntityTypeCustomEmoji A custom emoji. The text behind a custom emoji must be an emoji. Only premium users can use premium custom emoji
type TextEntityTypeCustomEmoji struct {
	tdCommon
	CustomEmojiID JSONInt64 `json:"custom_emoji_id"` // Unique identifier of the custom emoji
}

// MessageType return the string telegram-type of TextEntityTypeCustomEmoji
func (textEntityTypeCustomEmoji *TextEntityTypeCustomEmoji) MessageType() string {
	return "textEntityTypeCustomEmoji"
}

// NewTextEntityTypeCustomEmoji creates a new TextEntityTypeCustomEmoji
//
// @param customEmojiID Unique identifier of the custom emoji
func NewTextEntityTypeCustomEmoji(customEmojiID JSONInt64) *TextEntityTypeCustomEmoji {
	textEntityTypeCustomEmojiTemp := TextEntityTypeCustomEmoji{
		tdCommon:      tdCommon{Type: "textEntityTypeCustomEmoji"},
		CustomEmojiID: customEmojiID,
	}

	return &textEntityTypeCustomEmojiTemp
}

// UnmarshalJSON unmarshal to json
func (textEntityTypeCustomEmoji *TextEntityTypeCustomEmoji) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CustomEmojiID JSONInt64 `json:"custom_emoji_id"` // Unique identifier of the custom emoji
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntityTypeCustomEmoji.tdCommon = tempObj.tdCommon
	textEntityTypeCustomEmoji.CustomEmojiID = tempObj.CustomEmojiID

	return nil
}

// GetTextEntityTypeEnum return the enum type of this object
func (textEntityTypeCustomEmoji *TextEntityTypeCustomEmoji) GetTextEntityTypeEnum() TextEntityTypeEnum {
	return TextEntityTypeCustomEmojiType
}

// TextEntityTypeMediaTimestamp A media timestamp
type TextEntityTypeMediaTimestamp struct {
	tdCommon
	MediaTimestamp int32 `json:"media_timestamp"` // Timestamp from which a video/audio/video note/voice note/story playing must start, in seconds. The media can be in the content or the link preview of the current message, or in the same places in the replied message
}

// MessageType return the string telegram-type of TextEntityTypeMediaTimestamp
func (textEntityTypeMediaTimestamp *TextEntityTypeMediaTimestamp) MessageType() string {
	return "textEntityTypeMediaTimestamp"
}

// NewTextEntityTypeMediaTimestamp creates a new TextEntityTypeMediaTimestamp
//
// @param mediaTimestamp Timestamp from which a video/audio/video note/voice note/story playing must start, in seconds. The media can be in the content or the link preview of the current message, or in the same places in the replied message
func NewTextEntityTypeMediaTimestamp(mediaTimestamp int32) *TextEntityTypeMediaTimestamp {
	textEntityTypeMediaTimestampTemp := TextEntityTypeMediaTimestamp{
		tdCommon:       tdCommon{Type: "textEntityTypeMediaTimestamp"},
		MediaTimestamp: mediaTimestamp,
	}

	return &textEntityTypeMediaTimestampTemp
}

// UnmarshalJSON unmarshal to json
func (textEntityTypeMediaTimestamp *TextEntityTypeMediaTimestamp) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MediaTimestamp int32 `json:"media_timestamp"` // Timestamp from which a video/audio/video note/voice note/story playing must start, in seconds. The media can be in the content or the link preview of the current message, or in the same places in the replied message
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textEntityTypeMediaTimestamp.tdCommon = tempObj.tdCommon
	textEntityTypeMediaTimestamp.MediaTimestamp = tempObj.MediaTimestamp

	return nil
}

// GetTextEntityTypeEnum return the enum type of this object
func (textEntityTypeMediaTimestamp *TextEntityTypeMediaTimestamp) GetTextEntityTypeEnum() TextEntityTypeEnum {
	return TextEntityTypeMediaTimestampType
}

// InputThumbnail A thumbnail to be sent along with a file; must be in JPEG or WEBP format for stickers, and less than 200 KB in size
type InputThumbnail struct {
	tdCommon
	Thumbnail InputFile `json:"thumbnail"` // Thumbnail file to send. Sending thumbnails by file_id is currently not supported
	Width     int32     `json:"width"`     // Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown
	Height    int32     `json:"height"`    // Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown
}

// MessageType return the string telegram-type of InputThumbnail
func (inputThumbnail *InputThumbnail) MessageType() string {
	return "inputThumbnail"
}

// NewInputThumbnail creates a new InputThumbnail
//
// @param thumbnail Thumbnail file to send. Sending thumbnails by file_id is currently not supported
// @param width Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown
// @param height Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown
func NewInputThumbnail(thumbnail InputFile, width int32, height int32) *InputThumbnail {
	inputThumbnailTemp := InputThumbnail{
		tdCommon:  tdCommon{Type: "inputThumbnail"},
		Thumbnail: thumbnail,
		Width:     width,
		Height:    height,
	}

	return &inputThumbnailTemp
}

// UnmarshalJSON unmarshal to json
func (inputThumbnail *InputThumbnail) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Width  int32 `json:"width"`  // Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown
		Height int32 `json:"height"` // Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputThumbnail.tdCommon = tempObj.tdCommon
	inputThumbnail.Width = tempObj.Width
	inputThumbnail.Height = tempObj.Height

	fieldThumbnail, _ := unmarshalInputFile(objMap["thumbnail"])
	inputThumbnail.Thumbnail = fieldThumbnail

	return nil
}

// InputPaidMediaTypePhoto The media is a photo. The photo must be at most 10 MB in size. The photo's width and height must not exceed 10000 in total. Width and height ratio must be at most 20
type InputPaidMediaTypePhoto struct {
	tdCommon
}

// MessageType return the string telegram-type of InputPaidMediaTypePhoto
func (inputPaidMediaTypePhoto *InputPaidMediaTypePhoto) MessageType() string {
	return "inputPaidMediaTypePhoto"
}

// NewInputPaidMediaTypePhoto creates a new InputPaidMediaTypePhoto
//
func NewInputPaidMediaTypePhoto() *InputPaidMediaTypePhoto {
	inputPaidMediaTypePhotoTemp := InputPaidMediaTypePhoto{
		tdCommon: tdCommon{Type: "inputPaidMediaTypePhoto"},
	}

	return &inputPaidMediaTypePhotoTemp
}

// UnmarshalJSON unmarshal to json
func (inputPaidMediaTypePhoto *InputPaidMediaTypePhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPaidMediaTypePhoto.tdCommon = tempObj.tdCommon

	return nil
}

// GetInputPaidMediaTypeEnum return the enum type of this object
func (inputPaidMediaTypePhoto *InputPaidMediaTypePhoto) GetInputPaidMediaTypeEnum() InputPaidMediaTypeEnum {
	return InputPaidMediaTypePhotoType
}

// InputPaidMediaTypeVideo The media is a video
type InputPaidMediaTypeVideo struct {
	tdCommon
	Duration          int32 `json:"duration"`           // Duration of the video, in seconds
	SupportsStreaming bool  `json:"supports_streaming"` // True, if the video is supposed to be streamed
}

// MessageType return the string telegram-type of InputPaidMediaTypeVideo
func (inputPaidMediaTypeVideo *InputPaidMediaTypeVideo) MessageType() string {
	return "inputPaidMediaTypeVideo"
}

// NewInputPaidMediaTypeVideo creates a new InputPaidMediaTypeVideo
//
// @param duration Duration of the video, in seconds
// @param supportsStreaming True, if the video is supposed to be streamed
func NewInputPaidMediaTypeVideo(duration int32, supportsStreaming bool) *InputPaidMediaTypeVideo {
	inputPaidMediaTypeVideoTemp := InputPaidMediaTypeVideo{
		tdCommon:          tdCommon{Type: "inputPaidMediaTypeVideo"},
		Duration:          duration,
		SupportsStreaming: supportsStreaming,
	}

	return &inputPaidMediaTypeVideoTemp
}

// UnmarshalJSON unmarshal to json
func (inputPaidMediaTypeVideo *InputPaidMediaTypeVideo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Duration          int32 `json:"duration"`           // Duration of the video, in seconds
		SupportsStreaming bool  `json:"supports_streaming"` // True, if the video is supposed to be streamed
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPaidMediaTypeVideo.tdCommon = tempObj.tdCommon
	inputPaidMediaTypeVideo.Duration = tempObj.Duration
	inputPaidMediaTypeVideo.SupportsStreaming = tempObj.SupportsStreaming

	return nil
}

// GetInputPaidMediaTypeEnum return the enum type of this object
func (inputPaidMediaTypeVideo *InputPaidMediaTypeVideo) GetInputPaidMediaTypeEnum() InputPaidMediaTypeEnum {
	return InputPaidMediaTypeVideoType
}

// InputPaidMedia Describes a paid media to be sent
type InputPaidMedia struct {
	tdCommon
	Type                InputPaidMediaType `json:"type"`                   // Type of the media
	Media               InputFile          `json:"media"`                  // Photo or video to be sent
	Thumbnail           *InputThumbnail    `json:"thumbnail"`              // Media thumbnail; pass null to skip thumbnail uploading
	AddedStickerFileIDs []int32            `json:"added_sticker_file_ids"` // File identifiers of the stickers added to the media, if applicable
	Width               int32              `json:"width"`                  // Media width
	Height              int32              `json:"height"`                 // Media height
}

// MessageType return the string telegram-type of InputPaidMedia
func (inputPaidMedia *InputPaidMedia) MessageType() string {
	return "inputPaidMedia"
}

// NewInputPaidMedia creates a new InputPaidMedia
//
// @param typeParam Type of the media
// @param media Photo or video to be sent
// @param thumbnail Media thumbnail; pass null to skip thumbnail uploading
// @param addedStickerFileIDs File identifiers of the stickers added to the media, if applicable
// @param width Media width
// @param height Media height
func NewInputPaidMedia(typeParam InputPaidMediaType, media InputFile, thumbnail *InputThumbnail, addedStickerFileIDs []int32, width int32, height int32) *InputPaidMedia {
	inputPaidMediaTemp := InputPaidMedia{
		tdCommon:            tdCommon{Type: "inputPaidMedia"},
		Type:                typeParam,
		Media:               media,
		Thumbnail:           thumbnail,
		AddedStickerFileIDs: addedStickerFileIDs,
		Width:               width,
		Height:              height,
	}

	return &inputPaidMediaTemp
}

// UnmarshalJSON unmarshal to json
func (inputPaidMedia *InputPaidMedia) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		AddedStickerFileIDs []int32 `json:"added_sticker_file_ids"` // File identifiers of the stickers added to the media, if applicable
		Width               int32   `json:"width"`                  // Media width
		Height              int32   `json:"height"`                 // Media height
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputPaidMedia.tdCommon = tempObj.tdCommon
	inputPaidMedia.AddedStickerFileIDs = tempObj.AddedStickerFileIDs
	inputPaidMedia.Width = tempObj.Width
	inputPaidMedia.Height = tempObj.Height

	fieldType, _ := unmarshalInputPaidMediaType(objMap["type"])
	inputPaidMedia.Type = fieldType

	fieldMedia, _ := unmarshalInputFile(objMap["media"])
	inputPaidMedia.Media = fieldMedia

	var thumbnail InputThumbnail
	if objMap["thumbnail"] != nil {
		err = thumbnail.UnmarshalJSON(*objMap["thumbnail"])
		if err != nil {
			return err
		}
	}

	inputPaidMedia.Thumbnail = &thumbnail

	return nil
}

// MessageSchedulingStateSendAtDate The message will be sent at the specified date
type MessageSchedulingStateSendAtDate struct {
	tdCommon
	SendDate int32 `json:"send_date"` // Point in time (Unix timestamp) when the message will be sent. The date must be within 367 days in the future
}

// MessageType return the string telegram-type of MessageSchedulingStateSendAtDate
func (messageSchedulingStateSendAtDate *MessageSchedulingStateSendAtDate) MessageType() string {
	return "messageSchedulingStateSendAtDate"
}

// NewMessageSchedulingStateSendAtDate creates a new MessageSchedulingStateSendAtDate
//
// @param sendDate Point in time (Unix timestamp) when the message will be sent. The date must be within 367 days in the future
func NewMessageSchedulingStateSendAtDate(sendDate int32) *MessageSchedulingStateSendAtDate {
	messageSchedulingStateSendAtDateTemp := MessageSchedulingStateSendAtDate{
		tdCommon: tdCommon{Type: "messageSchedulingStateSendAtDate"},
		SendDate: sendDate,
	}

	return &messageSchedulingStateSendAtDateTemp
}

// UnmarshalJSON unmarshal to json
func (messageSchedulingStateSendAtDate *MessageSchedulingStateSendAtDate) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SendDate int32 `json:"send_date"` // Point in time (Unix timestamp) when the message will be sent. The date must be within 367 days in the future
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSchedulingStateSendAtDate.tdCommon = tempObj.tdCommon
	messageSchedulingStateSendAtDate.SendDate = tempObj.SendDate

	return nil
}

// GetMessageSchedulingStateEnum return the enum type of this object
func (messageSchedulingStateSendAtDate *MessageSchedulingStateSendAtDate) GetMessageSchedulingStateEnum() MessageSchedulingStateEnum {
	return MessageSchedulingStateSendAtDateType
}

// MessageSchedulingStateSendWhenOnline The message will be sent when the other user is online. Applicable to private chats only and when the exact online status of the other user is known
type MessageSchedulingStateSendWhenOnline struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageSchedulingStateSendWhenOnline
func (messageSchedulingStateSendWhenOnline *MessageSchedulingStateSendWhenOnline) MessageType() string {
	return "messageSchedulingStateSendWhenOnline"
}

// NewMessageSchedulingStateSendWhenOnline creates a new MessageSchedulingStateSendWhenOnline
//
func NewMessageSchedulingStateSendWhenOnline() *MessageSchedulingStateSendWhenOnline {
	messageSchedulingStateSendWhenOnlineTemp := MessageSchedulingStateSendWhenOnline{
		tdCommon: tdCommon{Type: "messageSchedulingStateSendWhenOnline"},
	}

	return &messageSchedulingStateSendWhenOnlineTemp
}

// UnmarshalJSON unmarshal to json
func (messageSchedulingStateSendWhenOnline *MessageSchedulingStateSendWhenOnline) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSchedulingStateSendWhenOnline.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageSchedulingStateEnum return the enum type of this object
func (messageSchedulingStateSendWhenOnline *MessageSchedulingStateSendWhenOnline) GetMessageSchedulingStateEnum() MessageSchedulingStateEnum {
	return MessageSchedulingStateSendWhenOnlineType
}

// MessageSelfDestructTypeTimer The message will be self-destructed in the specified time after its content was opened
type MessageSelfDestructTypeTimer struct {
	tdCommon
	SelfDestructTime int32 `json:"self_destruct_time"` // The message's self-destruct time, in seconds; must be between 0 and 60 in private chats
}

// MessageType return the string telegram-type of MessageSelfDestructTypeTimer
func (messageSelfDestructTypeTimer *MessageSelfDestructTypeTimer) MessageType() string {
	return "messageSelfDestructTypeTimer"
}

// NewMessageSelfDestructTypeTimer creates a new MessageSelfDestructTypeTimer
//
// @param selfDestructTime The message's self-destruct time, in seconds; must be between 0 and 60 in private chats
func NewMessageSelfDestructTypeTimer(selfDestructTime int32) *MessageSelfDestructTypeTimer {
	messageSelfDestructTypeTimerTemp := MessageSelfDestructTypeTimer{
		tdCommon:         tdCommon{Type: "messageSelfDestructTypeTimer"},
		SelfDestructTime: selfDestructTime,
	}

	return &messageSelfDestructTypeTimerTemp
}

// UnmarshalJSON unmarshal to json
func (messageSelfDestructTypeTimer *MessageSelfDestructTypeTimer) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SelfDestructTime int32 `json:"self_destruct_time"` // The message's self-destruct time, in seconds; must be between 0 and 60 in private chats
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSelfDestructTypeTimer.tdCommon = tempObj.tdCommon
	messageSelfDestructTypeTimer.SelfDestructTime = tempObj.SelfDestructTime

	return nil
}

// GetMessageSelfDestructTypeEnum return the enum type of this object
func (messageSelfDestructTypeTimer *MessageSelfDestructTypeTimer) GetMessageSelfDestructTypeEnum() MessageSelfDestructTypeEnum {
	return MessageSelfDestructTypeTimerType
}

// MessageSelfDestructTypeImmediately The message can be opened only once and will be self-destructed once closed
type MessageSelfDestructTypeImmediately struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageSelfDestructTypeImmediately
func (messageSelfDestructTypeImmediately *MessageSelfDestructTypeImmediately) MessageType() string {
	return "messageSelfDestructTypeImmediately"
}

// NewMessageSelfDestructTypeImmediately creates a new MessageSelfDestructTypeImmediately
//
func NewMessageSelfDestructTypeImmediately() *MessageSelfDestructTypeImmediately {
	messageSelfDestructTypeImmediatelyTemp := MessageSelfDestructTypeImmediately{
		tdCommon: tdCommon{Type: "messageSelfDestructTypeImmediately"},
	}

	return &messageSelfDestructTypeImmediatelyTemp
}

// UnmarshalJSON unmarshal to json
func (messageSelfDestructTypeImmediately *MessageSelfDestructTypeImmediately) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSelfDestructTypeImmediately.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageSelfDestructTypeEnum return the enum type of this object
func (messageSelfDestructTypeImmediately *MessageSelfDestructTypeImmediately) GetMessageSelfDestructTypeEnum() MessageSelfDestructTypeEnum {
	return MessageSelfDestructTypeImmediatelyType
}

// MessageSendOptions Options to be used when a message is sent
type MessageSendOptions struct {
	tdCommon
	DisableNotification               bool                   `json:"disable_notification"`                   // Pass true to disable notification for the message
	FromBackground                    bool                   `json:"from_background"`                        // Pass true if the message is sent from the background
	ProtectContent                    bool                   `json:"protect_content"`                        // Pass true if the content of the message must be protected from forwarding and saving; for bots only
	UpdateOrderOfInstalledStickerSets bool                   `json:"update_order_of_installed_sticker_sets"` // Pass true if the user explicitly chosen a sticker or a custom emoji from an installed sticker set; applicable only to sendMessage and sendMessageAlbum
	SchedulingState                   MessageSchedulingState `json:"scheduling_state"`                       // Message scheduling state; pass null to send message immediately. Messages sent to a secret chat, live location messages and self-destructing messages can't be scheduled
	EffectID                          JSONInt64              `json:"effect_id"`                              // Identifier of the effect to apply to the message; pass 0 if none; applicable only to sendMessage and sendMessageAlbum in private chats
	SendingID                         int32                  `json:"sending_id"`                             // Non-persistent identifier, which will be returned back in messageSendingStatePending object and can be used to match sent messages and corresponding updateNewMessage updates
	OnlyPreview                       bool                   `json:"only_preview"`                           // Pass true to get a fake message instead of actually sending them
}

// MessageType return the string telegram-type of MessageSendOptions
func (messageSendOptions *MessageSendOptions) MessageType() string {
	return "messageSendOptions"
}

// NewMessageSendOptions creates a new MessageSendOptions
//
// @param disableNotification Pass true to disable notification for the message
// @param fromBackground Pass true if the message is sent from the background
// @param protectContent Pass true if the content of the message must be protected from forwarding and saving; for bots only
// @param updateOrderOfInstalledStickerSets Pass true if the user explicitly chosen a sticker or a custom emoji from an installed sticker set; applicable only to sendMessage and sendMessageAlbum
// @param schedulingState Message scheduling state; pass null to send message immediately. Messages sent to a secret chat, live location messages and self-destructing messages can't be scheduled
// @param effectID Identifier of the effect to apply to the message; pass 0 if none; applicable only to sendMessage and sendMessageAlbum in private chats
// @param sendingID Non-persistent identifier, which will be returned back in messageSendingStatePending object and can be used to match sent messages and corresponding updateNewMessage updates
// @param onlyPreview Pass true to get a fake message instead of actually sending them
func NewMessageSendOptions(disableNotification bool, fromBackground bool, protectContent bool, updateOrderOfInstalledStickerSets bool, schedulingState MessageSchedulingState, effectID JSONInt64, sendingID int32, onlyPreview bool) *MessageSendOptions {
	messageSendOptionsTemp := MessageSendOptions{
		tdCommon:                          tdCommon{Type: "messageSendOptions"},
		DisableNotification:               disableNotification,
		FromBackground:                    fromBackground,
		ProtectContent:                    protectContent,
		UpdateOrderOfInstalledStickerSets: updateOrderOfInstalledStickerSets,
		SchedulingState:                   schedulingState,
		EffectID:                          effectID,
		SendingID:                         sendingID,
		OnlyPreview:                       onlyPreview,
	}

	return &messageSendOptionsTemp
}

// UnmarshalJSON unmarshal to json
func (messageSendOptions *MessageSendOptions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		DisableNotification               bool      `json:"disable_notification"`                   // Pass true to disable notification for the message
		FromBackground                    bool      `json:"from_background"`                        // Pass true if the message is sent from the background
		ProtectContent                    bool      `json:"protect_content"`                        // Pass true if the content of the message must be protected from forwarding and saving; for bots only
		UpdateOrderOfInstalledStickerSets bool      `json:"update_order_of_installed_sticker_sets"` // Pass true if the user explicitly chosen a sticker or a custom emoji from an installed sticker set; applicable only to sendMessage and sendMessageAlbum
		EffectID                          JSONInt64 `json:"effect_id"`                              // Identifier of the effect to apply to the message; pass 0 if none; applicable only to sendMessage and sendMessageAlbum in private chats
		SendingID                         int32     `json:"sending_id"`                             // Non-persistent identifier, which will be returned back in messageSendingStatePending object and can be used to match sent messages and corresponding updateNewMessage updates
		OnlyPreview                       bool      `json:"only_preview"`                           // Pass true to get a fake message instead of actually sending them
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageSendOptions.tdCommon = tempObj.tdCommon
	messageSendOptions.DisableNotification = tempObj.DisableNotification
	messageSendOptions.FromBackground = tempObj.FromBackground
	messageSendOptions.ProtectContent = tempObj.ProtectContent
	messageSendOptions.UpdateOrderOfInstalledStickerSets = tempObj.UpdateOrderOfInstalledStickerSets
	messageSendOptions.EffectID = tempObj.EffectID
	messageSendOptions.SendingID = tempObj.SendingID
	messageSendOptions.OnlyPreview = tempObj.OnlyPreview

	fieldSchedulingState, _ := unmarshalMessageSchedulingState(objMap["scheduling_state"])
	messageSendOptions.SchedulingState = fieldSchedulingState

	return nil
}

// MessageCopyOptions Options to be used when a message content is copied without reference to the original sender. Service messages, messages with messageInvoice, messagePaidMedia, messageGiveaway, or messageGiveawayWinners content can't be copied
type MessageCopyOptions struct {
	tdCommon
	SendCopy                 bool           `json:"send_copy"`                    // True, if content of the message needs to be copied without reference to the original sender. Always true if the message is forwarded to a secret chat or is local
	ReplaceCaption           bool           `json:"replace_caption"`              // True, if media caption of the message copy needs to be replaced. Ignored if send_copy is false
	NewCaption               *FormattedText `json:"new_caption"`                  // New message caption; pass null to copy message without caption. Ignored if replace_caption is false
	NewShowCaptionAboveMedia bool           `json:"new_show_caption_above_media"` // True, if new caption must be shown above the animation; otherwise, new caption must be shown below the animation; not supported in secret chats. Ignored if replace_caption is false
}

// MessageType return the string telegram-type of MessageCopyOptions
func (messageCopyOptions *MessageCopyOptions) MessageType() string {
	return "messageCopyOptions"
}

// NewMessageCopyOptions creates a new MessageCopyOptions
//
// @param sendCopy True, if content of the message needs to be copied without reference to the original sender. Always true if the message is forwarded to a secret chat or is local
// @param replaceCaption True, if media caption of the message copy needs to be replaced. Ignored if send_copy is false
// @param newCaption New message caption; pass null to copy message without caption. Ignored if replace_caption is false
// @param newShowCaptionAboveMedia True, if new caption must be shown above the animation; otherwise, new caption must be shown below the animation; not supported in secret chats. Ignored if replace_caption is false
func NewMessageCopyOptions(sendCopy bool, replaceCaption bool, newCaption *FormattedText, newShowCaptionAboveMedia bool) *MessageCopyOptions {
	messageCopyOptionsTemp := MessageCopyOptions{
		tdCommon:                 tdCommon{Type: "messageCopyOptions"},
		SendCopy:                 sendCopy,
		ReplaceCaption:           replaceCaption,
		NewCaption:               newCaption,
		NewShowCaptionAboveMedia: newShowCaptionAboveMedia,
	}

	return &messageCopyOptionsTemp
}

// UnmarshalJSON unmarshal to json
func (messageCopyOptions *MessageCopyOptions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SendCopy                 bool           `json:"send_copy"`                    // True, if content of the message needs to be copied without reference to the original sender. Always true if the message is forwarded to a secret chat or is local
		ReplaceCaption           bool           `json:"replace_caption"`              // True, if media caption of the message copy needs to be replaced. Ignored if send_copy is false
		NewCaption               *FormattedText `json:"new_caption"`                  // New message caption; pass null to copy message without caption. Ignored if replace_caption is false
		NewShowCaptionAboveMedia bool           `json:"new_show_caption_above_media"` // True, if new caption must be shown above the animation; otherwise, new caption must be shown below the animation; not supported in secret chats. Ignored if replace_caption is false
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageCopyOptions.tdCommon = tempObj.tdCommon
	messageCopyOptions.SendCopy = tempObj.SendCopy
	messageCopyOptions.ReplaceCaption = tempObj.ReplaceCaption
	messageCopyOptions.NewCaption = tempObj.NewCaption
	messageCopyOptions.NewShowCaptionAboveMedia = tempObj.NewShowCaptionAboveMedia

	return nil
}

// InputMessageText A text message
type InputMessageText struct {
	tdCommon
	Text               *FormattedText      `json:"text"`                 // Formatted text to be sent; 0-getOption("message_text_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, BlockQuote, ExpandableBlockQuote, Code, Pre, PreCode, TextUrl and MentionName entities are allowed to be specified manually
	LinkPreviewOptions *LinkPreviewOptions `json:"link_preview_options"` // Options to be used for generation of a link preview; may be null if none; pass null to use default link preview options
	ClearDraft         bool                `json:"clear_draft"`          // True, if a chat message draft must be deleted
}

// MessageType return the string telegram-type of InputMessageText
func (inputMessageText *InputMessageText) MessageType() string {
	return "inputMessageText"
}

// NewInputMessageText creates a new InputMessageText
//
// @param text Formatted text to be sent; 0-getOption("message_text_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, BlockQuote, ExpandableBlockQuote, Code, Pre, PreCode, TextUrl and MentionName entities are allowed to be specified manually
// @param linkPreviewOptions Options to be used for generation of a link preview; may be null if none; pass null to use default link preview options
// @param clearDraft True, if a chat message draft must be deleted
func NewInputMessageText(text *FormattedText, linkPreviewOptions *LinkPreviewOptions, clearDraft bool) *InputMessageText {
	inputMessageTextTemp := InputMessageText{
		tdCommon:           tdCommon{Type: "inputMessageText"},
		Text:               text,
		LinkPreviewOptions: linkPreviewOptions,
		ClearDraft:         clearDraft,
	}

	return &inputMessageTextTemp
}

// UnmarshalJSON unmarshal to json
func (inputMessageText *InputMessageText) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Text               *FormattedText      `json:"text"`                 // Formatted text to be sent; 0-getOption("message_text_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, BlockQuote, ExpandableBlockQuote, Code, Pre, PreCode, TextUrl and MentionName entities are allowed to be specified manually
		LinkPreviewOptions *LinkPreviewOptions `json:"link_preview_options"` // Options to be used for generation of a link preview; may be null if none; pass null to use default link preview options
		ClearDraft         bool                `json:"clear_draft"`          // True, if a chat message draft must be deleted
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputMessageText.tdCommon = tempObj.tdCommon
	inputMessageText.Text = tempObj.Text
	inputMessageText.LinkPreviewOptions = tempObj.LinkPreviewOptions
	inputMessageText.ClearDraft = tempObj.ClearDraft

	return nil
}

// GetInputMessageContentEnum return the enum type of this object
func (inputMessageText *InputMessageText) GetInputMessageContentEnum() InputMessageContentEnum {
	return InputMessageTextType
}

// InputMessageAnimation An animation message (GIF-style).
type InputMessageAnimation struct {
	tdCommon
	Animation             InputFile       `json:"animation"`                // Animation file to be sent
	Thumbnail             *InputThumbnail `json:"thumbnail"`                // Animation thumbnail; pass null to skip thumbnail uploading
	AddedStickerFileIDs   []int32         `json:"added_sticker_file_ids"`   // File identifiers of the stickers added to the animation, if applicable
	Duration              int32           `json:"duration"`                 // Duration of the animation, in seconds
	Width                 int32           `json:"width"`                    // Width of the animation; may be replaced by the server
	Height                int32           `json:"height"`                   // Height of the animation; may be replaced by the server
	Caption               *FormattedText  `json:"caption"`                  // Animation caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
	ShowCaptionAboveMedia bool            `json:"show_caption_above_media"` // True, if the caption must be shown above the animation; otherwise, the caption must be shown below the animation; not supported in secret chats
	HasSpoiler            bool            `json:"has_spoiler"`              // True, if the animation preview must be covered by a spoiler animation; not supported in secret chats
}

// MessageType return the string telegram-type of InputMessageAnimation
func (inputMessageAnimation *InputMessageAnimation) MessageType() string {
	return "inputMessageAnimation"
}

// NewInputMessageAnimation creates a new InputMessageAnimation
//
// @param animation Animation file to be sent
// @param thumbnail Animation thumbnail; pass null to skip thumbnail uploading
// @param addedStickerFileIDs File identifiers of the stickers added to the animation, if applicable
// @param duration Duration of the animation, in seconds
// @param width Width of the animation; may be replaced by the server
// @param height Height of the animation; may be replaced by the server
// @param caption Animation caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
// @param showCaptionAboveMedia True, if the caption must be shown above the animation; otherwise, the caption must be shown below the animation; not supported in secret chats
// @param hasSpoiler True, if the animation preview must be covered by a spoiler animation; not supported in secret chats
func NewInputMessageAnimation(animation InputFile, thumbnail *InputThumbnail, addedStickerFileIDs []int32, duration int32, width int32, height int32, caption *FormattedText, showCaptionAboveMedia bool, hasSpoiler bool) *InputMessageAnimation {
	inputMessageAnimationTemp := InputMessageAnimation{
		tdCommon:              tdCommon{Type: "inputMessageAnimation"},
		Animation:             animation,
		Thumbnail:             thumbnail,
		AddedStickerFileIDs:   addedStickerFileIDs,
		Duration:              duration,
		Width:                 width,
		Height:                height,
		Caption:               caption,
		ShowCaptionAboveMedia: showCaptionAboveMedia,
		HasSpoiler:            hasSpoiler,
	}

	return &inputMessageAnimationTemp
}

// UnmarshalJSON unmarshal to json
func (inputMessageAnimation *InputMessageAnimation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		AddedStickerFileIDs   []int32        `json:"added_sticker_file_ids"`   // File identifiers of the stickers added to the animation, if applicable
		Duration              int32          `json:"duration"`                 // Duration of the animation, in seconds
		Width                 int32          `json:"width"`                    // Width of the animation; may be replaced by the server
		Height                int32          `json:"height"`                   // Height of the animation; may be replaced by the server
		Caption               *FormattedText `json:"caption"`                  // Animation caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
		ShowCaptionAboveMedia bool           `json:"show_caption_above_media"` // True, if the caption must be shown above the animation; otherwise, the caption must be shown below the animation; not supported in secret chats
		HasSpoiler            bool           `json:"has_spoiler"`              // True, if the animation preview must be covered by a spoiler animation; not supported in secret chats
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputMessageAnimation.tdCommon = tempObj.tdCommon
	inputMessageAnimation.AddedStickerFileIDs = tempObj.AddedStickerFileIDs
	inputMessageAnimation.Duration = tempObj.Duration
	inputMessageAnimation.Width = tempObj.Width
	inputMessageAnimation.Height = tempObj.Height
	inputMessageAnimation.Caption = tempObj.Caption
	inputMessageAnimation.ShowCaptionAboveMedia = tempObj.ShowCaptionAboveMedia
	inputMessageAnimation.HasSpoiler = tempObj.HasSpoiler

	fieldAnimation, _ := unmarshalInputFile(objMap["animation"])
	inputMessageAnimation.Animation = fieldAnimation

	var thumbnail InputThumbnail
	if objMap["thumbnail"] != nil {
		err = thumbnail.UnmarshalJSON(*objMap["thumbnail"])
		if err != nil {
			return err
		}
	}

	inputMessageAnimation.Thumbnail = &thumbnail

	return nil
}

// GetInputMessageContentEnum return the enum type of this object
func (inputMessageAnimation *InputMessageAnimation) GetInputMessageContentEnum() InputMessageContentEnum {
	return InputMessageAnimationType
}

// InputMessageAudio An audio message
type InputMessageAudio struct {
	tdCommon
	Audio               InputFile       `json:"audio"`                 // Audio file to be sent
	AlbumCoverThumbnail *InputThumbnail `json:"album_cover_thumbnail"` // Thumbnail of the cover for the album; pass null to skip thumbnail uploading
	Duration            int32           `json:"duration"`              // Duration of the audio, in seconds; may be replaced by the server
	Title               string          `json:"title"`                 // Title of the audio; 0-64 characters; may be replaced by the server
	Performer           string          `json:"performer"`             // Performer of the audio; 0-64 characters, may be replaced by the server
	Caption             *FormattedText  `json:"caption"`               // Audio caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
}

// MessageType return the string telegram-type of InputMessageAudio
func (inputMessageAudio *InputMessageAudio) MessageType() string {
	return "inputMessageAudio"
}

// NewInputMessageAudio creates a new InputMessageAudio
//
// @param audio Audio file to be sent
// @param albumCoverThumbnail Thumbnail of the cover for the album; pass null to skip thumbnail uploading
// @param duration Duration of the audio, in seconds; may be replaced by the server
// @param title Title of the audio; 0-64 characters; may be replaced by the server
// @param performer Performer of the audio; 0-64 characters, may be replaced by the server
// @param caption Audio caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
func NewInputMessageAudio(audio InputFile, albumCoverThumbnail *InputThumbnail, duration int32, title string, performer string, caption *FormattedText) *InputMessageAudio {
	inputMessageAudioTemp := InputMessageAudio{
		tdCommon:            tdCommon{Type: "inputMessageAudio"},
		Audio:               audio,
		AlbumCoverThumbnail: albumCoverThumbnail,
		Duration:            duration,
		Title:               title,
		Performer:           performer,
		Caption:             caption,
	}

	return &inputMessageAudioTemp
}

// UnmarshalJSON unmarshal to json
func (inputMessageAudio *InputMessageAudio) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Duration  int32          `json:"duration"`  // Duration of the audio, in seconds; may be replaced by the server
		Title     string         `json:"title"`     // Title of the audio; 0-64 characters; may be replaced by the server
		Performer string         `json:"performer"` // Performer of the audio; 0-64 characters, may be replaced by the server
		Caption   *FormattedText `json:"caption"`   // Audio caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputMessageAudio.tdCommon = tempObj.tdCommon
	inputMessageAudio.Duration = tempObj.Duration
	inputMessageAudio.Title = tempObj.Title
	inputMessageAudio.Performer = tempObj.Performer
	inputMessageAudio.Caption = tempObj.Caption

	fieldAudio, _ := unmarshalInputFile(objMap["audio"])
	inputMessageAudio.Audio = fieldAudio

	var albumCoverThumbnail InputThumbnail
	if objMap["album_cover_thumbnail"] != nil {
		err = albumCoverThumbnail.UnmarshalJSON(*objMap["album_cover_thumbnail"])
		if err != nil {
			return err
		}
	}

	inputMessageAudio.AlbumCoverThumbnail = &albumCoverThumbnail

	return nil
}

// GetInputMessageContentEnum return the enum type of this object
func (inputMessageAudio *InputMessageAudio) GetInputMessageContentEnum() InputMessageContentEnum {
	return InputMessageAudioType
}

// InputMessageDocument A document message (general file)
type InputMessageDocument struct {
	tdCommon
	Document                    InputFile       `json:"document"`                       // Document to be sent
	Thumbnail                   *InputThumbnail `json:"thumbnail"`                      // Document thumbnail; pass null to skip thumbnail uploading
	DisableContentTypeDetection bool            `json:"disable_content_type_detection"` // Pass true to disable automatic file type detection and send the document as a file. Always true for files sent to secret chats
	Caption                     *FormattedText  `json:"caption"`                        // Document caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
}

// MessageType return the string telegram-type of InputMessageDocument
func (inputMessageDocument *InputMessageDocument) MessageType() string {
	return "inputMessageDocument"
}

// NewInputMessageDocument creates a new InputMessageDocument
//
// @param document Document to be sent
// @param thumbnail Document thumbnail; pass null to skip thumbnail uploading
// @param disableContentTypeDetection Pass true to disable automatic file type detection and send the document as a file. Always true for files sent to secret chats
// @param caption Document caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
func NewInputMessageDocument(document InputFile, thumbnail *InputThumbnail, disableContentTypeDetection bool, caption *FormattedText) *InputMessageDocument {
	inputMessageDocumentTemp := InputMessageDocument{
		tdCommon:                    tdCommon{Type: "inputMessageDocument"},
		Document:                    document,
		Thumbnail:                   thumbnail,
		DisableContentTypeDetection: disableContentTypeDetection,
		Caption:                     caption,
	}

	return &inputMessageDocumentTemp
}

// UnmarshalJSON unmarshal to json
func (inputMessageDocument *InputMessageDocument) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		DisableContentTypeDetection bool           `json:"disable_content_type_detection"` // Pass true to disable automatic file type detection and send the document as a file. Always true for files sent to secret chats
		Caption                     *FormattedText `json:"caption"`                        // Document caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputMessageDocument.tdCommon = tempObj.tdCommon
	inputMessageDocument.DisableContentTypeDetection = tempObj.DisableContentTypeDetection
	inputMessageDocument.Caption = tempObj.Caption

	fieldDocument, _ := unmarshalInputFile(objMap["document"])
	inputMessageDocument.Document = fieldDocument

	var thumbnail InputThumbnail
	if objMap["thumbnail"] != nil {
		err = thumbnail.UnmarshalJSON(*objMap["thumbnail"])
		if err != nil {
			return err
		}
	}

	inputMessageDocument.Thumbnail = &thumbnail

	return nil
}

// GetInputMessageContentEnum return the enum type of this object
func (inputMessageDocument *InputMessageDocument) GetInputMessageContentEnum() InputMessageContentEnum {
	return InputMessageDocumentType
}

// InputMessagePaidMedia A message with paid media; can be used only in channel chats with supergroupFullInfo.has_paid_media_allowed
type InputMessagePaidMedia struct {
	tdCommon
	StarCount             int64            `json:"star_count"`               // The number of Telegram Stars that must be paid to see the media; 1-getOption("paid_media_message_star_count_max")
	PaidMedia             []InputPaidMedia `json:"paid_media"`               // The content of the paid media
	Caption               *FormattedText   `json:"caption"`                  // Message caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
	ShowCaptionAboveMedia bool             `json:"show_caption_above_media"` // True, if the caption must be shown above the video; otherwise, the caption must be shown below the video; not supported in secret chats
	Payload               string           `json:"payload"`                  // Bot-provided data for the paid media; bots only
}

// MessageType return the string telegram-type of InputMessagePaidMedia
func (inputMessagePaidMedia *InputMessagePaidMedia) MessageType() string {
	return "inputMessagePaidMedia"
}

// NewInputMessagePaidMedia creates a new InputMessagePaidMedia
//
// @param starCount The number of Telegram Stars that must be paid to see the media; 1-getOption("paid_media_message_star_count_max")
// @param paidMedia The content of the paid media
// @param caption Message caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
// @param showCaptionAboveMedia True, if the caption must be shown above the video; otherwise, the caption must be shown below the video; not supported in secret chats
// @param payload Bot-provided data for the paid media; bots only
func NewInputMessagePaidMedia(starCount int64, paidMedia []InputPaidMedia, caption *FormattedText, showCaptionAboveMedia bool, payload string) *InputMessagePaidMedia {
	inputMessagePaidMediaTemp := InputMessagePaidMedia{
		tdCommon:              tdCommon{Type: "inputMessagePaidMedia"},
		StarCount:             starCount,
		PaidMedia:             paidMedia,
		Caption:               caption,
		ShowCaptionAboveMedia: showCaptionAboveMedia,
		Payload:               payload,
	}

	return &inputMessagePaidMediaTemp
}

// UnmarshalJSON unmarshal to json
func (inputMessagePaidMedia *InputMessagePaidMedia) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StarCount             int64            `json:"star_count"`               // The number of Telegram Stars that must be paid to see the media; 1-getOption("paid_media_message_star_count_max")
		PaidMedia             []InputPaidMedia `json:"paid_media"`               // The content of the paid media
		Caption               *FormattedText   `json:"caption"`                  // Message caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
		ShowCaptionAboveMedia bool             `json:"show_caption_above_media"` // True, if the caption must be shown above the video; otherwise, the caption must be shown below the video; not supported in secret chats
		Payload               string           `json:"payload"`                  // Bot-provided data for the paid media; bots only
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputMessagePaidMedia.tdCommon = tempObj.tdCommon
	inputMessagePaidMedia.StarCount = tempObj.StarCount
	inputMessagePaidMedia.PaidMedia = tempObj.PaidMedia
	inputMessagePaidMedia.Caption = tempObj.Caption
	inputMessagePaidMedia.ShowCaptionAboveMedia = tempObj.ShowCaptionAboveMedia
	inputMessagePaidMedia.Payload = tempObj.Payload

	return nil
}

// GetInputMessageContentEnum return the enum type of this object
func (inputMessagePaidMedia *InputMessagePaidMedia) GetInputMessageContentEnum() InputMessageContentEnum {
	return InputMessagePaidMediaType
}

// InputMessagePhoto A photo message
type InputMessagePhoto struct {
	tdCommon
	Photo                 InputFile               `json:"photo"`                    // Photo to send. The photo must be at most 10 MB in size. The photo's width and height must not exceed 10000 in total. Width and height ratio must be at most 20
	Thumbnail             *InputThumbnail         `json:"thumbnail"`                // Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail is sent to the other party only in secret chats
	AddedStickerFileIDs   []int32                 `json:"added_sticker_file_ids"`   // File identifiers of the stickers added to the photo, if applicable
	Width                 int32                   `json:"width"`                    // Photo width
	Height                int32                   `json:"height"`                   // Photo height
	Caption               *FormattedText          `json:"caption"`                  // Photo caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
	ShowCaptionAboveMedia bool                    `json:"show_caption_above_media"` // True, if the caption must be shown above the photo; otherwise, the caption must be shown below the photo; not supported in secret chats
	SelfDestructType      MessageSelfDestructType `json:"self_destruct_type"`       // Photo self-destruct type; pass null if none; private chats only
	HasSpoiler            bool                    `json:"has_spoiler"`              // True, if the photo preview must be covered by a spoiler animation; not supported in secret chats
}

// MessageType return the string telegram-type of InputMessagePhoto
func (inputMessagePhoto *InputMessagePhoto) MessageType() string {
	return "inputMessagePhoto"
}

// NewInputMessagePhoto creates a new InputMessagePhoto
//
// @param photo Photo to send. The photo must be at most 10 MB in size. The photo's width and height must not exceed 10000 in total. Width and height ratio must be at most 20
// @param thumbnail Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail is sent to the other party only in secret chats
// @param addedStickerFileIDs File identifiers of the stickers added to the photo, if applicable
// @param width Photo width
// @param height Photo height
// @param caption Photo caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
// @param showCaptionAboveMedia True, if the caption must be shown above the photo; otherwise, the caption must be shown below the photo; not supported in secret chats
// @param selfDestructType Photo self-destruct type; pass null if none; private chats only
// @param hasSpoiler True, if the photo preview must be covered by a spoiler animation; not supported in secret chats
func NewInputMessagePhoto(photo InputFile, thumbnail *InputThumbnail, addedStickerFileIDs []int32, width int32, height int32, caption *FormattedText, showCaptionAboveMedia bool, selfDestructType MessageSelfDestructType, hasSpoiler bool) *InputMessagePhoto {
	inputMessagePhotoTemp := InputMessagePhoto{
		tdCommon:              tdCommon{Type: "inputMessagePhoto"},
		Photo:                 photo,
		Thumbnail:             thumbnail,
		AddedStickerFileIDs:   addedStickerFileIDs,
		Width:                 width,
		Height:                height,
		Caption:               caption,
		ShowCaptionAboveMedia: showCaptionAboveMedia,
		SelfDestructType:      selfDestructType,
		HasSpoiler:            hasSpoiler,
	}

	return &inputMessagePhotoTemp
}

// UnmarshalJSON unmarshal to json
func (inputMessagePhoto *InputMessagePhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		AddedStickerFileIDs   []int32        `json:"added_sticker_file_ids"`   // File identifiers of the stickers added to the photo, if applicable
		Width                 int32          `json:"width"`                    // Photo width
		Height                int32          `json:"height"`                   // Photo height
		Caption               *FormattedText `json:"caption"`                  // Photo caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
		ShowCaptionAboveMedia bool           `json:"show_caption_above_media"` // True, if the caption must be shown above the photo; otherwise, the caption must be shown below the photo; not supported in secret chats
		HasSpoiler            bool           `json:"has_spoiler"`              // True, if the photo preview must be covered by a spoiler animation; not supported in secret chats
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputMessagePhoto.tdCommon = tempObj.tdCommon
	inputMessagePhoto.AddedStickerFileIDs = tempObj.AddedStickerFileIDs
	inputMessagePhoto.Width = tempObj.Width
	inputMessagePhoto.Height = tempObj.Height
	inputMessagePhoto.Caption = tempObj.Caption
	inputMessagePhoto.ShowCaptionAboveMedia = tempObj.ShowCaptionAboveMedia
	inputMessagePhoto.HasSpoiler = tempObj.HasSpoiler

	fieldPhoto, _ := unmarshalInputFile(objMap["photo"])
	inputMessagePhoto.Photo = fieldPhoto

	fieldSelfDestructType, _ := unmarshalMessageSelfDestructType(objMap["self_destruct_type"])
	inputMessagePhoto.SelfDestructType = fieldSelfDestructType

	var thumbnail InputThumbnail
	if objMap["thumbnail"] != nil {
		err = thumbnail.UnmarshalJSON(*objMap["thumbnail"])
		if err != nil {
			return err
		}
	}

	inputMessagePhoto.Thumbnail = &thumbnail

	return nil
}

// GetInputMessageContentEnum return the enum type of this object
func (inputMessagePhoto *InputMessagePhoto) GetInputMessageContentEnum() InputMessageContentEnum {
	return InputMessagePhotoType
}

// InputMessageSticker A sticker message
type InputMessageSticker struct {
	tdCommon
	Sticker   InputFile       `json:"sticker"`   // Sticker to be sent
	Thumbnail *InputThumbnail `json:"thumbnail"` // Sticker thumbnail; pass null to skip thumbnail uploading
	Width     int32           `json:"width"`     // Sticker width
	Height    int32           `json:"height"`    // Sticker height
	Emoji     string          `json:"emoji"`     // Emoji used to choose the sticker
}

// MessageType return the string telegram-type of InputMessageSticker
func (inputMessageSticker *InputMessageSticker) MessageType() string {
	return "inputMessageSticker"
}

// NewInputMessageSticker creates a new InputMessageSticker
//
// @param sticker Sticker to be sent
// @param thumbnail Sticker thumbnail; pass null to skip thumbnail uploading
// @param width Sticker width
// @param height Sticker height
// @param emoji Emoji used to choose the sticker
func NewInputMessageSticker(sticker InputFile, thumbnail *InputThumbnail, width int32, height int32, emoji string) *InputMessageSticker {
	inputMessageStickerTemp := InputMessageSticker{
		tdCommon:  tdCommon{Type: "inputMessageSticker"},
		Sticker:   sticker,
		Thumbnail: thumbnail,
		Width:     width,
		Height:    height,
		Emoji:     emoji,
	}

	return &inputMessageStickerTemp
}

// UnmarshalJSON unmarshal to json
func (inputMessageSticker *InputMessageSticker) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Width  int32  `json:"width"`  // Sticker width
		Height int32  `json:"height"` // Sticker height
		Emoji  string `json:"emoji"`  // Emoji used to choose the sticker
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputMessageSticker.tdCommon = tempObj.tdCommon
	inputMessageSticker.Width = tempObj.Width
	inputMessageSticker.Height = tempObj.Height
	inputMessageSticker.Emoji = tempObj.Emoji

	fieldSticker, _ := unmarshalInputFile(objMap["sticker"])
	inputMessageSticker.Sticker = fieldSticker

	var thumbnail InputThumbnail
	if objMap["thumbnail"] != nil {
		err = thumbnail.UnmarshalJSON(*objMap["thumbnail"])
		if err != nil {
			return err
		}
	}

	inputMessageSticker.Thumbnail = &thumbnail

	return nil
}

// GetInputMessageContentEnum return the enum type of this object
func (inputMessageSticker *InputMessageSticker) GetInputMessageContentEnum() InputMessageContentEnum {
	return InputMessageStickerType
}

// InputMessageVideo A video message
type InputMessageVideo struct {
	tdCommon
	Video                 InputFile               `json:"video"`                    // Video to be sent
	Thumbnail             *InputThumbnail         `json:"thumbnail"`                // Video thumbnail; pass null to skip thumbnail uploading
	AddedStickerFileIDs   []int32                 `json:"added_sticker_file_ids"`   // File identifiers of the stickers added to the video, if applicable
	Duration              int32                   `json:"duration"`                 // Duration of the video, in seconds
	Width                 int32                   `json:"width"`                    // Video width
	Height                int32                   `json:"height"`                   // Video height
	SupportsStreaming     bool                    `json:"supports_streaming"`       // True, if the video is supposed to be streamed
	Caption               *FormattedText          `json:"caption"`                  // Video caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
	ShowCaptionAboveMedia bool                    `json:"show_caption_above_media"` // True, if the caption must be shown above the video; otherwise, the caption must be shown below the video; not supported in secret chats
	SelfDestructType      MessageSelfDestructType `json:"self_destruct_type"`       // Video self-destruct type; pass null if none; private chats only
	HasSpoiler            bool                    `json:"has_spoiler"`              // True, if the video preview must be covered by a spoiler animation; not supported in secret chats
}

// MessageType return the string telegram-type of InputMessageVideo
func (inputMessageVideo *InputMessageVideo) MessageType() string {
	return "inputMessageVideo"
}

// NewInputMessageVideo creates a new InputMessageVideo
//
// @param video Video to be sent
// @param thumbnail Video thumbnail; pass null to skip thumbnail uploading
// @param addedStickerFileIDs File identifiers of the stickers added to the video, if applicable
// @param duration Duration of the video, in seconds
// @param width Video width
// @param height Video height
// @param supportsStreaming True, if the video is supposed to be streamed
// @param caption Video caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
// @param showCaptionAboveMedia True, if the caption must be shown above the video; otherwise, the caption must be shown below the video; not supported in secret chats
// @param selfDestructType Video self-destruct type; pass null if none; private chats only
// @param hasSpoiler True, if the video preview must be covered by a spoiler animation; not supported in secret chats
func NewInputMessageVideo(video InputFile, thumbnail *InputThumbnail, addedStickerFileIDs []int32, duration int32, width int32, height int32, supportsStreaming bool, caption *FormattedText, showCaptionAboveMedia bool, selfDestructType MessageSelfDestructType, hasSpoiler bool) *InputMessageVideo {
	inputMessageVideoTemp := InputMessageVideo{
		tdCommon:              tdCommon{Type: "inputMessageVideo"},
		Video:                 video,
		Thumbnail:             thumbnail,
		AddedStickerFileIDs:   addedStickerFileIDs,
		Duration:              duration,
		Width:                 width,
		Height:                height,
		SupportsStreaming:     supportsStreaming,
		Caption:               caption,
		ShowCaptionAboveMedia: showCaptionAboveMedia,
		SelfDestructType:      selfDestructType,
		HasSpoiler:            hasSpoiler,
	}

	return &inputMessageVideoTemp
}

// UnmarshalJSON unmarshal to json
func (inputMessageVideo *InputMessageVideo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		AddedStickerFileIDs   []int32        `json:"added_sticker_file_ids"`   // File identifiers of the stickers added to the video, if applicable
		Duration              int32          `json:"duration"`                 // Duration of the video, in seconds
		Width                 int32          `json:"width"`                    // Video width
		Height                int32          `json:"height"`                   // Video height
		SupportsStreaming     bool           `json:"supports_streaming"`       // True, if the video is supposed to be streamed
		Caption               *FormattedText `json:"caption"`                  // Video caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
		ShowCaptionAboveMedia bool           `json:"show_caption_above_media"` // True, if the caption must be shown above the video; otherwise, the caption must be shown below the video; not supported in secret chats
		HasSpoiler            bool           `json:"has_spoiler"`              // True, if the video preview must be covered by a spoiler animation; not supported in secret chats
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputMessageVideo.tdCommon = tempObj.tdCommon
	inputMessageVideo.AddedStickerFileIDs = tempObj.AddedStickerFileIDs
	inputMessageVideo.Duration = tempObj.Duration
	inputMessageVideo.Width = tempObj.Width
	inputMessageVideo.Height = tempObj.Height
	inputMessageVideo.SupportsStreaming = tempObj.SupportsStreaming
	inputMessageVideo.Caption = tempObj.Caption
	inputMessageVideo.ShowCaptionAboveMedia = tempObj.ShowCaptionAboveMedia
	inputMessageVideo.HasSpoiler = tempObj.HasSpoiler

	fieldVideo, _ := unmarshalInputFile(objMap["video"])
	inputMessageVideo.Video = fieldVideo

	fieldSelfDestructType, _ := unmarshalMessageSelfDestructType(objMap["self_destruct_type"])
	inputMessageVideo.SelfDestructType = fieldSelfDestructType

	var thumbnail InputThumbnail
	if objMap["thumbnail"] != nil {
		err = thumbnail.UnmarshalJSON(*objMap["thumbnail"])
		if err != nil {
			return err
		}
	}

	inputMessageVideo.Thumbnail = &thumbnail

	return nil
}

// GetInputMessageContentEnum return the enum type of this object
func (inputMessageVideo *InputMessageVideo) GetInputMessageContentEnum() InputMessageContentEnum {
	return InputMessageVideoType
}

// InputMessageVideoNote A video note message
type InputMessageVideoNote struct {
	tdCommon
	VideoNote        InputFile                `json:"video_note"`         // Video note to be sent
	Thumbnail        *InputThumbnail          `json:"thumbnail"`          // Video thumbnail; may be null if empty; pass null to skip thumbnail uploading
	Duration         int32                    `json:"duration"`           // Duration of the video, in seconds; 0-60
	Length           int32                    `json:"length"`             // Video width and height; must be positive and not greater than 640
	SelfDestructType *MessageSelfDestructType `json:"self_destruct_type"` // Video note self-destruct type; may be null if none; pass null if none; private chats only
}

// MessageType return the string telegram-type of InputMessageVideoNote
func (inputMessageVideoNote *InputMessageVideoNote) MessageType() string {
	return "inputMessageVideoNote"
}

// NewInputMessageVideoNote creates a new InputMessageVideoNote
//
// @param videoNote Video note to be sent
// @param thumbnail Video thumbnail; may be null if empty; pass null to skip thumbnail uploading
// @param duration Duration of the video, in seconds; 0-60
// @param length Video width and height; must be positive and not greater than 640
// @param selfDestructType Video note self-destruct type; may be null if none; pass null if none; private chats only
func NewInputMessageVideoNote(videoNote InputFile, thumbnail *InputThumbnail, duration int32, length int32, selfDestructType *MessageSelfDestructType) *InputMessageVideoNote {
	inputMessageVideoNoteTemp := InputMessageVideoNote{
		tdCommon:         tdCommon{Type: "inputMessageVideoNote"},
		VideoNote:        videoNote,
		Thumbnail:        thumbnail,
		Duration:         duration,
		Length:           length,
		SelfDestructType: selfDestructType,
	}

	return &inputMessageVideoNoteTemp
}

// UnmarshalJSON unmarshal to json
func (inputMessageVideoNote *InputMessageVideoNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Duration int32 `json:"duration"` // Duration of the video, in seconds; 0-60
		Length   int32 `json:"length"`   // Video width and height; must be positive and not greater than 640

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputMessageVideoNote.tdCommon = tempObj.tdCommon
	inputMessageVideoNote.Duration = tempObj.Duration
	inputMessageVideoNote.Length = tempObj.Length

	fieldVideoNote, _ := unmarshalInputFile(objMap["video_note"])
	inputMessageVideoNote.VideoNote = fieldVideoNote

	fieldSelfDestructType, _ := unmarshalMessageSelfDestructType(objMap["self_destruct_type"])
	inputMessageVideoNote.SelfDestructType = &fieldSelfDestructType

	var thumbnail InputThumbnail
	if objMap["thumbnail"] != nil {
		err = thumbnail.UnmarshalJSON(*objMap["thumbnail"])
		if err != nil {
			return err
		}
	}

	inputMessageVideoNote.Thumbnail = &thumbnail

	return nil
}

// GetInputMessageContentEnum return the enum type of this object
func (inputMessageVideoNote *InputMessageVideoNote) GetInputMessageContentEnum() InputMessageContentEnum {
	return InputMessageVideoNoteType
}

// InputMessageVoiceNote A voice note message
type InputMessageVoiceNote struct {
	tdCommon
	VoiceNote        InputFile                `json:"voice_note"`         // Voice note to be sent. The voice note must be encoded with the Opus codec and stored inside an OGG container with a single audio channel, or be in MP3 or M4A format as regular audio
	Duration         int32                    `json:"duration"`           // Duration of the voice note, in seconds
	Waveform         []byte                   `json:"waveform"`           // Waveform representation of the voice note in 5-bit format
	Caption          *FormattedText           `json:"caption"`            // Voice note caption; may be null if empty; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
	SelfDestructType *MessageSelfDestructType `json:"self_destruct_type"` // Voice note self-destruct type; may be null if none; pass null if none; private chats only
}

// MessageType return the string telegram-type of InputMessageVoiceNote
func (inputMessageVoiceNote *InputMessageVoiceNote) MessageType() string {
	return "inputMessageVoiceNote"
}

// NewInputMessageVoiceNote creates a new InputMessageVoiceNote
//
// @param voiceNote Voice note to be sent. The voice note must be encoded with the Opus codec and stored inside an OGG container with a single audio channel, or be in MP3 or M4A format as regular audio
// @param duration Duration of the voice note, in seconds
// @param waveform Waveform representation of the voice note in 5-bit format
// @param caption Voice note caption; may be null if empty; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
// @param selfDestructType Voice note self-destruct type; may be null if none; pass null if none; private chats only
func NewInputMessageVoiceNote(voiceNote InputFile, duration int32, waveform []byte, caption *FormattedText, selfDestructType *MessageSelfDestructType) *InputMessageVoiceNote {
	inputMessageVoiceNoteTemp := InputMessageVoiceNote{
		tdCommon:         tdCommon{Type: "inputMessageVoiceNote"},
		VoiceNote:        voiceNote,
		Duration:         duration,
		Waveform:         waveform,
		Caption:          caption,
		SelfDestructType: selfDestructType,
	}

	return &inputMessageVoiceNoteTemp
}

// UnmarshalJSON unmarshal to json
func (inputMessageVoiceNote *InputMessageVoiceNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Duration int32          `json:"duration"` // Duration of the voice note, in seconds
		Waveform []byte         `json:"waveform"` // Waveform representation of the voice note in 5-bit format
		Caption  *FormattedText `json:"caption"`  // Voice note caption; may be null if empty; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputMessageVoiceNote.tdCommon = tempObj.tdCommon
	inputMessageVoiceNote.Duration = tempObj.Duration
	inputMessageVoiceNote.Waveform = tempObj.Waveform
	inputMessageVoiceNote.Caption = tempObj.Caption

	fieldVoiceNote, _ := unmarshalInputFile(objMap["voice_note"])
	inputMessageVoiceNote.VoiceNote = fieldVoiceNote

	fieldSelfDestructType, _ := unmarshalMessageSelfDestructType(objMap["self_destruct_type"])
	inputMessageVoiceNote.SelfDestructType = &fieldSelfDestructType

	return nil
}

// GetInputMessageContentEnum return the enum type of this object
func (inputMessageVoiceNote *InputMessageVoiceNote) GetInputMessageContentEnum() InputMessageContentEnum {
	return InputMessageVoiceNoteType
}

// InputMessageLocation A message with a location
type InputMessageLocation struct {
	tdCommon
	Location             *Location `json:"location"`               // Location to be sent
	LivePeriod           int32     `json:"live_period"`            // Period for which the location can be updated, in seconds; must be between 60 and 86400 for a temporary live location, 0x7FFFFFFF for permanent live location, and 0 otherwise
	Heading              int32     `json:"heading"`                // For live locations, a direction in which the location moves, in degrees; 1-360. Pass 0 if unknown
	ProximityAlertRadius int32     `json:"proximity_alert_radius"` // For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled. Can't be enabled in channels and Saved Messages
}

// MessageType return the string telegram-type of InputMessageLocation
func (inputMessageLocation *InputMessageLocation) MessageType() string {
	return "inputMessageLocation"
}

// NewInputMessageLocation creates a new InputMessageLocation
//
// @param location Location to be sent
// @param livePeriod Period for which the location can be updated, in seconds; must be between 60 and 86400 for a temporary live location, 0x7FFFFFFF for permanent live location, and 0 otherwise
// @param heading For live locations, a direction in which the location moves, in degrees; 1-360. Pass 0 if unknown
// @param proximityAlertRadius For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled. Can't be enabled in channels and Saved Messages
func NewInputMessageLocation(location *Location, livePeriod int32, heading int32, proximityAlertRadius int32) *InputMessageLocation {
	inputMessageLocationTemp := InputMessageLocation{
		tdCommon:             tdCommon{Type: "inputMessageLocation"},
		Location:             location,
		LivePeriod:           livePeriod,
		Heading:              heading,
		ProximityAlertRadius: proximityAlertRadius,
	}

	return &inputMessageLocationTemp
}

// UnmarshalJSON unmarshal to json
func (inputMessageLocation *InputMessageLocation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Location             *Location `json:"location"`               // Location to be sent
		LivePeriod           int32     `json:"live_period"`            // Period for which the location can be updated, in seconds; must be between 60 and 86400 for a temporary live location, 0x7FFFFFFF for permanent live location, and 0 otherwise
		Heading              int32     `json:"heading"`                // For live locations, a direction in which the location moves, in degrees; 1-360. Pass 0 if unknown
		ProximityAlertRadius int32     `json:"proximity_alert_radius"` // For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled. Can't be enabled in channels and Saved Messages
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputMessageLocation.tdCommon = tempObj.tdCommon
	inputMessageLocation.Location = tempObj.Location
	inputMessageLocation.LivePeriod = tempObj.LivePeriod
	inputMessageLocation.Heading = tempObj.Heading
	inputMessageLocation.ProximityAlertRadius = tempObj.ProximityAlertRadius

	return nil
}

// GetInputMessageContentEnum return the enum type of this object
func (inputMessageLocation *InputMessageLocation) GetInputMessageContentEnum() InputMessageContentEnum {
	return InputMessageLocationType
}

// InputMessageVenue A message with information about a venue
type InputMessageVenue struct {
	tdCommon
	Venue *Venue `json:"venue"` // Venue to send
}

// MessageType return the string telegram-type of InputMessageVenue
func (inputMessageVenue *InputMessageVenue) MessageType() string {
	return "inputMessageVenue"
}

// NewInputMessageVenue creates a new InputMessageVenue
//
// @param venue Venue to send
func NewInputMessageVenue(venue *Venue) *InputMessageVenue {
	inputMessageVenueTemp := InputMessageVenue{
		tdCommon: tdCommon{Type: "inputMessageVenue"},
		Venue:    venue,
	}

	return &inputMessageVenueTemp
}

// UnmarshalJSON unmarshal to json
func (inputMessageVenue *InputMessageVenue) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Venue *Venue `json:"venue"` // Venue to send
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputMessageVenue.tdCommon = tempObj.tdCommon
	inputMessageVenue.Venue = tempObj.Venue

	return nil
}

// GetInputMessageContentEnum return the enum type of this object
func (inputMessageVenue *InputMessageVenue) GetInputMessageContentEnum() InputMessageContentEnum {
	return InputMessageVenueType
}

// InputMessageContact A message containing a user contact
type InputMessageContact struct {
	tdCommon
	Contact *Contact `json:"contact"` // Contact to send
}

// MessageType return the string telegram-type of InputMessageContact
func (inputMessageContact *InputMessageContact) MessageType() string {
	return "inputMessageContact"
}

// NewInputMessageContact creates a new InputMessageContact
//
// @param contact Contact to send
func NewInputMessageContact(contact *Contact) *InputMessageContact {
	inputMessageContactTemp := InputMessageContact{
		tdCommon: tdCommon{Type: "inputMessageContact"},
		Contact:  contact,
	}

	return &inputMessageContactTemp
}

// UnmarshalJSON unmarshal to json
func (inputMessageContact *InputMessageContact) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Contact *Contact `json:"contact"` // Contact to send
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputMessageContact.tdCommon = tempObj.tdCommon
	inputMessageContact.Contact = tempObj.Contact

	return nil
}

// GetInputMessageContentEnum return the enum type of this object
func (inputMessageContact *InputMessageContact) GetInputMessageContentEnum() InputMessageContentEnum {
	return InputMessageContactType
}

// InputMessageDice A dice message
type InputMessageDice struct {
	tdCommon
	Emoji      string `json:"emoji"`       // Emoji on which the dice throw animation is based
	ClearDraft bool   `json:"clear_draft"` // True, if the chat message draft must be deleted
}

// MessageType return the string telegram-type of InputMessageDice
func (inputMessageDice *InputMessageDice) MessageType() string {
	return "inputMessageDice"
}

// NewInputMessageDice creates a new InputMessageDice
//
// @param emoji Emoji on which the dice throw animation is based
// @param clearDraft True, if the chat message draft must be deleted
func NewInputMessageDice(emoji string, clearDraft bool) *InputMessageDice {
	inputMessageDiceTemp := InputMessageDice{
		tdCommon:   tdCommon{Type: "inputMessageDice"},
		Emoji:      emoji,
		ClearDraft: clearDraft,
	}

	return &inputMessageDiceTemp
}

// UnmarshalJSON unmarshal to json
func (inputMessageDice *InputMessageDice) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Emoji      string `json:"emoji"`       // Emoji on which the dice throw animation is based
		ClearDraft bool   `json:"clear_draft"` // True, if the chat message draft must be deleted
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputMessageDice.tdCommon = tempObj.tdCommon
	inputMessageDice.Emoji = tempObj.Emoji
	inputMessageDice.ClearDraft = tempObj.ClearDraft

	return nil
}

// GetInputMessageContentEnum return the enum type of this object
func (inputMessageDice *InputMessageDice) GetInputMessageContentEnum() InputMessageContentEnum {
	return InputMessageDiceType
}

// InputMessageGame A message with a game; not supported for channels or secret chats
type InputMessageGame struct {
	tdCommon
	BotUserID     int64  `json:"bot_user_id"`     // User identifier of the bot that owns the game
	GameShortName string `json:"game_short_name"` // Short name of the game
}

// MessageType return the string telegram-type of InputMessageGame
func (inputMessageGame *InputMessageGame) MessageType() string {
	return "inputMessageGame"
}

// NewInputMessageGame creates a new InputMessageGame
//
// @param botUserID User identifier of the bot that owns the game
// @param gameShortName Short name of the game
func NewInputMessageGame(botUserID int64, gameShortName string) *InputMessageGame {
	inputMessageGameTemp := InputMessageGame{
		tdCommon:      tdCommon{Type: "inputMessageGame"},
		BotUserID:     botUserID,
		GameShortName: gameShortName,
	}

	return &inputMessageGameTemp
}

// UnmarshalJSON unmarshal to json
func (inputMessageGame *InputMessageGame) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BotUserID     int64  `json:"bot_user_id"`     // User identifier of the bot that owns the game
		GameShortName string `json:"game_short_name"` // Short name of the game
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputMessageGame.tdCommon = tempObj.tdCommon
	inputMessageGame.BotUserID = tempObj.BotUserID
	inputMessageGame.GameShortName = tempObj.GameShortName

	return nil
}

// GetInputMessageContentEnum return the enum type of this object
func (inputMessageGame *InputMessageGame) GetInputMessageContentEnum() InputMessageContentEnum {
	return InputMessageGameType
}

// InputMessageInvoice A message with an invoice; can be used only by bots
type InputMessageInvoice struct {
	tdCommon
	Invoice          *Invoice        `json:"invoice"`            // Invoice
	Title            string          `json:"title"`              // Product title; 1-32 characters
	Description      string          `json:"description"`        // Product description; 0-255 characters
	PhotoURL         string          `json:"photo_url"`          // Product photo URL; optional
	PhotoSize        int32           `json:"photo_size"`         // Product photo size
	PhotoWidth       int32           `json:"photo_width"`        // Product photo width
	PhotoHeight      int32           `json:"photo_height"`       // Product photo height
	Payload          []byte          `json:"payload"`            // The invoice payload
	ProviderToken    string          `json:"provider_token"`     // Payment provider token; may be empty for payments in Telegram Stars
	ProviderData     string          `json:"provider_data"`      // JSON-encoded data about the invoice, which will be shared with the payment provider
	StartParameter   string          `json:"start_parameter"`    // Unique invoice bot deep link parameter for the generation of this invoice. If empty, it would be possible to pay directly from forwards of the invoice message
	PaidMedia        *InputPaidMedia `json:"paid_media"`         // The content of paid media attached to the invoice; pass null if none
	PaidMediaCaption *FormattedText  `json:"paid_media_caption"` // Paid media caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
}

// MessageType return the string telegram-type of InputMessageInvoice
func (inputMessageInvoice *InputMessageInvoice) MessageType() string {
	return "inputMessageInvoice"
}

// NewInputMessageInvoice creates a new InputMessageInvoice
//
// @param invoice Invoice
// @param title Product title; 1-32 characters
// @param description Product description; 0-255 characters
// @param photoURL Product photo URL; optional
// @param photoSize Product photo size
// @param photoWidth Product photo width
// @param photoHeight Product photo height
// @param payload The invoice payload
// @param providerToken Payment provider token; may be empty for payments in Telegram Stars
// @param providerData JSON-encoded data about the invoice, which will be shared with the payment provider
// @param startParameter Unique invoice bot deep link parameter for the generation of this invoice. If empty, it would be possible to pay directly from forwards of the invoice message
// @param paidMedia The content of paid media attached to the invoice; pass null if none
// @param paidMediaCaption Paid media caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
func NewInputMessageInvoice(invoice *Invoice, title string, description string, photoURL string, photoSize int32, photoWidth int32, photoHeight int32, payload []byte, providerToken string, providerData string, startParameter string, paidMedia *InputPaidMedia, paidMediaCaption *FormattedText) *InputMessageInvoice {
	inputMessageInvoiceTemp := InputMessageInvoice{
		tdCommon:         tdCommon{Type: "inputMessageInvoice"},
		Invoice:          invoice,
		Title:            title,
		Description:      description,
		PhotoURL:         photoURL,
		PhotoSize:        photoSize,
		PhotoWidth:       photoWidth,
		PhotoHeight:      photoHeight,
		Payload:          payload,
		ProviderToken:    providerToken,
		ProviderData:     providerData,
		StartParameter:   startParameter,
		PaidMedia:        paidMedia,
		PaidMediaCaption: paidMediaCaption,
	}

	return &inputMessageInvoiceTemp
}

// UnmarshalJSON unmarshal to json
func (inputMessageInvoice *InputMessageInvoice) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Invoice          *Invoice       `json:"invoice"`            // Invoice
		Title            string         `json:"title"`              // Product title; 1-32 characters
		Description      string         `json:"description"`        // Product description; 0-255 characters
		PhotoURL         string         `json:"photo_url"`          // Product photo URL; optional
		PhotoSize        int32          `json:"photo_size"`         // Product photo size
		PhotoWidth       int32          `json:"photo_width"`        // Product photo width
		PhotoHeight      int32          `json:"photo_height"`       // Product photo height
		Payload          []byte         `json:"payload"`            // The invoice payload
		ProviderToken    string         `json:"provider_token"`     // Payment provider token; may be empty for payments in Telegram Stars
		ProviderData     string         `json:"provider_data"`      // JSON-encoded data about the invoice, which will be shared with the payment provider
		StartParameter   string         `json:"start_parameter"`    // Unique invoice bot deep link parameter for the generation of this invoice. If empty, it would be possible to pay directly from forwards of the invoice message
		PaidMediaCaption *FormattedText `json:"paid_media_caption"` // Paid media caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputMessageInvoice.tdCommon = tempObj.tdCommon
	inputMessageInvoice.Invoice = tempObj.Invoice
	inputMessageInvoice.Title = tempObj.Title
	inputMessageInvoice.Description = tempObj.Description
	inputMessageInvoice.PhotoURL = tempObj.PhotoURL
	inputMessageInvoice.PhotoSize = tempObj.PhotoSize
	inputMessageInvoice.PhotoWidth = tempObj.PhotoWidth
	inputMessageInvoice.PhotoHeight = tempObj.PhotoHeight
	inputMessageInvoice.Payload = tempObj.Payload
	inputMessageInvoice.ProviderToken = tempObj.ProviderToken
	inputMessageInvoice.ProviderData = tempObj.ProviderData
	inputMessageInvoice.StartParameter = tempObj.StartParameter
	inputMessageInvoice.PaidMediaCaption = tempObj.PaidMediaCaption

	var paidMedia InputPaidMedia
	if objMap["paid_media"] != nil {
		err = paidMedia.UnmarshalJSON(*objMap["paid_media"])
		if err != nil {
			return err
		}
	}

	inputMessageInvoice.PaidMedia = &paidMedia

	return nil
}

// GetInputMessageContentEnum return the enum type of this object
func (inputMessageInvoice *InputMessageInvoice) GetInputMessageContentEnum() InputMessageContentEnum {
	return InputMessageInvoiceType
}

// InputMessagePoll A message with a poll. Polls can't be sent to secret chats. Polls can be sent only to a private chat with a bot
type InputMessagePoll struct {
	tdCommon
	Question    *FormattedText  `json:"question"`     // Poll question; 1-255 characters (up to 300 characters for bots). Only custom emoji entities are allowed to be added and only by Premium users
	Options     []FormattedText `json:"options"`      // List of poll answer options, 2-10 strings 1-100 characters each. Only custom emoji entities are allowed to be added and only by Premium users
	IsAnonymous bool            `json:"is_anonymous"` // True, if the poll voters are anonymous. Non-anonymous polls can't be sent or forwarded to channels
	Type        PollType        `json:"type"`         // Type of the poll
	OpenPeriod  int32           `json:"open_period"`  // Amount of time the poll will be active after creation, in seconds; for bots only
	CloseDate   int32           `json:"close_date"`   // Point in time (Unix timestamp) when the poll will automatically be closed; for bots only
	IsClosed    bool            `json:"is_closed"`    // True, if the poll needs to be sent already closed; for bots only
}

// MessageType return the string telegram-type of InputMessagePoll
func (inputMessagePoll *InputMessagePoll) MessageType() string {
	return "inputMessagePoll"
}

// NewInputMessagePoll creates a new InputMessagePoll
//
// @param question Poll question; 1-255 characters (up to 300 characters for bots). Only custom emoji entities are allowed to be added and only by Premium users
// @param options List of poll answer options, 2-10 strings 1-100 characters each. Only custom emoji entities are allowed to be added and only by Premium users
// @param isAnonymous True, if the poll voters are anonymous. Non-anonymous polls can't be sent or forwarded to channels
// @param typeParam Type of the poll
// @param openPeriod Amount of time the poll will be active after creation, in seconds; for bots only
// @param closeDate Point in time (Unix timestamp) when the poll will automatically be closed; for bots only
// @param isClosed True, if the poll needs to be sent already closed; for bots only
func NewInputMessagePoll(question *FormattedText, options []FormattedText, isAnonymous bool, typeParam PollType, openPeriod int32, closeDate int32, isClosed bool) *InputMessagePoll {
	inputMessagePollTemp := InputMessagePoll{
		tdCommon:    tdCommon{Type: "inputMessagePoll"},
		Question:    question,
		Options:     options,
		IsAnonymous: isAnonymous,
		Type:        typeParam,
		OpenPeriod:  openPeriod,
		CloseDate:   closeDate,
		IsClosed:    isClosed,
	}

	return &inputMessagePollTemp
}

// UnmarshalJSON unmarshal to json
func (inputMessagePoll *InputMessagePoll) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Question    *FormattedText  `json:"question"`     // Poll question; 1-255 characters (up to 300 characters for bots). Only custom emoji entities are allowed to be added and only by Premium users
		Options     []FormattedText `json:"options"`      // List of poll answer options, 2-10 strings 1-100 characters each. Only custom emoji entities are allowed to be added and only by Premium users
		IsAnonymous bool            `json:"is_anonymous"` // True, if the poll voters are anonymous. Non-anonymous polls can't be sent or forwarded to channels
		OpenPeriod  int32           `json:"open_period"`  // Amount of time the poll will be active after creation, in seconds; for bots only
		CloseDate   int32           `json:"close_date"`   // Point in time (Unix timestamp) when the poll will automatically be closed; for bots only
		IsClosed    bool            `json:"is_closed"`    // True, if the poll needs to be sent already closed; for bots only
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputMessagePoll.tdCommon = tempObj.tdCommon
	inputMessagePoll.Question = tempObj.Question
	inputMessagePoll.Options = tempObj.Options
	inputMessagePoll.IsAnonymous = tempObj.IsAnonymous
	inputMessagePoll.OpenPeriod = tempObj.OpenPeriod
	inputMessagePoll.CloseDate = tempObj.CloseDate
	inputMessagePoll.IsClosed = tempObj.IsClosed

	fieldType, _ := unmarshalPollType(objMap["type"])
	inputMessagePoll.Type = fieldType

	return nil
}

// GetInputMessageContentEnum return the enum type of this object
func (inputMessagePoll *InputMessagePoll) GetInputMessageContentEnum() InputMessageContentEnum {
	return InputMessagePollType
}

// InputMessageStory A message with a forwarded story. Stories can't be sent to secret chats. A story can be forwarded only if story.can_be_forwarded
type InputMessageStory struct {
	tdCommon
	StorySenderChatID int64 `json:"story_sender_chat_id"` // Identifier of the chat that posted the story
	StoryID           int32 `json:"story_id"`             // Story identifier
}

// MessageType return the string telegram-type of InputMessageStory
func (inputMessageStory *InputMessageStory) MessageType() string {
	return "inputMessageStory"
}

// NewInputMessageStory creates a new InputMessageStory
//
// @param storySenderChatID Identifier of the chat that posted the story
// @param storyID Story identifier
func NewInputMessageStory(storySenderChatID int64, storyID int32) *InputMessageStory {
	inputMessageStoryTemp := InputMessageStory{
		tdCommon:          tdCommon{Type: "inputMessageStory"},
		StorySenderChatID: storySenderChatID,
		StoryID:           storyID,
	}

	return &inputMessageStoryTemp
}

// UnmarshalJSON unmarshal to json
func (inputMessageStory *InputMessageStory) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StorySenderChatID int64 `json:"story_sender_chat_id"` // Identifier of the chat that posted the story
		StoryID           int32 `json:"story_id"`             // Story identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputMessageStory.tdCommon = tempObj.tdCommon
	inputMessageStory.StorySenderChatID = tempObj.StorySenderChatID
	inputMessageStory.StoryID = tempObj.StoryID

	return nil
}

// GetInputMessageContentEnum return the enum type of this object
func (inputMessageStory *InputMessageStory) GetInputMessageContentEnum() InputMessageContentEnum {
	return InputMessageStoryType
}

// InputMessageForwarded A forwarded message
type InputMessageForwarded struct {
	tdCommon
	FromChatID  int64               `json:"from_chat_id"`  // Identifier for the chat this forwarded message came from
	MessageID   int64               `json:"message_id"`    // Identifier of the message to forward. A message can be forwarded only if messageProperties.can_be_forwarded
	InGameShare bool                `json:"in_game_share"` // True, if a game message is being shared from a launched game; applies only to game messages
	CopyOptions *MessageCopyOptions `json:"copy_options"`  // Options to be used to copy content of the message without reference to the original sender; pass null to forward the message as usual
}

// MessageType return the string telegram-type of InputMessageForwarded
func (inputMessageForwarded *InputMessageForwarded) MessageType() string {
	return "inputMessageForwarded"
}

// NewInputMessageForwarded creates a new InputMessageForwarded
//
// @param fromChatID Identifier for the chat this forwarded message came from
// @param messageID Identifier of the message to forward. A message can be forwarded only if messageProperties.can_be_forwarded
// @param inGameShare True, if a game message is being shared from a launched game; applies only to game messages
// @param copyOptions Options to be used to copy content of the message without reference to the original sender; pass null to forward the message as usual
func NewInputMessageForwarded(fromChatID int64, messageID int64, inGameShare bool, copyOptions *MessageCopyOptions) *InputMessageForwarded {
	inputMessageForwardedTemp := InputMessageForwarded{
		tdCommon:    tdCommon{Type: "inputMessageForwarded"},
		FromChatID:  fromChatID,
		MessageID:   messageID,
		InGameShare: inGameShare,
		CopyOptions: copyOptions,
	}

	return &inputMessageForwardedTemp
}

// UnmarshalJSON unmarshal to json
func (inputMessageForwarded *InputMessageForwarded) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		FromChatID  int64               `json:"from_chat_id"`  // Identifier for the chat this forwarded message came from
		MessageID   int64               `json:"message_id"`    // Identifier of the message to forward. A message can be forwarded only if messageProperties.can_be_forwarded
		InGameShare bool                `json:"in_game_share"` // True, if a game message is being shared from a launched game; applies only to game messages
		CopyOptions *MessageCopyOptions `json:"copy_options"`  // Options to be used to copy content of the message without reference to the original sender; pass null to forward the message as usual
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputMessageForwarded.tdCommon = tempObj.tdCommon
	inputMessageForwarded.FromChatID = tempObj.FromChatID
	inputMessageForwarded.MessageID = tempObj.MessageID
	inputMessageForwarded.InGameShare = tempObj.InGameShare
	inputMessageForwarded.CopyOptions = tempObj.CopyOptions

	return nil
}

// GetInputMessageContentEnum return the enum type of this object
func (inputMessageForwarded *InputMessageForwarded) GetInputMessageContentEnum() InputMessageContentEnum {
	return InputMessageForwardedType
}

// MessageProperties Contains properties of a message and describes actions that can be done with the message right now
type MessageProperties struct {
	tdCommon
	CanBeCopiedToSecretChat   bool `json:"can_be_copied_to_secret_chat"`   // True, if content of the message can be copied to a secret chat using inputMessageForwarded or forwardMessages with copy options
	CanBeDeletedOnlyForSelf   bool `json:"can_be_deleted_only_for_self"`   // True, if the message can be deleted only for the current user while other users will continue to see it using the method deleteMessages with revoke == false
	CanBeDeletedForAllUsers   bool `json:"can_be_deleted_for_all_users"`   // True, if the message can be deleted for all users using the method deleteMessages with revoke == true
	CanBeEdited               bool `json:"can_be_edited"`                  // True, if the message can be edited using the methods editMessageText, editMessageMedia, editMessageCaption, or editMessageReplyMarkup. For live location and poll messages this fields shows whether editMessageLiveLocation or stopPoll can be used with this message
	CanBeForwarded            bool `json:"can_be_forwarded"`               // True, if the message can be forwarded using inputMessageForwarded or forwardMessages
	CanBePaid                 bool `json:"can_be_paid"`                    // True, if the message can be paid using inputInvoiceMessage
	CanBePinned               bool `json:"can_be_pinned"`                  // True, if the message can be pinned or unpinned in the chat using pinChatMessage or unpinChatMessage
	CanBeReplied              bool `json:"can_be_replied"`                 // True, if the message can be replied in the same chat and forum topic using inputMessageReplyToMessage
	CanBeRepliedInAnotherChat bool `json:"can_be_replied_in_another_chat"` // True, if the message can be replied in another chat or forum topic using inputMessageReplyToExternalMessage
	CanBeSaved                bool `json:"can_be_saved"`                   // True, if content of the message can be saved locally or copied using inputMessageForwarded or forwardMessages with copy options
	CanBeSharedInStory        bool `json:"can_be_shared_in_story"`         // True, if the message can be shared in a story using inputStoryAreaTypeMessage
	CanEditSchedulingState    bool `json:"can_edit_scheduling_state"`      // True, if scheduling state of the message can be edited
	CanGetEmbeddingCode       bool `json:"can_get_embedding_code"`         // True, if code for message embedding can be received using getMessageEmbeddingCode
	CanGetLink                bool `json:"can_get_link"`                   // True, if a link can be generated for the message using getMessageLink
	CanGetMediaTimestampLinks bool `json:"can_get_media_timestamp_links"`  // True, if media timestamp links can be generated for media timestamp entities in the message text, caption or link preview description using getMessageLink
	CanGetMessageThread       bool `json:"can_get_message_thread"`         // True, if information about the message thread is available through getMessageThread and getMessageThreadHistory
	CanGetReadDate            bool `json:"can_get_read_date"`              // True, if read date of the message can be received through getMessageReadDate
	CanGetStatistics          bool `json:"can_get_statistics"`             // True, if message statistics are available through getMessageStatistics and message forwards can be received using getMessagePublicForwards
	CanGetViewers             bool `json:"can_get_viewers"`                // True, if chat members already viewed the message can be received through getMessageViewers
	CanRecognizeSpeech        bool `json:"can_recognize_speech"`           // True, if speech can be recognized for the message through recognizeSpeech
	CanReportChat             bool `json:"can_report_chat"`                // True, if the message can be reported using reportChat
	CanReportReactions        bool `json:"can_report_reactions"`           // True, if reactions on the message can be reported through reportMessageReactions
	CanReportSupergroupSpam   bool `json:"can_report_supergroup_spam"`     // True, if the message can be reported using reportSupergroupSpam
	CanSetFactCheck           bool `json:"can_set_fact_check"`             // True, if fact check for the message can be changed through setMessageFactCheck
	NeedShowStatistics        bool `json:"need_show_statistics"`           // True, if message statistics must be available from context menu of the message
}

// MessageType return the string telegram-type of MessageProperties
func (messageProperties *MessageProperties) MessageType() string {
	return "messageProperties"
}

// NewMessageProperties creates a new MessageProperties
//
// @param canBeCopiedToSecretChat True, if content of the message can be copied to a secret chat using inputMessageForwarded or forwardMessages with copy options
// @param canBeDeletedOnlyForSelf True, if the message can be deleted only for the current user while other users will continue to see it using the method deleteMessages with revoke == false
// @param canBeDeletedForAllUsers True, if the message can be deleted for all users using the method deleteMessages with revoke == true
// @param canBeEdited True, if the message can be edited using the methods editMessageText, editMessageMedia, editMessageCaption, or editMessageReplyMarkup. For live location and poll messages this fields shows whether editMessageLiveLocation or stopPoll can be used with this message
// @param canBeForwarded True, if the message can be forwarded using inputMessageForwarded or forwardMessages
// @param canBePaid True, if the message can be paid using inputInvoiceMessage
// @param canBePinned True, if the message can be pinned or unpinned in the chat using pinChatMessage or unpinChatMessage
// @param canBeReplied True, if the message can be replied in the same chat and forum topic using inputMessageReplyToMessage
// @param canBeRepliedInAnotherChat True, if the message can be replied in another chat or forum topic using inputMessageReplyToExternalMessage
// @param canBeSaved True, if content of the message can be saved locally or copied using inputMessageForwarded or forwardMessages with copy options
// @param canBeSharedInStory True, if the message can be shared in a story using inputStoryAreaTypeMessage
// @param canEditSchedulingState True, if scheduling state of the message can be edited
// @param canGetEmbeddingCode True, if code for message embedding can be received using getMessageEmbeddingCode
// @param canGetLink True, if a link can be generated for the message using getMessageLink
// @param canGetMediaTimestampLinks True, if media timestamp links can be generated for media timestamp entities in the message text, caption or link preview description using getMessageLink
// @param canGetMessageThread True, if information about the message thread is available through getMessageThread and getMessageThreadHistory
// @param canGetReadDate True, if read date of the message can be received through getMessageReadDate
// @param canGetStatistics True, if message statistics are available through getMessageStatistics and message forwards can be received using getMessagePublicForwards
// @param canGetViewers True, if chat members already viewed the message can be received through getMessageViewers
// @param canRecognizeSpeech True, if speech can be recognized for the message through recognizeSpeech
// @param canReportChat True, if the message can be reported using reportChat
// @param canReportReactions True, if reactions on the message can be reported through reportMessageReactions
// @param canReportSupergroupSpam True, if the message can be reported using reportSupergroupSpam
// @param canSetFactCheck True, if fact check for the message can be changed through setMessageFactCheck
// @param needShowStatistics True, if message statistics must be available from context menu of the message
func NewMessageProperties(canBeCopiedToSecretChat bool, canBeDeletedOnlyForSelf bool, canBeDeletedForAllUsers bool, canBeEdited bool, canBeForwarded bool, canBePaid bool, canBePinned bool, canBeReplied bool, canBeRepliedInAnotherChat bool, canBeSaved bool, canBeSharedInStory bool, canEditSchedulingState bool, canGetEmbeddingCode bool, canGetLink bool, canGetMediaTimestampLinks bool, canGetMessageThread bool, canGetReadDate bool, canGetStatistics bool, canGetViewers bool, canRecognizeSpeech bool, canReportChat bool, canReportReactions bool, canReportSupergroupSpam bool, canSetFactCheck bool, needShowStatistics bool) *MessageProperties {
	messagePropertiesTemp := MessageProperties{
		tdCommon:                  tdCommon{Type: "messageProperties"},
		CanBeCopiedToSecretChat:   canBeCopiedToSecretChat,
		CanBeDeletedOnlyForSelf:   canBeDeletedOnlyForSelf,
		CanBeDeletedForAllUsers:   canBeDeletedForAllUsers,
		CanBeEdited:               canBeEdited,
		CanBeForwarded:            canBeForwarded,
		CanBePaid:                 canBePaid,
		CanBePinned:               canBePinned,
		CanBeReplied:              canBeReplied,
		CanBeRepliedInAnotherChat: canBeRepliedInAnotherChat,
		CanBeSaved:                canBeSaved,
		CanBeSharedInStory:        canBeSharedInStory,
		CanEditSchedulingState:    canEditSchedulingState,
		CanGetEmbeddingCode:       canGetEmbeddingCode,
		CanGetLink:                canGetLink,
		CanGetMediaTimestampLinks: canGetMediaTimestampLinks,
		CanGetMessageThread:       canGetMessageThread,
		CanGetReadDate:            canGetReadDate,
		CanGetStatistics:          canGetStatistics,
		CanGetViewers:             canGetViewers,
		CanRecognizeSpeech:        canRecognizeSpeech,
		CanReportChat:             canReportChat,
		CanReportReactions:        canReportReactions,
		CanReportSupergroupSpam:   canReportSupergroupSpam,
		CanSetFactCheck:           canSetFactCheck,
		NeedShowStatistics:        needShowStatistics,
	}

	return &messagePropertiesTemp
}

// UnmarshalJSON unmarshal to json
func (messageProperties *MessageProperties) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CanBeCopiedToSecretChat   bool `json:"can_be_copied_to_secret_chat"`   // True, if content of the message can be copied to a secret chat using inputMessageForwarded or forwardMessages with copy options
		CanBeDeletedOnlyForSelf   bool `json:"can_be_deleted_only_for_self"`   // True, if the message can be deleted only for the current user while other users will continue to see it using the method deleteMessages with revoke == false
		CanBeDeletedForAllUsers   bool `json:"can_be_deleted_for_all_users"`   // True, if the message can be deleted for all users using the method deleteMessages with revoke == true
		CanBeEdited               bool `json:"can_be_edited"`                  // True, if the message can be edited using the methods editMessageText, editMessageMedia, editMessageCaption, or editMessageReplyMarkup. For live location and poll messages this fields shows whether editMessageLiveLocation or stopPoll can be used with this message
		CanBeForwarded            bool `json:"can_be_forwarded"`               // True, if the message can be forwarded using inputMessageForwarded or forwardMessages
		CanBePaid                 bool `json:"can_be_paid"`                    // True, if the message can be paid using inputInvoiceMessage
		CanBePinned               bool `json:"can_be_pinned"`                  // True, if the message can be pinned or unpinned in the chat using pinChatMessage or unpinChatMessage
		CanBeReplied              bool `json:"can_be_replied"`                 // True, if the message can be replied in the same chat and forum topic using inputMessageReplyToMessage
		CanBeRepliedInAnotherChat bool `json:"can_be_replied_in_another_chat"` // True, if the message can be replied in another chat or forum topic using inputMessageReplyToExternalMessage
		CanBeSaved                bool `json:"can_be_saved"`                   // True, if content of the message can be saved locally or copied using inputMessageForwarded or forwardMessages with copy options
		CanBeSharedInStory        bool `json:"can_be_shared_in_story"`         // True, if the message can be shared in a story using inputStoryAreaTypeMessage
		CanEditSchedulingState    bool `json:"can_edit_scheduling_state"`      // True, if scheduling state of the message can be edited
		CanGetEmbeddingCode       bool `json:"can_get_embedding_code"`         // True, if code for message embedding can be received using getMessageEmbeddingCode
		CanGetLink                bool `json:"can_get_link"`                   // True, if a link can be generated for the message using getMessageLink
		CanGetMediaTimestampLinks bool `json:"can_get_media_timestamp_links"`  // True, if media timestamp links can be generated for media timestamp entities in the message text, caption or link preview description using getMessageLink
		CanGetMessageThread       bool `json:"can_get_message_thread"`         // True, if information about the message thread is available through getMessageThread and getMessageThreadHistory
		CanGetReadDate            bool `json:"can_get_read_date"`              // True, if read date of the message can be received through getMessageReadDate
		CanGetStatistics          bool `json:"can_get_statistics"`             // True, if message statistics are available through getMessageStatistics and message forwards can be received using getMessagePublicForwards
		CanGetViewers             bool `json:"can_get_viewers"`                // True, if chat members already viewed the message can be received through getMessageViewers
		CanRecognizeSpeech        bool `json:"can_recognize_speech"`           // True, if speech can be recognized for the message through recognizeSpeech
		CanReportChat             bool `json:"can_report_chat"`                // True, if the message can be reported using reportChat
		CanReportReactions        bool `json:"can_report_reactions"`           // True, if reactions on the message can be reported through reportMessageReactions
		CanReportSupergroupSpam   bool `json:"can_report_supergroup_spam"`     // True, if the message can be reported using reportSupergroupSpam
		CanSetFactCheck           bool `json:"can_set_fact_check"`             // True, if fact check for the message can be changed through setMessageFactCheck
		NeedShowStatistics        bool `json:"need_show_statistics"`           // True, if message statistics must be available from context menu of the message
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageProperties.tdCommon = tempObj.tdCommon
	messageProperties.CanBeCopiedToSecretChat = tempObj.CanBeCopiedToSecretChat
	messageProperties.CanBeDeletedOnlyForSelf = tempObj.CanBeDeletedOnlyForSelf
	messageProperties.CanBeDeletedForAllUsers = tempObj.CanBeDeletedForAllUsers
	messageProperties.CanBeEdited = tempObj.CanBeEdited
	messageProperties.CanBeForwarded = tempObj.CanBeForwarded
	messageProperties.CanBePaid = tempObj.CanBePaid
	messageProperties.CanBePinned = tempObj.CanBePinned
	messageProperties.CanBeReplied = tempObj.CanBeReplied
	messageProperties.CanBeRepliedInAnotherChat = tempObj.CanBeRepliedInAnotherChat
	messageProperties.CanBeSaved = tempObj.CanBeSaved
	messageProperties.CanBeSharedInStory = tempObj.CanBeSharedInStory
	messageProperties.CanEditSchedulingState = tempObj.CanEditSchedulingState
	messageProperties.CanGetEmbeddingCode = tempObj.CanGetEmbeddingCode
	messageProperties.CanGetLink = tempObj.CanGetLink
	messageProperties.CanGetMediaTimestampLinks = tempObj.CanGetMediaTimestampLinks
	messageProperties.CanGetMessageThread = tempObj.CanGetMessageThread
	messageProperties.CanGetReadDate = tempObj.CanGetReadDate
	messageProperties.CanGetStatistics = tempObj.CanGetStatistics
	messageProperties.CanGetViewers = tempObj.CanGetViewers
	messageProperties.CanRecognizeSpeech = tempObj.CanRecognizeSpeech
	messageProperties.CanReportChat = tempObj.CanReportChat
	messageProperties.CanReportReactions = tempObj.CanReportReactions
	messageProperties.CanReportSupergroupSpam = tempObj.CanReportSupergroupSpam
	messageProperties.CanSetFactCheck = tempObj.CanSetFactCheck
	messageProperties.NeedShowStatistics = tempObj.NeedShowStatistics

	return nil
}

// SearchMessagesFilterEmpty Returns all found messages, no filter is applied
type SearchMessagesFilterEmpty struct {
	tdCommon
}

// MessageType return the string telegram-type of SearchMessagesFilterEmpty
func (searchMessagesFilterEmpty *SearchMessagesFilterEmpty) MessageType() string {
	return "searchMessagesFilterEmpty"
}

// NewSearchMessagesFilterEmpty creates a new SearchMessagesFilterEmpty
//
func NewSearchMessagesFilterEmpty() *SearchMessagesFilterEmpty {
	searchMessagesFilterEmptyTemp := SearchMessagesFilterEmpty{
		tdCommon: tdCommon{Type: "searchMessagesFilterEmpty"},
	}

	return &searchMessagesFilterEmptyTemp
}

// UnmarshalJSON unmarshal to json
func (searchMessagesFilterEmpty *SearchMessagesFilterEmpty) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	searchMessagesFilterEmpty.tdCommon = tempObj.tdCommon

	return nil
}

// GetSearchMessagesFilterEnum return the enum type of this object
func (searchMessagesFilterEmpty *SearchMessagesFilterEmpty) GetSearchMessagesFilterEnum() SearchMessagesFilterEnum {
	return SearchMessagesFilterEmptyType
}

// SearchMessagesFilterAnimation Returns only animation messages
type SearchMessagesFilterAnimation struct {
	tdCommon
}

// MessageType return the string telegram-type of SearchMessagesFilterAnimation
func (searchMessagesFilterAnimation *SearchMessagesFilterAnimation) MessageType() string {
	return "searchMessagesFilterAnimation"
}

// NewSearchMessagesFilterAnimation creates a new SearchMessagesFilterAnimation
//
func NewSearchMessagesFilterAnimation() *SearchMessagesFilterAnimation {
	searchMessagesFilterAnimationTemp := SearchMessagesFilterAnimation{
		tdCommon: tdCommon{Type: "searchMessagesFilterAnimation"},
	}

	return &searchMessagesFilterAnimationTemp
}

// UnmarshalJSON unmarshal to json
func (searchMessagesFilterAnimation *SearchMessagesFilterAnimation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	searchMessagesFilterAnimation.tdCommon = tempObj.tdCommon

	return nil
}

// GetSearchMessagesFilterEnum return the enum type of this object
func (searchMessagesFilterAnimation *SearchMessagesFilterAnimation) GetSearchMessagesFilterEnum() SearchMessagesFilterEnum {
	return SearchMessagesFilterAnimationType
}

// SearchMessagesFilterAudio Returns only audio messages
type SearchMessagesFilterAudio struct {
	tdCommon
}

// MessageType return the string telegram-type of SearchMessagesFilterAudio
func (searchMessagesFilterAudio *SearchMessagesFilterAudio) MessageType() string {
	return "searchMessagesFilterAudio"
}

// NewSearchMessagesFilterAudio creates a new SearchMessagesFilterAudio
//
func NewSearchMessagesFilterAudio() *SearchMessagesFilterAudio {
	searchMessagesFilterAudioTemp := SearchMessagesFilterAudio{
		tdCommon: tdCommon{Type: "searchMessagesFilterAudio"},
	}

	return &searchMessagesFilterAudioTemp
}

// UnmarshalJSON unmarshal to json
func (searchMessagesFilterAudio *SearchMessagesFilterAudio) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	searchMessagesFilterAudio.tdCommon = tempObj.tdCommon

	return nil
}

// GetSearchMessagesFilterEnum return the enum type of this object
func (searchMessagesFilterAudio *SearchMessagesFilterAudio) GetSearchMessagesFilterEnum() SearchMessagesFilterEnum {
	return SearchMessagesFilterAudioType
}

// SearchMessagesFilterDocument Returns only document messages
type SearchMessagesFilterDocument struct {
	tdCommon
}

// MessageType return the string telegram-type of SearchMessagesFilterDocument
func (searchMessagesFilterDocument *SearchMessagesFilterDocument) MessageType() string {
	return "searchMessagesFilterDocument"
}

// NewSearchMessagesFilterDocument creates a new SearchMessagesFilterDocument
//
func NewSearchMessagesFilterDocument() *SearchMessagesFilterDocument {
	searchMessagesFilterDocumentTemp := SearchMessagesFilterDocument{
		tdCommon: tdCommon{Type: "searchMessagesFilterDocument"},
	}

	return &searchMessagesFilterDocumentTemp
}

// UnmarshalJSON unmarshal to json
func (searchMessagesFilterDocument *SearchMessagesFilterDocument) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	searchMessagesFilterDocument.tdCommon = tempObj.tdCommon

	return nil
}

// GetSearchMessagesFilterEnum return the enum type of this object
func (searchMessagesFilterDocument *SearchMessagesFilterDocument) GetSearchMessagesFilterEnum() SearchMessagesFilterEnum {
	return SearchMessagesFilterDocumentType
}

// SearchMessagesFilterPhoto Returns only photo messages
type SearchMessagesFilterPhoto struct {
	tdCommon
}

// MessageType return the string telegram-type of SearchMessagesFilterPhoto
func (searchMessagesFilterPhoto *SearchMessagesFilterPhoto) MessageType() string {
	return "searchMessagesFilterPhoto"
}

// NewSearchMessagesFilterPhoto creates a new SearchMessagesFilterPhoto
//
func NewSearchMessagesFilterPhoto() *SearchMessagesFilterPhoto {
	searchMessagesFilterPhotoTemp := SearchMessagesFilterPhoto{
		tdCommon: tdCommon{Type: "searchMessagesFilterPhoto"},
	}

	return &searchMessagesFilterPhotoTemp
}

// UnmarshalJSON unmarshal to json
func (searchMessagesFilterPhoto *SearchMessagesFilterPhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	searchMessagesFilterPhoto.tdCommon = tempObj.tdCommon

	return nil
}

// GetSearchMessagesFilterEnum return the enum type of this object
func (searchMessagesFilterPhoto *SearchMessagesFilterPhoto) GetSearchMessagesFilterEnum() SearchMessagesFilterEnum {
	return SearchMessagesFilterPhotoType
}

// SearchMessagesFilterVideo Returns only video messages
type SearchMessagesFilterVideo struct {
	tdCommon
}

// MessageType return the string telegram-type of SearchMessagesFilterVideo
func (searchMessagesFilterVideo *SearchMessagesFilterVideo) MessageType() string {
	return "searchMessagesFilterVideo"
}

// NewSearchMessagesFilterVideo creates a new SearchMessagesFilterVideo
//
func NewSearchMessagesFilterVideo() *SearchMessagesFilterVideo {
	searchMessagesFilterVideoTemp := SearchMessagesFilterVideo{
		tdCommon: tdCommon{Type: "searchMessagesFilterVideo"},
	}

	return &searchMessagesFilterVideoTemp
}

// UnmarshalJSON unmarshal to json
func (searchMessagesFilterVideo *SearchMessagesFilterVideo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	searchMessagesFilterVideo.tdCommon = tempObj.tdCommon

	return nil
}

// GetSearchMessagesFilterEnum return the enum type of this object
func (searchMessagesFilterVideo *SearchMessagesFilterVideo) GetSearchMessagesFilterEnum() SearchMessagesFilterEnum {
	return SearchMessagesFilterVideoType
}

// SearchMessagesFilterVoiceNote Returns only voice note messages
type SearchMessagesFilterVoiceNote struct {
	tdCommon
}

// MessageType return the string telegram-type of SearchMessagesFilterVoiceNote
func (searchMessagesFilterVoiceNote *SearchMessagesFilterVoiceNote) MessageType() string {
	return "searchMessagesFilterVoiceNote"
}

// NewSearchMessagesFilterVoiceNote creates a new SearchMessagesFilterVoiceNote
//
func NewSearchMessagesFilterVoiceNote() *SearchMessagesFilterVoiceNote {
	searchMessagesFilterVoiceNoteTemp := SearchMessagesFilterVoiceNote{
		tdCommon: tdCommon{Type: "searchMessagesFilterVoiceNote"},
	}

	return &searchMessagesFilterVoiceNoteTemp
}

// UnmarshalJSON unmarshal to json
func (searchMessagesFilterVoiceNote *SearchMessagesFilterVoiceNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	searchMessagesFilterVoiceNote.tdCommon = tempObj.tdCommon

	return nil
}

// GetSearchMessagesFilterEnum return the enum type of this object
func (searchMessagesFilterVoiceNote *SearchMessagesFilterVoiceNote) GetSearchMessagesFilterEnum() SearchMessagesFilterEnum {
	return SearchMessagesFilterVoiceNoteType
}

// SearchMessagesFilterPhotoAndVideo Returns only photo and video messages
type SearchMessagesFilterPhotoAndVideo struct {
	tdCommon
}

// MessageType return the string telegram-type of SearchMessagesFilterPhotoAndVideo
func (searchMessagesFilterPhotoAndVideo *SearchMessagesFilterPhotoAndVideo) MessageType() string {
	return "searchMessagesFilterPhotoAndVideo"
}

// NewSearchMessagesFilterPhotoAndVideo creates a new SearchMessagesFilterPhotoAndVideo
//
func NewSearchMessagesFilterPhotoAndVideo() *SearchMessagesFilterPhotoAndVideo {
	searchMessagesFilterPhotoAndVideoTemp := SearchMessagesFilterPhotoAndVideo{
		tdCommon: tdCommon{Type: "searchMessagesFilterPhotoAndVideo"},
	}

	return &searchMessagesFilterPhotoAndVideoTemp
}

// UnmarshalJSON unmarshal to json
func (searchMessagesFilterPhotoAndVideo *SearchMessagesFilterPhotoAndVideo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	searchMessagesFilterPhotoAndVideo.tdCommon = tempObj.tdCommon

	return nil
}

// GetSearchMessagesFilterEnum return the enum type of this object
func (searchMessagesFilterPhotoAndVideo *SearchMessagesFilterPhotoAndVideo) GetSearchMessagesFilterEnum() SearchMessagesFilterEnum {
	return SearchMessagesFilterPhotoAndVideoType
}

// SearchMessagesFilterURL Returns only messages containing URLs
type SearchMessagesFilterURL struct {
	tdCommon
}

// MessageType return the string telegram-type of SearchMessagesFilterURL
func (searchMessagesFilterURL *SearchMessagesFilterURL) MessageType() string {
	return "searchMessagesFilterUrl"
}

// NewSearchMessagesFilterURL creates a new SearchMessagesFilterURL
//
func NewSearchMessagesFilterURL() *SearchMessagesFilterURL {
	searchMessagesFilterURLTemp := SearchMessagesFilterURL{
		tdCommon: tdCommon{Type: "searchMessagesFilterUrl"},
	}

	return &searchMessagesFilterURLTemp
}

// UnmarshalJSON unmarshal to json
func (searchMessagesFilterURL *SearchMessagesFilterURL) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	searchMessagesFilterURL.tdCommon = tempObj.tdCommon

	return nil
}

// GetSearchMessagesFilterEnum return the enum type of this object
func (searchMessagesFilterURL *SearchMessagesFilterURL) GetSearchMessagesFilterEnum() SearchMessagesFilterEnum {
	return SearchMessagesFilterURLType
}

// SearchMessagesFilterChatPhoto Returns only messages containing chat photos
type SearchMessagesFilterChatPhoto struct {
	tdCommon
}

// MessageType return the string telegram-type of SearchMessagesFilterChatPhoto
func (searchMessagesFilterChatPhoto *SearchMessagesFilterChatPhoto) MessageType() string {
	return "searchMessagesFilterChatPhoto"
}

// NewSearchMessagesFilterChatPhoto creates a new SearchMessagesFilterChatPhoto
//
func NewSearchMessagesFilterChatPhoto() *SearchMessagesFilterChatPhoto {
	searchMessagesFilterChatPhotoTemp := SearchMessagesFilterChatPhoto{
		tdCommon: tdCommon{Type: "searchMessagesFilterChatPhoto"},
	}

	return &searchMessagesFilterChatPhotoTemp
}

// UnmarshalJSON unmarshal to json
func (searchMessagesFilterChatPhoto *SearchMessagesFilterChatPhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	searchMessagesFilterChatPhoto.tdCommon = tempObj.tdCommon

	return nil
}

// GetSearchMessagesFilterEnum return the enum type of this object
func (searchMessagesFilterChatPhoto *SearchMessagesFilterChatPhoto) GetSearchMessagesFilterEnum() SearchMessagesFilterEnum {
	return SearchMessagesFilterChatPhotoType
}

// SearchMessagesFilterVideoNote Returns only video note messages
type SearchMessagesFilterVideoNote struct {
	tdCommon
}

// MessageType return the string telegram-type of SearchMessagesFilterVideoNote
func (searchMessagesFilterVideoNote *SearchMessagesFilterVideoNote) MessageType() string {
	return "searchMessagesFilterVideoNote"
}

// NewSearchMessagesFilterVideoNote creates a new SearchMessagesFilterVideoNote
//
func NewSearchMessagesFilterVideoNote() *SearchMessagesFilterVideoNote {
	searchMessagesFilterVideoNoteTemp := SearchMessagesFilterVideoNote{
		tdCommon: tdCommon{Type: "searchMessagesFilterVideoNote"},
	}

	return &searchMessagesFilterVideoNoteTemp
}

// UnmarshalJSON unmarshal to json
func (searchMessagesFilterVideoNote *SearchMessagesFilterVideoNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	searchMessagesFilterVideoNote.tdCommon = tempObj.tdCommon

	return nil
}

// GetSearchMessagesFilterEnum return the enum type of this object
func (searchMessagesFilterVideoNote *SearchMessagesFilterVideoNote) GetSearchMessagesFilterEnum() SearchMessagesFilterEnum {
	return SearchMessagesFilterVideoNoteType
}

// SearchMessagesFilterVoiceAndVideoNote Returns only voice and video note messages
type SearchMessagesFilterVoiceAndVideoNote struct {
	tdCommon
}

// MessageType return the string telegram-type of SearchMessagesFilterVoiceAndVideoNote
func (searchMessagesFilterVoiceAndVideoNote *SearchMessagesFilterVoiceAndVideoNote) MessageType() string {
	return "searchMessagesFilterVoiceAndVideoNote"
}

// NewSearchMessagesFilterVoiceAndVideoNote creates a new SearchMessagesFilterVoiceAndVideoNote
//
func NewSearchMessagesFilterVoiceAndVideoNote() *SearchMessagesFilterVoiceAndVideoNote {
	searchMessagesFilterVoiceAndVideoNoteTemp := SearchMessagesFilterVoiceAndVideoNote{
		tdCommon: tdCommon{Type: "searchMessagesFilterVoiceAndVideoNote"},
	}

	return &searchMessagesFilterVoiceAndVideoNoteTemp
}

// UnmarshalJSON unmarshal to json
func (searchMessagesFilterVoiceAndVideoNote *SearchMessagesFilterVoiceAndVideoNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	searchMessagesFilterVoiceAndVideoNote.tdCommon = tempObj.tdCommon

	return nil
}

// GetSearchMessagesFilterEnum return the enum type of this object
func (searchMessagesFilterVoiceAndVideoNote *SearchMessagesFilterVoiceAndVideoNote) GetSearchMessagesFilterEnum() SearchMessagesFilterEnum {
	return SearchMessagesFilterVoiceAndVideoNoteType
}

// SearchMessagesFilterMention Returns only messages with mentions of the current user, or messages that are replies to their messages
type SearchMessagesFilterMention struct {
	tdCommon
}

// MessageType return the string telegram-type of SearchMessagesFilterMention
func (searchMessagesFilterMention *SearchMessagesFilterMention) MessageType() string {
	return "searchMessagesFilterMention"
}

// NewSearchMessagesFilterMention creates a new SearchMessagesFilterMention
//
func NewSearchMessagesFilterMention() *SearchMessagesFilterMention {
	searchMessagesFilterMentionTemp := SearchMessagesFilterMention{
		tdCommon: tdCommon{Type: "searchMessagesFilterMention"},
	}

	return &searchMessagesFilterMentionTemp
}

// UnmarshalJSON unmarshal to json
func (searchMessagesFilterMention *SearchMessagesFilterMention) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	searchMessagesFilterMention.tdCommon = tempObj.tdCommon

	return nil
}

// GetSearchMessagesFilterEnum return the enum type of this object
func (searchMessagesFilterMention *SearchMessagesFilterMention) GetSearchMessagesFilterEnum() SearchMessagesFilterEnum {
	return SearchMessagesFilterMentionType
}

// SearchMessagesFilterUnreadMention Returns only messages with unread mentions of the current user, or messages that are replies to their messages. When using this filter the results can't be additionally filtered by a query, a message thread or by the sending user
type SearchMessagesFilterUnreadMention struct {
	tdCommon
}

// MessageType return the string telegram-type of SearchMessagesFilterUnreadMention
func (searchMessagesFilterUnreadMention *SearchMessagesFilterUnreadMention) MessageType() string {
	return "searchMessagesFilterUnreadMention"
}

// NewSearchMessagesFilterUnreadMention creates a new SearchMessagesFilterUnreadMention
//
func NewSearchMessagesFilterUnreadMention() *SearchMessagesFilterUnreadMention {
	searchMessagesFilterUnreadMentionTemp := SearchMessagesFilterUnreadMention{
		tdCommon: tdCommon{Type: "searchMessagesFilterUnreadMention"},
	}

	return &searchMessagesFilterUnreadMentionTemp
}

// UnmarshalJSON unmarshal to json
func (searchMessagesFilterUnreadMention *SearchMessagesFilterUnreadMention) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	searchMessagesFilterUnreadMention.tdCommon = tempObj.tdCommon

	return nil
}

// GetSearchMessagesFilterEnum return the enum type of this object
func (searchMessagesFilterUnreadMention *SearchMessagesFilterUnreadMention) GetSearchMessagesFilterEnum() SearchMessagesFilterEnum {
	return SearchMessagesFilterUnreadMentionType
}

// SearchMessagesFilterUnreadReaction Returns only messages with unread reactions for the current user. When using this filter the results can't be additionally filtered by a query, a message thread or by the sending user
type SearchMessagesFilterUnreadReaction struct {
	tdCommon
}

// MessageType return the string telegram-type of SearchMessagesFilterUnreadReaction
func (searchMessagesFilterUnreadReaction *SearchMessagesFilterUnreadReaction) MessageType() string {
	return "searchMessagesFilterUnreadReaction"
}

// NewSearchMessagesFilterUnreadReaction creates a new SearchMessagesFilterUnreadReaction
//
func NewSearchMessagesFilterUnreadReaction() *SearchMessagesFilterUnreadReaction {
	searchMessagesFilterUnreadReactionTemp := SearchMessagesFilterUnreadReaction{
		tdCommon: tdCommon{Type: "searchMessagesFilterUnreadReaction"},
	}

	return &searchMessagesFilterUnreadReactionTemp
}

// UnmarshalJSON unmarshal to json
func (searchMessagesFilterUnreadReaction *SearchMessagesFilterUnreadReaction) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	searchMessagesFilterUnreadReaction.tdCommon = tempObj.tdCommon

	return nil
}

// GetSearchMessagesFilterEnum return the enum type of this object
func (searchMessagesFilterUnreadReaction *SearchMessagesFilterUnreadReaction) GetSearchMessagesFilterEnum() SearchMessagesFilterEnum {
	return SearchMessagesFilterUnreadReactionType
}

// SearchMessagesFilterFailedToSend Returns only failed to send messages. This filter can be used only if the message database is used
type SearchMessagesFilterFailedToSend struct {
	tdCommon
}

// MessageType return the string telegram-type of SearchMessagesFilterFailedToSend
func (searchMessagesFilterFailedToSend *SearchMessagesFilterFailedToSend) MessageType() string {
	return "searchMessagesFilterFailedToSend"
}

// NewSearchMessagesFilterFailedToSend creates a new SearchMessagesFilterFailedToSend
//
func NewSearchMessagesFilterFailedToSend() *SearchMessagesFilterFailedToSend {
	searchMessagesFilterFailedToSendTemp := SearchMessagesFilterFailedToSend{
		tdCommon: tdCommon{Type: "searchMessagesFilterFailedToSend"},
	}

	return &searchMessagesFilterFailedToSendTemp
}

// UnmarshalJSON unmarshal to json
func (searchMessagesFilterFailedToSend *SearchMessagesFilterFailedToSend) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	searchMessagesFilterFailedToSend.tdCommon = tempObj.tdCommon

	return nil
}

// GetSearchMessagesFilterEnum return the enum type of this object
func (searchMessagesFilterFailedToSend *SearchMessagesFilterFailedToSend) GetSearchMessagesFilterEnum() SearchMessagesFilterEnum {
	return SearchMessagesFilterFailedToSendType
}

// SearchMessagesFilterPinned Returns only pinned messages
type SearchMessagesFilterPinned struct {
	tdCommon
}

// MessageType return the string telegram-type of SearchMessagesFilterPinned
func (searchMessagesFilterPinned *SearchMessagesFilterPinned) MessageType() string {
	return "searchMessagesFilterPinned"
}

// NewSearchMessagesFilterPinned creates a new SearchMessagesFilterPinned
//
func NewSearchMessagesFilterPinned() *SearchMessagesFilterPinned {
	searchMessagesFilterPinnedTemp := SearchMessagesFilterPinned{
		tdCommon: tdCommon{Type: "searchMessagesFilterPinned"},
	}

	return &searchMessagesFilterPinnedTemp
}

// UnmarshalJSON unmarshal to json
func (searchMessagesFilterPinned *SearchMessagesFilterPinned) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	searchMessagesFilterPinned.tdCommon = tempObj.tdCommon

	return nil
}

// GetSearchMessagesFilterEnum return the enum type of this object
func (searchMessagesFilterPinned *SearchMessagesFilterPinned) GetSearchMessagesFilterEnum() SearchMessagesFilterEnum {
	return SearchMessagesFilterPinnedType
}

// ChatActionTyping The user is typing a message
type ChatActionTyping struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatActionTyping
func (chatActionTyping *ChatActionTyping) MessageType() string {
	return "chatActionTyping"
}

// NewChatActionTyping creates a new ChatActionTyping
//
func NewChatActionTyping() *ChatActionTyping {
	chatActionTypingTemp := ChatActionTyping{
		tdCommon: tdCommon{Type: "chatActionTyping"},
	}

	return &chatActionTypingTemp
}

// UnmarshalJSON unmarshal to json
func (chatActionTyping *ChatActionTyping) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActionTyping.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatActionEnum return the enum type of this object
func (chatActionTyping *ChatActionTyping) GetChatActionEnum() ChatActionEnum {
	return ChatActionTypingType
}

// ChatActionRecordingVideo The user is recording a video
type ChatActionRecordingVideo struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatActionRecordingVideo
func (chatActionRecordingVideo *ChatActionRecordingVideo) MessageType() string {
	return "chatActionRecordingVideo"
}

// NewChatActionRecordingVideo creates a new ChatActionRecordingVideo
//
func NewChatActionRecordingVideo() *ChatActionRecordingVideo {
	chatActionRecordingVideoTemp := ChatActionRecordingVideo{
		tdCommon: tdCommon{Type: "chatActionRecordingVideo"},
	}

	return &chatActionRecordingVideoTemp
}

// UnmarshalJSON unmarshal to json
func (chatActionRecordingVideo *ChatActionRecordingVideo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActionRecordingVideo.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatActionEnum return the enum type of this object
func (chatActionRecordingVideo *ChatActionRecordingVideo) GetChatActionEnum() ChatActionEnum {
	return ChatActionRecordingVideoType
}

// ChatActionUploadingVideo The user is uploading a video
type ChatActionUploadingVideo struct {
	tdCommon
	Progress int32 `json:"progress"` // Upload progress, as a percentage
}

// MessageType return the string telegram-type of ChatActionUploadingVideo
func (chatActionUploadingVideo *ChatActionUploadingVideo) MessageType() string {
	return "chatActionUploadingVideo"
}

// NewChatActionUploadingVideo creates a new ChatActionUploadingVideo
//
// @param progress Upload progress, as a percentage
func NewChatActionUploadingVideo(progress int32) *ChatActionUploadingVideo {
	chatActionUploadingVideoTemp := ChatActionUploadingVideo{
		tdCommon: tdCommon{Type: "chatActionUploadingVideo"},
		Progress: progress,
	}

	return &chatActionUploadingVideoTemp
}

// UnmarshalJSON unmarshal to json
func (chatActionUploadingVideo *ChatActionUploadingVideo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Progress int32 `json:"progress"` // Upload progress, as a percentage
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActionUploadingVideo.tdCommon = tempObj.tdCommon
	chatActionUploadingVideo.Progress = tempObj.Progress

	return nil
}

// GetChatActionEnum return the enum type of this object
func (chatActionUploadingVideo *ChatActionUploadingVideo) GetChatActionEnum() ChatActionEnum {
	return ChatActionUploadingVideoType
}

// ChatActionRecordingVoiceNote The user is recording a voice note
type ChatActionRecordingVoiceNote struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatActionRecordingVoiceNote
func (chatActionRecordingVoiceNote *ChatActionRecordingVoiceNote) MessageType() string {
	return "chatActionRecordingVoiceNote"
}

// NewChatActionRecordingVoiceNote creates a new ChatActionRecordingVoiceNote
//
func NewChatActionRecordingVoiceNote() *ChatActionRecordingVoiceNote {
	chatActionRecordingVoiceNoteTemp := ChatActionRecordingVoiceNote{
		tdCommon: tdCommon{Type: "chatActionRecordingVoiceNote"},
	}

	return &chatActionRecordingVoiceNoteTemp
}

// UnmarshalJSON unmarshal to json
func (chatActionRecordingVoiceNote *ChatActionRecordingVoiceNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActionRecordingVoiceNote.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatActionEnum return the enum type of this object
func (chatActionRecordingVoiceNote *ChatActionRecordingVoiceNote) GetChatActionEnum() ChatActionEnum {
	return ChatActionRecordingVoiceNoteType
}

// ChatActionUploadingVoiceNote The user is uploading a voice note
type ChatActionUploadingVoiceNote struct {
	tdCommon
	Progress int32 `json:"progress"` // Upload progress, as a percentage
}

// MessageType return the string telegram-type of ChatActionUploadingVoiceNote
func (chatActionUploadingVoiceNote *ChatActionUploadingVoiceNote) MessageType() string {
	return "chatActionUploadingVoiceNote"
}

// NewChatActionUploadingVoiceNote creates a new ChatActionUploadingVoiceNote
//
// @param progress Upload progress, as a percentage
func NewChatActionUploadingVoiceNote(progress int32) *ChatActionUploadingVoiceNote {
	chatActionUploadingVoiceNoteTemp := ChatActionUploadingVoiceNote{
		tdCommon: tdCommon{Type: "chatActionUploadingVoiceNote"},
		Progress: progress,
	}

	return &chatActionUploadingVoiceNoteTemp
}

// UnmarshalJSON unmarshal to json
func (chatActionUploadingVoiceNote *ChatActionUploadingVoiceNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Progress int32 `json:"progress"` // Upload progress, as a percentage
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActionUploadingVoiceNote.tdCommon = tempObj.tdCommon
	chatActionUploadingVoiceNote.Progress = tempObj.Progress

	return nil
}

// GetChatActionEnum return the enum type of this object
func (chatActionUploadingVoiceNote *ChatActionUploadingVoiceNote) GetChatActionEnum() ChatActionEnum {
	return ChatActionUploadingVoiceNoteType
}

// ChatActionUploadingPhoto The user is uploading a photo
type ChatActionUploadingPhoto struct {
	tdCommon
	Progress int32 `json:"progress"` // Upload progress, as a percentage
}

// MessageType return the string telegram-type of ChatActionUploadingPhoto
func (chatActionUploadingPhoto *ChatActionUploadingPhoto) MessageType() string {
	return "chatActionUploadingPhoto"
}

// NewChatActionUploadingPhoto creates a new ChatActionUploadingPhoto
//
// @param progress Upload progress, as a percentage
func NewChatActionUploadingPhoto(progress int32) *ChatActionUploadingPhoto {
	chatActionUploadingPhotoTemp := ChatActionUploadingPhoto{
		tdCommon: tdCommon{Type: "chatActionUploadingPhoto"},
		Progress: progress,
	}

	return &chatActionUploadingPhotoTemp
}

// UnmarshalJSON unmarshal to json
func (chatActionUploadingPhoto *ChatActionUploadingPhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Progress int32 `json:"progress"` // Upload progress, as a percentage
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActionUploadingPhoto.tdCommon = tempObj.tdCommon
	chatActionUploadingPhoto.Progress = tempObj.Progress

	return nil
}

// GetChatActionEnum return the enum type of this object
func (chatActionUploadingPhoto *ChatActionUploadingPhoto) GetChatActionEnum() ChatActionEnum {
	return ChatActionUploadingPhotoType
}

// ChatActionUploadingDocument The user is uploading a document
type ChatActionUploadingDocument struct {
	tdCommon
	Progress int32 `json:"progress"` // Upload progress, as a percentage
}

// MessageType return the string telegram-type of ChatActionUploadingDocument
func (chatActionUploadingDocument *ChatActionUploadingDocument) MessageType() string {
	return "chatActionUploadingDocument"
}

// NewChatActionUploadingDocument creates a new ChatActionUploadingDocument
//
// @param progress Upload progress, as a percentage
func NewChatActionUploadingDocument(progress int32) *ChatActionUploadingDocument {
	chatActionUploadingDocumentTemp := ChatActionUploadingDocument{
		tdCommon: tdCommon{Type: "chatActionUploadingDocument"},
		Progress: progress,
	}

	return &chatActionUploadingDocumentTemp
}

// UnmarshalJSON unmarshal to json
func (chatActionUploadingDocument *ChatActionUploadingDocument) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Progress int32 `json:"progress"` // Upload progress, as a percentage
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActionUploadingDocument.tdCommon = tempObj.tdCommon
	chatActionUploadingDocument.Progress = tempObj.Progress

	return nil
}

// GetChatActionEnum return the enum type of this object
func (chatActionUploadingDocument *ChatActionUploadingDocument) GetChatActionEnum() ChatActionEnum {
	return ChatActionUploadingDocumentType
}

// ChatActionChoosingSticker The user is picking a sticker to send
type ChatActionChoosingSticker struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatActionChoosingSticker
func (chatActionChoosingSticker *ChatActionChoosingSticker) MessageType() string {
	return "chatActionChoosingSticker"
}

// NewChatActionChoosingSticker creates a new ChatActionChoosingSticker
//
func NewChatActionChoosingSticker() *ChatActionChoosingSticker {
	chatActionChoosingStickerTemp := ChatActionChoosingSticker{
		tdCommon: tdCommon{Type: "chatActionChoosingSticker"},
	}

	return &chatActionChoosingStickerTemp
}

// UnmarshalJSON unmarshal to json
func (chatActionChoosingSticker *ChatActionChoosingSticker) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActionChoosingSticker.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatActionEnum return the enum type of this object
func (chatActionChoosingSticker *ChatActionChoosingSticker) GetChatActionEnum() ChatActionEnum {
	return ChatActionChoosingStickerType
}

// ChatActionChoosingLocation The user is picking a location or venue to send
type ChatActionChoosingLocation struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatActionChoosingLocation
func (chatActionChoosingLocation *ChatActionChoosingLocation) MessageType() string {
	return "chatActionChoosingLocation"
}

// NewChatActionChoosingLocation creates a new ChatActionChoosingLocation
//
func NewChatActionChoosingLocation() *ChatActionChoosingLocation {
	chatActionChoosingLocationTemp := ChatActionChoosingLocation{
		tdCommon: tdCommon{Type: "chatActionChoosingLocation"},
	}

	return &chatActionChoosingLocationTemp
}

// UnmarshalJSON unmarshal to json
func (chatActionChoosingLocation *ChatActionChoosingLocation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActionChoosingLocation.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatActionEnum return the enum type of this object
func (chatActionChoosingLocation *ChatActionChoosingLocation) GetChatActionEnum() ChatActionEnum {
	return ChatActionChoosingLocationType
}

// ChatActionChoosingContact The user is picking a contact to send
type ChatActionChoosingContact struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatActionChoosingContact
func (chatActionChoosingContact *ChatActionChoosingContact) MessageType() string {
	return "chatActionChoosingContact"
}

// NewChatActionChoosingContact creates a new ChatActionChoosingContact
//
func NewChatActionChoosingContact() *ChatActionChoosingContact {
	chatActionChoosingContactTemp := ChatActionChoosingContact{
		tdCommon: tdCommon{Type: "chatActionChoosingContact"},
	}

	return &chatActionChoosingContactTemp
}

// UnmarshalJSON unmarshal to json
func (chatActionChoosingContact *ChatActionChoosingContact) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActionChoosingContact.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatActionEnum return the enum type of this object
func (chatActionChoosingContact *ChatActionChoosingContact) GetChatActionEnum() ChatActionEnum {
	return ChatActionChoosingContactType
}

// ChatActionStartPlayingGame The user has started to play a game
type ChatActionStartPlayingGame struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatActionStartPlayingGame
func (chatActionStartPlayingGame *ChatActionStartPlayingGame) MessageType() string {
	return "chatActionStartPlayingGame"
}

// NewChatActionStartPlayingGame creates a new ChatActionStartPlayingGame
//
func NewChatActionStartPlayingGame() *ChatActionStartPlayingGame {
	chatActionStartPlayingGameTemp := ChatActionStartPlayingGame{
		tdCommon: tdCommon{Type: "chatActionStartPlayingGame"},
	}

	return &chatActionStartPlayingGameTemp
}

// UnmarshalJSON unmarshal to json
func (chatActionStartPlayingGame *ChatActionStartPlayingGame) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActionStartPlayingGame.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatActionEnum return the enum type of this object
func (chatActionStartPlayingGame *ChatActionStartPlayingGame) GetChatActionEnum() ChatActionEnum {
	return ChatActionStartPlayingGameType
}

// ChatActionRecordingVideoNote The user is recording a video note
type ChatActionRecordingVideoNote struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatActionRecordingVideoNote
func (chatActionRecordingVideoNote *ChatActionRecordingVideoNote) MessageType() string {
	return "chatActionRecordingVideoNote"
}

// NewChatActionRecordingVideoNote creates a new ChatActionRecordingVideoNote
//
func NewChatActionRecordingVideoNote() *ChatActionRecordingVideoNote {
	chatActionRecordingVideoNoteTemp := ChatActionRecordingVideoNote{
		tdCommon: tdCommon{Type: "chatActionRecordingVideoNote"},
	}

	return &chatActionRecordingVideoNoteTemp
}

// UnmarshalJSON unmarshal to json
func (chatActionRecordingVideoNote *ChatActionRecordingVideoNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActionRecordingVideoNote.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatActionEnum return the enum type of this object
func (chatActionRecordingVideoNote *ChatActionRecordingVideoNote) GetChatActionEnum() ChatActionEnum {
	return ChatActionRecordingVideoNoteType
}

// ChatActionUploadingVideoNote The user is uploading a video note
type ChatActionUploadingVideoNote struct {
	tdCommon
	Progress int32 `json:"progress"` // Upload progress, as a percentage
}

// MessageType return the string telegram-type of ChatActionUploadingVideoNote
func (chatActionUploadingVideoNote *ChatActionUploadingVideoNote) MessageType() string {
	return "chatActionUploadingVideoNote"
}

// NewChatActionUploadingVideoNote creates a new ChatActionUploadingVideoNote
//
// @param progress Upload progress, as a percentage
func NewChatActionUploadingVideoNote(progress int32) *ChatActionUploadingVideoNote {
	chatActionUploadingVideoNoteTemp := ChatActionUploadingVideoNote{
		tdCommon: tdCommon{Type: "chatActionUploadingVideoNote"},
		Progress: progress,
	}

	return &chatActionUploadingVideoNoteTemp
}

// UnmarshalJSON unmarshal to json
func (chatActionUploadingVideoNote *ChatActionUploadingVideoNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Progress int32 `json:"progress"` // Upload progress, as a percentage
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActionUploadingVideoNote.tdCommon = tempObj.tdCommon
	chatActionUploadingVideoNote.Progress = tempObj.Progress

	return nil
}

// GetChatActionEnum return the enum type of this object
func (chatActionUploadingVideoNote *ChatActionUploadingVideoNote) GetChatActionEnum() ChatActionEnum {
	return ChatActionUploadingVideoNoteType
}

// ChatActionWatchingAnimations The user is watching animations sent by the other party by clicking on an animated emoji
type ChatActionWatchingAnimations struct {
	tdCommon
	Emoji string `json:"emoji"` // The animated emoji
}

// MessageType return the string telegram-type of ChatActionWatchingAnimations
func (chatActionWatchingAnimations *ChatActionWatchingAnimations) MessageType() string {
	return "chatActionWatchingAnimations"
}

// NewChatActionWatchingAnimations creates a new ChatActionWatchingAnimations
//
// @param emoji The animated emoji
func NewChatActionWatchingAnimations(emoji string) *ChatActionWatchingAnimations {
	chatActionWatchingAnimationsTemp := ChatActionWatchingAnimations{
		tdCommon: tdCommon{Type: "chatActionWatchingAnimations"},
		Emoji:    emoji,
	}

	return &chatActionWatchingAnimationsTemp
}

// UnmarshalJSON unmarshal to json
func (chatActionWatchingAnimations *ChatActionWatchingAnimations) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Emoji string `json:"emoji"` // The animated emoji
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActionWatchingAnimations.tdCommon = tempObj.tdCommon
	chatActionWatchingAnimations.Emoji = tempObj.Emoji

	return nil
}

// GetChatActionEnum return the enum type of this object
func (chatActionWatchingAnimations *ChatActionWatchingAnimations) GetChatActionEnum() ChatActionEnum {
	return ChatActionWatchingAnimationsType
}

// ChatActionCancel The user has canceled the previous action
type ChatActionCancel struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatActionCancel
func (chatActionCancel *ChatActionCancel) MessageType() string {
	return "chatActionCancel"
}

// NewChatActionCancel creates a new ChatActionCancel
//
func NewChatActionCancel() *ChatActionCancel {
	chatActionCancelTemp := ChatActionCancel{
		tdCommon: tdCommon{Type: "chatActionCancel"},
	}

	return &chatActionCancelTemp
}

// UnmarshalJSON unmarshal to json
func (chatActionCancel *ChatActionCancel) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActionCancel.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatActionEnum return the enum type of this object
func (chatActionCancel *ChatActionCancel) GetChatActionEnum() ChatActionEnum {
	return ChatActionCancelType
}

// UserStatusEmpty The user's status has never been changed
type UserStatusEmpty struct {
	tdCommon
}

// MessageType return the string telegram-type of UserStatusEmpty
func (userStatusEmpty *UserStatusEmpty) MessageType() string {
	return "userStatusEmpty"
}

// NewUserStatusEmpty creates a new UserStatusEmpty
//
func NewUserStatusEmpty() *UserStatusEmpty {
	userStatusEmptyTemp := UserStatusEmpty{
		tdCommon: tdCommon{Type: "userStatusEmpty"},
	}

	return &userStatusEmptyTemp
}

// UnmarshalJSON unmarshal to json
func (userStatusEmpty *UserStatusEmpty) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userStatusEmpty.tdCommon = tempObj.tdCommon

	return nil
}

// GetUserStatusEnum return the enum type of this object
func (userStatusEmpty *UserStatusEmpty) GetUserStatusEnum() UserStatusEnum {
	return UserStatusEmptyType
}

// UserStatusOnline The user is online
type UserStatusOnline struct {
	tdCommon
	Expires int32 `json:"expires"` // Point in time (Unix timestamp) when the user's online status will expire
}

// MessageType return the string telegram-type of UserStatusOnline
func (userStatusOnline *UserStatusOnline) MessageType() string {
	return "userStatusOnline"
}

// NewUserStatusOnline creates a new UserStatusOnline
//
// @param expires Point in time (Unix timestamp) when the user's online status will expire
func NewUserStatusOnline(expires int32) *UserStatusOnline {
	userStatusOnlineTemp := UserStatusOnline{
		tdCommon: tdCommon{Type: "userStatusOnline"},
		Expires:  expires,
	}

	return &userStatusOnlineTemp
}

// UnmarshalJSON unmarshal to json
func (userStatusOnline *UserStatusOnline) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Expires int32 `json:"expires"` // Point in time (Unix timestamp) when the user's online status will expire
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userStatusOnline.tdCommon = tempObj.tdCommon
	userStatusOnline.Expires = tempObj.Expires

	return nil
}

// GetUserStatusEnum return the enum type of this object
func (userStatusOnline *UserStatusOnline) GetUserStatusEnum() UserStatusEnum {
	return UserStatusOnlineType
}

// UserStatusOffline The user is offline
type UserStatusOffline struct {
	tdCommon
	WasOnline int32 `json:"was_online"` // Point in time (Unix timestamp) when the user was last online
}

// MessageType return the string telegram-type of UserStatusOffline
func (userStatusOffline *UserStatusOffline) MessageType() string {
	return "userStatusOffline"
}

// NewUserStatusOffline creates a new UserStatusOffline
//
// @param wasOnline Point in time (Unix timestamp) when the user was last online
func NewUserStatusOffline(wasOnline int32) *UserStatusOffline {
	userStatusOfflineTemp := UserStatusOffline{
		tdCommon:  tdCommon{Type: "userStatusOffline"},
		WasOnline: wasOnline,
	}

	return &userStatusOfflineTemp
}

// UnmarshalJSON unmarshal to json
func (userStatusOffline *UserStatusOffline) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		WasOnline int32 `json:"was_online"` // Point in time (Unix timestamp) when the user was last online
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userStatusOffline.tdCommon = tempObj.tdCommon
	userStatusOffline.WasOnline = tempObj.WasOnline

	return nil
}

// GetUserStatusEnum return the enum type of this object
func (userStatusOffline *UserStatusOffline) GetUserStatusEnum() UserStatusEnum {
	return UserStatusOfflineType
}

// UserStatusRecently The user was online recently
type UserStatusRecently struct {
	tdCommon
	ByMyPrivacySettings bool `json:"by_my_privacy_settings"` // Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus privacy setting for the user and has no Telegram Premium
}

// MessageType return the string telegram-type of UserStatusRecently
func (userStatusRecently *UserStatusRecently) MessageType() string {
	return "userStatusRecently"
}

// NewUserStatusRecently creates a new UserStatusRecently
//
// @param byMyPrivacySettings Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus privacy setting for the user and has no Telegram Premium
func NewUserStatusRecently(byMyPrivacySettings bool) *UserStatusRecently {
	userStatusRecentlyTemp := UserStatusRecently{
		tdCommon:            tdCommon{Type: "userStatusRecently"},
		ByMyPrivacySettings: byMyPrivacySettings,
	}

	return &userStatusRecentlyTemp
}

// UnmarshalJSON unmarshal to json
func (userStatusRecently *UserStatusRecently) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ByMyPrivacySettings bool `json:"by_my_privacy_settings"` // Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus privacy setting for the user and has no Telegram Premium
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userStatusRecently.tdCommon = tempObj.tdCommon
	userStatusRecently.ByMyPrivacySettings = tempObj.ByMyPrivacySettings

	return nil
}

// GetUserStatusEnum return the enum type of this object
func (userStatusRecently *UserStatusRecently) GetUserStatusEnum() UserStatusEnum {
	return UserStatusRecentlyType
}

// UserStatusLastWeek The user is offline, but was online last week
type UserStatusLastWeek struct {
	tdCommon
	ByMyPrivacySettings bool `json:"by_my_privacy_settings"` // Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus privacy setting for the user and has no Telegram Premium
}

// MessageType return the string telegram-type of UserStatusLastWeek
func (userStatusLastWeek *UserStatusLastWeek) MessageType() string {
	return "userStatusLastWeek"
}

// NewUserStatusLastWeek creates a new UserStatusLastWeek
//
// @param byMyPrivacySettings Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus privacy setting for the user and has no Telegram Premium
func NewUserStatusLastWeek(byMyPrivacySettings bool) *UserStatusLastWeek {
	userStatusLastWeekTemp := UserStatusLastWeek{
		tdCommon:            tdCommon{Type: "userStatusLastWeek"},
		ByMyPrivacySettings: byMyPrivacySettings,
	}

	return &userStatusLastWeekTemp
}

// UnmarshalJSON unmarshal to json
func (userStatusLastWeek *UserStatusLastWeek) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ByMyPrivacySettings bool `json:"by_my_privacy_settings"` // Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus privacy setting for the user and has no Telegram Premium
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userStatusLastWeek.tdCommon = tempObj.tdCommon
	userStatusLastWeek.ByMyPrivacySettings = tempObj.ByMyPrivacySettings

	return nil
}

// GetUserStatusEnum return the enum type of this object
func (userStatusLastWeek *UserStatusLastWeek) GetUserStatusEnum() UserStatusEnum {
	return UserStatusLastWeekType
}

// UserStatusLastMonth The user is offline, but was online last month
type UserStatusLastMonth struct {
	tdCommon
	ByMyPrivacySettings bool `json:"by_my_privacy_settings"` // Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus privacy setting for the user and has no Telegram Premium
}

// MessageType return the string telegram-type of UserStatusLastMonth
func (userStatusLastMonth *UserStatusLastMonth) MessageType() string {
	return "userStatusLastMonth"
}

// NewUserStatusLastMonth creates a new UserStatusLastMonth
//
// @param byMyPrivacySettings Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus privacy setting for the user and has no Telegram Premium
func NewUserStatusLastMonth(byMyPrivacySettings bool) *UserStatusLastMonth {
	userStatusLastMonthTemp := UserStatusLastMonth{
		tdCommon:            tdCommon{Type: "userStatusLastMonth"},
		ByMyPrivacySettings: byMyPrivacySettings,
	}

	return &userStatusLastMonthTemp
}

// UnmarshalJSON unmarshal to json
func (userStatusLastMonth *UserStatusLastMonth) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ByMyPrivacySettings bool `json:"by_my_privacy_settings"` // Exact user's status is hidden because the current user enabled userPrivacySettingShowStatus privacy setting for the user and has no Telegram Premium
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userStatusLastMonth.tdCommon = tempObj.tdCommon
	userStatusLastMonth.ByMyPrivacySettings = tempObj.ByMyPrivacySettings

	return nil
}

// GetUserStatusEnum return the enum type of this object
func (userStatusLastMonth *UserStatusLastMonth) GetUserStatusEnum() UserStatusEnum {
	return UserStatusLastMonthType
}

// EmojiKeyword Represents an emoji with its keyword
type EmojiKeyword struct {
	tdCommon
	Emoji   string `json:"emoji"`   // The emoji
	Keyword string `json:"keyword"` // The keyword
}

// MessageType return the string telegram-type of EmojiKeyword
func (emojiKeyword *EmojiKeyword) MessageType() string {
	return "emojiKeyword"
}

// NewEmojiKeyword creates a new EmojiKeyword
//
// @param emoji The emoji
// @param keyword The keyword
func NewEmojiKeyword(emoji string, keyword string) *EmojiKeyword {
	emojiKeywordTemp := EmojiKeyword{
		tdCommon: tdCommon{Type: "emojiKeyword"},
		Emoji:    emoji,
		Keyword:  keyword,
	}

	return &emojiKeywordTemp
}

// UnmarshalJSON unmarshal to json
func (emojiKeyword *EmojiKeyword) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Emoji   string `json:"emoji"`   // The emoji
		Keyword string `json:"keyword"` // The keyword
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	emojiKeyword.tdCommon = tempObj.tdCommon
	emojiKeyword.Emoji = tempObj.Emoji
	emojiKeyword.Keyword = tempObj.Keyword

	return nil
}

// EmojiKeywords Represents a list of emojis with their keywords
type EmojiKeywords struct {
	tdCommon
	EmojiKeywords []EmojiKeyword `json:"emoji_keywords"` // List of emojis with their keywords
}

// MessageType return the string telegram-type of EmojiKeywords
func (emojiKeywords *EmojiKeywords) MessageType() string {
	return "emojiKeywords"
}

// NewEmojiKeywords creates a new EmojiKeywords
//
// @param emojiKeywords List of emojis with their keywords
func NewEmojiKeywords(emojiKeywords []EmojiKeyword) *EmojiKeywords {
	emojiKeywordsTemp := EmojiKeywords{
		tdCommon:      tdCommon{Type: "emojiKeywords"},
		EmojiKeywords: emojiKeywords,
	}

	return &emojiKeywordsTemp
}

// UnmarshalJSON unmarshal to json
func (emojiKeywords *EmojiKeywords) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		EmojiKeywords []EmojiKeyword `json:"emoji_keywords"` // List of emojis with their keywords
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	emojiKeywords.tdCommon = tempObj.tdCommon
	emojiKeywords.EmojiKeywords = tempObj.EmojiKeywords

	return nil
}

// Stickers Represents a list of stickers
type Stickers struct {
	tdCommon
	Stickers []Sticker `json:"stickers"` // List of stickers
}

// MessageType return the string telegram-type of Stickers
func (stickers *Stickers) MessageType() string {
	return "stickers"
}

// NewStickers creates a new Stickers
//
// @param stickers List of stickers
func NewStickers(stickers []Sticker) *Stickers {
	stickersTemp := Stickers{
		tdCommon: tdCommon{Type: "stickers"},
		Stickers: stickers,
	}

	return &stickersTemp
}

// UnmarshalJSON unmarshal to json
func (stickers *Stickers) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Stickers []Sticker `json:"stickers"` // List of stickers
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	stickers.tdCommon = tempObj.tdCommon
	stickers.Stickers = tempObj.Stickers

	return nil
}

// Emojis Represents a list of emojis
type Emojis struct {
	tdCommon
	Emojis []string `json:"emojis"` // List of emojis
}

// MessageType return the string telegram-type of Emojis
func (emojis *Emojis) MessageType() string {
	return "emojis"
}

// NewEmojis creates a new Emojis
//
// @param emojis List of emojis
func NewEmojis(emojis []string) *Emojis {
	emojisTemp := Emojis{
		tdCommon: tdCommon{Type: "emojis"},
		Emojis:   emojis,
	}

	return &emojisTemp
}

// UnmarshalJSON unmarshal to json
func (emojis *Emojis) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Emojis []string `json:"emojis"` // List of emojis
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	emojis.tdCommon = tempObj.tdCommon
	emojis.Emojis = tempObj.Emojis

	return nil
}

// StickerSet Represents a sticker set
type StickerSet struct {
	tdCommon
	ID                         JSONInt64          `json:"id"`                              // Identifier of the sticker set
	Title                      string             `json:"title"`                           // Title of the sticker set
	Name                       string             `json:"name"`                            // Name of the sticker set
	Thumbnail                  *Thumbnail         `json:"thumbnail"`                       // Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null. The file can be downloaded only before the thumbnail is changed
	ThumbnailOutline           []ClosedVectorPath `json:"thumbnail_outline"`               // Sticker set thumbnail's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
	IsOwned                    bool               `json:"is_owned"`                        // True, if the sticker set is owned by the current user
	IsInstalled                bool               `json:"is_installed"`                    // True, if the sticker set has been installed by the current user
	IsArchived                 bool               `json:"is_archived"`                     // True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
	IsOfficial                 bool               `json:"is_official"`                     // True, if the sticker set is official
	StickerType                StickerType        `json:"sticker_type"`                    // Type of the stickers in the set
	NeedsRepainting            bool               `json:"needs_repainting"`                // True, if stickers in the sticker set are custom emoji that must be repainted; for custom emoji sticker sets only
	IsAllowedAsChatEmojiStatus bool               `json:"is_allowed_as_chat_emoji_status"` // True, if stickers in the sticker set are custom emoji that can be used as chat emoji status; for custom emoji sticker sets only
	IsViewed                   bool               `json:"is_viewed"`                       // True for already viewed trending sticker sets
	Stickers                   []Sticker          `json:"stickers"`                        // List of stickers in this set
	Emojis                     []Emojis           `json:"emojis"`                          // A list of emojis corresponding to the stickers in the same order. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object
}

// MessageType return the string telegram-type of StickerSet
func (stickerSet *StickerSet) MessageType() string {
	return "stickerSet"
}

// NewStickerSet creates a new StickerSet
//
// @param iD Identifier of the sticker set
// @param title Title of the sticker set
// @param name Name of the sticker set
// @param thumbnail Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null. The file can be downloaded only before the thumbnail is changed
// @param thumbnailOutline Sticker set thumbnail's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
// @param isOwned True, if the sticker set is owned by the current user
// @param isInstalled True, if the sticker set has been installed by the current user
// @param isArchived True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
// @param isOfficial True, if the sticker set is official
// @param stickerType Type of the stickers in the set
// @param needsRepainting True, if stickers in the sticker set are custom emoji that must be repainted; for custom emoji sticker sets only
// @param isAllowedAsChatEmojiStatus True, if stickers in the sticker set are custom emoji that can be used as chat emoji status; for custom emoji sticker sets only
// @param isViewed True for already viewed trending sticker sets
// @param stickers List of stickers in this set
// @param emojis A list of emojis corresponding to the stickers in the same order. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object
func NewStickerSet(iD JSONInt64, title string, name string, thumbnail *Thumbnail, thumbnailOutline []ClosedVectorPath, isOwned bool, isInstalled bool, isArchived bool, isOfficial bool, stickerType StickerType, needsRepainting bool, isAllowedAsChatEmojiStatus bool, isViewed bool, stickers []Sticker, emojis []Emojis) *StickerSet {
	stickerSetTemp := StickerSet{
		tdCommon:                   tdCommon{Type: "stickerSet"},
		ID:                         iD,
		Title:                      title,
		Name:                       name,
		Thumbnail:                  thumbnail,
		ThumbnailOutline:           thumbnailOutline,
		IsOwned:                    isOwned,
		IsInstalled:                isInstalled,
		IsArchived:                 isArchived,
		IsOfficial:                 isOfficial,
		StickerType:                stickerType,
		NeedsRepainting:            needsRepainting,
		IsAllowedAsChatEmojiStatus: isAllowedAsChatEmojiStatus,
		IsViewed:                   isViewed,
		Stickers:                   stickers,
		Emojis:                     emojis,
	}

	return &stickerSetTemp
}

// UnmarshalJSON unmarshal to json
func (stickerSet *StickerSet) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID                         JSONInt64          `json:"id"`                              // Identifier of the sticker set
		Title                      string             `json:"title"`                           // Title of the sticker set
		Name                       string             `json:"name"`                            // Name of the sticker set
		ThumbnailOutline           []ClosedVectorPath `json:"thumbnail_outline"`               // Sticker set thumbnail's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
		IsOwned                    bool               `json:"is_owned"`                        // True, if the sticker set is owned by the current user
		IsInstalled                bool               `json:"is_installed"`                    // True, if the sticker set has been installed by the current user
		IsArchived                 bool               `json:"is_archived"`                     // True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
		IsOfficial                 bool               `json:"is_official"`                     // True, if the sticker set is official
		NeedsRepainting            bool               `json:"needs_repainting"`                // True, if stickers in the sticker set are custom emoji that must be repainted; for custom emoji sticker sets only
		IsAllowedAsChatEmojiStatus bool               `json:"is_allowed_as_chat_emoji_status"` // True, if stickers in the sticker set are custom emoji that can be used as chat emoji status; for custom emoji sticker sets only
		IsViewed                   bool               `json:"is_viewed"`                       // True for already viewed trending sticker sets
		Stickers                   []Sticker          `json:"stickers"`                        // List of stickers in this set
		Emojis                     []Emojis           `json:"emojis"`                          // A list of emojis corresponding to the stickers in the same order. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	stickerSet.tdCommon = tempObj.tdCommon
	stickerSet.ID = tempObj.ID
	stickerSet.Title = tempObj.Title
	stickerSet.Name = tempObj.Name
	stickerSet.ThumbnailOutline = tempObj.ThumbnailOutline
	stickerSet.IsOwned = tempObj.IsOwned
	stickerSet.IsInstalled = tempObj.IsInstalled
	stickerSet.IsArchived = tempObj.IsArchived
	stickerSet.IsOfficial = tempObj.IsOfficial
	stickerSet.NeedsRepainting = tempObj.NeedsRepainting
	stickerSet.IsAllowedAsChatEmojiStatus = tempObj.IsAllowedAsChatEmojiStatus
	stickerSet.IsViewed = tempObj.IsViewed
	stickerSet.Stickers = tempObj.Stickers
	stickerSet.Emojis = tempObj.Emojis

	fieldStickerType, _ := unmarshalStickerType(objMap["sticker_type"])
	stickerSet.StickerType = fieldStickerType

	var thumbnail Thumbnail
	if objMap["thumbnail"] != nil {
		err = thumbnail.UnmarshalJSON(*objMap["thumbnail"])
		if err != nil {
			return err
		}
	}

	stickerSet.Thumbnail = &thumbnail

	return nil
}

// StickerSetInfo Represents short information about a sticker set
type StickerSetInfo struct {
	tdCommon
	ID                         JSONInt64          `json:"id"`                              // Identifier of the sticker set
	Title                      string             `json:"title"`                           // Title of the sticker set
	Name                       string             `json:"name"`                            // Name of the sticker set
	Thumbnail                  *Thumbnail         `json:"thumbnail"`                       // Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null. The file can be downloaded only before the thumbnail is changed
	ThumbnailOutline           []ClosedVectorPath `json:"thumbnail_outline"`               // Sticker set thumbnail's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
	IsOwned                    bool               `json:"is_owned"`                        // True, if the sticker set is owned by the current user
	IsInstalled                bool               `json:"is_installed"`                    // True, if the sticker set has been installed by the current user
	IsArchived                 bool               `json:"is_archived"`                     // True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
	IsOfficial                 bool               `json:"is_official"`                     // True, if the sticker set is official
	StickerType                StickerType        `json:"sticker_type"`                    // Type of the stickers in the set
	NeedsRepainting            bool               `json:"needs_repainting"`                // True, if stickers in the sticker set are custom emoji that must be repainted; for custom emoji sticker sets only
	IsAllowedAsChatEmojiStatus bool               `json:"is_allowed_as_chat_emoji_status"` // True, if stickers in the sticker set are custom emoji that can be used as chat emoji status; for custom emoji sticker sets only
	IsViewed                   bool               `json:"is_viewed"`                       // True for already viewed trending sticker sets
	Size                       int32              `json:"size"`                            // Total number of stickers in the set
	Covers                     []Sticker          `json:"covers"`                          // Up to the first 5 stickers from the set, depending on the context. If the application needs more stickers the full sticker set needs to be requested
}

// MessageType return the string telegram-type of StickerSetInfo
func (stickerSetInfo *StickerSetInfo) MessageType() string {
	return "stickerSetInfo"
}

// NewStickerSetInfo creates a new StickerSetInfo
//
// @param iD Identifier of the sticker set
// @param title Title of the sticker set
// @param name Name of the sticker set
// @param thumbnail Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null. The file can be downloaded only before the thumbnail is changed
// @param thumbnailOutline Sticker set thumbnail's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
// @param isOwned True, if the sticker set is owned by the current user
// @param isInstalled True, if the sticker set has been installed by the current user
// @param isArchived True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
// @param isOfficial True, if the sticker set is official
// @param stickerType Type of the stickers in the set
// @param needsRepainting True, if stickers in the sticker set are custom emoji that must be repainted; for custom emoji sticker sets only
// @param isAllowedAsChatEmojiStatus True, if stickers in the sticker set are custom emoji that can be used as chat emoji status; for custom emoji sticker sets only
// @param isViewed True for already viewed trending sticker sets
// @param size Total number of stickers in the set
// @param covers Up to the first 5 stickers from the set, depending on the context. If the application needs more stickers the full sticker set needs to be requested
func NewStickerSetInfo(iD JSONInt64, title string, name string, thumbnail *Thumbnail, thumbnailOutline []ClosedVectorPath, isOwned bool, isInstalled bool, isArchived bool, isOfficial bool, stickerType StickerType, needsRepainting bool, isAllowedAsChatEmojiStatus bool, isViewed bool, size int32, covers []Sticker) *StickerSetInfo {
	stickerSetInfoTemp := StickerSetInfo{
		tdCommon:                   tdCommon{Type: "stickerSetInfo"},
		ID:                         iD,
		Title:                      title,
		Name:                       name,
		Thumbnail:                  thumbnail,
		ThumbnailOutline:           thumbnailOutline,
		IsOwned:                    isOwned,
		IsInstalled:                isInstalled,
		IsArchived:                 isArchived,
		IsOfficial:                 isOfficial,
		StickerType:                stickerType,
		NeedsRepainting:            needsRepainting,
		IsAllowedAsChatEmojiStatus: isAllowedAsChatEmojiStatus,
		IsViewed:                   isViewed,
		Size:                       size,
		Covers:                     covers,
	}

	return &stickerSetInfoTemp
}

// UnmarshalJSON unmarshal to json
func (stickerSetInfo *StickerSetInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID                         JSONInt64          `json:"id"`                              // Identifier of the sticker set
		Title                      string             `json:"title"`                           // Title of the sticker set
		Name                       string             `json:"name"`                            // Name of the sticker set
		ThumbnailOutline           []ClosedVectorPath `json:"thumbnail_outline"`               // Sticker set thumbnail's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
		IsOwned                    bool               `json:"is_owned"`                        // True, if the sticker set is owned by the current user
		IsInstalled                bool               `json:"is_installed"`                    // True, if the sticker set has been installed by the current user
		IsArchived                 bool               `json:"is_archived"`                     // True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
		IsOfficial                 bool               `json:"is_official"`                     // True, if the sticker set is official
		NeedsRepainting            bool               `json:"needs_repainting"`                // True, if stickers in the sticker set are custom emoji that must be repainted; for custom emoji sticker sets only
		IsAllowedAsChatEmojiStatus bool               `json:"is_allowed_as_chat_emoji_status"` // True, if stickers in the sticker set are custom emoji that can be used as chat emoji status; for custom emoji sticker sets only
		IsViewed                   bool               `json:"is_viewed"`                       // True for already viewed trending sticker sets
		Size                       int32              `json:"size"`                            // Total number of stickers in the set
		Covers                     []Sticker          `json:"covers"`                          // Up to the first 5 stickers from the set, depending on the context. If the application needs more stickers the full sticker set needs to be requested
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	stickerSetInfo.tdCommon = tempObj.tdCommon
	stickerSetInfo.ID = tempObj.ID
	stickerSetInfo.Title = tempObj.Title
	stickerSetInfo.Name = tempObj.Name
	stickerSetInfo.ThumbnailOutline = tempObj.ThumbnailOutline
	stickerSetInfo.IsOwned = tempObj.IsOwned
	stickerSetInfo.IsInstalled = tempObj.IsInstalled
	stickerSetInfo.IsArchived = tempObj.IsArchived
	stickerSetInfo.IsOfficial = tempObj.IsOfficial
	stickerSetInfo.NeedsRepainting = tempObj.NeedsRepainting
	stickerSetInfo.IsAllowedAsChatEmojiStatus = tempObj.IsAllowedAsChatEmojiStatus
	stickerSetInfo.IsViewed = tempObj.IsViewed
	stickerSetInfo.Size = tempObj.Size
	stickerSetInfo.Covers = tempObj.Covers

	fieldStickerType, _ := unmarshalStickerType(objMap["sticker_type"])
	stickerSetInfo.StickerType = fieldStickerType

	var thumbnail Thumbnail
	if objMap["thumbnail"] != nil {
		err = thumbnail.UnmarshalJSON(*objMap["thumbnail"])
		if err != nil {
			return err
		}
	}

	stickerSetInfo.Thumbnail = &thumbnail

	return nil
}

// StickerSets Represents a list of sticker sets
type StickerSets struct {
	tdCommon
	TotalCount int32            `json:"total_count"` // Approximate total number of sticker sets found
	Sets       []StickerSetInfo `json:"sets"`        // List of sticker sets
}

// MessageType return the string telegram-type of StickerSets
func (stickerSets *StickerSets) MessageType() string {
	return "stickerSets"
}

// NewStickerSets creates a new StickerSets
//
// @param totalCount Approximate total number of sticker sets found
// @param sets List of sticker sets
func NewStickerSets(totalCount int32, sets []StickerSetInfo) *StickerSets {
	stickerSetsTemp := StickerSets{
		tdCommon:   tdCommon{Type: "stickerSets"},
		TotalCount: totalCount,
		Sets:       sets,
	}

	return &stickerSetsTemp
}

// UnmarshalJSON unmarshal to json
func (stickerSets *StickerSets) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32            `json:"total_count"` // Approximate total number of sticker sets found
		Sets       []StickerSetInfo `json:"sets"`        // List of sticker sets
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	stickerSets.tdCommon = tempObj.tdCommon
	stickerSets.TotalCount = tempObj.TotalCount
	stickerSets.Sets = tempObj.Sets

	return nil
}

// TrendingStickerSets Represents a list of trending sticker sets
type TrendingStickerSets struct {
	tdCommon
	TotalCount int32            `json:"total_count"` // Approximate total number of trending sticker sets
	Sets       []StickerSetInfo `json:"sets"`        // List of trending sticker sets
	IsPremium  bool             `json:"is_premium"`  // True, if the list contains sticker sets with premium stickers
}

// MessageType return the string telegram-type of TrendingStickerSets
func (trendingStickerSets *TrendingStickerSets) MessageType() string {
	return "trendingStickerSets"
}

// NewTrendingStickerSets creates a new TrendingStickerSets
//
// @param totalCount Approximate total number of trending sticker sets
// @param sets List of trending sticker sets
// @param isPremium True, if the list contains sticker sets with premium stickers
func NewTrendingStickerSets(totalCount int32, sets []StickerSetInfo, isPremium bool) *TrendingStickerSets {
	trendingStickerSetsTemp := TrendingStickerSets{
		tdCommon:   tdCommon{Type: "trendingStickerSets"},
		TotalCount: totalCount,
		Sets:       sets,
		IsPremium:  isPremium,
	}

	return &trendingStickerSetsTemp
}

// UnmarshalJSON unmarshal to json
func (trendingStickerSets *TrendingStickerSets) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32            `json:"total_count"` // Approximate total number of trending sticker sets
		Sets       []StickerSetInfo `json:"sets"`        // List of trending sticker sets
		IsPremium  bool             `json:"is_premium"`  // True, if the list contains sticker sets with premium stickers
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	trendingStickerSets.tdCommon = tempObj.tdCommon
	trendingStickerSets.TotalCount = tempObj.TotalCount
	trendingStickerSets.Sets = tempObj.Sets
	trendingStickerSets.IsPremium = tempObj.IsPremium

	return nil
}

// EmojiCategorySourceSearch The category contains a list of similar emoji to search for in getStickers and searchStickers for stickers, or getInlineQueryResults with the bot getOption("animation_search_bot_username") for animations
type EmojiCategorySourceSearch struct {
	tdCommon
	Emojis []string `json:"emojis"` // List of emojis to search for
}

// MessageType return the string telegram-type of EmojiCategorySourceSearch
func (emojiCategorySourceSearch *EmojiCategorySourceSearch) MessageType() string {
	return "emojiCategorySourceSearch"
}

// NewEmojiCategorySourceSearch creates a new EmojiCategorySourceSearch
//
// @param emojis List of emojis to search for
func NewEmojiCategorySourceSearch(emojis []string) *EmojiCategorySourceSearch {
	emojiCategorySourceSearchTemp := EmojiCategorySourceSearch{
		tdCommon: tdCommon{Type: "emojiCategorySourceSearch"},
		Emojis:   emojis,
	}

	return &emojiCategorySourceSearchTemp
}

// UnmarshalJSON unmarshal to json
func (emojiCategorySourceSearch *EmojiCategorySourceSearch) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Emojis []string `json:"emojis"` // List of emojis to search for
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	emojiCategorySourceSearch.tdCommon = tempObj.tdCommon
	emojiCategorySourceSearch.Emojis = tempObj.Emojis

	return nil
}

// GetEmojiCategorySourceEnum return the enum type of this object
func (emojiCategorySourceSearch *EmojiCategorySourceSearch) GetEmojiCategorySourceEnum() EmojiCategorySourceEnum {
	return EmojiCategorySourceSearchType
}

// EmojiCategorySourcePremium The category contains premium stickers that must be found by getPremiumStickers
type EmojiCategorySourcePremium struct {
	tdCommon
}

// MessageType return the string telegram-type of EmojiCategorySourcePremium
func (emojiCategorySourcePremium *EmojiCategorySourcePremium) MessageType() string {
	return "emojiCategorySourcePremium"
}

// NewEmojiCategorySourcePremium creates a new EmojiCategorySourcePremium
//
func NewEmojiCategorySourcePremium() *EmojiCategorySourcePremium {
	emojiCategorySourcePremiumTemp := EmojiCategorySourcePremium{
		tdCommon: tdCommon{Type: "emojiCategorySourcePremium"},
	}

	return &emojiCategorySourcePremiumTemp
}

// UnmarshalJSON unmarshal to json
func (emojiCategorySourcePremium *EmojiCategorySourcePremium) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	emojiCategorySourcePremium.tdCommon = tempObj.tdCommon

	return nil
}

// GetEmojiCategorySourceEnum return the enum type of this object
func (emojiCategorySourcePremium *EmojiCategorySourcePremium) GetEmojiCategorySourceEnum() EmojiCategorySourceEnum {
	return EmojiCategorySourcePremiumType
}

// EmojiCategory Describes an emoji category
type EmojiCategory struct {
	tdCommon
	Name       string              `json:"name"`        // Name of the category
	Icon       *Sticker            `json:"icon"`        // Custom emoji sticker, which represents icon of the category
	Source     EmojiCategorySource `json:"source"`      // Source of stickers for the emoji category
	IsGreeting bool                `json:"is_greeting"` // True, if the category must be shown first when choosing a sticker for the start page
}

// MessageType return the string telegram-type of EmojiCategory
func (emojiCategory *EmojiCategory) MessageType() string {
	return "emojiCategory"
}

// NewEmojiCategory creates a new EmojiCategory
//
// @param name Name of the category
// @param icon Custom emoji sticker, which represents icon of the category
// @param source Source of stickers for the emoji category
// @param isGreeting True, if the category must be shown first when choosing a sticker for the start page
func NewEmojiCategory(name string, icon *Sticker, source EmojiCategorySource, isGreeting bool) *EmojiCategory {
	emojiCategoryTemp := EmojiCategory{
		tdCommon:   tdCommon{Type: "emojiCategory"},
		Name:       name,
		Icon:       icon,
		Source:     source,
		IsGreeting: isGreeting,
	}

	return &emojiCategoryTemp
}

// UnmarshalJSON unmarshal to json
func (emojiCategory *EmojiCategory) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Name       string `json:"name"`        // Name of the category
		IsGreeting bool   `json:"is_greeting"` // True, if the category must be shown first when choosing a sticker for the start page
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	emojiCategory.tdCommon = tempObj.tdCommon
	emojiCategory.Name = tempObj.Name
	emojiCategory.IsGreeting = tempObj.IsGreeting

	fieldSource, _ := unmarshalEmojiCategorySource(objMap["source"])
	emojiCategory.Source = fieldSource

	var icon Sticker
	if objMap["icon"] != nil {
		err = icon.UnmarshalJSON(*objMap["icon"])
		if err != nil {
			return err
		}
	}

	emojiCategory.Icon = &icon

	return nil
}

// EmojiCategories Represents a list of emoji categories
type EmojiCategories struct {
	tdCommon
	Categories []EmojiCategory `json:"categories"` // List of categories
}

// MessageType return the string telegram-type of EmojiCategories
func (emojiCategories *EmojiCategories) MessageType() string {
	return "emojiCategories"
}

// NewEmojiCategories creates a new EmojiCategories
//
// @param categories List of categories
func NewEmojiCategories(categories []EmojiCategory) *EmojiCategories {
	emojiCategoriesTemp := EmojiCategories{
		tdCommon:   tdCommon{Type: "emojiCategories"},
		Categories: categories,
	}

	return &emojiCategoriesTemp
}

// UnmarshalJSON unmarshal to json
func (emojiCategories *EmojiCategories) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Categories []EmojiCategory `json:"categories"` // List of categories
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	emojiCategories.tdCommon = tempObj.tdCommon
	emojiCategories.Categories = tempObj.Categories

	return nil
}

// EmojiCategoryTypeDefault The category must be used by default (e.g., for custom emoji or animation search)
type EmojiCategoryTypeDefault struct {
	tdCommon
}

// MessageType return the string telegram-type of EmojiCategoryTypeDefault
func (emojiCategoryTypeDefault *EmojiCategoryTypeDefault) MessageType() string {
	return "emojiCategoryTypeDefault"
}

// NewEmojiCategoryTypeDefault creates a new EmojiCategoryTypeDefault
//
func NewEmojiCategoryTypeDefault() *EmojiCategoryTypeDefault {
	emojiCategoryTypeDefaultTemp := EmojiCategoryTypeDefault{
		tdCommon: tdCommon{Type: "emojiCategoryTypeDefault"},
	}

	return &emojiCategoryTypeDefaultTemp
}

// UnmarshalJSON unmarshal to json
func (emojiCategoryTypeDefault *EmojiCategoryTypeDefault) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	emojiCategoryTypeDefault.tdCommon = tempObj.tdCommon

	return nil
}

// GetEmojiCategoryTypeEnum return the enum type of this object
func (emojiCategoryTypeDefault *EmojiCategoryTypeDefault) GetEmojiCategoryTypeEnum() EmojiCategoryTypeEnum {
	return EmojiCategoryTypeDefaultType
}

// EmojiCategoryTypeRegularStickers The category must be used by default for regular sticker selection. It may contain greeting emoji category and premium stickers
type EmojiCategoryTypeRegularStickers struct {
	tdCommon
}

// MessageType return the string telegram-type of EmojiCategoryTypeRegularStickers
func (emojiCategoryTypeRegularStickers *EmojiCategoryTypeRegularStickers) MessageType() string {
	return "emojiCategoryTypeRegularStickers"
}

// NewEmojiCategoryTypeRegularStickers creates a new EmojiCategoryTypeRegularStickers
//
func NewEmojiCategoryTypeRegularStickers() *EmojiCategoryTypeRegularStickers {
	emojiCategoryTypeRegularStickersTemp := EmojiCategoryTypeRegularStickers{
		tdCommon: tdCommon{Type: "emojiCategoryTypeRegularStickers"},
	}

	return &emojiCategoryTypeRegularStickersTemp
}

// UnmarshalJSON unmarshal to json
func (emojiCategoryTypeRegularStickers *EmojiCategoryTypeRegularStickers) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	emojiCategoryTypeRegularStickers.tdCommon = tempObj.tdCommon

	return nil
}

// GetEmojiCategoryTypeEnum return the enum type of this object
func (emojiCategoryTypeRegularStickers *EmojiCategoryTypeRegularStickers) GetEmojiCategoryTypeEnum() EmojiCategoryTypeEnum {
	return EmojiCategoryTypeRegularStickersType
}

// EmojiCategoryTypeEmojiStatus The category must be used for emoji status selection
type EmojiCategoryTypeEmojiStatus struct {
	tdCommon
}

// MessageType return the string telegram-type of EmojiCategoryTypeEmojiStatus
func (emojiCategoryTypeEmojiStatus *EmojiCategoryTypeEmojiStatus) MessageType() string {
	return "emojiCategoryTypeEmojiStatus"
}

// NewEmojiCategoryTypeEmojiStatus creates a new EmojiCategoryTypeEmojiStatus
//
func NewEmojiCategoryTypeEmojiStatus() *EmojiCategoryTypeEmojiStatus {
	emojiCategoryTypeEmojiStatusTemp := EmojiCategoryTypeEmojiStatus{
		tdCommon: tdCommon{Type: "emojiCategoryTypeEmojiStatus"},
	}

	return &emojiCategoryTypeEmojiStatusTemp
}

// UnmarshalJSON unmarshal to json
func (emojiCategoryTypeEmojiStatus *EmojiCategoryTypeEmojiStatus) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	emojiCategoryTypeEmojiStatus.tdCommon = tempObj.tdCommon

	return nil
}

// GetEmojiCategoryTypeEnum return the enum type of this object
func (emojiCategoryTypeEmojiStatus *EmojiCategoryTypeEmojiStatus) GetEmojiCategoryTypeEnum() EmojiCategoryTypeEnum {
	return EmojiCategoryTypeEmojiStatusType
}

// EmojiCategoryTypeChatPhoto The category must be used for chat photo emoji selection
type EmojiCategoryTypeChatPhoto struct {
	tdCommon
}

// MessageType return the string telegram-type of EmojiCategoryTypeChatPhoto
func (emojiCategoryTypeChatPhoto *EmojiCategoryTypeChatPhoto) MessageType() string {
	return "emojiCategoryTypeChatPhoto"
}

// NewEmojiCategoryTypeChatPhoto creates a new EmojiCategoryTypeChatPhoto
//
func NewEmojiCategoryTypeChatPhoto() *EmojiCategoryTypeChatPhoto {
	emojiCategoryTypeChatPhotoTemp := EmojiCategoryTypeChatPhoto{
		tdCommon: tdCommon{Type: "emojiCategoryTypeChatPhoto"},
	}

	return &emojiCategoryTypeChatPhotoTemp
}

// UnmarshalJSON unmarshal to json
func (emojiCategoryTypeChatPhoto *EmojiCategoryTypeChatPhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	emojiCategoryTypeChatPhoto.tdCommon = tempObj.tdCommon

	return nil
}

// GetEmojiCategoryTypeEnum return the enum type of this object
func (emojiCategoryTypeChatPhoto *EmojiCategoryTypeChatPhoto) GetEmojiCategoryTypeEnum() EmojiCategoryTypeEnum {
	return EmojiCategoryTypeChatPhotoType
}

// CurrentWeather Describes the current weather
type CurrentWeather struct {
	tdCommon
	Temperature float64 `json:"temperature"` // Temperature, in degree Celsius
	Emoji       string  `json:"emoji"`       // Emoji representing the weather
}

// MessageType return the string telegram-type of CurrentWeather
func (currentWeather *CurrentWeather) MessageType() string {
	return "currentWeather"
}

// NewCurrentWeather creates a new CurrentWeather
//
// @param temperature Temperature, in degree Celsius
// @param emoji Emoji representing the weather
func NewCurrentWeather(temperature float64, emoji string) *CurrentWeather {
	currentWeatherTemp := CurrentWeather{
		tdCommon:    tdCommon{Type: "currentWeather"},
		Temperature: temperature,
		Emoji:       emoji,
	}

	return &currentWeatherTemp
}

// UnmarshalJSON unmarshal to json
func (currentWeather *CurrentWeather) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Temperature float64 `json:"temperature"` // Temperature, in degree Celsius
		Emoji       string  `json:"emoji"`       // Emoji representing the weather
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	currentWeather.tdCommon = tempObj.tdCommon
	currentWeather.Temperature = tempObj.Temperature
	currentWeather.Emoji = tempObj.Emoji

	return nil
}

// StoryAreaPosition Describes position of a clickable rectangle area on a story media
type StoryAreaPosition struct {
	tdCommon
	XPercentage            float64 `json:"x_percentage"`             // The abscissa of the rectangle's center, as a percentage of the media width
	YPercentage            float64 `json:"y_percentage"`             // The ordinate of the rectangle's center, as a percentage of the media height
	WidthPercentage        float64 `json:"width_percentage"`         // The width of the rectangle, as a percentage of the media width
	HeightPercentage       float64 `json:"height_percentage"`        // The height of the rectangle, as a percentage of the media height
	RotationAngle          float64 `json:"rotation_angle"`           // Clockwise rotation angle of the rectangle, in degrees; 0-360
	CornerRadiusPercentage float64 `json:"corner_radius_percentage"` // The radius of the rectangle corner rounding, as a percentage of the media width
}

// MessageType return the string telegram-type of StoryAreaPosition
func (storyAreaPosition *StoryAreaPosition) MessageType() string {
	return "storyAreaPosition"
}

// NewStoryAreaPosition creates a new StoryAreaPosition
//
// @param xPercentage The abscissa of the rectangle's center, as a percentage of the media width
// @param yPercentage The ordinate of the rectangle's center, as a percentage of the media height
// @param widthPercentage The width of the rectangle, as a percentage of the media width
// @param heightPercentage The height of the rectangle, as a percentage of the media height
// @param rotationAngle Clockwise rotation angle of the rectangle, in degrees; 0-360
// @param cornerRadiusPercentage The radius of the rectangle corner rounding, as a percentage of the media width
func NewStoryAreaPosition(xPercentage float64, yPercentage float64, widthPercentage float64, heightPercentage float64, rotationAngle float64, cornerRadiusPercentage float64) *StoryAreaPosition {
	storyAreaPositionTemp := StoryAreaPosition{
		tdCommon:               tdCommon{Type: "storyAreaPosition"},
		XPercentage:            xPercentage,
		YPercentage:            yPercentage,
		WidthPercentage:        widthPercentage,
		HeightPercentage:       heightPercentage,
		RotationAngle:          rotationAngle,
		CornerRadiusPercentage: cornerRadiusPercentage,
	}

	return &storyAreaPositionTemp
}

// UnmarshalJSON unmarshal to json
func (storyAreaPosition *StoryAreaPosition) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		XPercentage            float64 `json:"x_percentage"`             // The abscissa of the rectangle's center, as a percentage of the media width
		YPercentage            float64 `json:"y_percentage"`             // The ordinate of the rectangle's center, as a percentage of the media height
		WidthPercentage        float64 `json:"width_percentage"`         // The width of the rectangle, as a percentage of the media width
		HeightPercentage       float64 `json:"height_percentage"`        // The height of the rectangle, as a percentage of the media height
		RotationAngle          float64 `json:"rotation_angle"`           // Clockwise rotation angle of the rectangle, in degrees; 0-360
		CornerRadiusPercentage float64 `json:"corner_radius_percentage"` // The radius of the rectangle corner rounding, as a percentage of the media width
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyAreaPosition.tdCommon = tempObj.tdCommon
	storyAreaPosition.XPercentage = tempObj.XPercentage
	storyAreaPosition.YPercentage = tempObj.YPercentage
	storyAreaPosition.WidthPercentage = tempObj.WidthPercentage
	storyAreaPosition.HeightPercentage = tempObj.HeightPercentage
	storyAreaPosition.RotationAngle = tempObj.RotationAngle
	storyAreaPosition.CornerRadiusPercentage = tempObj.CornerRadiusPercentage

	return nil
}

// StoryAreaTypeLocation An area pointing to a location
type StoryAreaTypeLocation struct {
	tdCommon
	Location *Location        `json:"location"` // The location
	Address  *LocationAddress `json:"address"`  // Address of the location; may be null if unknown
}

// MessageType return the string telegram-type of StoryAreaTypeLocation
func (storyAreaTypeLocation *StoryAreaTypeLocation) MessageType() string {
	return "storyAreaTypeLocation"
}

// NewStoryAreaTypeLocation creates a new StoryAreaTypeLocation
//
// @param location The location
// @param address Address of the location; may be null if unknown
func NewStoryAreaTypeLocation(location *Location, address *LocationAddress) *StoryAreaTypeLocation {
	storyAreaTypeLocationTemp := StoryAreaTypeLocation{
		tdCommon: tdCommon{Type: "storyAreaTypeLocation"},
		Location: location,
		Address:  address,
	}

	return &storyAreaTypeLocationTemp
}

// UnmarshalJSON unmarshal to json
func (storyAreaTypeLocation *StoryAreaTypeLocation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Location *Location        `json:"location"` // The location
		Address  *LocationAddress `json:"address"`  // Address of the location; may be null if unknown
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyAreaTypeLocation.tdCommon = tempObj.tdCommon
	storyAreaTypeLocation.Location = tempObj.Location
	storyAreaTypeLocation.Address = tempObj.Address

	return nil
}

// GetStoryAreaTypeEnum return the enum type of this object
func (storyAreaTypeLocation *StoryAreaTypeLocation) GetStoryAreaTypeEnum() StoryAreaTypeEnum {
	return StoryAreaTypeLocationType
}

// StoryAreaTypeVenue An area pointing to a venue
type StoryAreaTypeVenue struct {
	tdCommon
	Venue *Venue `json:"venue"` // Information about the venue
}

// MessageType return the string telegram-type of StoryAreaTypeVenue
func (storyAreaTypeVenue *StoryAreaTypeVenue) MessageType() string {
	return "storyAreaTypeVenue"
}

// NewStoryAreaTypeVenue creates a new StoryAreaTypeVenue
//
// @param venue Information about the venue
func NewStoryAreaTypeVenue(venue *Venue) *StoryAreaTypeVenue {
	storyAreaTypeVenueTemp := StoryAreaTypeVenue{
		tdCommon: tdCommon{Type: "storyAreaTypeVenue"},
		Venue:    venue,
	}

	return &storyAreaTypeVenueTemp
}

// UnmarshalJSON unmarshal to json
func (storyAreaTypeVenue *StoryAreaTypeVenue) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Venue *Venue `json:"venue"` // Information about the venue
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyAreaTypeVenue.tdCommon = tempObj.tdCommon
	storyAreaTypeVenue.Venue = tempObj.Venue

	return nil
}

// GetStoryAreaTypeEnum return the enum type of this object
func (storyAreaTypeVenue *StoryAreaTypeVenue) GetStoryAreaTypeEnum() StoryAreaTypeEnum {
	return StoryAreaTypeVenueType
}

// StoryAreaTypeSuggestedReaction An area pointing to a suggested reaction. App needs to show a clickable reaction on the area and call setStoryReaction when the are is clicked
type StoryAreaTypeSuggestedReaction struct {
	tdCommon
	ReactionType ReactionType `json:"reaction_type"` // Type of the reaction
	TotalCount   int32        `json:"total_count"`   // Number of times the reaction was added
	IsDark       bool         `json:"is_dark"`       // True, if reaction has a dark background
	IsFlipped    bool         `json:"is_flipped"`    // True, if reaction corner is flipped
}

// MessageType return the string telegram-type of StoryAreaTypeSuggestedReaction
func (storyAreaTypeSuggestedReaction *StoryAreaTypeSuggestedReaction) MessageType() string {
	return "storyAreaTypeSuggestedReaction"
}

// NewStoryAreaTypeSuggestedReaction creates a new StoryAreaTypeSuggestedReaction
//
// @param reactionType Type of the reaction
// @param totalCount Number of times the reaction was added
// @param isDark True, if reaction has a dark background
// @param isFlipped True, if reaction corner is flipped
func NewStoryAreaTypeSuggestedReaction(reactionType ReactionType, totalCount int32, isDark bool, isFlipped bool) *StoryAreaTypeSuggestedReaction {
	storyAreaTypeSuggestedReactionTemp := StoryAreaTypeSuggestedReaction{
		tdCommon:     tdCommon{Type: "storyAreaTypeSuggestedReaction"},
		ReactionType: reactionType,
		TotalCount:   totalCount,
		IsDark:       isDark,
		IsFlipped:    isFlipped,
	}

	return &storyAreaTypeSuggestedReactionTemp
}

// UnmarshalJSON unmarshal to json
func (storyAreaTypeSuggestedReaction *StoryAreaTypeSuggestedReaction) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32 `json:"total_count"` // Number of times the reaction was added
		IsDark     bool  `json:"is_dark"`     // True, if reaction has a dark background
		IsFlipped  bool  `json:"is_flipped"`  // True, if reaction corner is flipped
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyAreaTypeSuggestedReaction.tdCommon = tempObj.tdCommon
	storyAreaTypeSuggestedReaction.TotalCount = tempObj.TotalCount
	storyAreaTypeSuggestedReaction.IsDark = tempObj.IsDark
	storyAreaTypeSuggestedReaction.IsFlipped = tempObj.IsFlipped

	fieldReactionType, _ := unmarshalReactionType(objMap["reaction_type"])
	storyAreaTypeSuggestedReaction.ReactionType = fieldReactionType

	return nil
}

// GetStoryAreaTypeEnum return the enum type of this object
func (storyAreaTypeSuggestedReaction *StoryAreaTypeSuggestedReaction) GetStoryAreaTypeEnum() StoryAreaTypeEnum {
	return StoryAreaTypeSuggestedReactionType
}

// StoryAreaTypeMessage An area pointing to a message
type StoryAreaTypeMessage struct {
	tdCommon
	ChatID    int64 `json:"chat_id"`    // Identifier of the chat with the message
	MessageID int64 `json:"message_id"` // Identifier of the message
}

// MessageType return the string telegram-type of StoryAreaTypeMessage
func (storyAreaTypeMessage *StoryAreaTypeMessage) MessageType() string {
	return "storyAreaTypeMessage"
}

// NewStoryAreaTypeMessage creates a new StoryAreaTypeMessage
//
// @param chatID Identifier of the chat with the message
// @param messageID Identifier of the message
func NewStoryAreaTypeMessage(chatID int64, messageID int64) *StoryAreaTypeMessage {
	storyAreaTypeMessageTemp := StoryAreaTypeMessage{
		tdCommon:  tdCommon{Type: "storyAreaTypeMessage"},
		ChatID:    chatID,
		MessageID: messageID,
	}

	return &storyAreaTypeMessageTemp
}

// UnmarshalJSON unmarshal to json
func (storyAreaTypeMessage *StoryAreaTypeMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID    int64 `json:"chat_id"`    // Identifier of the chat with the message
		MessageID int64 `json:"message_id"` // Identifier of the message
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyAreaTypeMessage.tdCommon = tempObj.tdCommon
	storyAreaTypeMessage.ChatID = tempObj.ChatID
	storyAreaTypeMessage.MessageID = tempObj.MessageID

	return nil
}

// GetStoryAreaTypeEnum return the enum type of this object
func (storyAreaTypeMessage *StoryAreaTypeMessage) GetStoryAreaTypeEnum() StoryAreaTypeEnum {
	return StoryAreaTypeMessageType
}

// StoryAreaTypeLink An area pointing to a HTTP or tg:// link
type StoryAreaTypeLink struct {
	tdCommon
	URL string `json:"url"` // HTTP or tg:// URL to be opened when the area is clicked
}

// MessageType return the string telegram-type of StoryAreaTypeLink
func (storyAreaTypeLink *StoryAreaTypeLink) MessageType() string {
	return "storyAreaTypeLink"
}

// NewStoryAreaTypeLink creates a new StoryAreaTypeLink
//
// @param uRL HTTP or tg:// URL to be opened when the area is clicked
func NewStoryAreaTypeLink(uRL string) *StoryAreaTypeLink {
	storyAreaTypeLinkTemp := StoryAreaTypeLink{
		tdCommon: tdCommon{Type: "storyAreaTypeLink"},
		URL:      uRL,
	}

	return &storyAreaTypeLinkTemp
}

// UnmarshalJSON unmarshal to json
func (storyAreaTypeLink *StoryAreaTypeLink) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL string `json:"url"` // HTTP or tg:// URL to be opened when the area is clicked
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyAreaTypeLink.tdCommon = tempObj.tdCommon
	storyAreaTypeLink.URL = tempObj.URL

	return nil
}

// GetStoryAreaTypeEnum return the enum type of this object
func (storyAreaTypeLink *StoryAreaTypeLink) GetStoryAreaTypeEnum() StoryAreaTypeEnum {
	return StoryAreaTypeLinkType
}

// StoryAreaTypeWeather An area with information about weather
type StoryAreaTypeWeather struct {
	tdCommon
	Temperature     float64 `json:"temperature"`      // Temperature, in degree Celsius
	Emoji           string  `json:"emoji"`            // Emoji representing the weather
	BackgroundColor int32   `json:"background_color"` // A color of the area background in the ARGB format
}

// MessageType return the string telegram-type of StoryAreaTypeWeather
func (storyAreaTypeWeather *StoryAreaTypeWeather) MessageType() string {
	return "storyAreaTypeWeather"
}

// NewStoryAreaTypeWeather creates a new StoryAreaTypeWeather
//
// @param temperature Temperature, in degree Celsius
// @param emoji Emoji representing the weather
// @param backgroundColor A color of the area background in the ARGB format
func NewStoryAreaTypeWeather(temperature float64, emoji string, backgroundColor int32) *StoryAreaTypeWeather {
	storyAreaTypeWeatherTemp := StoryAreaTypeWeather{
		tdCommon:        tdCommon{Type: "storyAreaTypeWeather"},
		Temperature:     temperature,
		Emoji:           emoji,
		BackgroundColor: backgroundColor,
	}

	return &storyAreaTypeWeatherTemp
}

// UnmarshalJSON unmarshal to json
func (storyAreaTypeWeather *StoryAreaTypeWeather) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Temperature     float64 `json:"temperature"`      // Temperature, in degree Celsius
		Emoji           string  `json:"emoji"`            // Emoji representing the weather
		BackgroundColor int32   `json:"background_color"` // A color of the area background in the ARGB format
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyAreaTypeWeather.tdCommon = tempObj.tdCommon
	storyAreaTypeWeather.Temperature = tempObj.Temperature
	storyAreaTypeWeather.Emoji = tempObj.Emoji
	storyAreaTypeWeather.BackgroundColor = tempObj.BackgroundColor

	return nil
}

// GetStoryAreaTypeEnum return the enum type of this object
func (storyAreaTypeWeather *StoryAreaTypeWeather) GetStoryAreaTypeEnum() StoryAreaTypeEnum {
	return StoryAreaTypeWeatherType
}

// StoryArea Describes a clickable rectangle area on a story media
type StoryArea struct {
	tdCommon
	Position *StoryAreaPosition `json:"position"` // Position of the area
	Type     StoryAreaType      `json:"type"`     // Type of the area
}

// MessageType return the string telegram-type of StoryArea
func (storyArea *StoryArea) MessageType() string {
	return "storyArea"
}

// NewStoryArea creates a new StoryArea
//
// @param position Position of the area
// @param typeParam Type of the area
func NewStoryArea(position *StoryAreaPosition, typeParam StoryAreaType) *StoryArea {
	storyAreaTemp := StoryArea{
		tdCommon: tdCommon{Type: "storyArea"},
		Position: position,
		Type:     typeParam,
	}

	return &storyAreaTemp
}

// UnmarshalJSON unmarshal to json
func (storyArea *StoryArea) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Position *StoryAreaPosition `json:"position"` // Position of the area

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyArea.tdCommon = tempObj.tdCommon
	storyArea.Position = tempObj.Position

	fieldType, _ := unmarshalStoryAreaType(objMap["type"])
	storyArea.Type = fieldType

	return nil
}

// InputStoryAreaTypeLocation An area pointing to a location
type InputStoryAreaTypeLocation struct {
	tdCommon
	Location *Location        `json:"location"` // The location
	Address  *LocationAddress `json:"address"`  // Address of the location; pass null if unknown
}

// MessageType return the string telegram-type of InputStoryAreaTypeLocation
func (inputStoryAreaTypeLocation *InputStoryAreaTypeLocation) MessageType() string {
	return "inputStoryAreaTypeLocation"
}

// NewInputStoryAreaTypeLocation creates a new InputStoryAreaTypeLocation
//
// @param location The location
// @param address Address of the location; pass null if unknown
func NewInputStoryAreaTypeLocation(location *Location, address *LocationAddress) *InputStoryAreaTypeLocation {
	inputStoryAreaTypeLocationTemp := InputStoryAreaTypeLocation{
		tdCommon: tdCommon{Type: "inputStoryAreaTypeLocation"},
		Location: location,
		Address:  address,
	}

	return &inputStoryAreaTypeLocationTemp
}

// UnmarshalJSON unmarshal to json
func (inputStoryAreaTypeLocation *InputStoryAreaTypeLocation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Location *Location        `json:"location"` // The location
		Address  *LocationAddress `json:"address"`  // Address of the location; pass null if unknown
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputStoryAreaTypeLocation.tdCommon = tempObj.tdCommon
	inputStoryAreaTypeLocation.Location = tempObj.Location
	inputStoryAreaTypeLocation.Address = tempObj.Address

	return nil
}

// GetInputStoryAreaTypeEnum return the enum type of this object
func (inputStoryAreaTypeLocation *InputStoryAreaTypeLocation) GetInputStoryAreaTypeEnum() InputStoryAreaTypeEnum {
	return InputStoryAreaTypeLocationType
}

// InputStoryAreaTypeFoundVenue An area pointing to a venue found by the bot getOption("venue_search_bot_username")
type InputStoryAreaTypeFoundVenue struct {
	tdCommon
	QueryID  JSONInt64 `json:"query_id"`  // Identifier of the inline query, used to found the venue
	ResultID string    `json:"result_id"` // Identifier of the inline query result
}

// MessageType return the string telegram-type of InputStoryAreaTypeFoundVenue
func (inputStoryAreaTypeFoundVenue *InputStoryAreaTypeFoundVenue) MessageType() string {
	return "inputStoryAreaTypeFoundVenue"
}

// NewInputStoryAreaTypeFoundVenue creates a new InputStoryAreaTypeFoundVenue
//
// @param queryID Identifier of the inline query, used to found the venue
// @param resultID Identifier of the inline query result
func NewInputStoryAreaTypeFoundVenue(queryID JSONInt64, resultID string) *InputStoryAreaTypeFoundVenue {
	inputStoryAreaTypeFoundVenueTemp := InputStoryAreaTypeFoundVenue{
		tdCommon: tdCommon{Type: "inputStoryAreaTypeFoundVenue"},
		QueryID:  queryID,
		ResultID: resultID,
	}

	return &inputStoryAreaTypeFoundVenueTemp
}

// UnmarshalJSON unmarshal to json
func (inputStoryAreaTypeFoundVenue *InputStoryAreaTypeFoundVenue) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		QueryID  JSONInt64 `json:"query_id"`  // Identifier of the inline query, used to found the venue
		ResultID string    `json:"result_id"` // Identifier of the inline query result
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputStoryAreaTypeFoundVenue.tdCommon = tempObj.tdCommon
	inputStoryAreaTypeFoundVenue.QueryID = tempObj.QueryID
	inputStoryAreaTypeFoundVenue.ResultID = tempObj.ResultID

	return nil
}

// GetInputStoryAreaTypeEnum return the enum type of this object
func (inputStoryAreaTypeFoundVenue *InputStoryAreaTypeFoundVenue) GetInputStoryAreaTypeEnum() InputStoryAreaTypeEnum {
	return InputStoryAreaTypeFoundVenueType
}

// InputStoryAreaTypePreviousVenue An area pointing to a venue already added to the story
type InputStoryAreaTypePreviousVenue struct {
	tdCommon
	VenueProvider string `json:"venue_provider"` // Provider of the venue
	VenueID       string `json:"venue_id"`       // Identifier of the venue in the provider database
}

// MessageType return the string telegram-type of InputStoryAreaTypePreviousVenue
func (inputStoryAreaTypePreviousVenue *InputStoryAreaTypePreviousVenue) MessageType() string {
	return "inputStoryAreaTypePreviousVenue"
}

// NewInputStoryAreaTypePreviousVenue creates a new InputStoryAreaTypePreviousVenue
//
// @param venueProvider Provider of the venue
// @param venueID Identifier of the venue in the provider database
func NewInputStoryAreaTypePreviousVenue(venueProvider string, venueID string) *InputStoryAreaTypePreviousVenue {
	inputStoryAreaTypePreviousVenueTemp := InputStoryAreaTypePreviousVenue{
		tdCommon:      tdCommon{Type: "inputStoryAreaTypePreviousVenue"},
		VenueProvider: venueProvider,
		VenueID:       venueID,
	}

	return &inputStoryAreaTypePreviousVenueTemp
}

// UnmarshalJSON unmarshal to json
func (inputStoryAreaTypePreviousVenue *InputStoryAreaTypePreviousVenue) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		VenueProvider string `json:"venue_provider"` // Provider of the venue
		VenueID       string `json:"venue_id"`       // Identifier of the venue in the provider database
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputStoryAreaTypePreviousVenue.tdCommon = tempObj.tdCommon
	inputStoryAreaTypePreviousVenue.VenueProvider = tempObj.VenueProvider
	inputStoryAreaTypePreviousVenue.VenueID = tempObj.VenueID

	return nil
}

// GetInputStoryAreaTypeEnum return the enum type of this object
func (inputStoryAreaTypePreviousVenue *InputStoryAreaTypePreviousVenue) GetInputStoryAreaTypeEnum() InputStoryAreaTypeEnum {
	return InputStoryAreaTypePreviousVenueType
}

// InputStoryAreaTypeSuggestedReaction An area pointing to a suggested reaction
type InputStoryAreaTypeSuggestedReaction struct {
	tdCommon
	ReactionType ReactionType `json:"reaction_type"` // Type of the reaction
	IsDark       bool         `json:"is_dark"`       // True, if reaction has a dark background
	IsFlipped    bool         `json:"is_flipped"`    // True, if reaction corner is flipped
}

// MessageType return the string telegram-type of InputStoryAreaTypeSuggestedReaction
func (inputStoryAreaTypeSuggestedReaction *InputStoryAreaTypeSuggestedReaction) MessageType() string {
	return "inputStoryAreaTypeSuggestedReaction"
}

// NewInputStoryAreaTypeSuggestedReaction creates a new InputStoryAreaTypeSuggestedReaction
//
// @param reactionType Type of the reaction
// @param isDark True, if reaction has a dark background
// @param isFlipped True, if reaction corner is flipped
func NewInputStoryAreaTypeSuggestedReaction(reactionType ReactionType, isDark bool, isFlipped bool) *InputStoryAreaTypeSuggestedReaction {
	inputStoryAreaTypeSuggestedReactionTemp := InputStoryAreaTypeSuggestedReaction{
		tdCommon:     tdCommon{Type: "inputStoryAreaTypeSuggestedReaction"},
		ReactionType: reactionType,
		IsDark:       isDark,
		IsFlipped:    isFlipped,
	}

	return &inputStoryAreaTypeSuggestedReactionTemp
}

// UnmarshalJSON unmarshal to json
func (inputStoryAreaTypeSuggestedReaction *InputStoryAreaTypeSuggestedReaction) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsDark    bool `json:"is_dark"`    // True, if reaction has a dark background
		IsFlipped bool `json:"is_flipped"` // True, if reaction corner is flipped
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputStoryAreaTypeSuggestedReaction.tdCommon = tempObj.tdCommon
	inputStoryAreaTypeSuggestedReaction.IsDark = tempObj.IsDark
	inputStoryAreaTypeSuggestedReaction.IsFlipped = tempObj.IsFlipped

	fieldReactionType, _ := unmarshalReactionType(objMap["reaction_type"])
	inputStoryAreaTypeSuggestedReaction.ReactionType = fieldReactionType

	return nil
}

// GetInputStoryAreaTypeEnum return the enum type of this object
func (inputStoryAreaTypeSuggestedReaction *InputStoryAreaTypeSuggestedReaction) GetInputStoryAreaTypeEnum() InputStoryAreaTypeEnum {
	return InputStoryAreaTypeSuggestedReactionType
}

// InputStoryAreaTypeMessage An area pointing to a message
type InputStoryAreaTypeMessage struct {
	tdCommon
	ChatID    int64 `json:"chat_id"`    // Identifier of the chat with the message. Currently, the chat must be a supergroup or a channel chat
	MessageID int64 `json:"message_id"` // Identifier of the message. Use messageProperties.can_be_shared_in_story to check whether the message is suitable
}

// MessageType return the string telegram-type of InputStoryAreaTypeMessage
func (inputStoryAreaTypeMessage *InputStoryAreaTypeMessage) MessageType() string {
	return "inputStoryAreaTypeMessage"
}

// NewInputStoryAreaTypeMessage creates a new InputStoryAreaTypeMessage
//
// @param chatID Identifier of the chat with the message. Currently, the chat must be a supergroup or a channel chat
// @param messageID Identifier of the message. Use messageProperties.can_be_shared_in_story to check whether the message is suitable
func NewInputStoryAreaTypeMessage(chatID int64, messageID int64) *InputStoryAreaTypeMessage {
	inputStoryAreaTypeMessageTemp := InputStoryAreaTypeMessage{
		tdCommon:  tdCommon{Type: "inputStoryAreaTypeMessage"},
		ChatID:    chatID,
		MessageID: messageID,
	}

	return &inputStoryAreaTypeMessageTemp
}

// UnmarshalJSON unmarshal to json
func (inputStoryAreaTypeMessage *InputStoryAreaTypeMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID    int64 `json:"chat_id"`    // Identifier of the chat with the message. Currently, the chat must be a supergroup or a channel chat
		MessageID int64 `json:"message_id"` // Identifier of the message. Use messageProperties.can_be_shared_in_story to check whether the message is suitable
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputStoryAreaTypeMessage.tdCommon = tempObj.tdCommon
	inputStoryAreaTypeMessage.ChatID = tempObj.ChatID
	inputStoryAreaTypeMessage.MessageID = tempObj.MessageID

	return nil
}

// GetInputStoryAreaTypeEnum return the enum type of this object
func (inputStoryAreaTypeMessage *InputStoryAreaTypeMessage) GetInputStoryAreaTypeEnum() InputStoryAreaTypeEnum {
	return InputStoryAreaTypeMessageType
}

// InputStoryAreaTypeLink An area pointing to a HTTP or tg:// link
type InputStoryAreaTypeLink struct {
	tdCommon
	URL string `json:"url"` // HTTP or tg:// URL to be opened when the area is clicked
}

// MessageType return the string telegram-type of InputStoryAreaTypeLink
func (inputStoryAreaTypeLink *InputStoryAreaTypeLink) MessageType() string {
	return "inputStoryAreaTypeLink"
}

// NewInputStoryAreaTypeLink creates a new InputStoryAreaTypeLink
//
// @param uRL HTTP or tg:// URL to be opened when the area is clicked
func NewInputStoryAreaTypeLink(uRL string) *InputStoryAreaTypeLink {
	inputStoryAreaTypeLinkTemp := InputStoryAreaTypeLink{
		tdCommon: tdCommon{Type: "inputStoryAreaTypeLink"},
		URL:      uRL,
	}

	return &inputStoryAreaTypeLinkTemp
}

// UnmarshalJSON unmarshal to json
func (inputStoryAreaTypeLink *InputStoryAreaTypeLink) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL string `json:"url"` // HTTP or tg:// URL to be opened when the area is clicked
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputStoryAreaTypeLink.tdCommon = tempObj.tdCommon
	inputStoryAreaTypeLink.URL = tempObj.URL

	return nil
}

// GetInputStoryAreaTypeEnum return the enum type of this object
func (inputStoryAreaTypeLink *InputStoryAreaTypeLink) GetInputStoryAreaTypeEnum() InputStoryAreaTypeEnum {
	return InputStoryAreaTypeLinkType
}

// InputStoryAreaTypeWeather An area with information about weather
type InputStoryAreaTypeWeather struct {
	tdCommon
	Temperature     float64 `json:"temperature"`      // Temperature, in degree Celsius
	Emoji           string  `json:"emoji"`            // Emoji representing the weather
	BackgroundColor int32   `json:"background_color"` // A color of the area background in the ARGB format
}

// MessageType return the string telegram-type of InputStoryAreaTypeWeather
func (inputStoryAreaTypeWeather *InputStoryAreaTypeWeather) MessageType() string {
	return "inputStoryAreaTypeWeather"
}

// NewInputStoryAreaTypeWeather creates a new InputStoryAreaTypeWeather
//
// @param temperature Temperature, in degree Celsius
// @param emoji Emoji representing the weather
// @param backgroundColor A color of the area background in the ARGB format
func NewInputStoryAreaTypeWeather(temperature float64, emoji string, backgroundColor int32) *InputStoryAreaTypeWeather {
	inputStoryAreaTypeWeatherTemp := InputStoryAreaTypeWeather{
		tdCommon:        tdCommon{Type: "inputStoryAreaTypeWeather"},
		Temperature:     temperature,
		Emoji:           emoji,
		BackgroundColor: backgroundColor,
	}

	return &inputStoryAreaTypeWeatherTemp
}

// UnmarshalJSON unmarshal to json
func (inputStoryAreaTypeWeather *InputStoryAreaTypeWeather) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Temperature     float64 `json:"temperature"`      // Temperature, in degree Celsius
		Emoji           string  `json:"emoji"`            // Emoji representing the weather
		BackgroundColor int32   `json:"background_color"` // A color of the area background in the ARGB format
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputStoryAreaTypeWeather.tdCommon = tempObj.tdCommon
	inputStoryAreaTypeWeather.Temperature = tempObj.Temperature
	inputStoryAreaTypeWeather.Emoji = tempObj.Emoji
	inputStoryAreaTypeWeather.BackgroundColor = tempObj.BackgroundColor

	return nil
}

// GetInputStoryAreaTypeEnum return the enum type of this object
func (inputStoryAreaTypeWeather *InputStoryAreaTypeWeather) GetInputStoryAreaTypeEnum() InputStoryAreaTypeEnum {
	return InputStoryAreaTypeWeatherType
}

// InputStoryArea Describes a clickable rectangle area on a story media to be added
type InputStoryArea struct {
	tdCommon
	Position *StoryAreaPosition `json:"position"` // Position of the area
	Type     InputStoryAreaType `json:"type"`     // Type of the area
}

// MessageType return the string telegram-type of InputStoryArea
func (inputStoryArea *InputStoryArea) MessageType() string {
	return "inputStoryArea"
}

// NewInputStoryArea creates a new InputStoryArea
//
// @param position Position of the area
// @param typeParam Type of the area
func NewInputStoryArea(position *StoryAreaPosition, typeParam InputStoryAreaType) *InputStoryArea {
	inputStoryAreaTemp := InputStoryArea{
		tdCommon: tdCommon{Type: "inputStoryArea"},
		Position: position,
		Type:     typeParam,
	}

	return &inputStoryAreaTemp
}

// UnmarshalJSON unmarshal to json
func (inputStoryArea *InputStoryArea) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Position *StoryAreaPosition `json:"position"` // Position of the area

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputStoryArea.tdCommon = tempObj.tdCommon
	inputStoryArea.Position = tempObj.Position

	fieldType, _ := unmarshalInputStoryAreaType(objMap["type"])
	inputStoryArea.Type = fieldType

	return nil
}

// InputStoryAreas Contains a list of story areas to be added
type InputStoryAreas struct {
	tdCommon
	Areas []InputStoryArea `json:"areas"` // List of input story areas. Currently, a story can have up to 10 inputStoryAreaTypeLocation, inputStoryAreaTypeFoundVenue, and inputStoryAreaTypePreviousVenue areas, up to getOption("story_suggested_reaction_area_count_max") inputStoryAreaTypeSuggestedReaction areas, up to 1 inputStoryAreaTypeMessage area, up to getOption("story_link_area_count_max") inputStoryAreaTypeLink areas if the current user is a Telegram Premium user, and up to 3 inputStoryAreaTypeWeather areas
}

// MessageType return the string telegram-type of InputStoryAreas
func (inputStoryAreas *InputStoryAreas) MessageType() string {
	return "inputStoryAreas"
}

// NewInputStoryAreas creates a new InputStoryAreas
//
// @param areas List of input story areas. Currently, a story can have up to 10 inputStoryAreaTypeLocation, inputStoryAreaTypeFoundVenue, and inputStoryAreaTypePreviousVenue areas, up to getOption("story_suggested_reaction_area_count_max") inputStoryAreaTypeSuggestedReaction areas, up to 1 inputStoryAreaTypeMessage area, up to getOption("story_link_area_count_max") inputStoryAreaTypeLink areas if the current user is a Telegram Premium user, and up to 3 inputStoryAreaTypeWeather areas
func NewInputStoryAreas(areas []InputStoryArea) *InputStoryAreas {
	inputStoryAreasTemp := InputStoryAreas{
		tdCommon: tdCommon{Type: "inputStoryAreas"},
		Areas:    areas,
	}

	return &inputStoryAreasTemp
}

// UnmarshalJSON unmarshal to json
func (inputStoryAreas *InputStoryAreas) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Areas []InputStoryArea `json:"areas"` // List of input story areas. Currently, a story can have up to 10 inputStoryAreaTypeLocation, inputStoryAreaTypeFoundVenue, and inputStoryAreaTypePreviousVenue areas, up to getOption("story_suggested_reaction_area_count_max") inputStoryAreaTypeSuggestedReaction areas, up to 1 inputStoryAreaTypeMessage area, up to getOption("story_link_area_count_max") inputStoryAreaTypeLink areas if the current user is a Telegram Premium user, and up to 3 inputStoryAreaTypeWeather areas
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputStoryAreas.tdCommon = tempObj.tdCommon
	inputStoryAreas.Areas = tempObj.Areas

	return nil
}

// StoryVideo Describes a video file sent in a story
type StoryVideo struct {
	tdCommon
	Duration            float64        `json:"duration"`              // Duration of the video, in seconds
	Width               int32          `json:"width"`                 // Video width
	Height              int32          `json:"height"`                // Video height
	HasStickers         bool           `json:"has_stickers"`          // True, if stickers were added to the video. The list of corresponding sticker sets can be received using getAttachedStickerSets
	IsAnimation         bool           `json:"is_animation"`          // True, if the video has no sound
	Minithumbnail       *Minithumbnail `json:"minithumbnail"`         // Video minithumbnail; may be null
	Thumbnail           *Thumbnail     `json:"thumbnail"`             // Video thumbnail in JPEG or MPEG4 format; may be null
	PreloadPrefixSize   int32          `json:"preload_prefix_size"`   // Size of file prefix, which is supposed to be preloaded, in bytes
	CoverFrameTimestamp float64        `json:"cover_frame_timestamp"` // Timestamp of the frame used as video thumbnail
	Video               *File          `json:"video"`                 // File containing the video
}

// MessageType return the string telegram-type of StoryVideo
func (storyVideo *StoryVideo) MessageType() string {
	return "storyVideo"
}

// NewStoryVideo creates a new StoryVideo
//
// @param duration Duration of the video, in seconds
// @param width Video width
// @param height Video height
// @param hasStickers True, if stickers were added to the video. The list of corresponding sticker sets can be received using getAttachedStickerSets
// @param isAnimation True, if the video has no sound
// @param minithumbnail Video minithumbnail; may be null
// @param thumbnail Video thumbnail in JPEG or MPEG4 format; may be null
// @param preloadPrefixSize Size of file prefix, which is supposed to be preloaded, in bytes
// @param coverFrameTimestamp Timestamp of the frame used as video thumbnail
// @param video File containing the video
func NewStoryVideo(duration float64, width int32, height int32, hasStickers bool, isAnimation bool, minithumbnail *Minithumbnail, thumbnail *Thumbnail, preloadPrefixSize int32, coverFrameTimestamp float64, video *File) *StoryVideo {
	storyVideoTemp := StoryVideo{
		tdCommon:            tdCommon{Type: "storyVideo"},
		Duration:            duration,
		Width:               width,
		Height:              height,
		HasStickers:         hasStickers,
		IsAnimation:         isAnimation,
		Minithumbnail:       minithumbnail,
		Thumbnail:           thumbnail,
		PreloadPrefixSize:   preloadPrefixSize,
		CoverFrameTimestamp: coverFrameTimestamp,
		Video:               video,
	}

	return &storyVideoTemp
}

// UnmarshalJSON unmarshal to json
func (storyVideo *StoryVideo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Duration            float64        `json:"duration"`              // Duration of the video, in seconds
		Width               int32          `json:"width"`                 // Video width
		Height              int32          `json:"height"`                // Video height
		HasStickers         bool           `json:"has_stickers"`          // True, if stickers were added to the video. The list of corresponding sticker sets can be received using getAttachedStickerSets
		IsAnimation         bool           `json:"is_animation"`          // True, if the video has no sound
		Minithumbnail       *Minithumbnail `json:"minithumbnail"`         // Video minithumbnail; may be null
		PreloadPrefixSize   int32          `json:"preload_prefix_size"`   // Size of file prefix, which is supposed to be preloaded, in bytes
		CoverFrameTimestamp float64        `json:"cover_frame_timestamp"` // Timestamp of the frame used as video thumbnail
		Video               *File          `json:"video"`                 // File containing the video
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyVideo.tdCommon = tempObj.tdCommon
	storyVideo.Duration = tempObj.Duration
	storyVideo.Width = tempObj.Width
	storyVideo.Height = tempObj.Height
	storyVideo.HasStickers = tempObj.HasStickers
	storyVideo.IsAnimation = tempObj.IsAnimation
	storyVideo.Minithumbnail = tempObj.Minithumbnail
	storyVideo.PreloadPrefixSize = tempObj.PreloadPrefixSize
	storyVideo.CoverFrameTimestamp = tempObj.CoverFrameTimestamp
	storyVideo.Video = tempObj.Video

	var thumbnail Thumbnail
	if objMap["thumbnail"] != nil {
		err = thumbnail.UnmarshalJSON(*objMap["thumbnail"])
		if err != nil {
			return err
		}
	}

	storyVideo.Thumbnail = &thumbnail

	return nil
}

// StoryContentPhoto A photo story
type StoryContentPhoto struct {
	tdCommon
	Photo *Photo `json:"photo"` // The photo
}

// MessageType return the string telegram-type of StoryContentPhoto
func (storyContentPhoto *StoryContentPhoto) MessageType() string {
	return "storyContentPhoto"
}

// NewStoryContentPhoto creates a new StoryContentPhoto
//
// @param photo The photo
func NewStoryContentPhoto(photo *Photo) *StoryContentPhoto {
	storyContentPhotoTemp := StoryContentPhoto{
		tdCommon: tdCommon{Type: "storyContentPhoto"},
		Photo:    photo,
	}

	return &storyContentPhotoTemp
}

// UnmarshalJSON unmarshal to json
func (storyContentPhoto *StoryContentPhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Photo *Photo `json:"photo"` // The photo
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyContentPhoto.tdCommon = tempObj.tdCommon
	storyContentPhoto.Photo = tempObj.Photo

	return nil
}

// GetStoryContentEnum return the enum type of this object
func (storyContentPhoto *StoryContentPhoto) GetStoryContentEnum() StoryContentEnum {
	return StoryContentPhotoType
}

// StoryContentVideo A video story
type StoryContentVideo struct {
	tdCommon
	Video            *StoryVideo `json:"video"`             // The video in MPEG4 format
	AlternativeVideo *StoryVideo `json:"alternative_video"` // Alternative version of the video in MPEG4 format, encoded by x264 codec; may be null
}

// MessageType return the string telegram-type of StoryContentVideo
func (storyContentVideo *StoryContentVideo) MessageType() string {
	return "storyContentVideo"
}

// NewStoryContentVideo creates a new StoryContentVideo
//
// @param video The video in MPEG4 format
// @param alternativeVideo Alternative version of the video in MPEG4 format, encoded by x264 codec; may be null
func NewStoryContentVideo(video *StoryVideo, alternativeVideo *StoryVideo) *StoryContentVideo {
	storyContentVideoTemp := StoryContentVideo{
		tdCommon:         tdCommon{Type: "storyContentVideo"},
		Video:            video,
		AlternativeVideo: alternativeVideo,
	}

	return &storyContentVideoTemp
}

// UnmarshalJSON unmarshal to json
func (storyContentVideo *StoryContentVideo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Video            *StoryVideo `json:"video"`             // The video in MPEG4 format
		AlternativeVideo *StoryVideo `json:"alternative_video"` // Alternative version of the video in MPEG4 format, encoded by x264 codec; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyContentVideo.tdCommon = tempObj.tdCommon
	storyContentVideo.Video = tempObj.Video
	storyContentVideo.AlternativeVideo = tempObj.AlternativeVideo

	return nil
}

// GetStoryContentEnum return the enum type of this object
func (storyContentVideo *StoryContentVideo) GetStoryContentEnum() StoryContentEnum {
	return StoryContentVideoType
}

// StoryContentUnsupported A story content that is not supported in the current TDLib version
type StoryContentUnsupported struct {
	tdCommon
}

// MessageType return the string telegram-type of StoryContentUnsupported
func (storyContentUnsupported *StoryContentUnsupported) MessageType() string {
	return "storyContentUnsupported"
}

// NewStoryContentUnsupported creates a new StoryContentUnsupported
//
func NewStoryContentUnsupported() *StoryContentUnsupported {
	storyContentUnsupportedTemp := StoryContentUnsupported{
		tdCommon: tdCommon{Type: "storyContentUnsupported"},
	}

	return &storyContentUnsupportedTemp
}

// UnmarshalJSON unmarshal to json
func (storyContentUnsupported *StoryContentUnsupported) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyContentUnsupported.tdCommon = tempObj.tdCommon

	return nil
}

// GetStoryContentEnum return the enum type of this object
func (storyContentUnsupported *StoryContentUnsupported) GetStoryContentEnum() StoryContentEnum {
	return StoryContentUnsupportedType
}

// InputStoryContentPhoto A photo story
type InputStoryContentPhoto struct {
	tdCommon
	Photo               InputFile `json:"photo"`                  // Photo to send. The photo must be at most 10 MB in size. The photo size must be 1080x1920
	AddedStickerFileIDs []int32   `json:"added_sticker_file_ids"` // File identifiers of the stickers added to the photo, if applicable
}

// MessageType return the string telegram-type of InputStoryContentPhoto
func (inputStoryContentPhoto *InputStoryContentPhoto) MessageType() string {
	return "inputStoryContentPhoto"
}

// NewInputStoryContentPhoto creates a new InputStoryContentPhoto
//
// @param photo Photo to send. The photo must be at most 10 MB in size. The photo size must be 1080x1920
// @param addedStickerFileIDs File identifiers of the stickers added to the photo, if applicable
func NewInputStoryContentPhoto(photo InputFile, addedStickerFileIDs []int32) *InputStoryContentPhoto {
	inputStoryContentPhotoTemp := InputStoryContentPhoto{
		tdCommon:            tdCommon{Type: "inputStoryContentPhoto"},
		Photo:               photo,
		AddedStickerFileIDs: addedStickerFileIDs,
	}

	return &inputStoryContentPhotoTemp
}

// UnmarshalJSON unmarshal to json
func (inputStoryContentPhoto *InputStoryContentPhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		AddedStickerFileIDs []int32 `json:"added_sticker_file_ids"` // File identifiers of the stickers added to the photo, if applicable
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputStoryContentPhoto.tdCommon = tempObj.tdCommon
	inputStoryContentPhoto.AddedStickerFileIDs = tempObj.AddedStickerFileIDs

	fieldPhoto, _ := unmarshalInputFile(objMap["photo"])
	inputStoryContentPhoto.Photo = fieldPhoto

	return nil
}

// GetInputStoryContentEnum return the enum type of this object
func (inputStoryContentPhoto *InputStoryContentPhoto) GetInputStoryContentEnum() InputStoryContentEnum {
	return InputStoryContentPhotoType
}

// InputStoryContentVideo A video story
type InputStoryContentVideo struct {
	tdCommon
	Video               InputFile `json:"video"`                  // Video to be sent. The video size must be 720x1280. The video must be streamable and stored in MPEG4 format, after encoding with x265 codec and key frames added each second
	AddedStickerFileIDs []int32   `json:"added_sticker_file_ids"` // File identifiers of the stickers added to the video, if applicable
	Duration            float64   `json:"duration"`               // Precise duration of the video, in seconds; 0-60
	CoverFrameTimestamp float64   `json:"cover_frame_timestamp"`  // Timestamp of the frame, which will be used as video thumbnail
	IsAnimation         bool      `json:"is_animation"`           // True, if the video has no sound
}

// MessageType return the string telegram-type of InputStoryContentVideo
func (inputStoryContentVideo *InputStoryContentVideo) MessageType() string {
	return "inputStoryContentVideo"
}

// NewInputStoryContentVideo creates a new InputStoryContentVideo
//
// @param video Video to be sent. The video size must be 720x1280. The video must be streamable and stored in MPEG4 format, after encoding with x265 codec and key frames added each second
// @param addedStickerFileIDs File identifiers of the stickers added to the video, if applicable
// @param duration Precise duration of the video, in seconds; 0-60
// @param coverFrameTimestamp Timestamp of the frame, which will be used as video thumbnail
// @param isAnimation True, if the video has no sound
func NewInputStoryContentVideo(video InputFile, addedStickerFileIDs []int32, duration float64, coverFrameTimestamp float64, isAnimation bool) *InputStoryContentVideo {
	inputStoryContentVideoTemp := InputStoryContentVideo{
		tdCommon:            tdCommon{Type: "inputStoryContentVideo"},
		Video:               video,
		AddedStickerFileIDs: addedStickerFileIDs,
		Duration:            duration,
		CoverFrameTimestamp: coverFrameTimestamp,
		IsAnimation:         isAnimation,
	}

	return &inputStoryContentVideoTemp
}

// UnmarshalJSON unmarshal to json
func (inputStoryContentVideo *InputStoryContentVideo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		AddedStickerFileIDs []int32 `json:"added_sticker_file_ids"` // File identifiers of the stickers added to the video, if applicable
		Duration            float64 `json:"duration"`               // Precise duration of the video, in seconds; 0-60
		CoverFrameTimestamp float64 `json:"cover_frame_timestamp"`  // Timestamp of the frame, which will be used as video thumbnail
		IsAnimation         bool    `json:"is_animation"`           // True, if the video has no sound
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputStoryContentVideo.tdCommon = tempObj.tdCommon
	inputStoryContentVideo.AddedStickerFileIDs = tempObj.AddedStickerFileIDs
	inputStoryContentVideo.Duration = tempObj.Duration
	inputStoryContentVideo.CoverFrameTimestamp = tempObj.CoverFrameTimestamp
	inputStoryContentVideo.IsAnimation = tempObj.IsAnimation

	fieldVideo, _ := unmarshalInputFile(objMap["video"])
	inputStoryContentVideo.Video = fieldVideo

	return nil
}

// GetInputStoryContentEnum return the enum type of this object
func (inputStoryContentVideo *InputStoryContentVideo) GetInputStoryContentEnum() InputStoryContentEnum {
	return InputStoryContentVideoType
}

// StoryListMain The list of stories, shown in the main chat list and folder chat lists
type StoryListMain struct {
	tdCommon
}

// MessageType return the string telegram-type of StoryListMain
func (storyListMain *StoryListMain) MessageType() string {
	return "storyListMain"
}

// NewStoryListMain creates a new StoryListMain
//
func NewStoryListMain() *StoryListMain {
	storyListMainTemp := StoryListMain{
		tdCommon: tdCommon{Type: "storyListMain"},
	}

	return &storyListMainTemp
}

// UnmarshalJSON unmarshal to json
func (storyListMain *StoryListMain) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyListMain.tdCommon = tempObj.tdCommon

	return nil
}

// GetStoryListEnum return the enum type of this object
func (storyListMain *StoryListMain) GetStoryListEnum() StoryListEnum {
	return StoryListMainType
}

// StoryListArchive The list of stories, shown in the Arvhive chat list
type StoryListArchive struct {
	tdCommon
}

// MessageType return the string telegram-type of StoryListArchive
func (storyListArchive *StoryListArchive) MessageType() string {
	return "storyListArchive"
}

// NewStoryListArchive creates a new StoryListArchive
//
func NewStoryListArchive() *StoryListArchive {
	storyListArchiveTemp := StoryListArchive{
		tdCommon: tdCommon{Type: "storyListArchive"},
	}

	return &storyListArchiveTemp
}

// UnmarshalJSON unmarshal to json
func (storyListArchive *StoryListArchive) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyListArchive.tdCommon = tempObj.tdCommon

	return nil
}

// GetStoryListEnum return the enum type of this object
func (storyListArchive *StoryListArchive) GetStoryListEnum() StoryListEnum {
	return StoryListArchiveType
}

// StoryOriginPublicStory The original story was a public story with known sender
type StoryOriginPublicStory struct {
	tdCommon
	ChatID  int64 `json:"chat_id"`  // Identifier of the chat that posted original story
	StoryID int32 `json:"story_id"` // Story identifier of the original story
}

// MessageType return the string telegram-type of StoryOriginPublicStory
func (storyOriginPublicStory *StoryOriginPublicStory) MessageType() string {
	return "storyOriginPublicStory"
}

// NewStoryOriginPublicStory creates a new StoryOriginPublicStory
//
// @param chatID Identifier of the chat that posted original story
// @param storyID Story identifier of the original story
func NewStoryOriginPublicStory(chatID int64, storyID int32) *StoryOriginPublicStory {
	storyOriginPublicStoryTemp := StoryOriginPublicStory{
		tdCommon: tdCommon{Type: "storyOriginPublicStory"},
		ChatID:   chatID,
		StoryID:  storyID,
	}

	return &storyOriginPublicStoryTemp
}

// UnmarshalJSON unmarshal to json
func (storyOriginPublicStory *StoryOriginPublicStory) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID  int64 `json:"chat_id"`  // Identifier of the chat that posted original story
		StoryID int32 `json:"story_id"` // Story identifier of the original story
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyOriginPublicStory.tdCommon = tempObj.tdCommon
	storyOriginPublicStory.ChatID = tempObj.ChatID
	storyOriginPublicStory.StoryID = tempObj.StoryID

	return nil
}

// GetStoryOriginEnum return the enum type of this object
func (storyOriginPublicStory *StoryOriginPublicStory) GetStoryOriginEnum() StoryOriginEnum {
	return StoryOriginPublicStoryType
}

// StoryOriginHiddenUser The original story was sent by an unknown user
type StoryOriginHiddenUser struct {
	tdCommon
	SenderName string `json:"sender_name"` // Name of the story sender
}

// MessageType return the string telegram-type of StoryOriginHiddenUser
func (storyOriginHiddenUser *StoryOriginHiddenUser) MessageType() string {
	return "storyOriginHiddenUser"
}

// NewStoryOriginHiddenUser creates a new StoryOriginHiddenUser
//
// @param senderName Name of the story sender
func NewStoryOriginHiddenUser(senderName string) *StoryOriginHiddenUser {
	storyOriginHiddenUserTemp := StoryOriginHiddenUser{
		tdCommon:   tdCommon{Type: "storyOriginHiddenUser"},
		SenderName: senderName,
	}

	return &storyOriginHiddenUserTemp
}

// UnmarshalJSON unmarshal to json
func (storyOriginHiddenUser *StoryOriginHiddenUser) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SenderName string `json:"sender_name"` // Name of the story sender
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyOriginHiddenUser.tdCommon = tempObj.tdCommon
	storyOriginHiddenUser.SenderName = tempObj.SenderName

	return nil
}

// GetStoryOriginEnum return the enum type of this object
func (storyOriginHiddenUser *StoryOriginHiddenUser) GetStoryOriginEnum() StoryOriginEnum {
	return StoryOriginHiddenUserType
}

// StoryRepostInfo Contains information about original story that was reposted
type StoryRepostInfo struct {
	tdCommon
	Origin            StoryOrigin `json:"origin"`              // Origin of the story that was reposted
	IsContentModified bool        `json:"is_content_modified"` // True, if story content was modified during reposting; otherwise, story wasn't modified
}

// MessageType return the string telegram-type of StoryRepostInfo
func (storyRepostInfo *StoryRepostInfo) MessageType() string {
	return "storyRepostInfo"
}

// NewStoryRepostInfo creates a new StoryRepostInfo
//
// @param origin Origin of the story that was reposted
// @param isContentModified True, if story content was modified during reposting; otherwise, story wasn't modified
func NewStoryRepostInfo(origin StoryOrigin, isContentModified bool) *StoryRepostInfo {
	storyRepostInfoTemp := StoryRepostInfo{
		tdCommon:          tdCommon{Type: "storyRepostInfo"},
		Origin:            origin,
		IsContentModified: isContentModified,
	}

	return &storyRepostInfoTemp
}

// UnmarshalJSON unmarshal to json
func (storyRepostInfo *StoryRepostInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsContentModified bool `json:"is_content_modified"` // True, if story content was modified during reposting; otherwise, story wasn't modified
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyRepostInfo.tdCommon = tempObj.tdCommon
	storyRepostInfo.IsContentModified = tempObj.IsContentModified

	fieldOrigin, _ := unmarshalStoryOrigin(objMap["origin"])
	storyRepostInfo.Origin = fieldOrigin

	return nil
}

// StoryInteractionInfo Contains information about interactions with a story
type StoryInteractionInfo struct {
	tdCommon
	ViewCount           int32   `json:"view_count"`             // Number of times the story was viewed
	ForwardCount        int32   `json:"forward_count"`          // Number of times the story was forwarded; 0 if none or unknown
	ReactionCount       int32   `json:"reaction_count"`         // Number of reactions added to the story; 0 if none or unknown
	RecentViewerUserIDs []int64 `json:"recent_viewer_user_ids"` // Identifiers of at most 3 recent viewers of the story
}

// MessageType return the string telegram-type of StoryInteractionInfo
func (storyInteractionInfo *StoryInteractionInfo) MessageType() string {
	return "storyInteractionInfo"
}

// NewStoryInteractionInfo creates a new StoryInteractionInfo
//
// @param viewCount Number of times the story was viewed
// @param forwardCount Number of times the story was forwarded; 0 if none or unknown
// @param reactionCount Number of reactions added to the story; 0 if none or unknown
// @param recentViewerUserIDs Identifiers of at most 3 recent viewers of the story
func NewStoryInteractionInfo(viewCount int32, forwardCount int32, reactionCount int32, recentViewerUserIDs []int64) *StoryInteractionInfo {
	storyInteractionInfoTemp := StoryInteractionInfo{
		tdCommon:            tdCommon{Type: "storyInteractionInfo"},
		ViewCount:           viewCount,
		ForwardCount:        forwardCount,
		ReactionCount:       reactionCount,
		RecentViewerUserIDs: recentViewerUserIDs,
	}

	return &storyInteractionInfoTemp
}

// UnmarshalJSON unmarshal to json
func (storyInteractionInfo *StoryInteractionInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ViewCount           int32   `json:"view_count"`             // Number of times the story was viewed
		ForwardCount        int32   `json:"forward_count"`          // Number of times the story was forwarded; 0 if none or unknown
		ReactionCount       int32   `json:"reaction_count"`         // Number of reactions added to the story; 0 if none or unknown
		RecentViewerUserIDs []int64 `json:"recent_viewer_user_ids"` // Identifiers of at most 3 recent viewers of the story
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyInteractionInfo.tdCommon = tempObj.tdCommon
	storyInteractionInfo.ViewCount = tempObj.ViewCount
	storyInteractionInfo.ForwardCount = tempObj.ForwardCount
	storyInteractionInfo.ReactionCount = tempObj.ReactionCount
	storyInteractionInfo.RecentViewerUserIDs = tempObj.RecentViewerUserIDs

	return nil
}

// Story Represents a story
type Story struct {
	tdCommon
	ID                          int32                 `json:"id"`                                // Unique story identifier among stories of the given sender
	SenderChatID                int64                 `json:"sender_chat_id"`                    // Identifier of the chat that posted the story
	SenderID                    *MessageSender        `json:"sender_id"`                         // Identifier of the sender of the story; may be null if the story is posted on behalf of the sender_chat_id
	Date                        int32                 `json:"date"`                              // Point in time (Unix timestamp) when the story was published
	IsBeingSent                 bool                  `json:"is_being_sent"`                     // True, if the story is being sent by the current user
	IsBeingEdited               bool                  `json:"is_being_edited"`                   // True, if the story is being edited by the current user
	IsEdited                    bool                  `json:"is_edited"`                         // True, if the story was edited
	IsPostedToChatPage          bool                  `json:"is_posted_to_chat_page"`            // True, if the story is saved in the sender's profile and will be available there after expiration
	IsVisibleOnlyForSelf        bool                  `json:"is_visible_only_for_self"`          // True, if the story is visible only for the current user
	CanBeDeleted                bool                  `json:"can_be_deleted"`                    // True, if the story can be deleted
	CanBeEdited                 bool                  `json:"can_be_edited"`                     // True, if the story can be edited
	CanBeForwarded              bool                  `json:"can_be_forwarded"`                  // True, if the story can be forwarded as a message. Otherwise, screenshots and saving of the story content must be also forbidden
	CanBeReplied                bool                  `json:"can_be_replied"`                    // True, if the story can be replied in the chat with the story sender
	CanToggleIsPostedToChatPage bool                  `json:"can_toggle_is_posted_to_chat_page"` // True, if the story's is_posted_to_chat_page value can be changed
	CanGetStatistics            bool                  `json:"can_get_statistics"`                // True, if the story statistics are available through getStoryStatistics
	CanGetInteractions          bool                  `json:"can_get_interactions"`              // True, if interactions with the story can be received through getStoryInteractions
	HasExpiredViewers           bool                  `json:"has_expired_viewers"`               // True, if users viewed the story can't be received, because the story has expired more than getOption("story_viewers_expiration_delay") seconds ago
	RepostInfo                  *StoryRepostInfo      `json:"repost_info"`                       // Information about the original story; may be null if the story wasn't reposted
	InteractionInfo             *StoryInteractionInfo `json:"interaction_info"`                  // Information about interactions with the story; may be null if the story isn't owned or there were no interactions
	ChosenReactionType          *ReactionType         `json:"chosen_reaction_type"`              // Type of the chosen reaction; may be null if none
	PrivacySettings             StoryPrivacySettings  `json:"privacy_settings"`                  // Privacy rules affecting story visibility; may be approximate for non-owned stories
	Content                     StoryContent          `json:"content"`                           // Content of the story
	Areas                       []StoryArea           `json:"areas"`                             // Clickable areas to be shown on the story content
	Caption                     *FormattedText        `json:"caption"`                           // Caption of the story
}

// MessageType return the string telegram-type of Story
func (story *Story) MessageType() string {
	return "story"
}

// NewStory creates a new Story
//
// @param iD Unique story identifier among stories of the given sender
// @param senderChatID Identifier of the chat that posted the story
// @param senderID Identifier of the sender of the story; may be null if the story is posted on behalf of the sender_chat_id
// @param date Point in time (Unix timestamp) when the story was published
// @param isBeingSent True, if the story is being sent by the current user
// @param isBeingEdited True, if the story is being edited by the current user
// @param isEdited True, if the story was edited
// @param isPostedToChatPage True, if the story is saved in the sender's profile and will be available there after expiration
// @param isVisibleOnlyForSelf True, if the story is visible only for the current user
// @param canBeDeleted True, if the story can be deleted
// @param canBeEdited True, if the story can be edited
// @param canBeForwarded True, if the story can be forwarded as a message. Otherwise, screenshots and saving of the story content must be also forbidden
// @param canBeReplied True, if the story can be replied in the chat with the story sender
// @param canToggleIsPostedToChatPage True, if the story's is_posted_to_chat_page value can be changed
// @param canGetStatistics True, if the story statistics are available through getStoryStatistics
// @param canGetInteractions True, if interactions with the story can be received through getStoryInteractions
// @param hasExpiredViewers True, if users viewed the story can't be received, because the story has expired more than getOption("story_viewers_expiration_delay") seconds ago
// @param repostInfo Information about the original story; may be null if the story wasn't reposted
// @param interactionInfo Information about interactions with the story; may be null if the story isn't owned or there were no interactions
// @param chosenReactionType Type of the chosen reaction; may be null if none
// @param privacySettings Privacy rules affecting story visibility; may be approximate for non-owned stories
// @param content Content of the story
// @param areas Clickable areas to be shown on the story content
// @param caption Caption of the story
func NewStory(iD int32, senderChatID int64, senderID *MessageSender, date int32, isBeingSent bool, isBeingEdited bool, isEdited bool, isPostedToChatPage bool, isVisibleOnlyForSelf bool, canBeDeleted bool, canBeEdited bool, canBeForwarded bool, canBeReplied bool, canToggleIsPostedToChatPage bool, canGetStatistics bool, canGetInteractions bool, hasExpiredViewers bool, repostInfo *StoryRepostInfo, interactionInfo *StoryInteractionInfo, chosenReactionType *ReactionType, privacySettings StoryPrivacySettings, content StoryContent, areas []StoryArea, caption *FormattedText) *Story {
	storyTemp := Story{
		tdCommon:                    tdCommon{Type: "story"},
		ID:                          iD,
		SenderChatID:                senderChatID,
		SenderID:                    senderID,
		Date:                        date,
		IsBeingSent:                 isBeingSent,
		IsBeingEdited:               isBeingEdited,
		IsEdited:                    isEdited,
		IsPostedToChatPage:          isPostedToChatPage,
		IsVisibleOnlyForSelf:        isVisibleOnlyForSelf,
		CanBeDeleted:                canBeDeleted,
		CanBeEdited:                 canBeEdited,
		CanBeForwarded:              canBeForwarded,
		CanBeReplied:                canBeReplied,
		CanToggleIsPostedToChatPage: canToggleIsPostedToChatPage,
		CanGetStatistics:            canGetStatistics,
		CanGetInteractions:          canGetInteractions,
		HasExpiredViewers:           hasExpiredViewers,
		RepostInfo:                  repostInfo,
		InteractionInfo:             interactionInfo,
		ChosenReactionType:          chosenReactionType,
		PrivacySettings:             privacySettings,
		Content:                     content,
		Areas:                       areas,
		Caption:                     caption,
	}

	return &storyTemp
}

// UnmarshalJSON unmarshal to json
func (story *Story) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID                          int32                 `json:"id"`                                // Unique story identifier among stories of the given sender
		SenderChatID                int64                 `json:"sender_chat_id"`                    // Identifier of the chat that posted the story
		Date                        int32                 `json:"date"`                              // Point in time (Unix timestamp) when the story was published
		IsBeingSent                 bool                  `json:"is_being_sent"`                     // True, if the story is being sent by the current user
		IsBeingEdited               bool                  `json:"is_being_edited"`                   // True, if the story is being edited by the current user
		IsEdited                    bool                  `json:"is_edited"`                         // True, if the story was edited
		IsPostedToChatPage          bool                  `json:"is_posted_to_chat_page"`            // True, if the story is saved in the sender's profile and will be available there after expiration
		IsVisibleOnlyForSelf        bool                  `json:"is_visible_only_for_self"`          // True, if the story is visible only for the current user
		CanBeDeleted                bool                  `json:"can_be_deleted"`                    // True, if the story can be deleted
		CanBeEdited                 bool                  `json:"can_be_edited"`                     // True, if the story can be edited
		CanBeForwarded              bool                  `json:"can_be_forwarded"`                  // True, if the story can be forwarded as a message. Otherwise, screenshots and saving of the story content must be also forbidden
		CanBeReplied                bool                  `json:"can_be_replied"`                    // True, if the story can be replied in the chat with the story sender
		CanToggleIsPostedToChatPage bool                  `json:"can_toggle_is_posted_to_chat_page"` // True, if the story's is_posted_to_chat_page value can be changed
		CanGetStatistics            bool                  `json:"can_get_statistics"`                // True, if the story statistics are available through getStoryStatistics
		CanGetInteractions          bool                  `json:"can_get_interactions"`              // True, if interactions with the story can be received through getStoryInteractions
		HasExpiredViewers           bool                  `json:"has_expired_viewers"`               // True, if users viewed the story can't be received, because the story has expired more than getOption("story_viewers_expiration_delay") seconds ago
		InteractionInfo             *StoryInteractionInfo `json:"interaction_info"`                  // Information about interactions with the story; may be null if the story isn't owned or there were no interactions
		Areas                       []StoryArea           `json:"areas"`                             // Clickable areas to be shown on the story content
		Caption                     *FormattedText        `json:"caption"`                           // Caption of the story
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	story.tdCommon = tempObj.tdCommon
	story.ID = tempObj.ID
	story.SenderChatID = tempObj.SenderChatID
	story.Date = tempObj.Date
	story.IsBeingSent = tempObj.IsBeingSent
	story.IsBeingEdited = tempObj.IsBeingEdited
	story.IsEdited = tempObj.IsEdited
	story.IsPostedToChatPage = tempObj.IsPostedToChatPage
	story.IsVisibleOnlyForSelf = tempObj.IsVisibleOnlyForSelf
	story.CanBeDeleted = tempObj.CanBeDeleted
	story.CanBeEdited = tempObj.CanBeEdited
	story.CanBeForwarded = tempObj.CanBeForwarded
	story.CanBeReplied = tempObj.CanBeReplied
	story.CanToggleIsPostedToChatPage = tempObj.CanToggleIsPostedToChatPage
	story.CanGetStatistics = tempObj.CanGetStatistics
	story.CanGetInteractions = tempObj.CanGetInteractions
	story.HasExpiredViewers = tempObj.HasExpiredViewers
	story.InteractionInfo = tempObj.InteractionInfo
	story.Areas = tempObj.Areas
	story.Caption = tempObj.Caption

	fieldSenderID, _ := unmarshalMessageSender(objMap["sender_id"])
	story.SenderID = &fieldSenderID

	fieldChosenReactionType, _ := unmarshalReactionType(objMap["chosen_reaction_type"])
	story.ChosenReactionType = &fieldChosenReactionType

	fieldPrivacySettings, _ := unmarshalStoryPrivacySettings(objMap["privacy_settings"])
	story.PrivacySettings = fieldPrivacySettings

	fieldContent, _ := unmarshalStoryContent(objMap["content"])
	story.Content = fieldContent

	var repostInfo StoryRepostInfo
	if objMap["repost_info"] != nil {
		err = repostInfo.UnmarshalJSON(*objMap["repost_info"])
		if err != nil {
			return err
		}
	}

	story.RepostInfo = &repostInfo

	return nil
}

// Stories Represents a list of stories
type Stories struct {
	tdCommon
	TotalCount     int32   `json:"total_count"`      // Approximate total number of stories found
	Stories        []Story `json:"stories"`          // The list of stories
	PinnedStoryIDs []int32 `json:"pinned_story_ids"` // Identifiers of the pinned stories; returned only in getChatPostedToChatPageStories with from_story_id == 0
}

// MessageType return the string telegram-type of Stories
func (stories *Stories) MessageType() string {
	return "stories"
}

// NewStories creates a new Stories
//
// @param totalCount Approximate total number of stories found
// @param stories The list of stories
// @param pinnedStoryIDs Identifiers of the pinned stories; returned only in getChatPostedToChatPageStories with from_story_id == 0
func NewStories(totalCount int32, stories []Story, pinnedStoryIDs []int32) *Stories {
	storiesTemp := Stories{
		tdCommon:       tdCommon{Type: "stories"},
		TotalCount:     totalCount,
		Stories:        stories,
		PinnedStoryIDs: pinnedStoryIDs,
	}

	return &storiesTemp
}

// UnmarshalJSON unmarshal to json
func (stories *Stories) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount     int32   `json:"total_count"`      // Approximate total number of stories found
		Stories        []Story `json:"stories"`          // The list of stories
		PinnedStoryIDs []int32 `json:"pinned_story_ids"` // Identifiers of the pinned stories; returned only in getChatPostedToChatPageStories with from_story_id == 0
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	stories.tdCommon = tempObj.tdCommon
	stories.TotalCount = tempObj.TotalCount
	stories.Stories = tempObj.Stories
	stories.PinnedStoryIDs = tempObj.PinnedStoryIDs

	return nil
}

// FoundStories Contains a list of stories found by a search
type FoundStories struct {
	tdCommon
	TotalCount int32   `json:"total_count"` // Approximate total number of stories found
	Stories    []Story `json:"stories"`     // List of stories
	NextOffset string  `json:"next_offset"` // The offset for the next request. If empty, then there are no more results
}

// MessageType return the string telegram-type of FoundStories
func (foundStories *FoundStories) MessageType() string {
	return "foundStories"
}

// NewFoundStories creates a new FoundStories
//
// @param totalCount Approximate total number of stories found
// @param stories List of stories
// @param nextOffset The offset for the next request. If empty, then there are no more results
func NewFoundStories(totalCount int32, stories []Story, nextOffset string) *FoundStories {
	foundStoriesTemp := FoundStories{
		tdCommon:   tdCommon{Type: "foundStories"},
		TotalCount: totalCount,
		Stories:    stories,
		NextOffset: nextOffset,
	}

	return &foundStoriesTemp
}

// UnmarshalJSON unmarshal to json
func (foundStories *FoundStories) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32   `json:"total_count"` // Approximate total number of stories found
		Stories    []Story `json:"stories"`     // List of stories
		NextOffset string  `json:"next_offset"` // The offset for the next request. If empty, then there are no more results
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	foundStories.tdCommon = tempObj.tdCommon
	foundStories.TotalCount = tempObj.TotalCount
	foundStories.Stories = tempObj.Stories
	foundStories.NextOffset = tempObj.NextOffset

	return nil
}

// StoryFullID Contains identifier of a story along with identifier of its sender
type StoryFullID struct {
	tdCommon
	SenderChatID int64 `json:"sender_chat_id"` // Identifier of the chat that posted the story
	StoryID      int32 `json:"story_id"`       // Unique story identifier among stories of the given sender
}

// MessageType return the string telegram-type of StoryFullID
func (storyFullID *StoryFullID) MessageType() string {
	return "storyFullId"
}

// NewStoryFullID creates a new StoryFullID
//
// @param senderChatID Identifier of the chat that posted the story
// @param storyID Unique story identifier among stories of the given sender
func NewStoryFullID(senderChatID int64, storyID int32) *StoryFullID {
	storyFullIDTemp := StoryFullID{
		tdCommon:     tdCommon{Type: "storyFullId"},
		SenderChatID: senderChatID,
		StoryID:      storyID,
	}

	return &storyFullIDTemp
}

// UnmarshalJSON unmarshal to json
func (storyFullID *StoryFullID) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SenderChatID int64 `json:"sender_chat_id"` // Identifier of the chat that posted the story
		StoryID      int32 `json:"story_id"`       // Unique story identifier among stories of the given sender
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyFullID.tdCommon = tempObj.tdCommon
	storyFullID.SenderChatID = tempObj.SenderChatID
	storyFullID.StoryID = tempObj.StoryID

	return nil
}

// StoryInfo Contains basic information about a story
type StoryInfo struct {
	tdCommon
	StoryID           int32 `json:"story_id"`             // Unique story identifier among stories of the given sender
	Date              int32 `json:"date"`                 // Point in time (Unix timestamp) when the story was published
	IsForCloseFriends bool  `json:"is_for_close_friends"` // True, if the story is available only to close friends
}

// MessageType return the string telegram-type of StoryInfo
func (storyInfo *StoryInfo) MessageType() string {
	return "storyInfo"
}

// NewStoryInfo creates a new StoryInfo
//
// @param storyID Unique story identifier among stories of the given sender
// @param date Point in time (Unix timestamp) when the story was published
// @param isForCloseFriends True, if the story is available only to close friends
func NewStoryInfo(storyID int32, date int32, isForCloseFriends bool) *StoryInfo {
	storyInfoTemp := StoryInfo{
		tdCommon:          tdCommon{Type: "storyInfo"},
		StoryID:           storyID,
		Date:              date,
		IsForCloseFriends: isForCloseFriends,
	}

	return &storyInfoTemp
}

// UnmarshalJSON unmarshal to json
func (storyInfo *StoryInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StoryID           int32 `json:"story_id"`             // Unique story identifier among stories of the given sender
		Date              int32 `json:"date"`                 // Point in time (Unix timestamp) when the story was published
		IsForCloseFriends bool  `json:"is_for_close_friends"` // True, if the story is available only to close friends
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyInfo.tdCommon = tempObj.tdCommon
	storyInfo.StoryID = tempObj.StoryID
	storyInfo.Date = tempObj.Date
	storyInfo.IsForCloseFriends = tempObj.IsForCloseFriends

	return nil
}

// ChatActiveStories Describes active stories posted by a chat
type ChatActiveStories struct {
	tdCommon
	ChatID         int64       `json:"chat_id"`           // Identifier of the chat that posted the stories
	List           *StoryList  `json:"list"`              // Identifier of the story list in which the stories are shown; may be null if the stories aren't shown in a story list
	Order          int64       `json:"order"`             // A parameter used to determine order of the stories in the story list; 0 if the stories doesn't need to be shown in the story list. Stories must be sorted by the pair (order, story_sender_chat_id) in descending order
	MaxReadStoryID int32       `json:"max_read_story_id"` // Identifier of the last read active story
	Stories        []StoryInfo `json:"stories"`           // Basic information about the stories; use getStory to get full information about the stories. The stories are in chronological order (i.e., in order of increasing story identifiers)
}

// MessageType return the string telegram-type of ChatActiveStories
func (chatActiveStories *ChatActiveStories) MessageType() string {
	return "chatActiveStories"
}

// NewChatActiveStories creates a new ChatActiveStories
//
// @param chatID Identifier of the chat that posted the stories
// @param list Identifier of the story list in which the stories are shown; may be null if the stories aren't shown in a story list
// @param order A parameter used to determine order of the stories in the story list; 0 if the stories doesn't need to be shown in the story list. Stories must be sorted by the pair (order, story_sender_chat_id) in descending order
// @param maxReadStoryID Identifier of the last read active story
// @param stories Basic information about the stories; use getStory to get full information about the stories. The stories are in chronological order (i.e., in order of increasing story identifiers)
func NewChatActiveStories(chatID int64, list *StoryList, order int64, maxReadStoryID int32, stories []StoryInfo) *ChatActiveStories {
	chatActiveStoriesTemp := ChatActiveStories{
		tdCommon:       tdCommon{Type: "chatActiveStories"},
		ChatID:         chatID,
		List:           list,
		Order:          order,
		MaxReadStoryID: maxReadStoryID,
		Stories:        stories,
	}

	return &chatActiveStoriesTemp
}

// UnmarshalJSON unmarshal to json
func (chatActiveStories *ChatActiveStories) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID         int64       `json:"chat_id"`           // Identifier of the chat that posted the stories
		Order          int64       `json:"order"`             // A parameter used to determine order of the stories in the story list; 0 if the stories doesn't need to be shown in the story list. Stories must be sorted by the pair (order, story_sender_chat_id) in descending order
		MaxReadStoryID int32       `json:"max_read_story_id"` // Identifier of the last read active story
		Stories        []StoryInfo `json:"stories"`           // Basic information about the stories; use getStory to get full information about the stories. The stories are in chronological order (i.e., in order of increasing story identifiers)
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatActiveStories.tdCommon = tempObj.tdCommon
	chatActiveStories.ChatID = tempObj.ChatID
	chatActiveStories.Order = tempObj.Order
	chatActiveStories.MaxReadStoryID = tempObj.MaxReadStoryID
	chatActiveStories.Stories = tempObj.Stories

	fieldList, _ := unmarshalStoryList(objMap["list"])
	chatActiveStories.List = &fieldList

	return nil
}

// StoryInteractionTypeView A view of the story
type StoryInteractionTypeView struct {
	tdCommon
	ChosenReactionType *ReactionType `json:"chosen_reaction_type"` // Type of the reaction that was chosen by the viewer; may be null if none
}

// MessageType return the string telegram-type of StoryInteractionTypeView
func (storyInteractionTypeView *StoryInteractionTypeView) MessageType() string {
	return "storyInteractionTypeView"
}

// NewStoryInteractionTypeView creates a new StoryInteractionTypeView
//
// @param chosenReactionType Type of the reaction that was chosen by the viewer; may be null if none
func NewStoryInteractionTypeView(chosenReactionType *ReactionType) *StoryInteractionTypeView {
	storyInteractionTypeViewTemp := StoryInteractionTypeView{
		tdCommon:           tdCommon{Type: "storyInteractionTypeView"},
		ChosenReactionType: chosenReactionType,
	}

	return &storyInteractionTypeViewTemp
}

// UnmarshalJSON unmarshal to json
func (storyInteractionTypeView *StoryInteractionTypeView) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyInteractionTypeView.tdCommon = tempObj.tdCommon

	fieldChosenReactionType, _ := unmarshalReactionType(objMap["chosen_reaction_type"])
	storyInteractionTypeView.ChosenReactionType = &fieldChosenReactionType

	return nil
}

// GetStoryInteractionTypeEnum return the enum type of this object
func (storyInteractionTypeView *StoryInteractionTypeView) GetStoryInteractionTypeEnum() StoryInteractionTypeEnum {
	return StoryInteractionTypeViewType
}

// StoryInteractionTypeForward A forward of the story as a message
type StoryInteractionTypeForward struct {
	tdCommon
	Message *Message `json:"message"` // The message with story forward
}

// MessageType return the string telegram-type of StoryInteractionTypeForward
func (storyInteractionTypeForward *StoryInteractionTypeForward) MessageType() string {
	return "storyInteractionTypeForward"
}

// NewStoryInteractionTypeForward creates a new StoryInteractionTypeForward
//
// @param message The message with story forward
func NewStoryInteractionTypeForward(message *Message) *StoryInteractionTypeForward {
	storyInteractionTypeForwardTemp := StoryInteractionTypeForward{
		tdCommon: tdCommon{Type: "storyInteractionTypeForward"},
		Message:  message,
	}

	return &storyInteractionTypeForwardTemp
}

// UnmarshalJSON unmarshal to json
func (storyInteractionTypeForward *StoryInteractionTypeForward) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyInteractionTypeForward.tdCommon = tempObj.tdCommon

	var message Message
	if objMap["message"] != nil {
		err = message.UnmarshalJSON(*objMap["message"])
		if err != nil {
			return err
		}
	}

	storyInteractionTypeForward.Message = &message

	return nil
}

// GetStoryInteractionTypeEnum return the enum type of this object
func (storyInteractionTypeForward *StoryInteractionTypeForward) GetStoryInteractionTypeEnum() StoryInteractionTypeEnum {
	return StoryInteractionTypeForwardType
}

// StoryInteractionTypeRepost A repost of the story as a story
type StoryInteractionTypeRepost struct {
	tdCommon
	Story *Story `json:"story"` // The reposted story
}

// MessageType return the string telegram-type of StoryInteractionTypeRepost
func (storyInteractionTypeRepost *StoryInteractionTypeRepost) MessageType() string {
	return "storyInteractionTypeRepost"
}

// NewStoryInteractionTypeRepost creates a new StoryInteractionTypeRepost
//
// @param story The reposted story
func NewStoryInteractionTypeRepost(story *Story) *StoryInteractionTypeRepost {
	storyInteractionTypeRepostTemp := StoryInteractionTypeRepost{
		tdCommon: tdCommon{Type: "storyInteractionTypeRepost"},
		Story:    story,
	}

	return &storyInteractionTypeRepostTemp
}

// UnmarshalJSON unmarshal to json
func (storyInteractionTypeRepost *StoryInteractionTypeRepost) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyInteractionTypeRepost.tdCommon = tempObj.tdCommon

	var story Story
	if objMap["story"] != nil {
		err = story.UnmarshalJSON(*objMap["story"])
		if err != nil {
			return err
		}
	}

	storyInteractionTypeRepost.Story = &story

	return nil
}

// GetStoryInteractionTypeEnum return the enum type of this object
func (storyInteractionTypeRepost *StoryInteractionTypeRepost) GetStoryInteractionTypeEnum() StoryInteractionTypeEnum {
	return StoryInteractionTypeRepostType
}

// StoryInteraction Represents interaction with a story
type StoryInteraction struct {
	tdCommon
	ActorID         MessageSender        `json:"actor_id"`         // Identifier of the user or chat that made the interaction
	InteractionDate int32                `json:"interaction_date"` // Approximate point in time (Unix timestamp) when the interaction happened
	BlockList       *BlockList           `json:"block_list"`       // Block list to which the actor is added; may be null if none or for chat stories
	Type            StoryInteractionType `json:"type"`             // Type of the interaction
}

// MessageType return the string telegram-type of StoryInteraction
func (storyInteraction *StoryInteraction) MessageType() string {
	return "storyInteraction"
}

// NewStoryInteraction creates a new StoryInteraction
//
// @param actorID Identifier of the user or chat that made the interaction
// @param interactionDate Approximate point in time (Unix timestamp) when the interaction happened
// @param blockList Block list to which the actor is added; may be null if none or for chat stories
// @param typeParam Type of the interaction
func NewStoryInteraction(actorID MessageSender, interactionDate int32, blockList *BlockList, typeParam StoryInteractionType) *StoryInteraction {
	storyInteractionTemp := StoryInteraction{
		tdCommon:        tdCommon{Type: "storyInteraction"},
		ActorID:         actorID,
		InteractionDate: interactionDate,
		BlockList:       blockList,
		Type:            typeParam,
	}

	return &storyInteractionTemp
}

// UnmarshalJSON unmarshal to json
func (storyInteraction *StoryInteraction) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		InteractionDate int32 `json:"interaction_date"` // Approximate point in time (Unix timestamp) when the interaction happened

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyInteraction.tdCommon = tempObj.tdCommon
	storyInteraction.InteractionDate = tempObj.InteractionDate

	fieldActorID, _ := unmarshalMessageSender(objMap["actor_id"])
	storyInteraction.ActorID = fieldActorID

	fieldBlockList, _ := unmarshalBlockList(objMap["block_list"])
	storyInteraction.BlockList = &fieldBlockList

	fieldType, _ := unmarshalStoryInteractionType(objMap["type"])
	storyInteraction.Type = fieldType

	return nil
}

// StoryInteractions Represents a list of interactions with a story
type StoryInteractions struct {
	tdCommon
	TotalCount         int32              `json:"total_count"`          // Approximate total number of interactions found
	TotalForwardCount  int32              `json:"total_forward_count"`  // Approximate total number of found forwards and reposts; always 0 for chat stories
	TotalReactionCount int32              `json:"total_reaction_count"` // Approximate total number of found reactions; always 0 for chat stories
	Interactions       []StoryInteraction `json:"interactions"`         // List of story interactions
	NextOffset         string             `json:"next_offset"`          // The offset for the next request. If empty, then there are no more results
}

// MessageType return the string telegram-type of StoryInteractions
func (storyInteractions *StoryInteractions) MessageType() string {
	return "storyInteractions"
}

// NewStoryInteractions creates a new StoryInteractions
//
// @param totalCount Approximate total number of interactions found
// @param totalForwardCount Approximate total number of found forwards and reposts; always 0 for chat stories
// @param totalReactionCount Approximate total number of found reactions; always 0 for chat stories
// @param interactions List of story interactions
// @param nextOffset The offset for the next request. If empty, then there are no more results
func NewStoryInteractions(totalCount int32, totalForwardCount int32, totalReactionCount int32, interactions []StoryInteraction, nextOffset string) *StoryInteractions {
	storyInteractionsTemp := StoryInteractions{
		tdCommon:           tdCommon{Type: "storyInteractions"},
		TotalCount:         totalCount,
		TotalForwardCount:  totalForwardCount,
		TotalReactionCount: totalReactionCount,
		Interactions:       interactions,
		NextOffset:         nextOffset,
	}

	return &storyInteractionsTemp
}

// UnmarshalJSON unmarshal to json
func (storyInteractions *StoryInteractions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount         int32              `json:"total_count"`          // Approximate total number of interactions found
		TotalForwardCount  int32              `json:"total_forward_count"`  // Approximate total number of found forwards and reposts; always 0 for chat stories
		TotalReactionCount int32              `json:"total_reaction_count"` // Approximate total number of found reactions; always 0 for chat stories
		Interactions       []StoryInteraction `json:"interactions"`         // List of story interactions
		NextOffset         string             `json:"next_offset"`          // The offset for the next request. If empty, then there are no more results
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyInteractions.tdCommon = tempObj.tdCommon
	storyInteractions.TotalCount = tempObj.TotalCount
	storyInteractions.TotalForwardCount = tempObj.TotalForwardCount
	storyInteractions.TotalReactionCount = tempObj.TotalReactionCount
	storyInteractions.Interactions = tempObj.Interactions
	storyInteractions.NextOffset = tempObj.NextOffset

	return nil
}

// QuickReplyMessage Describes a message that can be used for quick reply
type QuickReplyMessage struct {
	tdCommon
	ID               int64                `json:"id"`                  // Unique message identifier among all quick replies
	SendingState     *MessageSendingState `json:"sending_state"`       // The sending state of the message; may be null if the message isn't being sent and didn't fail to be sent
	CanBeEdited      bool                 `json:"can_be_edited"`       // True, if the message can be edited
	ReplyToMessageID int64                `json:"reply_to_message_id"` // The identifier of the quick reply message to which the message replies; 0 if none
	ViaBotUserID     int64                `json:"via_bot_user_id"`     // If non-zero, the user identifier of the bot through which this message was sent
	MediaAlbumID     JSONInt64            `json:"media_album_id"`      // Unique identifier of an album this message belongs to; 0 if none. Only audios, documents, photos and videos can be grouped together in albums
	Content          MessageContent       `json:"content"`             // Content of the message
	ReplyMarkup      *ReplyMarkup         `json:"reply_markup"`        // Inline keyboard reply markup for the message; may be null if none
}

// MessageType return the string telegram-type of QuickReplyMessage
func (quickReplyMessage *QuickReplyMessage) MessageType() string {
	return "quickReplyMessage"
}

// NewQuickReplyMessage creates a new QuickReplyMessage
//
// @param iD Unique message identifier among all quick replies
// @param sendingState The sending state of the message; may be null if the message isn't being sent and didn't fail to be sent
// @param canBeEdited True, if the message can be edited
// @param replyToMessageID The identifier of the quick reply message to which the message replies; 0 if none
// @param viaBotUserID If non-zero, the user identifier of the bot through which this message was sent
// @param mediaAlbumID Unique identifier of an album this message belongs to; 0 if none. Only audios, documents, photos and videos can be grouped together in albums
// @param content Content of the message
// @param replyMarkup Inline keyboard reply markup for the message; may be null if none
func NewQuickReplyMessage(iD int64, sendingState *MessageSendingState, canBeEdited bool, replyToMessageID int64, viaBotUserID int64, mediaAlbumID JSONInt64, content MessageContent, replyMarkup *ReplyMarkup) *QuickReplyMessage {
	quickReplyMessageTemp := QuickReplyMessage{
		tdCommon:         tdCommon{Type: "quickReplyMessage"},
		ID:               iD,
		SendingState:     sendingState,
		CanBeEdited:      canBeEdited,
		ReplyToMessageID: replyToMessageID,
		ViaBotUserID:     viaBotUserID,
		MediaAlbumID:     mediaAlbumID,
		Content:          content,
		ReplyMarkup:      replyMarkup,
	}

	return &quickReplyMessageTemp
}

// UnmarshalJSON unmarshal to json
func (quickReplyMessage *QuickReplyMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID               int64     `json:"id"`                  // Unique message identifier among all quick replies
		CanBeEdited      bool      `json:"can_be_edited"`       // True, if the message can be edited
		ReplyToMessageID int64     `json:"reply_to_message_id"` // The identifier of the quick reply message to which the message replies; 0 if none
		ViaBotUserID     int64     `json:"via_bot_user_id"`     // If non-zero, the user identifier of the bot through which this message was sent
		MediaAlbumID     JSONInt64 `json:"media_album_id"`      // Unique identifier of an album this message belongs to; 0 if none. Only audios, documents, photos and videos can be grouped together in albums

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	quickReplyMessage.tdCommon = tempObj.tdCommon
	quickReplyMessage.ID = tempObj.ID
	quickReplyMessage.CanBeEdited = tempObj.CanBeEdited
	quickReplyMessage.ReplyToMessageID = tempObj.ReplyToMessageID
	quickReplyMessage.ViaBotUserID = tempObj.ViaBotUserID
	quickReplyMessage.MediaAlbumID = tempObj.MediaAlbumID

	fieldSendingState, _ := unmarshalMessageSendingState(objMap["sending_state"])
	quickReplyMessage.SendingState = &fieldSendingState

	fieldContent, _ := unmarshalMessageContent(objMap["content"])
	quickReplyMessage.Content = fieldContent

	fieldReplyMarkup, _ := unmarshalReplyMarkup(objMap["reply_markup"])
	quickReplyMessage.ReplyMarkup = &fieldReplyMarkup

	return nil
}

// QuickReplyMessages Contains a list of quick reply messages
type QuickReplyMessages struct {
	tdCommon
	Messages []QuickReplyMessage `json:"messages"` // List of quick reply messages; messages may be null
}

// MessageType return the string telegram-type of QuickReplyMessages
func (quickReplyMessages *QuickReplyMessages) MessageType() string {
	return "quickReplyMessages"
}

// NewQuickReplyMessages creates a new QuickReplyMessages
//
// @param messages List of quick reply messages; messages may be null
func NewQuickReplyMessages(messages []QuickReplyMessage) *QuickReplyMessages {
	quickReplyMessagesTemp := QuickReplyMessages{
		tdCommon: tdCommon{Type: "quickReplyMessages"},
		Messages: messages,
	}

	return &quickReplyMessagesTemp
}

// UnmarshalJSON unmarshal to json
func (quickReplyMessages *QuickReplyMessages) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Messages []QuickReplyMessage `json:"messages"` // List of quick reply messages; messages may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	quickReplyMessages.tdCommon = tempObj.tdCommon
	quickReplyMessages.Messages = tempObj.Messages

	return nil
}

// QuickReplyShortcut Describes a shortcut that can be used for a quick reply
type QuickReplyShortcut struct {
	tdCommon
	ID           int32              `json:"id"`            // Unique shortcut identifier
	Name         string             `json:"name"`          // The name of the shortcut that can be used to use the shortcut
	FirstMessage *QuickReplyMessage `json:"first_message"` // The first shortcut message
	MessageCount int32              `json:"message_count"` // The total number of messages in the shortcut
}

// MessageType return the string telegram-type of QuickReplyShortcut
func (quickReplyShortcut *QuickReplyShortcut) MessageType() string {
	return "quickReplyShortcut"
}

// NewQuickReplyShortcut creates a new QuickReplyShortcut
//
// @param iD Unique shortcut identifier
// @param name The name of the shortcut that can be used to use the shortcut
// @param firstMessage The first shortcut message
// @param messageCount The total number of messages in the shortcut
func NewQuickReplyShortcut(iD int32, name string, firstMessage *QuickReplyMessage, messageCount int32) *QuickReplyShortcut {
	quickReplyShortcutTemp := QuickReplyShortcut{
		tdCommon:     tdCommon{Type: "quickReplyShortcut"},
		ID:           iD,
		Name:         name,
		FirstMessage: firstMessage,
		MessageCount: messageCount,
	}

	return &quickReplyShortcutTemp
}

// UnmarshalJSON unmarshal to json
func (quickReplyShortcut *QuickReplyShortcut) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID           int32  `json:"id"`            // Unique shortcut identifier
		Name         string `json:"name"`          // The name of the shortcut that can be used to use the shortcut
		MessageCount int32  `json:"message_count"` // The total number of messages in the shortcut
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	quickReplyShortcut.tdCommon = tempObj.tdCommon
	quickReplyShortcut.ID = tempObj.ID
	quickReplyShortcut.Name = tempObj.Name
	quickReplyShortcut.MessageCount = tempObj.MessageCount

	var firstMessage QuickReplyMessage
	if objMap["first_message"] != nil {
		err = firstMessage.UnmarshalJSON(*objMap["first_message"])
		if err != nil {
			return err
		}
	}

	quickReplyShortcut.FirstMessage = &firstMessage

	return nil
}

// PublicForwardMessage Contains a public forward as a message
type PublicForwardMessage struct {
	tdCommon
	Message *Message `json:"message"` // Information about the message
}

// MessageType return the string telegram-type of PublicForwardMessage
func (publicForwardMessage *PublicForwardMessage) MessageType() string {
	return "publicForwardMessage"
}

// NewPublicForwardMessage creates a new PublicForwardMessage
//
// @param message Information about the message
func NewPublicForwardMessage(message *Message) *PublicForwardMessage {
	publicForwardMessageTemp := PublicForwardMessage{
		tdCommon: tdCommon{Type: "publicForwardMessage"},
		Message:  message,
	}

	return &publicForwardMessageTemp
}

// UnmarshalJSON unmarshal to json
func (publicForwardMessage *PublicForwardMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	publicForwardMessage.tdCommon = tempObj.tdCommon

	var message Message
	if objMap["message"] != nil {
		err = message.UnmarshalJSON(*objMap["message"])
		if err != nil {
			return err
		}
	}

	publicForwardMessage.Message = &message

	return nil
}

// GetPublicForwardEnum return the enum type of this object
func (publicForwardMessage *PublicForwardMessage) GetPublicForwardEnum() PublicForwardEnum {
	return PublicForwardMessageType
}

// PublicForwardStory Contains a public repost to a story
type PublicForwardStory struct {
	tdCommon
	Story *Story `json:"story"` // Information about the story
}

// MessageType return the string telegram-type of PublicForwardStory
func (publicForwardStory *PublicForwardStory) MessageType() string {
	return "publicForwardStory"
}

// NewPublicForwardStory creates a new PublicForwardStory
//
// @param story Information about the story
func NewPublicForwardStory(story *Story) *PublicForwardStory {
	publicForwardStoryTemp := PublicForwardStory{
		tdCommon: tdCommon{Type: "publicForwardStory"},
		Story:    story,
	}

	return &publicForwardStoryTemp
}

// UnmarshalJSON unmarshal to json
func (publicForwardStory *PublicForwardStory) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	publicForwardStory.tdCommon = tempObj.tdCommon

	var story Story
	if objMap["story"] != nil {
		err = story.UnmarshalJSON(*objMap["story"])
		if err != nil {
			return err
		}
	}

	publicForwardStory.Story = &story

	return nil
}

// GetPublicForwardEnum return the enum type of this object
func (publicForwardStory *PublicForwardStory) GetPublicForwardEnum() PublicForwardEnum {
	return PublicForwardStoryType
}

// PublicForwards Represents a list of public forwards and reposts as a story of a message or a story
type PublicForwards struct {
	tdCommon
	TotalCount int32           `json:"total_count"` // Approximate total number of messages and stories found
	Forwards   []PublicForward `json:"forwards"`    // List of found public forwards and reposts
	NextOffset string          `json:"next_offset"` // The offset for the next request. If empty, then there are no more results
}

// MessageType return the string telegram-type of PublicForwards
func (publicForwards *PublicForwards) MessageType() string {
	return "publicForwards"
}

// NewPublicForwards creates a new PublicForwards
//
// @param totalCount Approximate total number of messages and stories found
// @param forwards List of found public forwards and reposts
// @param nextOffset The offset for the next request. If empty, then there are no more results
func NewPublicForwards(totalCount int32, forwards []PublicForward, nextOffset string) *PublicForwards {
	publicForwardsTemp := PublicForwards{
		tdCommon:   tdCommon{Type: "publicForwards"},
		TotalCount: totalCount,
		Forwards:   forwards,
		NextOffset: nextOffset,
	}

	return &publicForwardsTemp
}

// UnmarshalJSON unmarshal to json
func (publicForwards *PublicForwards) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32  `json:"total_count"` // Approximate total number of messages and stories found
		NextOffset string `json:"next_offset"` // The offset for the next request. If empty, then there are no more results
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	publicForwards.tdCommon = tempObj.tdCommon
	publicForwards.TotalCount = tempObj.TotalCount
	publicForwards.NextOffset = tempObj.NextOffset

	fieldForwards, _ := unmarshalPublicForwardSlice(objMap["forwards"])
	publicForwards.Forwards = fieldForwards

	return nil
}

// BotMediaPreview Describes media previews of a bot
type BotMediaPreview struct {
	tdCommon
	Date    int32        `json:"date"`    // Point in time (Unix timestamp) when the preview was added or changed last time
	Content StoryContent `json:"content"` // Content of the preview
}

// MessageType return the string telegram-type of BotMediaPreview
func (botMediaPreview *BotMediaPreview) MessageType() string {
	return "botMediaPreview"
}

// NewBotMediaPreview creates a new BotMediaPreview
//
// @param date Point in time (Unix timestamp) when the preview was added or changed last time
// @param content Content of the preview
func NewBotMediaPreview(date int32, content StoryContent) *BotMediaPreview {
	botMediaPreviewTemp := BotMediaPreview{
		tdCommon: tdCommon{Type: "botMediaPreview"},
		Date:     date,
		Content:  content,
	}

	return &botMediaPreviewTemp
}

// UnmarshalJSON unmarshal to json
func (botMediaPreview *BotMediaPreview) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Date int32 `json:"date"` // Point in time (Unix timestamp) when the preview was added or changed last time

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	botMediaPreview.tdCommon = tempObj.tdCommon
	botMediaPreview.Date = tempObj.Date

	fieldContent, _ := unmarshalStoryContent(objMap["content"])
	botMediaPreview.Content = fieldContent

	return nil
}

// BotMediaPreviews Contains a list of media previews of a bot
type BotMediaPreviews struct {
	tdCommon
	Previews []BotMediaPreview `json:"previews"` // List of media previews
}

// MessageType return the string telegram-type of BotMediaPreviews
func (botMediaPreviews *BotMediaPreviews) MessageType() string {
	return "botMediaPreviews"
}

// NewBotMediaPreviews creates a new BotMediaPreviews
//
// @param previews List of media previews
func NewBotMediaPreviews(previews []BotMediaPreview) *BotMediaPreviews {
	botMediaPreviewsTemp := BotMediaPreviews{
		tdCommon: tdCommon{Type: "botMediaPreviews"},
		Previews: previews,
	}

	return &botMediaPreviewsTemp
}

// UnmarshalJSON unmarshal to json
func (botMediaPreviews *BotMediaPreviews) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Previews []BotMediaPreview `json:"previews"` // List of media previews
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	botMediaPreviews.tdCommon = tempObj.tdCommon
	botMediaPreviews.Previews = tempObj.Previews

	return nil
}

// BotMediaPreviewInfo Contains a list of media previews of a bot for the given language and the list of languages for which the bot has dedicated previews
type BotMediaPreviewInfo struct {
	tdCommon
	Previews      []BotMediaPreview `json:"previews"`       // List of media previews
	LanguageCodes []string          `json:"language_codes"` // List of language codes for which the bot has dedicated previews
}

// MessageType return the string telegram-type of BotMediaPreviewInfo
func (botMediaPreviewInfo *BotMediaPreviewInfo) MessageType() string {
	return "botMediaPreviewInfo"
}

// NewBotMediaPreviewInfo creates a new BotMediaPreviewInfo
//
// @param previews List of media previews
// @param languageCodes List of language codes for which the bot has dedicated previews
func NewBotMediaPreviewInfo(previews []BotMediaPreview, languageCodes []string) *BotMediaPreviewInfo {
	botMediaPreviewInfoTemp := BotMediaPreviewInfo{
		tdCommon:      tdCommon{Type: "botMediaPreviewInfo"},
		Previews:      previews,
		LanguageCodes: languageCodes,
	}

	return &botMediaPreviewInfoTemp
}

// UnmarshalJSON unmarshal to json
func (botMediaPreviewInfo *BotMediaPreviewInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Previews      []BotMediaPreview `json:"previews"`       // List of media previews
		LanguageCodes []string          `json:"language_codes"` // List of language codes for which the bot has dedicated previews
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	botMediaPreviewInfo.tdCommon = tempObj.tdCommon
	botMediaPreviewInfo.Previews = tempObj.Previews
	botMediaPreviewInfo.LanguageCodes = tempObj.LanguageCodes

	return nil
}

// ChatBoostLevelFeatures Contains a list of features available on a specific chat boost level
type ChatBoostLevelFeatures struct {
	tdCommon
	Level                              int32 `json:"level"`                                   // Target chat boost level
	StoryPerDayCount                   int32 `json:"story_per_day_count"`                     // Number of stories that the chat can publish daily
	CustomEmojiReactionCount           int32 `json:"custom_emoji_reaction_count"`             // Number of custom emoji reactions that can be added to the list of available reactions
	TitleColorCount                    int32 `json:"title_color_count"`                       // Number of custom colors for chat title
	ProfileAccentColorCount            int32 `json:"profile_accent_color_count"`              // Number of custom colors for profile photo background
	CanSetProfileBackgroundCustomEmoji bool  `json:"can_set_profile_background_custom_emoji"` // True, if custom emoji for profile background can be set
	AccentColorCount                   int32 `json:"accent_color_count"`                      // Number of custom colors for background of empty chat photo, replies to messages and link previews
	CanSetBackgroundCustomEmoji        bool  `json:"can_set_background_custom_emoji"`         // True, if custom emoji for reply header and link preview background can be set
	CanSetEmojiStatus                  bool  `json:"can_set_emoji_status"`                    // True, if emoji status can be set
	ChatThemeBackgroundCount           int32 `json:"chat_theme_background_count"`             // Number of chat theme backgrounds that can be set as chat background
	CanSetCustomBackground             bool  `json:"can_set_custom_background"`               // True, if custom background can be set in the chat for all users
	CanSetCustomEmojiStickerSet        bool  `json:"can_set_custom_emoji_sticker_set"`        // True, if custom emoji sticker set can be set for the chat
	CanRecognizeSpeech                 bool  `json:"can_recognize_speech"`                    // True, if speech recognition can be used for video note and voice note messages by all users
	CanDisableSponsoredMessages        bool  `json:"can_disable_sponsored_messages"`          // True, if sponsored messages can be disabled in the chat
}

// MessageType return the string telegram-type of ChatBoostLevelFeatures
func (chatBoostLevelFeatures *ChatBoostLevelFeatures) MessageType() string {
	return "chatBoostLevelFeatures"
}

// NewChatBoostLevelFeatures creates a new ChatBoostLevelFeatures
//
// @param level Target chat boost level
// @param storyPerDayCount Number of stories that the chat can publish daily
// @param customEmojiReactionCount Number of custom emoji reactions that can be added to the list of available reactions
// @param titleColorCount Number of custom colors for chat title
// @param profileAccentColorCount Number of custom colors for profile photo background
// @param canSetProfileBackgroundCustomEmoji True, if custom emoji for profile background can be set
// @param accentColorCount Number of custom colors for background of empty chat photo, replies to messages and link previews
// @param canSetBackgroundCustomEmoji True, if custom emoji for reply header and link preview background can be set
// @param canSetEmojiStatus True, if emoji status can be set
// @param chatThemeBackgroundCount Number of chat theme backgrounds that can be set as chat background
// @param canSetCustomBackground True, if custom background can be set in the chat for all users
// @param canSetCustomEmojiStickerSet True, if custom emoji sticker set can be set for the chat
// @param canRecognizeSpeech True, if speech recognition can be used for video note and voice note messages by all users
// @param canDisableSponsoredMessages True, if sponsored messages can be disabled in the chat
func NewChatBoostLevelFeatures(level int32, storyPerDayCount int32, customEmojiReactionCount int32, titleColorCount int32, profileAccentColorCount int32, canSetProfileBackgroundCustomEmoji bool, accentColorCount int32, canSetBackgroundCustomEmoji bool, canSetEmojiStatus bool, chatThemeBackgroundCount int32, canSetCustomBackground bool, canSetCustomEmojiStickerSet bool, canRecognizeSpeech bool, canDisableSponsoredMessages bool) *ChatBoostLevelFeatures {
	chatBoostLevelFeaturesTemp := ChatBoostLevelFeatures{
		tdCommon:                           tdCommon{Type: "chatBoostLevelFeatures"},
		Level:                              level,
		StoryPerDayCount:                   storyPerDayCount,
		CustomEmojiReactionCount:           customEmojiReactionCount,
		TitleColorCount:                    titleColorCount,
		ProfileAccentColorCount:            profileAccentColorCount,
		CanSetProfileBackgroundCustomEmoji: canSetProfileBackgroundCustomEmoji,
		AccentColorCount:                   accentColorCount,
		CanSetBackgroundCustomEmoji:        canSetBackgroundCustomEmoji,
		CanSetEmojiStatus:                  canSetEmojiStatus,
		ChatThemeBackgroundCount:           chatThemeBackgroundCount,
		CanSetCustomBackground:             canSetCustomBackground,
		CanSetCustomEmojiStickerSet:        canSetCustomEmojiStickerSet,
		CanRecognizeSpeech:                 canRecognizeSpeech,
		CanDisableSponsoredMessages:        canDisableSponsoredMessages,
	}

	return &chatBoostLevelFeaturesTemp
}

// UnmarshalJSON unmarshal to json
func (chatBoostLevelFeatures *ChatBoostLevelFeatures) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Level                              int32 `json:"level"`                                   // Target chat boost level
		StoryPerDayCount                   int32 `json:"story_per_day_count"`                     // Number of stories that the chat can publish daily
		CustomEmojiReactionCount           int32 `json:"custom_emoji_reaction_count"`             // Number of custom emoji reactions that can be added to the list of available reactions
		TitleColorCount                    int32 `json:"title_color_count"`                       // Number of custom colors for chat title
		ProfileAccentColorCount            int32 `json:"profile_accent_color_count"`              // Number of custom colors for profile photo background
		CanSetProfileBackgroundCustomEmoji bool  `json:"can_set_profile_background_custom_emoji"` // True, if custom emoji for profile background can be set
		AccentColorCount                   int32 `json:"accent_color_count"`                      // Number of custom colors for background of empty chat photo, replies to messages and link previews
		CanSetBackgroundCustomEmoji        bool  `json:"can_set_background_custom_emoji"`         // True, if custom emoji for reply header and link preview background can be set
		CanSetEmojiStatus                  bool  `json:"can_set_emoji_status"`                    // True, if emoji status can be set
		ChatThemeBackgroundCount           int32 `json:"chat_theme_background_count"`             // Number of chat theme backgrounds that can be set as chat background
		CanSetCustomBackground             bool  `json:"can_set_custom_background"`               // True, if custom background can be set in the chat for all users
		CanSetCustomEmojiStickerSet        bool  `json:"can_set_custom_emoji_sticker_set"`        // True, if custom emoji sticker set can be set for the chat
		CanRecognizeSpeech                 bool  `json:"can_recognize_speech"`                    // True, if speech recognition can be used for video note and voice note messages by all users
		CanDisableSponsoredMessages        bool  `json:"can_disable_sponsored_messages"`          // True, if sponsored messages can be disabled in the chat
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatBoostLevelFeatures.tdCommon = tempObj.tdCommon
	chatBoostLevelFeatures.Level = tempObj.Level
	chatBoostLevelFeatures.StoryPerDayCount = tempObj.StoryPerDayCount
	chatBoostLevelFeatures.CustomEmojiReactionCount = tempObj.CustomEmojiReactionCount
	chatBoostLevelFeatures.TitleColorCount = tempObj.TitleColorCount
	chatBoostLevelFeatures.ProfileAccentColorCount = tempObj.ProfileAccentColorCount
	chatBoostLevelFeatures.CanSetProfileBackgroundCustomEmoji = tempObj.CanSetProfileBackgroundCustomEmoji
	chatBoostLevelFeatures.AccentColorCount = tempObj.AccentColorCount
	chatBoostLevelFeatures.CanSetBackgroundCustomEmoji = tempObj.CanSetBackgroundCustomEmoji
	chatBoostLevelFeatures.CanSetEmojiStatus = tempObj.CanSetEmojiStatus
	chatBoostLevelFeatures.ChatThemeBackgroundCount = tempObj.ChatThemeBackgroundCount
	chatBoostLevelFeatures.CanSetCustomBackground = tempObj.CanSetCustomBackground
	chatBoostLevelFeatures.CanSetCustomEmojiStickerSet = tempObj.CanSetCustomEmojiStickerSet
	chatBoostLevelFeatures.CanRecognizeSpeech = tempObj.CanRecognizeSpeech
	chatBoostLevelFeatures.CanDisableSponsoredMessages = tempObj.CanDisableSponsoredMessages

	return nil
}

// ChatBoostFeatures Contains a list of features available on the first chat boost levels
type ChatBoostFeatures struct {
	tdCommon
	Features                                  []ChatBoostLevelFeatures `json:"features"`                                        // The list of features
	MinProfileBackgroundCustomEmojiBoostLevel int32                    `json:"min_profile_background_custom_emoji_boost_level"` // The minimum boost level required to set custom emoji for profile background
	MinBackgroundCustomEmojiBoostLevel        int32                    `json:"min_background_custom_emoji_boost_level"`         // The minimum boost level required to set custom emoji for reply header and link preview background; for channel chats only
	MinEmojiStatusBoostLevel                  int32                    `json:"min_emoji_status_boost_level"`                    // The minimum boost level required to set emoji status
	MinChatThemeBackgroundBoostLevel          int32                    `json:"min_chat_theme_background_boost_level"`           // The minimum boost level required to set a chat theme background as chat background
	MinCustomBackgroundBoostLevel             int32                    `json:"min_custom_background_boost_level"`               // The minimum boost level required to set custom chat background
	MinCustomEmojiStickerSetBoostLevel        int32                    `json:"min_custom_emoji_sticker_set_boost_level"`        // The minimum boost level required to set custom emoji sticker set for the chat; for supergroup chats only
	MinSpeechRecognitionBoostLevel            int32                    `json:"min_speech_recognition_boost_level"`              // The minimum boost level allowing to recognize speech in video note and voice note messages for non-Premium users; for supergroup chats only
	MinSponsoredMessageDisableBoostLevel      int32                    `json:"min_sponsored_message_disable_boost_level"`       // The minimum boost level allowing to disable sponsored messages in the chat; for channel chats only
}

// MessageType return the string telegram-type of ChatBoostFeatures
func (chatBoostFeatures *ChatBoostFeatures) MessageType() string {
	return "chatBoostFeatures"
}

// NewChatBoostFeatures creates a new ChatBoostFeatures
//
// @param features The list of features
// @param minProfileBackgroundCustomEmojiBoostLevel The minimum boost level required to set custom emoji for profile background
// @param minBackgroundCustomEmojiBoostLevel The minimum boost level required to set custom emoji for reply header and link preview background; for channel chats only
// @param minEmojiStatusBoostLevel The minimum boost level required to set emoji status
// @param minChatThemeBackgroundBoostLevel The minimum boost level required to set a chat theme background as chat background
// @param minCustomBackgroundBoostLevel The minimum boost level required to set custom chat background
// @param minCustomEmojiStickerSetBoostLevel The minimum boost level required to set custom emoji sticker set for the chat; for supergroup chats only
// @param minSpeechRecognitionBoostLevel The minimum boost level allowing to recognize speech in video note and voice note messages for non-Premium users; for supergroup chats only
// @param minSponsoredMessageDisableBoostLevel The minimum boost level allowing to disable sponsored messages in the chat; for channel chats only
func NewChatBoostFeatures(features []ChatBoostLevelFeatures, minProfileBackgroundCustomEmojiBoostLevel int32, minBackgroundCustomEmojiBoostLevel int32, minEmojiStatusBoostLevel int32, minChatThemeBackgroundBoostLevel int32, minCustomBackgroundBoostLevel int32, minCustomEmojiStickerSetBoostLevel int32, minSpeechRecognitionBoostLevel int32, minSponsoredMessageDisableBoostLevel int32) *ChatBoostFeatures {
	chatBoostFeaturesTemp := ChatBoostFeatures{
		tdCommon: tdCommon{Type: "chatBoostFeatures"},
		Features: features,
		MinProfileBackgroundCustomEmojiBoostLevel: minProfileBackgroundCustomEmojiBoostLevel,
		MinBackgroundCustomEmojiBoostLevel:        minBackgroundCustomEmojiBoostLevel,
		MinEmojiStatusBoostLevel:                  minEmojiStatusBoostLevel,
		MinChatThemeBackgroundBoostLevel:          minChatThemeBackgroundBoostLevel,
		MinCustomBackgroundBoostLevel:             minCustomBackgroundBoostLevel,
		MinCustomEmojiStickerSetBoostLevel:        minCustomEmojiStickerSetBoostLevel,
		MinSpeechRecognitionBoostLevel:            minSpeechRecognitionBoostLevel,
		MinSponsoredMessageDisableBoostLevel:      minSponsoredMessageDisableBoostLevel,
	}

	return &chatBoostFeaturesTemp
}

// UnmarshalJSON unmarshal to json
func (chatBoostFeatures *ChatBoostFeatures) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Features                                  []ChatBoostLevelFeatures `json:"features"`                                        // The list of features
		MinProfileBackgroundCustomEmojiBoostLevel int32                    `json:"min_profile_background_custom_emoji_boost_level"` // The minimum boost level required to set custom emoji for profile background
		MinBackgroundCustomEmojiBoostLevel        int32                    `json:"min_background_custom_emoji_boost_level"`         // The minimum boost level required to set custom emoji for reply header and link preview background; for channel chats only
		MinEmojiStatusBoostLevel                  int32                    `json:"min_emoji_status_boost_level"`                    // The minimum boost level required to set emoji status
		MinChatThemeBackgroundBoostLevel          int32                    `json:"min_chat_theme_background_boost_level"`           // The minimum boost level required to set a chat theme background as chat background
		MinCustomBackgroundBoostLevel             int32                    `json:"min_custom_background_boost_level"`               // The minimum boost level required to set custom chat background
		MinCustomEmojiStickerSetBoostLevel        int32                    `json:"min_custom_emoji_sticker_set_boost_level"`        // The minimum boost level required to set custom emoji sticker set for the chat; for supergroup chats only
		MinSpeechRecognitionBoostLevel            int32                    `json:"min_speech_recognition_boost_level"`              // The minimum boost level allowing to recognize speech in video note and voice note messages for non-Premium users; for supergroup chats only
		MinSponsoredMessageDisableBoostLevel      int32                    `json:"min_sponsored_message_disable_boost_level"`       // The minimum boost level allowing to disable sponsored messages in the chat; for channel chats only
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatBoostFeatures.tdCommon = tempObj.tdCommon
	chatBoostFeatures.Features = tempObj.Features
	chatBoostFeatures.MinProfileBackgroundCustomEmojiBoostLevel = tempObj.MinProfileBackgroundCustomEmojiBoostLevel
	chatBoostFeatures.MinBackgroundCustomEmojiBoostLevel = tempObj.MinBackgroundCustomEmojiBoostLevel
	chatBoostFeatures.MinEmojiStatusBoostLevel = tempObj.MinEmojiStatusBoostLevel
	chatBoostFeatures.MinChatThemeBackgroundBoostLevel = tempObj.MinChatThemeBackgroundBoostLevel
	chatBoostFeatures.MinCustomBackgroundBoostLevel = tempObj.MinCustomBackgroundBoostLevel
	chatBoostFeatures.MinCustomEmojiStickerSetBoostLevel = tempObj.MinCustomEmojiStickerSetBoostLevel
	chatBoostFeatures.MinSpeechRecognitionBoostLevel = tempObj.MinSpeechRecognitionBoostLevel
	chatBoostFeatures.MinSponsoredMessageDisableBoostLevel = tempObj.MinSponsoredMessageDisableBoostLevel

	return nil
}

// ChatBoostSourceGiftCode The chat created a Telegram Premium gift code for a user
type ChatBoostSourceGiftCode struct {
	tdCommon
	UserID   int64  `json:"user_id"`   // Identifier of a user, for which the gift code was created
	GiftCode string `json:"gift_code"` // The created Telegram Premium gift code, which is known only if this is a gift code for the current user, or it has already been claimed
}

// MessageType return the string telegram-type of ChatBoostSourceGiftCode
func (chatBoostSourceGiftCode *ChatBoostSourceGiftCode) MessageType() string {
	return "chatBoostSourceGiftCode"
}

// NewChatBoostSourceGiftCode creates a new ChatBoostSourceGiftCode
//
// @param userID Identifier of a user, for which the gift code was created
// @param giftCode The created Telegram Premium gift code, which is known only if this is a gift code for the current user, or it has already been claimed
func NewChatBoostSourceGiftCode(userID int64, giftCode string) *ChatBoostSourceGiftCode {
	chatBoostSourceGiftCodeTemp := ChatBoostSourceGiftCode{
		tdCommon: tdCommon{Type: "chatBoostSourceGiftCode"},
		UserID:   userID,
		GiftCode: giftCode,
	}

	return &chatBoostSourceGiftCodeTemp
}

// UnmarshalJSON unmarshal to json
func (chatBoostSourceGiftCode *ChatBoostSourceGiftCode) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID   int64  `json:"user_id"`   // Identifier of a user, for which the gift code was created
		GiftCode string `json:"gift_code"` // The created Telegram Premium gift code, which is known only if this is a gift code for the current user, or it has already been claimed
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatBoostSourceGiftCode.tdCommon = tempObj.tdCommon
	chatBoostSourceGiftCode.UserID = tempObj.UserID
	chatBoostSourceGiftCode.GiftCode = tempObj.GiftCode

	return nil
}

// GetChatBoostSourceEnum return the enum type of this object
func (chatBoostSourceGiftCode *ChatBoostSourceGiftCode) GetChatBoostSourceEnum() ChatBoostSourceEnum {
	return ChatBoostSourceGiftCodeType
}

// ChatBoostSourceGiveaway The chat created a giveaway
type ChatBoostSourceGiveaway struct {
	tdCommon
	UserID            int64  `json:"user_id"`             // Identifier of a user that won in the giveaway; 0 if none
	GiftCode          string `json:"gift_code"`           // The created Telegram Premium gift code if it was used by the user or can be claimed by the current user; an empty string otherwise; for Telegram Premium giveways only
	StarCount         int64  `json:"star_count"`          // Number of Telegram Stars distributed among winners of the giveaway
	GiveawayMessageID int64  `json:"giveaway_message_id"` // Identifier of the corresponding giveaway message; can be an identifier of a deleted message
	IsUnclaimed       bool   `json:"is_unclaimed"`        // True, if the winner for the corresponding giveaway prize wasn't chosen, because there were not enough participants
}

// MessageType return the string telegram-type of ChatBoostSourceGiveaway
func (chatBoostSourceGiveaway *ChatBoostSourceGiveaway) MessageType() string {
	return "chatBoostSourceGiveaway"
}

// NewChatBoostSourceGiveaway creates a new ChatBoostSourceGiveaway
//
// @param userID Identifier of a user that won in the giveaway; 0 if none
// @param giftCode The created Telegram Premium gift code if it was used by the user or can be claimed by the current user; an empty string otherwise; for Telegram Premium giveways only
// @param starCount Number of Telegram Stars distributed among winners of the giveaway
// @param giveawayMessageID Identifier of the corresponding giveaway message; can be an identifier of a deleted message
// @param isUnclaimed True, if the winner for the corresponding giveaway prize wasn't chosen, because there were not enough participants
func NewChatBoostSourceGiveaway(userID int64, giftCode string, starCount int64, giveawayMessageID int64, isUnclaimed bool) *ChatBoostSourceGiveaway {
	chatBoostSourceGiveawayTemp := ChatBoostSourceGiveaway{
		tdCommon:          tdCommon{Type: "chatBoostSourceGiveaway"},
		UserID:            userID,
		GiftCode:          giftCode,
		StarCount:         starCount,
		GiveawayMessageID: giveawayMessageID,
		IsUnclaimed:       isUnclaimed,
	}

	return &chatBoostSourceGiveawayTemp
}

// UnmarshalJSON unmarshal to json
func (chatBoostSourceGiveaway *ChatBoostSourceGiveaway) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID            int64  `json:"user_id"`             // Identifier of a user that won in the giveaway; 0 if none
		GiftCode          string `json:"gift_code"`           // The created Telegram Premium gift code if it was used by the user or can be claimed by the current user; an empty string otherwise; for Telegram Premium giveways only
		StarCount         int64  `json:"star_count"`          // Number of Telegram Stars distributed among winners of the giveaway
		GiveawayMessageID int64  `json:"giveaway_message_id"` // Identifier of the corresponding giveaway message; can be an identifier of a deleted message
		IsUnclaimed       bool   `json:"is_unclaimed"`        // True, if the winner for the corresponding giveaway prize wasn't chosen, because there were not enough participants
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatBoostSourceGiveaway.tdCommon = tempObj.tdCommon
	chatBoostSourceGiveaway.UserID = tempObj.UserID
	chatBoostSourceGiveaway.GiftCode = tempObj.GiftCode
	chatBoostSourceGiveaway.StarCount = tempObj.StarCount
	chatBoostSourceGiveaway.GiveawayMessageID = tempObj.GiveawayMessageID
	chatBoostSourceGiveaway.IsUnclaimed = tempObj.IsUnclaimed

	return nil
}

// GetChatBoostSourceEnum return the enum type of this object
func (chatBoostSourceGiveaway *ChatBoostSourceGiveaway) GetChatBoostSourceEnum() ChatBoostSourceEnum {
	return ChatBoostSourceGiveawayType
}

// ChatBoostSourcePremium A user with Telegram Premium subscription or gifted Telegram Premium boosted the chat
type ChatBoostSourcePremium struct {
	tdCommon
	UserID int64 `json:"user_id"` // Identifier of the user
}

// MessageType return the string telegram-type of ChatBoostSourcePremium
func (chatBoostSourcePremium *ChatBoostSourcePremium) MessageType() string {
	return "chatBoostSourcePremium"
}

// NewChatBoostSourcePremium creates a new ChatBoostSourcePremium
//
// @param userID Identifier of the user
func NewChatBoostSourcePremium(userID int64) *ChatBoostSourcePremium {
	chatBoostSourcePremiumTemp := ChatBoostSourcePremium{
		tdCommon: tdCommon{Type: "chatBoostSourcePremium"},
		UserID:   userID,
	}

	return &chatBoostSourcePremiumTemp
}

// UnmarshalJSON unmarshal to json
func (chatBoostSourcePremium *ChatBoostSourcePremium) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID int64 `json:"user_id"` // Identifier of the user
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatBoostSourcePremium.tdCommon = tempObj.tdCommon
	chatBoostSourcePremium.UserID = tempObj.UserID

	return nil
}

// GetChatBoostSourceEnum return the enum type of this object
func (chatBoostSourcePremium *ChatBoostSourcePremium) GetChatBoostSourceEnum() ChatBoostSourceEnum {
	return ChatBoostSourcePremiumType
}

// PrepaidGiveaway Describes a prepaid giveaway
type PrepaidGiveaway struct {
	tdCommon
	ID          JSONInt64     `json:"id"`           // Unique identifier of the prepaid giveaway
	WinnerCount int32         `json:"winner_count"` // Number of users which will receive giveaway prize
	Prize       GiveawayPrize `json:"prize"`        // Prize of the giveaway
	BoostCount  int32         `json:"boost_count"`  // The number of boosts received by the chat from the giveaway; for Telegram Star giveaways only
	PaymentDate int32         `json:"payment_date"` // Point in time (Unix timestamp) when the giveaway was paid
}

// MessageType return the string telegram-type of PrepaidGiveaway
func (prepaidGiveaway *PrepaidGiveaway) MessageType() string {
	return "prepaidGiveaway"
}

// NewPrepaidGiveaway creates a new PrepaidGiveaway
//
// @param iD Unique identifier of the prepaid giveaway
// @param winnerCount Number of users which will receive giveaway prize
// @param prize Prize of the giveaway
// @param boostCount The number of boosts received by the chat from the giveaway; for Telegram Star giveaways only
// @param paymentDate Point in time (Unix timestamp) when the giveaway was paid
func NewPrepaidGiveaway(iD JSONInt64, winnerCount int32, prize GiveawayPrize, boostCount int32, paymentDate int32) *PrepaidGiveaway {
	prepaidGiveawayTemp := PrepaidGiveaway{
		tdCommon:    tdCommon{Type: "prepaidGiveaway"},
		ID:          iD,
		WinnerCount: winnerCount,
		Prize:       prize,
		BoostCount:  boostCount,
		PaymentDate: paymentDate,
	}

	return &prepaidGiveawayTemp
}

// UnmarshalJSON unmarshal to json
func (prepaidGiveaway *PrepaidGiveaway) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID          JSONInt64 `json:"id"`           // Unique identifier of the prepaid giveaway
		WinnerCount int32     `json:"winner_count"` // Number of users which will receive giveaway prize
		BoostCount  int32     `json:"boost_count"`  // The number of boosts received by the chat from the giveaway; for Telegram Star giveaways only
		PaymentDate int32     `json:"payment_date"` // Point in time (Unix timestamp) when the giveaway was paid
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	prepaidGiveaway.tdCommon = tempObj.tdCommon
	prepaidGiveaway.ID = tempObj.ID
	prepaidGiveaway.WinnerCount = tempObj.WinnerCount
	prepaidGiveaway.BoostCount = tempObj.BoostCount
	prepaidGiveaway.PaymentDate = tempObj.PaymentDate

	fieldPrize, _ := unmarshalGiveawayPrize(objMap["prize"])
	prepaidGiveaway.Prize = fieldPrize

	return nil
}

// ChatBoostStatus Describes current boost status of a chat
type ChatBoostStatus struct {
	tdCommon
	BoostURL                string            `json:"boost_url"`                 // An HTTP URL, which can be used to boost the chat
	AppliedSlotIDs          []int32           `json:"applied_slot_ids"`          // Identifiers of boost slots of the current user applied to the chat
	Level                   int32             `json:"level"`                     // Current boost level of the chat
	GiftCodeBoostCount      int32             `json:"gift_code_boost_count"`     // The number of boosts received by the chat from created Telegram Premium gift codes and giveaways; always 0 if the current user isn't an administrator in the chat
	BoostCount              int32             `json:"boost_count"`               // The number of boosts received by the chat
	CurrentLevelBoostCount  int32             `json:"current_level_boost_count"` // The number of boosts added to reach the current level
	NextLevelBoostCount     int32             `json:"next_level_boost_count"`    // The number of boosts needed to reach the next level; 0 if the next level isn't available
	PremiumMemberCount      int32             `json:"premium_member_count"`      // Approximate number of Telegram Premium subscribers joined the chat; always 0 if the current user isn't an administrator in the chat
	PremiumMemberPercentage float64           `json:"premium_member_percentage"` // A percentage of Telegram Premium subscribers joined the chat; always 0 if the current user isn't an administrator in the chat
	PrepaidGiveaways        []PrepaidGiveaway `json:"prepaid_giveaways"`         // The list of prepaid giveaways available for the chat; only for chat administrators
}

// MessageType return the string telegram-type of ChatBoostStatus
func (chatBoostStatus *ChatBoostStatus) MessageType() string {
	return "chatBoostStatus"
}

// NewChatBoostStatus creates a new ChatBoostStatus
//
// @param boostURL An HTTP URL, which can be used to boost the chat
// @param appliedSlotIDs Identifiers of boost slots of the current user applied to the chat
// @param level Current boost level of the chat
// @param giftCodeBoostCount The number of boosts received by the chat from created Telegram Premium gift codes and giveaways; always 0 if the current user isn't an administrator in the chat
// @param boostCount The number of boosts received by the chat
// @param currentLevelBoostCount The number of boosts added to reach the current level
// @param nextLevelBoostCount The number of boosts needed to reach the next level; 0 if the next level isn't available
// @param premiumMemberCount Approximate number of Telegram Premium subscribers joined the chat; always 0 if the current user isn't an administrator in the chat
// @param premiumMemberPercentage A percentage of Telegram Premium subscribers joined the chat; always 0 if the current user isn't an administrator in the chat
// @param prepaidGiveaways The list of prepaid giveaways available for the chat; only for chat administrators
func NewChatBoostStatus(boostURL string, appliedSlotIDs []int32, level int32, giftCodeBoostCount int32, boostCount int32, currentLevelBoostCount int32, nextLevelBoostCount int32, premiumMemberCount int32, premiumMemberPercentage float64, prepaidGiveaways []PrepaidGiveaway) *ChatBoostStatus {
	chatBoostStatusTemp := ChatBoostStatus{
		tdCommon:                tdCommon{Type: "chatBoostStatus"},
		BoostURL:                boostURL,
		AppliedSlotIDs:          appliedSlotIDs,
		Level:                   level,
		GiftCodeBoostCount:      giftCodeBoostCount,
		BoostCount:              boostCount,
		CurrentLevelBoostCount:  currentLevelBoostCount,
		NextLevelBoostCount:     nextLevelBoostCount,
		PremiumMemberCount:      premiumMemberCount,
		PremiumMemberPercentage: premiumMemberPercentage,
		PrepaidGiveaways:        prepaidGiveaways,
	}

	return &chatBoostStatusTemp
}

// UnmarshalJSON unmarshal to json
func (chatBoostStatus *ChatBoostStatus) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BoostURL                string            `json:"boost_url"`                 // An HTTP URL, which can be used to boost the chat
		AppliedSlotIDs          []int32           `json:"applied_slot_ids"`          // Identifiers of boost slots of the current user applied to the chat
		Level                   int32             `json:"level"`                     // Current boost level of the chat
		GiftCodeBoostCount      int32             `json:"gift_code_boost_count"`     // The number of boosts received by the chat from created Telegram Premium gift codes and giveaways; always 0 if the current user isn't an administrator in the chat
		BoostCount              int32             `json:"boost_count"`               // The number of boosts received by the chat
		CurrentLevelBoostCount  int32             `json:"current_level_boost_count"` // The number of boosts added to reach the current level
		NextLevelBoostCount     int32             `json:"next_level_boost_count"`    // The number of boosts needed to reach the next level; 0 if the next level isn't available
		PremiumMemberCount      int32             `json:"premium_member_count"`      // Approximate number of Telegram Premium subscribers joined the chat; always 0 if the current user isn't an administrator in the chat
		PremiumMemberPercentage float64           `json:"premium_member_percentage"` // A percentage of Telegram Premium subscribers joined the chat; always 0 if the current user isn't an administrator in the chat
		PrepaidGiveaways        []PrepaidGiveaway `json:"prepaid_giveaways"`         // The list of prepaid giveaways available for the chat; only for chat administrators
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatBoostStatus.tdCommon = tempObj.tdCommon
	chatBoostStatus.BoostURL = tempObj.BoostURL
	chatBoostStatus.AppliedSlotIDs = tempObj.AppliedSlotIDs
	chatBoostStatus.Level = tempObj.Level
	chatBoostStatus.GiftCodeBoostCount = tempObj.GiftCodeBoostCount
	chatBoostStatus.BoostCount = tempObj.BoostCount
	chatBoostStatus.CurrentLevelBoostCount = tempObj.CurrentLevelBoostCount
	chatBoostStatus.NextLevelBoostCount = tempObj.NextLevelBoostCount
	chatBoostStatus.PremiumMemberCount = tempObj.PremiumMemberCount
	chatBoostStatus.PremiumMemberPercentage = tempObj.PremiumMemberPercentage
	chatBoostStatus.PrepaidGiveaways = tempObj.PrepaidGiveaways

	return nil
}

// ChatBoost Describes a boost applied to a chat
type ChatBoost struct {
	tdCommon
	ID             string          `json:"id"`              // Unique identifier of the boost
	Count          int32           `json:"count"`           // The number of identical boosts applied
	Source         ChatBoostSource `json:"source"`          // Source of the boost
	StartDate      int32           `json:"start_date"`      // Point in time (Unix timestamp) when the chat was boosted
	ExpirationDate int32           `json:"expiration_date"` // Point in time (Unix timestamp) when the boost will expire
}

// MessageType return the string telegram-type of ChatBoost
func (chatBoost *ChatBoost) MessageType() string {
	return "chatBoost"
}

// NewChatBoost creates a new ChatBoost
//
// @param iD Unique identifier of the boost
// @param count The number of identical boosts applied
// @param source Source of the boost
// @param startDate Point in time (Unix timestamp) when the chat was boosted
// @param expirationDate Point in time (Unix timestamp) when the boost will expire
func NewChatBoost(iD string, count int32, source ChatBoostSource, startDate int32, expirationDate int32) *ChatBoost {
	chatBoostTemp := ChatBoost{
		tdCommon:       tdCommon{Type: "chatBoost"},
		ID:             iD,
		Count:          count,
		Source:         source,
		StartDate:      startDate,
		ExpirationDate: expirationDate,
	}

	return &chatBoostTemp
}

// UnmarshalJSON unmarshal to json
func (chatBoost *ChatBoost) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID             string `json:"id"`              // Unique identifier of the boost
		Count          int32  `json:"count"`           // The number of identical boosts applied
		StartDate      int32  `json:"start_date"`      // Point in time (Unix timestamp) when the chat was boosted
		ExpirationDate int32  `json:"expiration_date"` // Point in time (Unix timestamp) when the boost will expire
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatBoost.tdCommon = tempObj.tdCommon
	chatBoost.ID = tempObj.ID
	chatBoost.Count = tempObj.Count
	chatBoost.StartDate = tempObj.StartDate
	chatBoost.ExpirationDate = tempObj.ExpirationDate

	fieldSource, _ := unmarshalChatBoostSource(objMap["source"])
	chatBoost.Source = fieldSource

	return nil
}

// FoundChatBoosts Contains a list of boosts applied to a chat
type FoundChatBoosts struct {
	tdCommon
	TotalCount int32       `json:"total_count"` // Total number of boosts applied to the chat
	Boosts     []ChatBoost `json:"boosts"`      // List of boosts
	NextOffset string      `json:"next_offset"` // The offset for the next request. If empty, then there are no more results
}

// MessageType return the string telegram-type of FoundChatBoosts
func (foundChatBoosts *FoundChatBoosts) MessageType() string {
	return "foundChatBoosts"
}

// NewFoundChatBoosts creates a new FoundChatBoosts
//
// @param totalCount Total number of boosts applied to the chat
// @param boosts List of boosts
// @param nextOffset The offset for the next request. If empty, then there are no more results
func NewFoundChatBoosts(totalCount int32, boosts []ChatBoost, nextOffset string) *FoundChatBoosts {
	foundChatBoostsTemp := FoundChatBoosts{
		tdCommon:   tdCommon{Type: "foundChatBoosts"},
		TotalCount: totalCount,
		Boosts:     boosts,
		NextOffset: nextOffset,
	}

	return &foundChatBoostsTemp
}

// UnmarshalJSON unmarshal to json
func (foundChatBoosts *FoundChatBoosts) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32       `json:"total_count"` // Total number of boosts applied to the chat
		Boosts     []ChatBoost `json:"boosts"`      // List of boosts
		NextOffset string      `json:"next_offset"` // The offset for the next request. If empty, then there are no more results
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	foundChatBoosts.tdCommon = tempObj.tdCommon
	foundChatBoosts.TotalCount = tempObj.TotalCount
	foundChatBoosts.Boosts = tempObj.Boosts
	foundChatBoosts.NextOffset = tempObj.NextOffset

	return nil
}

// ChatBoostSlot Describes a slot for chat boost
type ChatBoostSlot struct {
	tdCommon
	SlotID                 int32 `json:"slot_id"`                   // Unique identifier of the slot
	CurrentlyBoostedChatID int64 `json:"currently_boosted_chat_id"` // Identifier of the currently boosted chat; 0 if none
	StartDate              int32 `json:"start_date"`                // Point in time (Unix timestamp) when the chat was boosted; 0 if none
	ExpirationDate         int32 `json:"expiration_date"`           // Point in time (Unix timestamp) when the boost will expire
	CooldownUntilDate      int32 `json:"cooldown_until_date"`       // Point in time (Unix timestamp) after which the boost can be used for another chat
}

// MessageType return the string telegram-type of ChatBoostSlot
func (chatBoostSlot *ChatBoostSlot) MessageType() string {
	return "chatBoostSlot"
}

// NewChatBoostSlot creates a new ChatBoostSlot
//
// @param slotID Unique identifier of the slot
// @param currentlyBoostedChatID Identifier of the currently boosted chat; 0 if none
// @param startDate Point in time (Unix timestamp) when the chat was boosted; 0 if none
// @param expirationDate Point in time (Unix timestamp) when the boost will expire
// @param cooldownUntilDate Point in time (Unix timestamp) after which the boost can be used for another chat
func NewChatBoostSlot(slotID int32, currentlyBoostedChatID int64, startDate int32, expirationDate int32, cooldownUntilDate int32) *ChatBoostSlot {
	chatBoostSlotTemp := ChatBoostSlot{
		tdCommon:               tdCommon{Type: "chatBoostSlot"},
		SlotID:                 slotID,
		CurrentlyBoostedChatID: currentlyBoostedChatID,
		StartDate:              startDate,
		ExpirationDate:         expirationDate,
		CooldownUntilDate:      cooldownUntilDate,
	}

	return &chatBoostSlotTemp
}

// UnmarshalJSON unmarshal to json
func (chatBoostSlot *ChatBoostSlot) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SlotID                 int32 `json:"slot_id"`                   // Unique identifier of the slot
		CurrentlyBoostedChatID int64 `json:"currently_boosted_chat_id"` // Identifier of the currently boosted chat; 0 if none
		StartDate              int32 `json:"start_date"`                // Point in time (Unix timestamp) when the chat was boosted; 0 if none
		ExpirationDate         int32 `json:"expiration_date"`           // Point in time (Unix timestamp) when the boost will expire
		CooldownUntilDate      int32 `json:"cooldown_until_date"`       // Point in time (Unix timestamp) after which the boost can be used for another chat
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatBoostSlot.tdCommon = tempObj.tdCommon
	chatBoostSlot.SlotID = tempObj.SlotID
	chatBoostSlot.CurrentlyBoostedChatID = tempObj.CurrentlyBoostedChatID
	chatBoostSlot.StartDate = tempObj.StartDate
	chatBoostSlot.ExpirationDate = tempObj.ExpirationDate
	chatBoostSlot.CooldownUntilDate = tempObj.CooldownUntilDate

	return nil
}

// ChatBoostSlots Contains a list of chat boost slots
type ChatBoostSlots struct {
	tdCommon
	Slots []ChatBoostSlot `json:"slots"` // List of boost slots
}

// MessageType return the string telegram-type of ChatBoostSlots
func (chatBoostSlots *ChatBoostSlots) MessageType() string {
	return "chatBoostSlots"
}

// NewChatBoostSlots creates a new ChatBoostSlots
//
// @param slots List of boost slots
func NewChatBoostSlots(slots []ChatBoostSlot) *ChatBoostSlots {
	chatBoostSlotsTemp := ChatBoostSlots{
		tdCommon: tdCommon{Type: "chatBoostSlots"},
		Slots:    slots,
	}

	return &chatBoostSlotsTemp
}

// UnmarshalJSON unmarshal to json
func (chatBoostSlots *ChatBoostSlots) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Slots []ChatBoostSlot `json:"slots"` // List of boost slots
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatBoostSlots.tdCommon = tempObj.tdCommon
	chatBoostSlots.Slots = tempObj.Slots

	return nil
}

// ResendCodeReasonUserRequest The user requested to resend the code
type ResendCodeReasonUserRequest struct {
	tdCommon
}

// MessageType return the string telegram-type of ResendCodeReasonUserRequest
func (resendCodeReasonUserRequest *ResendCodeReasonUserRequest) MessageType() string {
	return "resendCodeReasonUserRequest"
}

// NewResendCodeReasonUserRequest creates a new ResendCodeReasonUserRequest
//
func NewResendCodeReasonUserRequest() *ResendCodeReasonUserRequest {
	resendCodeReasonUserRequestTemp := ResendCodeReasonUserRequest{
		tdCommon: tdCommon{Type: "resendCodeReasonUserRequest"},
	}

	return &resendCodeReasonUserRequestTemp
}

// UnmarshalJSON unmarshal to json
func (resendCodeReasonUserRequest *ResendCodeReasonUserRequest) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	resendCodeReasonUserRequest.tdCommon = tempObj.tdCommon

	return nil
}

// GetResendCodeReasonEnum return the enum type of this object
func (resendCodeReasonUserRequest *ResendCodeReasonUserRequest) GetResendCodeReasonEnum() ResendCodeReasonEnum {
	return ResendCodeReasonUserRequestType
}

// ResendCodeReasonVerificationFailed The code is re-sent, because device verification has failed
type ResendCodeReasonVerificationFailed struct {
	tdCommon
	ErrorMessage string `json:"error_message"` // Cause of the verification failure, for example, PLAY_SERVICES_NOT_AVAILABLE, APNS_RECEIVE_TIMEOUT, or APNS_INIT_FAILED
}

// MessageType return the string telegram-type of ResendCodeReasonVerificationFailed
func (resendCodeReasonVerificationFailed *ResendCodeReasonVerificationFailed) MessageType() string {
	return "resendCodeReasonVerificationFailed"
}

// NewResendCodeReasonVerificationFailed creates a new ResendCodeReasonVerificationFailed
//
// @param errParamMessage Cause of the verification failure, for example, PLAY_SERVICES_NOT_AVAILABLE, APNS_RECEIVE_TIMEOUT, or APNS_INIT_FAILED
func NewResendCodeReasonVerificationFailed(errParamMessage string) *ResendCodeReasonVerificationFailed {
	resendCodeReasonVerificationFailedTemp := ResendCodeReasonVerificationFailed{
		tdCommon:     tdCommon{Type: "resendCodeReasonVerificationFailed"},
		ErrorMessage: errParamMessage,
	}

	return &resendCodeReasonVerificationFailedTemp
}

// UnmarshalJSON unmarshal to json
func (resendCodeReasonVerificationFailed *ResendCodeReasonVerificationFailed) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ErrorMessage string `json:"error_message"` // Cause of the verification failure, for example, PLAY_SERVICES_NOT_AVAILABLE, APNS_RECEIVE_TIMEOUT, or APNS_INIT_FAILED
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	resendCodeReasonVerificationFailed.tdCommon = tempObj.tdCommon
	resendCodeReasonVerificationFailed.ErrorMessage = tempObj.ErrorMessage

	return nil
}

// GetResendCodeReasonEnum return the enum type of this object
func (resendCodeReasonVerificationFailed *ResendCodeReasonVerificationFailed) GetResendCodeReasonEnum() ResendCodeReasonEnum {
	return ResendCodeReasonVerificationFailedType
}

// CallDiscardReasonEmpty The call wasn't discarded, or the reason is unknown
type CallDiscardReasonEmpty struct {
	tdCommon
}

// MessageType return the string telegram-type of CallDiscardReasonEmpty
func (callDiscardReasonEmpty *CallDiscardReasonEmpty) MessageType() string {
	return "callDiscardReasonEmpty"
}

// NewCallDiscardReasonEmpty creates a new CallDiscardReasonEmpty
//
func NewCallDiscardReasonEmpty() *CallDiscardReasonEmpty {
	callDiscardReasonEmptyTemp := CallDiscardReasonEmpty{
		tdCommon: tdCommon{Type: "callDiscardReasonEmpty"},
	}

	return &callDiscardReasonEmptyTemp
}

// UnmarshalJSON unmarshal to json
func (callDiscardReasonEmpty *CallDiscardReasonEmpty) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callDiscardReasonEmpty.tdCommon = tempObj.tdCommon

	return nil
}

// GetCallDiscardReasonEnum return the enum type of this object
func (callDiscardReasonEmpty *CallDiscardReasonEmpty) GetCallDiscardReasonEnum() CallDiscardReasonEnum {
	return CallDiscardReasonEmptyType
}

// CallDiscardReasonMissed The call was ended before the conversation started. It was canceled by the caller or missed by the other party
type CallDiscardReasonMissed struct {
	tdCommon
}

// MessageType return the string telegram-type of CallDiscardReasonMissed
func (callDiscardReasonMissed *CallDiscardReasonMissed) MessageType() string {
	return "callDiscardReasonMissed"
}

// NewCallDiscardReasonMissed creates a new CallDiscardReasonMissed
//
func NewCallDiscardReasonMissed() *CallDiscardReasonMissed {
	callDiscardReasonMissedTemp := CallDiscardReasonMissed{
		tdCommon: tdCommon{Type: "callDiscardReasonMissed"},
	}

	return &callDiscardReasonMissedTemp
}

// UnmarshalJSON unmarshal to json
func (callDiscardReasonMissed *CallDiscardReasonMissed) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callDiscardReasonMissed.tdCommon = tempObj.tdCommon

	return nil
}

// GetCallDiscardReasonEnum return the enum type of this object
func (callDiscardReasonMissed *CallDiscardReasonMissed) GetCallDiscardReasonEnum() CallDiscardReasonEnum {
	return CallDiscardReasonMissedType
}

// CallDiscardReasonDeclined The call was ended before the conversation started. It was declined by the other party
type CallDiscardReasonDeclined struct {
	tdCommon
}

// MessageType return the string telegram-type of CallDiscardReasonDeclined
func (callDiscardReasonDeclined *CallDiscardReasonDeclined) MessageType() string {
	return "callDiscardReasonDeclined"
}

// NewCallDiscardReasonDeclined creates a new CallDiscardReasonDeclined
//
func NewCallDiscardReasonDeclined() *CallDiscardReasonDeclined {
	callDiscardReasonDeclinedTemp := CallDiscardReasonDeclined{
		tdCommon: tdCommon{Type: "callDiscardReasonDeclined"},
	}

	return &callDiscardReasonDeclinedTemp
}

// UnmarshalJSON unmarshal to json
func (callDiscardReasonDeclined *CallDiscardReasonDeclined) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callDiscardReasonDeclined.tdCommon = tempObj.tdCommon

	return nil
}

// GetCallDiscardReasonEnum return the enum type of this object
func (callDiscardReasonDeclined *CallDiscardReasonDeclined) GetCallDiscardReasonEnum() CallDiscardReasonEnum {
	return CallDiscardReasonDeclinedType
}

// CallDiscardReasonDisconnected The call was ended during the conversation because the users were disconnected
type CallDiscardReasonDisconnected struct {
	tdCommon
}

// MessageType return the string telegram-type of CallDiscardReasonDisconnected
func (callDiscardReasonDisconnected *CallDiscardReasonDisconnected) MessageType() string {
	return "callDiscardReasonDisconnected"
}

// NewCallDiscardReasonDisconnected creates a new CallDiscardReasonDisconnected
//
func NewCallDiscardReasonDisconnected() *CallDiscardReasonDisconnected {
	callDiscardReasonDisconnectedTemp := CallDiscardReasonDisconnected{
		tdCommon: tdCommon{Type: "callDiscardReasonDisconnected"},
	}

	return &callDiscardReasonDisconnectedTemp
}

// UnmarshalJSON unmarshal to json
func (callDiscardReasonDisconnected *CallDiscardReasonDisconnected) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callDiscardReasonDisconnected.tdCommon = tempObj.tdCommon

	return nil
}

// GetCallDiscardReasonEnum return the enum type of this object
func (callDiscardReasonDisconnected *CallDiscardReasonDisconnected) GetCallDiscardReasonEnum() CallDiscardReasonEnum {
	return CallDiscardReasonDisconnectedType
}

// CallDiscardReasonHungUp The call was ended because one of the parties hung up
type CallDiscardReasonHungUp struct {
	tdCommon
}

// MessageType return the string telegram-type of CallDiscardReasonHungUp
func (callDiscardReasonHungUp *CallDiscardReasonHungUp) MessageType() string {
	return "callDiscardReasonHungUp"
}

// NewCallDiscardReasonHungUp creates a new CallDiscardReasonHungUp
//
func NewCallDiscardReasonHungUp() *CallDiscardReasonHungUp {
	callDiscardReasonHungUpTemp := CallDiscardReasonHungUp{
		tdCommon: tdCommon{Type: "callDiscardReasonHungUp"},
	}

	return &callDiscardReasonHungUpTemp
}

// UnmarshalJSON unmarshal to json
func (callDiscardReasonHungUp *CallDiscardReasonHungUp) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callDiscardReasonHungUp.tdCommon = tempObj.tdCommon

	return nil
}

// GetCallDiscardReasonEnum return the enum type of this object
func (callDiscardReasonHungUp *CallDiscardReasonHungUp) GetCallDiscardReasonEnum() CallDiscardReasonEnum {
	return CallDiscardReasonHungUpType
}

// CallProtocol Specifies the supported call protocols
type CallProtocol struct {
	tdCommon
	UDPP2p          bool     `json:"udp_p2p"`          // True, if UDP peer-to-peer connections are supported
	UDPReflector    bool     `json:"udp_reflector"`    // True, if connection through UDP reflectors is supported
	MinLayer        int32    `json:"min_layer"`        // The minimum supported API layer; use 65
	MaxLayer        int32    `json:"max_layer"`        // The maximum supported API layer; use 92
	LibraryVersions []string `json:"library_versions"` // List of supported tgcalls versions
}

// MessageType return the string telegram-type of CallProtocol
func (callProtocol *CallProtocol) MessageType() string {
	return "callProtocol"
}

// NewCallProtocol creates a new CallProtocol
//
// @param uDPP2p True, if UDP peer-to-peer connections are supported
// @param uDPReflector True, if connection through UDP reflectors is supported
// @param minLayer The minimum supported API layer; use 65
// @param maxLayer The maximum supported API layer; use 92
// @param libraryVersions List of supported tgcalls versions
func NewCallProtocol(uDPP2p bool, uDPReflector bool, minLayer int32, maxLayer int32, libraryVersions []string) *CallProtocol {
	callProtocolTemp := CallProtocol{
		tdCommon:        tdCommon{Type: "callProtocol"},
		UDPP2p:          uDPP2p,
		UDPReflector:    uDPReflector,
		MinLayer:        minLayer,
		MaxLayer:        maxLayer,
		LibraryVersions: libraryVersions,
	}

	return &callProtocolTemp
}

// UnmarshalJSON unmarshal to json
func (callProtocol *CallProtocol) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UDPP2p          bool     `json:"udp_p2p"`          // True, if UDP peer-to-peer connections are supported
		UDPReflector    bool     `json:"udp_reflector"`    // True, if connection through UDP reflectors is supported
		MinLayer        int32    `json:"min_layer"`        // The minimum supported API layer; use 65
		MaxLayer        int32    `json:"max_layer"`        // The maximum supported API layer; use 92
		LibraryVersions []string `json:"library_versions"` // List of supported tgcalls versions
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callProtocol.tdCommon = tempObj.tdCommon
	callProtocol.UDPP2p = tempObj.UDPP2p
	callProtocol.UDPReflector = tempObj.UDPReflector
	callProtocol.MinLayer = tempObj.MinLayer
	callProtocol.MaxLayer = tempObj.MaxLayer
	callProtocol.LibraryVersions = tempObj.LibraryVersions

	return nil
}

// CallServerTypeTelegramReflector A Telegram call reflector
type CallServerTypeTelegramReflector struct {
	tdCommon
	PeerTag []byte `json:"peer_tag"` // A peer tag to be used with the reflector
	IsTcp   bool   `json:"is_tcp"`   // True, if the server uses TCP instead of UDP
}

// MessageType return the string telegram-type of CallServerTypeTelegramReflector
func (callServerTypeTelegramReflector *CallServerTypeTelegramReflector) MessageType() string {
	return "callServerTypeTelegramReflector"
}

// NewCallServerTypeTelegramReflector creates a new CallServerTypeTelegramReflector
//
// @param peerTag A peer tag to be used with the reflector
// @param isTcp True, if the server uses TCP instead of UDP
func NewCallServerTypeTelegramReflector(peerTag []byte, isTcp bool) *CallServerTypeTelegramReflector {
	callServerTypeTelegramReflectorTemp := CallServerTypeTelegramReflector{
		tdCommon: tdCommon{Type: "callServerTypeTelegramReflector"},
		PeerTag:  peerTag,
		IsTcp:    isTcp,
	}

	return &callServerTypeTelegramReflectorTemp
}

// UnmarshalJSON unmarshal to json
func (callServerTypeTelegramReflector *CallServerTypeTelegramReflector) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PeerTag []byte `json:"peer_tag"` // A peer tag to be used with the reflector
		IsTcp   bool   `json:"is_tcp"`   // True, if the server uses TCP instead of UDP
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callServerTypeTelegramReflector.tdCommon = tempObj.tdCommon
	callServerTypeTelegramReflector.PeerTag = tempObj.PeerTag
	callServerTypeTelegramReflector.IsTcp = tempObj.IsTcp

	return nil
}

// GetCallServerTypeEnum return the enum type of this object
func (callServerTypeTelegramReflector *CallServerTypeTelegramReflector) GetCallServerTypeEnum() CallServerTypeEnum {
	return CallServerTypeTelegramReflectorType
}

// CallServerTypeWebrtc A WebRTC server
type CallServerTypeWebrtc struct {
	tdCommon
	Username     string `json:"username"`      // Username to be used for authentication
	Password     string `json:"password"`      // Authentication password
	SupportsTurn bool   `json:"supports_turn"` // True, if the server supports TURN
	SupportsStun bool   `json:"supports_stun"` // True, if the server supports STUN
}

// MessageType return the string telegram-type of CallServerTypeWebrtc
func (callServerTypeWebrtc *CallServerTypeWebrtc) MessageType() string {
	return "callServerTypeWebrtc"
}

// NewCallServerTypeWebrtc creates a new CallServerTypeWebrtc
//
// @param username Username to be used for authentication
// @param password Authentication password
// @param supportsTurn True, if the server supports TURN
// @param supportsStun True, if the server supports STUN
func NewCallServerTypeWebrtc(username string, password string, supportsTurn bool, supportsStun bool) *CallServerTypeWebrtc {
	callServerTypeWebrtcTemp := CallServerTypeWebrtc{
		tdCommon:     tdCommon{Type: "callServerTypeWebrtc"},
		Username:     username,
		Password:     password,
		SupportsTurn: supportsTurn,
		SupportsStun: supportsStun,
	}

	return &callServerTypeWebrtcTemp
}

// UnmarshalJSON unmarshal to json
func (callServerTypeWebrtc *CallServerTypeWebrtc) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Username     string `json:"username"`      // Username to be used for authentication
		Password     string `json:"password"`      // Authentication password
		SupportsTurn bool   `json:"supports_turn"` // True, if the server supports TURN
		SupportsStun bool   `json:"supports_stun"` // True, if the server supports STUN
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callServerTypeWebrtc.tdCommon = tempObj.tdCommon
	callServerTypeWebrtc.Username = tempObj.Username
	callServerTypeWebrtc.Password = tempObj.Password
	callServerTypeWebrtc.SupportsTurn = tempObj.SupportsTurn
	callServerTypeWebrtc.SupportsStun = tempObj.SupportsStun

	return nil
}

// GetCallServerTypeEnum return the enum type of this object
func (callServerTypeWebrtc *CallServerTypeWebrtc) GetCallServerTypeEnum() CallServerTypeEnum {
	return CallServerTypeWebrtcType
}

// CallServer Describes a server for relaying call data
type CallServer struct {
	tdCommon
	ID          JSONInt64      `json:"id"`           // Server identifier
	IPAddress   string         `json:"ip_address"`   // Server IPv4 address
	IPv6Address string         `json:"ipv6_address"` // Server IPv6 address
	Port        int32          `json:"port"`         // Server port number
	Type        CallServerType `json:"type"`         // Server type
}

// MessageType return the string telegram-type of CallServer
func (callServer *CallServer) MessageType() string {
	return "callServer"
}

// NewCallServer creates a new CallServer
//
// @param iD Server identifier
// @param iPAddress Server IPv4 address
// @param iPv6Address Server IPv6 address
// @param port Server port number
// @param typeParam Server type
func NewCallServer(iD JSONInt64, iPAddress string, iPv6Address string, port int32, typeParam CallServerType) *CallServer {
	callServerTemp := CallServer{
		tdCommon:    tdCommon{Type: "callServer"},
		ID:          iD,
		IPAddress:   iPAddress,
		IPv6Address: iPv6Address,
		Port:        port,
		Type:        typeParam,
	}

	return &callServerTemp
}

// UnmarshalJSON unmarshal to json
func (callServer *CallServer) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID          JSONInt64 `json:"id"`           // Server identifier
		IPAddress   string    `json:"ip_address"`   // Server IPv4 address
		IPv6Address string    `json:"ipv6_address"` // Server IPv6 address
		Port        int32     `json:"port"`         // Server port number

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callServer.tdCommon = tempObj.tdCommon
	callServer.ID = tempObj.ID
	callServer.IPAddress = tempObj.IPAddress
	callServer.IPv6Address = tempObj.IPv6Address
	callServer.Port = tempObj.Port

	fieldType, _ := unmarshalCallServerType(objMap["type"])
	callServer.Type = fieldType

	return nil
}

// CallID Contains the call identifier
type CallID struct {
	tdCommon
	ID int32 `json:"id"` // Call identifier
}

// MessageType return the string telegram-type of CallID
func (callID *CallID) MessageType() string {
	return "callId"
}

// NewCallID creates a new CallID
//
// @param iD Call identifier
func NewCallID(iD int32) *CallID {
	callIDTemp := CallID{
		tdCommon: tdCommon{Type: "callId"},
		ID:       iD,
	}

	return &callIDTemp
}

// UnmarshalJSON unmarshal to json
func (callID *CallID) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID int32 `json:"id"` // Call identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callID.tdCommon = tempObj.tdCommon
	callID.ID = tempObj.ID

	return nil
}

// GroupCallID Contains the group call identifier
type GroupCallID struct {
	tdCommon
	ID int32 `json:"id"` // Group call identifier
}

// MessageType return the string telegram-type of GroupCallID
func (groupCallID *GroupCallID) MessageType() string {
	return "groupCallId"
}

// NewGroupCallID creates a new GroupCallID
//
// @param iD Group call identifier
func NewGroupCallID(iD int32) *GroupCallID {
	groupCallIDTemp := GroupCallID{
		tdCommon: tdCommon{Type: "groupCallId"},
		ID:       iD,
	}

	return &groupCallIDTemp
}

// UnmarshalJSON unmarshal to json
func (groupCallID *GroupCallID) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID int32 `json:"id"` // Group call identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	groupCallID.tdCommon = tempObj.tdCommon
	groupCallID.ID = tempObj.ID

	return nil
}

// CallStatePending The call is pending, waiting to be accepted by a user
type CallStatePending struct {
	tdCommon
	IsCreated  bool `json:"is_created"`  // True, if the call has already been created by the server
	IsReceived bool `json:"is_received"` // True, if the call has already been received by the other party
}

// MessageType return the string telegram-type of CallStatePending
func (callStatePending *CallStatePending) MessageType() string {
	return "callStatePending"
}

// NewCallStatePending creates a new CallStatePending
//
// @param isCreated True, if the call has already been created by the server
// @param isReceived True, if the call has already been received by the other party
func NewCallStatePending(isCreated bool, isReceived bool) *CallStatePending {
	callStatePendingTemp := CallStatePending{
		tdCommon:   tdCommon{Type: "callStatePending"},
		IsCreated:  isCreated,
		IsReceived: isReceived,
	}

	return &callStatePendingTemp
}

// UnmarshalJSON unmarshal to json
func (callStatePending *CallStatePending) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsCreated  bool `json:"is_created"`  // True, if the call has already been created by the server
		IsReceived bool `json:"is_received"` // True, if the call has already been received by the other party
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callStatePending.tdCommon = tempObj.tdCommon
	callStatePending.IsCreated = tempObj.IsCreated
	callStatePending.IsReceived = tempObj.IsReceived

	return nil
}

// GetCallStateEnum return the enum type of this object
func (callStatePending *CallStatePending) GetCallStateEnum() CallStateEnum {
	return CallStatePendingType
}

// CallStateExchangingKeys The call has been answered and encryption keys are being exchanged
type CallStateExchangingKeys struct {
	tdCommon
}

// MessageType return the string telegram-type of CallStateExchangingKeys
func (callStateExchangingKeys *CallStateExchangingKeys) MessageType() string {
	return "callStateExchangingKeys"
}

// NewCallStateExchangingKeys creates a new CallStateExchangingKeys
//
func NewCallStateExchangingKeys() *CallStateExchangingKeys {
	callStateExchangingKeysTemp := CallStateExchangingKeys{
		tdCommon: tdCommon{Type: "callStateExchangingKeys"},
	}

	return &callStateExchangingKeysTemp
}

// UnmarshalJSON unmarshal to json
func (callStateExchangingKeys *CallStateExchangingKeys) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callStateExchangingKeys.tdCommon = tempObj.tdCommon

	return nil
}

// GetCallStateEnum return the enum type of this object
func (callStateExchangingKeys *CallStateExchangingKeys) GetCallStateEnum() CallStateEnum {
	return CallStateExchangingKeysType
}

// CallStateReady The call is ready to use
type CallStateReady struct {
	tdCommon
	Protocol         *CallProtocol `json:"protocol"`          // Call protocols supported by the other call participant
	Servers          []CallServer  `json:"servers"`           // List of available call servers
	Config           string        `json:"config"`            // A JSON-encoded call config
	EncryptionKey    []byte        `json:"encryption_key"`    // Call encryption key
	Emojis           []string      `json:"emojis"`            // Encryption key fingerprint represented as 4 emoji
	AllowP2p         bool          `json:"allow_p2p"`         // True, if peer-to-peer connection is allowed by users privacy settings
	CustomParameters string        `json:"custom_parameters"` // Custom JSON-encoded call parameters to be passed to tgcalls
}

// MessageType return the string telegram-type of CallStateReady
func (callStateReady *CallStateReady) MessageType() string {
	return "callStateReady"
}

// NewCallStateReady creates a new CallStateReady
//
// @param protocol Call protocols supported by the other call participant
// @param servers List of available call servers
// @param config A JSON-encoded call config
// @param encryptionKey Call encryption key
// @param emojis Encryption key fingerprint represented as 4 emoji
// @param allowP2p True, if peer-to-peer connection is allowed by users privacy settings
// @param customParameters Custom JSON-encoded call parameters to be passed to tgcalls
func NewCallStateReady(protocol *CallProtocol, servers []CallServer, config string, encryptionKey []byte, emojis []string, allowP2p bool, customParameters string) *CallStateReady {
	callStateReadyTemp := CallStateReady{
		tdCommon:         tdCommon{Type: "callStateReady"},
		Protocol:         protocol,
		Servers:          servers,
		Config:           config,
		EncryptionKey:    encryptionKey,
		Emojis:           emojis,
		AllowP2p:         allowP2p,
		CustomParameters: customParameters,
	}

	return &callStateReadyTemp
}

// UnmarshalJSON unmarshal to json
func (callStateReady *CallStateReady) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Protocol         *CallProtocol `json:"protocol"`          // Call protocols supported by the other call participant
		Servers          []CallServer  `json:"servers"`           // List of available call servers
		Config           string        `json:"config"`            // A JSON-encoded call config
		EncryptionKey    []byte        `json:"encryption_key"`    // Call encryption key
		Emojis           []string      `json:"emojis"`            // Encryption key fingerprint represented as 4 emoji
		AllowP2p         bool          `json:"allow_p2p"`         // True, if peer-to-peer connection is allowed by users privacy settings
		CustomParameters string        `json:"custom_parameters"` // Custom JSON-encoded call parameters to be passed to tgcalls
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callStateReady.tdCommon = tempObj.tdCommon
	callStateReady.Protocol = tempObj.Protocol
	callStateReady.Servers = tempObj.Servers
	callStateReady.Config = tempObj.Config
	callStateReady.EncryptionKey = tempObj.EncryptionKey
	callStateReady.Emojis = tempObj.Emojis
	callStateReady.AllowP2p = tempObj.AllowP2p
	callStateReady.CustomParameters = tempObj.CustomParameters

	return nil
}

// GetCallStateEnum return the enum type of this object
func (callStateReady *CallStateReady) GetCallStateEnum() CallStateEnum {
	return CallStateReadyType
}

// CallStateHangingUp The call is hanging up after discardCall has been called
type CallStateHangingUp struct {
	tdCommon
}

// MessageType return the string telegram-type of CallStateHangingUp
func (callStateHangingUp *CallStateHangingUp) MessageType() string {
	return "callStateHangingUp"
}

// NewCallStateHangingUp creates a new CallStateHangingUp
//
func NewCallStateHangingUp() *CallStateHangingUp {
	callStateHangingUpTemp := CallStateHangingUp{
		tdCommon: tdCommon{Type: "callStateHangingUp"},
	}

	return &callStateHangingUpTemp
}

// UnmarshalJSON unmarshal to json
func (callStateHangingUp *CallStateHangingUp) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callStateHangingUp.tdCommon = tempObj.tdCommon

	return nil
}

// GetCallStateEnum return the enum type of this object
func (callStateHangingUp *CallStateHangingUp) GetCallStateEnum() CallStateEnum {
	return CallStateHangingUpType
}

// CallStateDiscarded The call has ended successfully
type CallStateDiscarded struct {
	tdCommon
	Reason               CallDiscardReason `json:"reason"`                 // The reason why the call has ended
	NeedRating           bool              `json:"need_rating"`            // True, if the call rating must be sent to the server
	NeedDebugInformation bool              `json:"need_debug_information"` // True, if the call debug information must be sent to the server
	NeedLog              bool              `json:"need_log"`               // True, if the call log must be sent to the server
}

// MessageType return the string telegram-type of CallStateDiscarded
func (callStateDiscarded *CallStateDiscarded) MessageType() string {
	return "callStateDiscarded"
}

// NewCallStateDiscarded creates a new CallStateDiscarded
//
// @param reason The reason why the call has ended
// @param needRating True, if the call rating must be sent to the server
// @param needDebugInformation True, if the call debug information must be sent to the server
// @param needLog True, if the call log must be sent to the server
func NewCallStateDiscarded(reason CallDiscardReason, needRating bool, needDebugInformation bool, needLog bool) *CallStateDiscarded {
	callStateDiscardedTemp := CallStateDiscarded{
		tdCommon:             tdCommon{Type: "callStateDiscarded"},
		Reason:               reason,
		NeedRating:           needRating,
		NeedDebugInformation: needDebugInformation,
		NeedLog:              needLog,
	}

	return &callStateDiscardedTemp
}

// UnmarshalJSON unmarshal to json
func (callStateDiscarded *CallStateDiscarded) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		NeedRating           bool `json:"need_rating"`            // True, if the call rating must be sent to the server
		NeedDebugInformation bool `json:"need_debug_information"` // True, if the call debug information must be sent to the server
		NeedLog              bool `json:"need_log"`               // True, if the call log must be sent to the server
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callStateDiscarded.tdCommon = tempObj.tdCommon
	callStateDiscarded.NeedRating = tempObj.NeedRating
	callStateDiscarded.NeedDebugInformation = tempObj.NeedDebugInformation
	callStateDiscarded.NeedLog = tempObj.NeedLog

	fieldReason, _ := unmarshalCallDiscardReason(objMap["reason"])
	callStateDiscarded.Reason = fieldReason

	return nil
}

// GetCallStateEnum return the enum type of this object
func (callStateDiscarded *CallStateDiscarded) GetCallStateEnum() CallStateEnum {
	return CallStateDiscardedType
}

// CallStateError The call has ended with an error
type CallStateError struct {
	tdCommon
	Error *Error `json:"error"` // Error. An error with the code 4005000 will be returned if an outgoing call is missed because of an expired timeout
}

// MessageType return the string telegram-type of CallStateError
func (callStateError *CallStateError) MessageType() string {
	return "callStateError"
}

// NewCallStateError creates a new CallStateError
//
// @param errParam Error. An error with the code 4005000 will be returned if an outgoing call is missed because of an expired timeout
func NewCallStateError(errParam *Error) *CallStateError {
	callStateErrorTemp := CallStateError{
		tdCommon: tdCommon{Type: "callStateError"},
		Error:    errParam,
	}

	return &callStateErrorTemp
}

// UnmarshalJSON unmarshal to json
func (callStateError *CallStateError) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Error *Error `json:"error"` // Error. An error with the code 4005000 will be returned if an outgoing call is missed because of an expired timeout
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callStateError.tdCommon = tempObj.tdCommon
	callStateError.Error = tempObj.Error

	return nil
}

// GetCallStateEnum return the enum type of this object
func (callStateError *CallStateError) GetCallStateEnum() CallStateEnum {
	return CallStateErrorType
}

// GroupCallVideoQualityThumbnail The worst available video quality
type GroupCallVideoQualityThumbnail struct {
	tdCommon
}

// MessageType return the string telegram-type of GroupCallVideoQualityThumbnail
func (groupCallVideoQualityThumbnail *GroupCallVideoQualityThumbnail) MessageType() string {
	return "groupCallVideoQualityThumbnail"
}

// NewGroupCallVideoQualityThumbnail creates a new GroupCallVideoQualityThumbnail
//
func NewGroupCallVideoQualityThumbnail() *GroupCallVideoQualityThumbnail {
	groupCallVideoQualityThumbnailTemp := GroupCallVideoQualityThumbnail{
		tdCommon: tdCommon{Type: "groupCallVideoQualityThumbnail"},
	}

	return &groupCallVideoQualityThumbnailTemp
}

// UnmarshalJSON unmarshal to json
func (groupCallVideoQualityThumbnail *GroupCallVideoQualityThumbnail) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	groupCallVideoQualityThumbnail.tdCommon = tempObj.tdCommon

	return nil
}

// GetGroupCallVideoQualityEnum return the enum type of this object
func (groupCallVideoQualityThumbnail *GroupCallVideoQualityThumbnail) GetGroupCallVideoQualityEnum() GroupCallVideoQualityEnum {
	return GroupCallVideoQualityThumbnailType
}

// GroupCallVideoQualityMedium The medium video quality
type GroupCallVideoQualityMedium struct {
	tdCommon
}

// MessageType return the string telegram-type of GroupCallVideoQualityMedium
func (groupCallVideoQualityMedium *GroupCallVideoQualityMedium) MessageType() string {
	return "groupCallVideoQualityMedium"
}

// NewGroupCallVideoQualityMedium creates a new GroupCallVideoQualityMedium
//
func NewGroupCallVideoQualityMedium() *GroupCallVideoQualityMedium {
	groupCallVideoQualityMediumTemp := GroupCallVideoQualityMedium{
		tdCommon: tdCommon{Type: "groupCallVideoQualityMedium"},
	}

	return &groupCallVideoQualityMediumTemp
}

// UnmarshalJSON unmarshal to json
func (groupCallVideoQualityMedium *GroupCallVideoQualityMedium) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	groupCallVideoQualityMedium.tdCommon = tempObj.tdCommon

	return nil
}

// GetGroupCallVideoQualityEnum return the enum type of this object
func (groupCallVideoQualityMedium *GroupCallVideoQualityMedium) GetGroupCallVideoQualityEnum() GroupCallVideoQualityEnum {
	return GroupCallVideoQualityMediumType
}

// GroupCallVideoQualityFull The best available video quality
type GroupCallVideoQualityFull struct {
	tdCommon
}

// MessageType return the string telegram-type of GroupCallVideoQualityFull
func (groupCallVideoQualityFull *GroupCallVideoQualityFull) MessageType() string {
	return "groupCallVideoQualityFull"
}

// NewGroupCallVideoQualityFull creates a new GroupCallVideoQualityFull
//
func NewGroupCallVideoQualityFull() *GroupCallVideoQualityFull {
	groupCallVideoQualityFullTemp := GroupCallVideoQualityFull{
		tdCommon: tdCommon{Type: "groupCallVideoQualityFull"},
	}

	return &groupCallVideoQualityFullTemp
}

// UnmarshalJSON unmarshal to json
func (groupCallVideoQualityFull *GroupCallVideoQualityFull) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	groupCallVideoQualityFull.tdCommon = tempObj.tdCommon

	return nil
}

// GetGroupCallVideoQualityEnum return the enum type of this object
func (groupCallVideoQualityFull *GroupCallVideoQualityFull) GetGroupCallVideoQualityEnum() GroupCallVideoQualityEnum {
	return GroupCallVideoQualityFullType
}

// GroupCallStream Describes an available stream in a group call
type GroupCallStream struct {
	tdCommon
	ChannelID  int32 `json:"channel_id"`  // Identifier of an audio/video channel
	Scale      int32 `json:"scale"`       // Scale of segment durations in the stream. The duration is 1000/(2**scale) milliseconds
	TimeOffset int64 `json:"time_offset"` // Point in time when the stream currently ends; Unix timestamp in milliseconds
}

// MessageType return the string telegram-type of GroupCallStream
func (groupCallStream *GroupCallStream) MessageType() string {
	return "groupCallStream"
}

// NewGroupCallStream creates a new GroupCallStream
//
// @param channelID Identifier of an audio/video channel
// @param scale Scale of segment durations in the stream. The duration is 1000/(2**scale) milliseconds
// @param timeOffset Point in time when the stream currently ends; Unix timestamp in milliseconds
func NewGroupCallStream(channelID int32, scale int32, timeOffset int64) *GroupCallStream {
	groupCallStreamTemp := GroupCallStream{
		tdCommon:   tdCommon{Type: "groupCallStream"},
		ChannelID:  channelID,
		Scale:      scale,
		TimeOffset: timeOffset,
	}

	return &groupCallStreamTemp
}

// UnmarshalJSON unmarshal to json
func (groupCallStream *GroupCallStream) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChannelID  int32 `json:"channel_id"`  // Identifier of an audio/video channel
		Scale      int32 `json:"scale"`       // Scale of segment durations in the stream. The duration is 1000/(2**scale) milliseconds
		TimeOffset int64 `json:"time_offset"` // Point in time when the stream currently ends; Unix timestamp in milliseconds
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	groupCallStream.tdCommon = tempObj.tdCommon
	groupCallStream.ChannelID = tempObj.ChannelID
	groupCallStream.Scale = tempObj.Scale
	groupCallStream.TimeOffset = tempObj.TimeOffset

	return nil
}

// GroupCallStreams Represents a list of group call streams
type GroupCallStreams struct {
	tdCommon
	Streams []GroupCallStream `json:"streams"` // A list of group call streams
}

// MessageType return the string telegram-type of GroupCallStreams
func (groupCallStreams *GroupCallStreams) MessageType() string {
	return "groupCallStreams"
}

// NewGroupCallStreams creates a new GroupCallStreams
//
// @param streams A list of group call streams
func NewGroupCallStreams(streams []GroupCallStream) *GroupCallStreams {
	groupCallStreamsTemp := GroupCallStreams{
		tdCommon: tdCommon{Type: "groupCallStreams"},
		Streams:  streams,
	}

	return &groupCallStreamsTemp
}

// UnmarshalJSON unmarshal to json
func (groupCallStreams *GroupCallStreams) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Streams []GroupCallStream `json:"streams"` // A list of group call streams
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	groupCallStreams.tdCommon = tempObj.tdCommon
	groupCallStreams.Streams = tempObj.Streams

	return nil
}

// RtmpURL Represents an RTMP URL
type RtmpURL struct {
	tdCommon
	URL       string `json:"url"`        // The URL
	StreamKey string `json:"stream_key"` // Stream key
}

// MessageType return the string telegram-type of RtmpURL
func (rtmpURL *RtmpURL) MessageType() string {
	return "rtmpUrl"
}

// NewRtmpURL creates a new RtmpURL
//
// @param uRL The URL
// @param streamKey Stream key
func NewRtmpURL(uRL string, streamKey string) *RtmpURL {
	rtmpURLTemp := RtmpURL{
		tdCommon:  tdCommon{Type: "rtmpUrl"},
		URL:       uRL,
		StreamKey: streamKey,
	}

	return &rtmpURLTemp
}

// UnmarshalJSON unmarshal to json
func (rtmpURL *RtmpURL) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL       string `json:"url"`        // The URL
		StreamKey string `json:"stream_key"` // Stream key
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	rtmpURL.tdCommon = tempObj.tdCommon
	rtmpURL.URL = tempObj.URL
	rtmpURL.StreamKey = tempObj.StreamKey

	return nil
}

// GroupCallRecentSpeaker Describes a recently speaking participant in a group call
type GroupCallRecentSpeaker struct {
	tdCommon
	ParticipantID MessageSender `json:"participant_id"` // Group call participant identifier
	IsSpeaking    bool          `json:"is_speaking"`    // True, is the user has spoken recently
}

// MessageType return the string telegram-type of GroupCallRecentSpeaker
func (groupCallRecentSpeaker *GroupCallRecentSpeaker) MessageType() string {
	return "groupCallRecentSpeaker"
}

// NewGroupCallRecentSpeaker creates a new GroupCallRecentSpeaker
//
// @param participantID Group call participant identifier
// @param isSpeaking True, is the user has spoken recently
func NewGroupCallRecentSpeaker(participantID MessageSender, isSpeaking bool) *GroupCallRecentSpeaker {
	groupCallRecentSpeakerTemp := GroupCallRecentSpeaker{
		tdCommon:      tdCommon{Type: "groupCallRecentSpeaker"},
		ParticipantID: participantID,
		IsSpeaking:    isSpeaking,
	}

	return &groupCallRecentSpeakerTemp
}

// UnmarshalJSON unmarshal to json
func (groupCallRecentSpeaker *GroupCallRecentSpeaker) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsSpeaking bool `json:"is_speaking"` // True, is the user has spoken recently
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	groupCallRecentSpeaker.tdCommon = tempObj.tdCommon
	groupCallRecentSpeaker.IsSpeaking = tempObj.IsSpeaking

	fieldParticipantID, _ := unmarshalMessageSender(objMap["participant_id"])
	groupCallRecentSpeaker.ParticipantID = fieldParticipantID

	return nil
}

// GroupCall Describes a group call
type GroupCall struct {
	tdCommon
	ID                           int32                    `json:"id"`                               // Group call identifier
	Title                        string                   `json:"title"`                            // Group call title
	ScheduledStartDate           int32                    `json:"scheduled_start_date"`             // Point in time (Unix timestamp) when the group call is supposed to be started by an administrator; 0 if it is already active or was ended
	EnabledStartNotification     bool                     `json:"enabled_start_notification"`       // True, if the group call is scheduled and the current user will receive a notification when the group call starts
	IsActive                     bool                     `json:"is_active"`                        // True, if the call is active
	IsRtmpStream                 bool                     `json:"is_rtmp_stream"`                   // True, if the chat is an RTMP stream instead of an ordinary video chat
	IsJoined                     bool                     `json:"is_joined"`                        // True, if the call is joined
	NeedRejoin                   bool                     `json:"need_rejoin"`                      // True, if user was kicked from the call because of network loss and the call needs to be rejoined
	CanBeManaged                 bool                     `json:"can_be_managed"`                   // True, if the current user can manage the group call
	ParticipantCount             int32                    `json:"participant_count"`                // Number of participants in the group call
	HasHiddenListeners           bool                     `json:"has_hidden_listeners"`             // True, if group call participants, which are muted, aren't returned in participant list
	LoadedAllParticipants        bool                     `json:"loaded_all_participants"`          // True, if all group call participants are loaded
	RecentSpeakers               []GroupCallRecentSpeaker `json:"recent_speakers"`                  // At most 3 recently speaking users in the group call
	IsMyVideoEnabled             bool                     `json:"is_my_video_enabled"`              // True, if the current user's video is enabled
	IsMyVideoPaused              bool                     `json:"is_my_video_paused"`               // True, if the current user's video is paused
	CanEnableVideo               bool                     `json:"can_enable_video"`                 // True, if the current user can broadcast video or share screen
	MuteNewParticipants          bool                     `json:"mute_new_participants"`            // True, if only group call administrators can unmute new participants
	CanToggleMuteNewParticipants bool                     `json:"can_toggle_mute_new_participants"` // True, if the current user can enable or disable mute_new_participants setting
	RecordDuration               int32                    `json:"record_duration"`                  // Duration of the ongoing group call recording, in seconds; 0 if none. An updateGroupCall update is not triggered when value of this field changes, but the same recording goes on
	IsVideoRecorded              bool                     `json:"is_video_recorded"`                // True, if a video file is being recorded for the call
	Duration                     int32                    `json:"duration"`                         // Call duration, in seconds; for ended calls only
}

// MessageType return the string telegram-type of GroupCall
func (groupCall *GroupCall) MessageType() string {
	return "groupCall"
}

// NewGroupCall creates a new GroupCall
//
// @param iD Group call identifier
// @param title Group call title
// @param scheduledStartDate Point in time (Unix timestamp) when the group call is supposed to be started by an administrator; 0 if it is already active or was ended
// @param enabledStartNotification True, if the group call is scheduled and the current user will receive a notification when the group call starts
// @param isActive True, if the call is active
// @param isRtmpStream True, if the chat is an RTMP stream instead of an ordinary video chat
// @param isJoined True, if the call is joined
// @param needRejoin True, if user was kicked from the call because of network loss and the call needs to be rejoined
// @param canBeManaged True, if the current user can manage the group call
// @param participantCount Number of participants in the group call
// @param hasHiddenListeners True, if group call participants, which are muted, aren't returned in participant list
// @param loadedAllParticipants True, if all group call participants are loaded
// @param recentSpeakers At most 3 recently speaking users in the group call
// @param isMyVideoEnabled True, if the current user's video is enabled
// @param isMyVideoPaused True, if the current user's video is paused
// @param canEnableVideo True, if the current user can broadcast video or share screen
// @param muteNewParticipants True, if only group call administrators can unmute new participants
// @param canToggleMuteNewParticipants True, if the current user can enable or disable mute_new_participants setting
// @param recordDuration Duration of the ongoing group call recording, in seconds; 0 if none. An updateGroupCall update is not triggered when value of this field changes, but the same recording goes on
// @param isVideoRecorded True, if a video file is being recorded for the call
// @param duration Call duration, in seconds; for ended calls only
func NewGroupCall(iD int32, title string, scheduledStartDate int32, enabledStartNotification bool, isActive bool, isRtmpStream bool, isJoined bool, needRejoin bool, canBeManaged bool, participantCount int32, hasHiddenListeners bool, loadedAllParticipants bool, recentSpeakers []GroupCallRecentSpeaker, isMyVideoEnabled bool, isMyVideoPaused bool, canEnableVideo bool, muteNewParticipants bool, canToggleMuteNewParticipants bool, recordDuration int32, isVideoRecorded bool, duration int32) *GroupCall {
	groupCallTemp := GroupCall{
		tdCommon:                     tdCommon{Type: "groupCall"},
		ID:                           iD,
		Title:                        title,
		ScheduledStartDate:           scheduledStartDate,
		EnabledStartNotification:     enabledStartNotification,
		IsActive:                     isActive,
		IsRtmpStream:                 isRtmpStream,
		IsJoined:                     isJoined,
		NeedRejoin:                   needRejoin,
		CanBeManaged:                 canBeManaged,
		ParticipantCount:             participantCount,
		HasHiddenListeners:           hasHiddenListeners,
		LoadedAllParticipants:        loadedAllParticipants,
		RecentSpeakers:               recentSpeakers,
		IsMyVideoEnabled:             isMyVideoEnabled,
		IsMyVideoPaused:              isMyVideoPaused,
		CanEnableVideo:               canEnableVideo,
		MuteNewParticipants:          muteNewParticipants,
		CanToggleMuteNewParticipants: canToggleMuteNewParticipants,
		RecordDuration:               recordDuration,
		IsVideoRecorded:              isVideoRecorded,
		Duration:                     duration,
	}

	return &groupCallTemp
}

// UnmarshalJSON unmarshal to json
func (groupCall *GroupCall) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID                           int32                    `json:"id"`                               // Group call identifier
		Title                        string                   `json:"title"`                            // Group call title
		ScheduledStartDate           int32                    `json:"scheduled_start_date"`             // Point in time (Unix timestamp) when the group call is supposed to be started by an administrator; 0 if it is already active or was ended
		EnabledStartNotification     bool                     `json:"enabled_start_notification"`       // True, if the group call is scheduled and the current user will receive a notification when the group call starts
		IsActive                     bool                     `json:"is_active"`                        // True, if the call is active
		IsRtmpStream                 bool                     `json:"is_rtmp_stream"`                   // True, if the chat is an RTMP stream instead of an ordinary video chat
		IsJoined                     bool                     `json:"is_joined"`                        // True, if the call is joined
		NeedRejoin                   bool                     `json:"need_rejoin"`                      // True, if user was kicked from the call because of network loss and the call needs to be rejoined
		CanBeManaged                 bool                     `json:"can_be_managed"`                   // True, if the current user can manage the group call
		ParticipantCount             int32                    `json:"participant_count"`                // Number of participants in the group call
		HasHiddenListeners           bool                     `json:"has_hidden_listeners"`             // True, if group call participants, which are muted, aren't returned in participant list
		LoadedAllParticipants        bool                     `json:"loaded_all_participants"`          // True, if all group call participants are loaded
		RecentSpeakers               []GroupCallRecentSpeaker `json:"recent_speakers"`                  // At most 3 recently speaking users in the group call
		IsMyVideoEnabled             bool                     `json:"is_my_video_enabled"`              // True, if the current user's video is enabled
		IsMyVideoPaused              bool                     `json:"is_my_video_paused"`               // True, if the current user's video is paused
		CanEnableVideo               bool                     `json:"can_enable_video"`                 // True, if the current user can broadcast video or share screen
		MuteNewParticipants          bool                     `json:"mute_new_participants"`            // True, if only group call administrators can unmute new participants
		CanToggleMuteNewParticipants bool                     `json:"can_toggle_mute_new_participants"` // True, if the current user can enable or disable mute_new_participants setting
		RecordDuration               int32                    `json:"record_duration"`                  // Duration of the ongoing group call recording, in seconds; 0 if none. An updateGroupCall update is not triggered when value of this field changes, but the same recording goes on
		IsVideoRecorded              bool                     `json:"is_video_recorded"`                // True, if a video file is being recorded for the call
		Duration                     int32                    `json:"duration"`                         // Call duration, in seconds; for ended calls only
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	groupCall.tdCommon = tempObj.tdCommon
	groupCall.ID = tempObj.ID
	groupCall.Title = tempObj.Title
	groupCall.ScheduledStartDate = tempObj.ScheduledStartDate
	groupCall.EnabledStartNotification = tempObj.EnabledStartNotification
	groupCall.IsActive = tempObj.IsActive
	groupCall.IsRtmpStream = tempObj.IsRtmpStream
	groupCall.IsJoined = tempObj.IsJoined
	groupCall.NeedRejoin = tempObj.NeedRejoin
	groupCall.CanBeManaged = tempObj.CanBeManaged
	groupCall.ParticipantCount = tempObj.ParticipantCount
	groupCall.HasHiddenListeners = tempObj.HasHiddenListeners
	groupCall.LoadedAllParticipants = tempObj.LoadedAllParticipants
	groupCall.RecentSpeakers = tempObj.RecentSpeakers
	groupCall.IsMyVideoEnabled = tempObj.IsMyVideoEnabled
	groupCall.IsMyVideoPaused = tempObj.IsMyVideoPaused
	groupCall.CanEnableVideo = tempObj.CanEnableVideo
	groupCall.MuteNewParticipants = tempObj.MuteNewParticipants
	groupCall.CanToggleMuteNewParticipants = tempObj.CanToggleMuteNewParticipants
	groupCall.RecordDuration = tempObj.RecordDuration
	groupCall.IsVideoRecorded = tempObj.IsVideoRecorded
	groupCall.Duration = tempObj.Duration

	return nil
}

// GroupCallVideoSourceGroup Describes a group of video synchronization source identifiers
type GroupCallVideoSourceGroup struct {
	tdCommon
	Semantics string  `json:"semantics"`  // The semantics of sources, one of "SIM" or "FID"
	SourceIDs []int32 `json:"source_ids"` // The list of synchronization source identifiers
}

// MessageType return the string telegram-type of GroupCallVideoSourceGroup
func (groupCallVideoSourceGroup *GroupCallVideoSourceGroup) MessageType() string {
	return "groupCallVideoSourceGroup"
}

// NewGroupCallVideoSourceGroup creates a new GroupCallVideoSourceGroup
//
// @param semantics The semantics of sources, one of "SIM" or "FID"
// @param sourceIDs The list of synchronization source identifiers
func NewGroupCallVideoSourceGroup(semantics string, sourceIDs []int32) *GroupCallVideoSourceGroup {
	groupCallVideoSourceGroupTemp := GroupCallVideoSourceGroup{
		tdCommon:  tdCommon{Type: "groupCallVideoSourceGroup"},
		Semantics: semantics,
		SourceIDs: sourceIDs,
	}

	return &groupCallVideoSourceGroupTemp
}

// UnmarshalJSON unmarshal to json
func (groupCallVideoSourceGroup *GroupCallVideoSourceGroup) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Semantics string  `json:"semantics"`  // The semantics of sources, one of "SIM" or "FID"
		SourceIDs []int32 `json:"source_ids"` // The list of synchronization source identifiers
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	groupCallVideoSourceGroup.tdCommon = tempObj.tdCommon
	groupCallVideoSourceGroup.Semantics = tempObj.Semantics
	groupCallVideoSourceGroup.SourceIDs = tempObj.SourceIDs

	return nil
}

// GroupCallParticipantVideoInfo Contains information about a group call participant's video channel
type GroupCallParticipantVideoInfo struct {
	tdCommon
	SourceGroups []GroupCallVideoSourceGroup `json:"source_groups"` // List of synchronization source groups of the video
	EndpointID   string                      `json:"endpoint_id"`   // Video channel endpoint identifier
	IsPaused     bool                        `json:"is_paused"`     // True, if the video is paused. This flag needs to be ignored, if new video frames are received
}

// MessageType return the string telegram-type of GroupCallParticipantVideoInfo
func (groupCallParticipantVideoInfo *GroupCallParticipantVideoInfo) MessageType() string {
	return "groupCallParticipantVideoInfo"
}

// NewGroupCallParticipantVideoInfo creates a new GroupCallParticipantVideoInfo
//
// @param sourceGroups List of synchronization source groups of the video
// @param endpointID Video channel endpoint identifier
// @param isPaused True, if the video is paused. This flag needs to be ignored, if new video frames are received
func NewGroupCallParticipantVideoInfo(sourceGroups []GroupCallVideoSourceGroup, endpointID string, isPaused bool) *GroupCallParticipantVideoInfo {
	groupCallParticipantVideoInfoTemp := GroupCallParticipantVideoInfo{
		tdCommon:     tdCommon{Type: "groupCallParticipantVideoInfo"},
		SourceGroups: sourceGroups,
		EndpointID:   endpointID,
		IsPaused:     isPaused,
	}

	return &groupCallParticipantVideoInfoTemp
}

// UnmarshalJSON unmarshal to json
func (groupCallParticipantVideoInfo *GroupCallParticipantVideoInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SourceGroups []GroupCallVideoSourceGroup `json:"source_groups"` // List of synchronization source groups of the video
		EndpointID   string                      `json:"endpoint_id"`   // Video channel endpoint identifier
		IsPaused     bool                        `json:"is_paused"`     // True, if the video is paused. This flag needs to be ignored, if new video frames are received
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	groupCallParticipantVideoInfo.tdCommon = tempObj.tdCommon
	groupCallParticipantVideoInfo.SourceGroups = tempObj.SourceGroups
	groupCallParticipantVideoInfo.EndpointID = tempObj.EndpointID
	groupCallParticipantVideoInfo.IsPaused = tempObj.IsPaused

	return nil
}

// GroupCallParticipant Represents a group call participant
type GroupCallParticipant struct {
	tdCommon
	ParticipantID              MessageSender                  `json:"participant_id"`                  // Identifier of the group call participant
	AudioSourceID              int32                          `json:"audio_source_id"`                 // User's audio channel synchronization source identifier
	ScreenSharingAudioSourceID int32                          `json:"screen_sharing_audio_source_id"`  // User's screen sharing audio channel synchronization source identifier
	VideoInfo                  *GroupCallParticipantVideoInfo `json:"video_info"`                      // Information about user's video channel; may be null if there is no active video
	ScreenSharingVideoInfo     *GroupCallParticipantVideoInfo `json:"screen_sharing_video_info"`       // Information about user's screen sharing video channel; may be null if there is no active screen sharing video
	Bio                        string                         `json:"bio"`                             // The participant user's bio or the participant chat's description
	IsCurrentUser              bool                           `json:"is_current_user"`                 // True, if the participant is the current user
	IsSpeaking                 bool                           `json:"is_speaking"`                     // True, if the participant is speaking as set by setGroupCallParticipantIsSpeaking
	IsHandRaised               bool                           `json:"is_hand_raised"`                  // True, if the participant hand is raised
	CanBeMutedForAllUsers      bool                           `json:"can_be_muted_for_all_users"`      // True, if the current user can mute the participant for all other group call participants
	CanBeUnmutedForAllUsers    bool                           `json:"can_be_unmuted_for_all_users"`    // True, if the current user can allow the participant to unmute themselves or unmute the participant (if the participant is the current user)
	CanBeMutedForCurrentUser   bool                           `json:"can_be_muted_for_current_user"`   // True, if the current user can mute the participant only for self
	CanBeUnmutedForCurrentUser bool                           `json:"can_be_unmuted_for_current_user"` // True, if the current user can unmute the participant for self
	IsMutedForAllUsers         bool                           `json:"is_muted_for_all_users"`          // True, if the participant is muted for all users
	IsMutedForCurrentUser      bool                           `json:"is_muted_for_current_user"`       // True, if the participant is muted for the current user
	CanUnmuteSelf              bool                           `json:"can_unmute_self"`                 // True, if the participant is muted for all users, but can unmute themselves
	VolumeLevel                int32                          `json:"volume_level"`                    // Participant's volume level; 1-20000 in hundreds of percents
	Order                      string                         `json:"order"`                           // User's order in the group call participant list. Orders must be compared lexicographically. The bigger is order, the higher is user in the list. If order is empty, the user must be removed from the participant list
}

// MessageType return the string telegram-type of GroupCallParticipant
func (groupCallParticipant *GroupCallParticipant) MessageType() string {
	return "groupCallParticipant"
}

// NewGroupCallParticipant creates a new GroupCallParticipant
//
// @param participantID Identifier of the group call participant
// @param audioSourceID User's audio channel synchronization source identifier
// @param screenSharingAudioSourceID User's screen sharing audio channel synchronization source identifier
// @param videoInfo Information about user's video channel; may be null if there is no active video
// @param screenSharingVideoInfo Information about user's screen sharing video channel; may be null if there is no active screen sharing video
// @param bio The participant user's bio or the participant chat's description
// @param isCurrentUser True, if the participant is the current user
// @param isSpeaking True, if the participant is speaking as set by setGroupCallParticipantIsSpeaking
// @param isHandRaised True, if the participant hand is raised
// @param canBeMutedForAllUsers True, if the current user can mute the participant for all other group call participants
// @param canBeUnmutedForAllUsers True, if the current user can allow the participant to unmute themselves or unmute the participant (if the participant is the current user)
// @param canBeMutedForCurrentUser True, if the current user can mute the participant only for self
// @param canBeUnmutedForCurrentUser True, if the current user can unmute the participant for self
// @param isMutedForAllUsers True, if the participant is muted for all users
// @param isMutedForCurrentUser True, if the participant is muted for the current user
// @param canUnmuteSelf True, if the participant is muted for all users, but can unmute themselves
// @param volumeLevel Participant's volume level; 1-20000 in hundreds of percents
// @param order User's order in the group call participant list. Orders must be compared lexicographically. The bigger is order, the higher is user in the list. If order is empty, the user must be removed from the participant list
func NewGroupCallParticipant(participantID MessageSender, audioSourceID int32, screenSharingAudioSourceID int32, videoInfo *GroupCallParticipantVideoInfo, screenSharingVideoInfo *GroupCallParticipantVideoInfo, bio string, isCurrentUser bool, isSpeaking bool, isHandRaised bool, canBeMutedForAllUsers bool, canBeUnmutedForAllUsers bool, canBeMutedForCurrentUser bool, canBeUnmutedForCurrentUser bool, isMutedForAllUsers bool, isMutedForCurrentUser bool, canUnmuteSelf bool, volumeLevel int32, order string) *GroupCallParticipant {
	groupCallParticipantTemp := GroupCallParticipant{
		tdCommon:                   tdCommon{Type: "groupCallParticipant"},
		ParticipantID:              participantID,
		AudioSourceID:              audioSourceID,
		ScreenSharingAudioSourceID: screenSharingAudioSourceID,
		VideoInfo:                  videoInfo,
		ScreenSharingVideoInfo:     screenSharingVideoInfo,
		Bio:                        bio,
		IsCurrentUser:              isCurrentUser,
		IsSpeaking:                 isSpeaking,
		IsHandRaised:               isHandRaised,
		CanBeMutedForAllUsers:      canBeMutedForAllUsers,
		CanBeUnmutedForAllUsers:    canBeUnmutedForAllUsers,
		CanBeMutedForCurrentUser:   canBeMutedForCurrentUser,
		CanBeUnmutedForCurrentUser: canBeUnmutedForCurrentUser,
		IsMutedForAllUsers:         isMutedForAllUsers,
		IsMutedForCurrentUser:      isMutedForCurrentUser,
		CanUnmuteSelf:              canUnmuteSelf,
		VolumeLevel:                volumeLevel,
		Order:                      order,
	}

	return &groupCallParticipantTemp
}

// UnmarshalJSON unmarshal to json
func (groupCallParticipant *GroupCallParticipant) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		AudioSourceID              int32                          `json:"audio_source_id"`                 // User's audio channel synchronization source identifier
		ScreenSharingAudioSourceID int32                          `json:"screen_sharing_audio_source_id"`  // User's screen sharing audio channel synchronization source identifier
		VideoInfo                  *GroupCallParticipantVideoInfo `json:"video_info"`                      // Information about user's video channel; may be null if there is no active video
		ScreenSharingVideoInfo     *GroupCallParticipantVideoInfo `json:"screen_sharing_video_info"`       // Information about user's screen sharing video channel; may be null if there is no active screen sharing video
		Bio                        string                         `json:"bio"`                             // The participant user's bio or the participant chat's description
		IsCurrentUser              bool                           `json:"is_current_user"`                 // True, if the participant is the current user
		IsSpeaking                 bool                           `json:"is_speaking"`                     // True, if the participant is speaking as set by setGroupCallParticipantIsSpeaking
		IsHandRaised               bool                           `json:"is_hand_raised"`                  // True, if the participant hand is raised
		CanBeMutedForAllUsers      bool                           `json:"can_be_muted_for_all_users"`      // True, if the current user can mute the participant for all other group call participants
		CanBeUnmutedForAllUsers    bool                           `json:"can_be_unmuted_for_all_users"`    // True, if the current user can allow the participant to unmute themselves or unmute the participant (if the participant is the current user)
		CanBeMutedForCurrentUser   bool                           `json:"can_be_muted_for_current_user"`   // True, if the current user can mute the participant only for self
		CanBeUnmutedForCurrentUser bool                           `json:"can_be_unmuted_for_current_user"` // True, if the current user can unmute the participant for self
		IsMutedForAllUsers         bool                           `json:"is_muted_for_all_users"`          // True, if the participant is muted for all users
		IsMutedForCurrentUser      bool                           `json:"is_muted_for_current_user"`       // True, if the participant is muted for the current user
		CanUnmuteSelf              bool                           `json:"can_unmute_self"`                 // True, if the participant is muted for all users, but can unmute themselves
		VolumeLevel                int32                          `json:"volume_level"`                    // Participant's volume level; 1-20000 in hundreds of percents
		Order                      string                         `json:"order"`                           // User's order in the group call participant list. Orders must be compared lexicographically. The bigger is order, the higher is user in the list. If order is empty, the user must be removed from the participant list
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	groupCallParticipant.tdCommon = tempObj.tdCommon
	groupCallParticipant.AudioSourceID = tempObj.AudioSourceID
	groupCallParticipant.ScreenSharingAudioSourceID = tempObj.ScreenSharingAudioSourceID
	groupCallParticipant.VideoInfo = tempObj.VideoInfo
	groupCallParticipant.ScreenSharingVideoInfo = tempObj.ScreenSharingVideoInfo
	groupCallParticipant.Bio = tempObj.Bio
	groupCallParticipant.IsCurrentUser = tempObj.IsCurrentUser
	groupCallParticipant.IsSpeaking = tempObj.IsSpeaking
	groupCallParticipant.IsHandRaised = tempObj.IsHandRaised
	groupCallParticipant.CanBeMutedForAllUsers = tempObj.CanBeMutedForAllUsers
	groupCallParticipant.CanBeUnmutedForAllUsers = tempObj.CanBeUnmutedForAllUsers
	groupCallParticipant.CanBeMutedForCurrentUser = tempObj.CanBeMutedForCurrentUser
	groupCallParticipant.CanBeUnmutedForCurrentUser = tempObj.CanBeUnmutedForCurrentUser
	groupCallParticipant.IsMutedForAllUsers = tempObj.IsMutedForAllUsers
	groupCallParticipant.IsMutedForCurrentUser = tempObj.IsMutedForCurrentUser
	groupCallParticipant.CanUnmuteSelf = tempObj.CanUnmuteSelf
	groupCallParticipant.VolumeLevel = tempObj.VolumeLevel
	groupCallParticipant.Order = tempObj.Order

	fieldParticipantID, _ := unmarshalMessageSender(objMap["participant_id"])
	groupCallParticipant.ParticipantID = fieldParticipantID

	return nil
}

// CallProblemEcho The user heard their own voice
type CallProblemEcho struct {
	tdCommon
}

// MessageType return the string telegram-type of CallProblemEcho
func (callProblemEcho *CallProblemEcho) MessageType() string {
	return "callProblemEcho"
}

// NewCallProblemEcho creates a new CallProblemEcho
//
func NewCallProblemEcho() *CallProblemEcho {
	callProblemEchoTemp := CallProblemEcho{
		tdCommon: tdCommon{Type: "callProblemEcho"},
	}

	return &callProblemEchoTemp
}

// UnmarshalJSON unmarshal to json
func (callProblemEcho *CallProblemEcho) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callProblemEcho.tdCommon = tempObj.tdCommon

	return nil
}

// GetCallProblemEnum return the enum type of this object
func (callProblemEcho *CallProblemEcho) GetCallProblemEnum() CallProblemEnum {
	return CallProblemEchoType
}

// CallProblemNoise The user heard background noise
type CallProblemNoise struct {
	tdCommon
}

// MessageType return the string telegram-type of CallProblemNoise
func (callProblemNoise *CallProblemNoise) MessageType() string {
	return "callProblemNoise"
}

// NewCallProblemNoise creates a new CallProblemNoise
//
func NewCallProblemNoise() *CallProblemNoise {
	callProblemNoiseTemp := CallProblemNoise{
		tdCommon: tdCommon{Type: "callProblemNoise"},
	}

	return &callProblemNoiseTemp
}

// UnmarshalJSON unmarshal to json
func (callProblemNoise *CallProblemNoise) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callProblemNoise.tdCommon = tempObj.tdCommon

	return nil
}

// GetCallProblemEnum return the enum type of this object
func (callProblemNoise *CallProblemNoise) GetCallProblemEnum() CallProblemEnum {
	return CallProblemNoiseType
}

// CallProblemInterruptions The other side kept disappearing
type CallProblemInterruptions struct {
	tdCommon
}

// MessageType return the string telegram-type of CallProblemInterruptions
func (callProblemInterruptions *CallProblemInterruptions) MessageType() string {
	return "callProblemInterruptions"
}

// NewCallProblemInterruptions creates a new CallProblemInterruptions
//
func NewCallProblemInterruptions() *CallProblemInterruptions {
	callProblemInterruptionsTemp := CallProblemInterruptions{
		tdCommon: tdCommon{Type: "callProblemInterruptions"},
	}

	return &callProblemInterruptionsTemp
}

// UnmarshalJSON unmarshal to json
func (callProblemInterruptions *CallProblemInterruptions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callProblemInterruptions.tdCommon = tempObj.tdCommon

	return nil
}

// GetCallProblemEnum return the enum type of this object
func (callProblemInterruptions *CallProblemInterruptions) GetCallProblemEnum() CallProblemEnum {
	return CallProblemInterruptionsType
}

// CallProblemDistortedSpeech The speech was distorted
type CallProblemDistortedSpeech struct {
	tdCommon
}

// MessageType return the string telegram-type of CallProblemDistortedSpeech
func (callProblemDistortedSpeech *CallProblemDistortedSpeech) MessageType() string {
	return "callProblemDistortedSpeech"
}

// NewCallProblemDistortedSpeech creates a new CallProblemDistortedSpeech
//
func NewCallProblemDistortedSpeech() *CallProblemDistortedSpeech {
	callProblemDistortedSpeechTemp := CallProblemDistortedSpeech{
		tdCommon: tdCommon{Type: "callProblemDistortedSpeech"},
	}

	return &callProblemDistortedSpeechTemp
}

// UnmarshalJSON unmarshal to json
func (callProblemDistortedSpeech *CallProblemDistortedSpeech) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callProblemDistortedSpeech.tdCommon = tempObj.tdCommon

	return nil
}

// GetCallProblemEnum return the enum type of this object
func (callProblemDistortedSpeech *CallProblemDistortedSpeech) GetCallProblemEnum() CallProblemEnum {
	return CallProblemDistortedSpeechType
}

// CallProblemSilentLocal The user couldn't hear the other side
type CallProblemSilentLocal struct {
	tdCommon
}

// MessageType return the string telegram-type of CallProblemSilentLocal
func (callProblemSilentLocal *CallProblemSilentLocal) MessageType() string {
	return "callProblemSilentLocal"
}

// NewCallProblemSilentLocal creates a new CallProblemSilentLocal
//
func NewCallProblemSilentLocal() *CallProblemSilentLocal {
	callProblemSilentLocalTemp := CallProblemSilentLocal{
		tdCommon: tdCommon{Type: "callProblemSilentLocal"},
	}

	return &callProblemSilentLocalTemp
}

// UnmarshalJSON unmarshal to json
func (callProblemSilentLocal *CallProblemSilentLocal) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callProblemSilentLocal.tdCommon = tempObj.tdCommon

	return nil
}

// GetCallProblemEnum return the enum type of this object
func (callProblemSilentLocal *CallProblemSilentLocal) GetCallProblemEnum() CallProblemEnum {
	return CallProblemSilentLocalType
}

// CallProblemSilentRemote The other side couldn't hear the user
type CallProblemSilentRemote struct {
	tdCommon
}

// MessageType return the string telegram-type of CallProblemSilentRemote
func (callProblemSilentRemote *CallProblemSilentRemote) MessageType() string {
	return "callProblemSilentRemote"
}

// NewCallProblemSilentRemote creates a new CallProblemSilentRemote
//
func NewCallProblemSilentRemote() *CallProblemSilentRemote {
	callProblemSilentRemoteTemp := CallProblemSilentRemote{
		tdCommon: tdCommon{Type: "callProblemSilentRemote"},
	}

	return &callProblemSilentRemoteTemp
}

// UnmarshalJSON unmarshal to json
func (callProblemSilentRemote *CallProblemSilentRemote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callProblemSilentRemote.tdCommon = tempObj.tdCommon

	return nil
}

// GetCallProblemEnum return the enum type of this object
func (callProblemSilentRemote *CallProblemSilentRemote) GetCallProblemEnum() CallProblemEnum {
	return CallProblemSilentRemoteType
}

// CallProblemDropped The call ended unexpectedly
type CallProblemDropped struct {
	tdCommon
}

// MessageType return the string telegram-type of CallProblemDropped
func (callProblemDropped *CallProblemDropped) MessageType() string {
	return "callProblemDropped"
}

// NewCallProblemDropped creates a new CallProblemDropped
//
func NewCallProblemDropped() *CallProblemDropped {
	callProblemDroppedTemp := CallProblemDropped{
		tdCommon: tdCommon{Type: "callProblemDropped"},
	}

	return &callProblemDroppedTemp
}

// UnmarshalJSON unmarshal to json
func (callProblemDropped *CallProblemDropped) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callProblemDropped.tdCommon = tempObj.tdCommon

	return nil
}

// GetCallProblemEnum return the enum type of this object
func (callProblemDropped *CallProblemDropped) GetCallProblemEnum() CallProblemEnum {
	return CallProblemDroppedType
}

// CallProblemDistortedVideo The video was distorted
type CallProblemDistortedVideo struct {
	tdCommon
}

// MessageType return the string telegram-type of CallProblemDistortedVideo
func (callProblemDistortedVideo *CallProblemDistortedVideo) MessageType() string {
	return "callProblemDistortedVideo"
}

// NewCallProblemDistortedVideo creates a new CallProblemDistortedVideo
//
func NewCallProblemDistortedVideo() *CallProblemDistortedVideo {
	callProblemDistortedVideoTemp := CallProblemDistortedVideo{
		tdCommon: tdCommon{Type: "callProblemDistortedVideo"},
	}

	return &callProblemDistortedVideoTemp
}

// UnmarshalJSON unmarshal to json
func (callProblemDistortedVideo *CallProblemDistortedVideo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callProblemDistortedVideo.tdCommon = tempObj.tdCommon

	return nil
}

// GetCallProblemEnum return the enum type of this object
func (callProblemDistortedVideo *CallProblemDistortedVideo) GetCallProblemEnum() CallProblemEnum {
	return CallProblemDistortedVideoType
}

// CallProblemPixelatedVideo The video was pixelated
type CallProblemPixelatedVideo struct {
	tdCommon
}

// MessageType return the string telegram-type of CallProblemPixelatedVideo
func (callProblemPixelatedVideo *CallProblemPixelatedVideo) MessageType() string {
	return "callProblemPixelatedVideo"
}

// NewCallProblemPixelatedVideo creates a new CallProblemPixelatedVideo
//
func NewCallProblemPixelatedVideo() *CallProblemPixelatedVideo {
	callProblemPixelatedVideoTemp := CallProblemPixelatedVideo{
		tdCommon: tdCommon{Type: "callProblemPixelatedVideo"},
	}

	return &callProblemPixelatedVideoTemp
}

// UnmarshalJSON unmarshal to json
func (callProblemPixelatedVideo *CallProblemPixelatedVideo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callProblemPixelatedVideo.tdCommon = tempObj.tdCommon

	return nil
}

// GetCallProblemEnum return the enum type of this object
func (callProblemPixelatedVideo *CallProblemPixelatedVideo) GetCallProblemEnum() CallProblemEnum {
	return CallProblemPixelatedVideoType
}

// Call Describes a call
type Call struct {
	tdCommon
	ID         int32     `json:"id"`          // Call identifier, not persistent
	UserID     int64     `json:"user_id"`     // User identifier of the other call participant
	IsOutgoing bool      `json:"is_outgoing"` // True, if the call is outgoing
	IsVideo    bool      `json:"is_video"`    // True, if the call is a video call
	State      CallState `json:"state"`       // Call state
}

// MessageType return the string telegram-type of Call
func (call *Call) MessageType() string {
	return "call"
}

// NewCall creates a new Call
//
// @param iD Call identifier, not persistent
// @param userID User identifier of the other call participant
// @param isOutgoing True, if the call is outgoing
// @param isVideo True, if the call is a video call
// @param state Call state
func NewCall(iD int32, userID int64, isOutgoing bool, isVideo bool, state CallState) *Call {
	callTemp := Call{
		tdCommon:   tdCommon{Type: "call"},
		ID:         iD,
		UserID:     userID,
		IsOutgoing: isOutgoing,
		IsVideo:    isVideo,
		State:      state,
	}

	return &callTemp
}

// UnmarshalJSON unmarshal to json
func (call *Call) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID         int32 `json:"id"`          // Call identifier, not persistent
		UserID     int64 `json:"user_id"`     // User identifier of the other call participant
		IsOutgoing bool  `json:"is_outgoing"` // True, if the call is outgoing
		IsVideo    bool  `json:"is_video"`    // True, if the call is a video call

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	call.tdCommon = tempObj.tdCommon
	call.ID = tempObj.ID
	call.UserID = tempObj.UserID
	call.IsOutgoing = tempObj.IsOutgoing
	call.IsVideo = tempObj.IsVideo

	fieldState, _ := unmarshalCallState(objMap["state"])
	call.State = fieldState

	return nil
}

// FirebaseAuthenticationSettingsAndroid Settings for Firebase Authentication in the official Android application
type FirebaseAuthenticationSettingsAndroid struct {
	tdCommon
}

// MessageType return the string telegram-type of FirebaseAuthenticationSettingsAndroid
func (firebaseAuthenticationSettingsAndroid *FirebaseAuthenticationSettingsAndroid) MessageType() string {
	return "firebaseAuthenticationSettingsAndroid"
}

// NewFirebaseAuthenticationSettingsAndroid creates a new FirebaseAuthenticationSettingsAndroid
//
func NewFirebaseAuthenticationSettingsAndroid() *FirebaseAuthenticationSettingsAndroid {
	firebaseAuthenticationSettingsAndroidTemp := FirebaseAuthenticationSettingsAndroid{
		tdCommon: tdCommon{Type: "firebaseAuthenticationSettingsAndroid"},
	}

	return &firebaseAuthenticationSettingsAndroidTemp
}

// UnmarshalJSON unmarshal to json
func (firebaseAuthenticationSettingsAndroid *FirebaseAuthenticationSettingsAndroid) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	firebaseAuthenticationSettingsAndroid.tdCommon = tempObj.tdCommon

	return nil
}

// GetFirebaseAuthenticationSettingsEnum return the enum type of this object
func (firebaseAuthenticationSettingsAndroid *FirebaseAuthenticationSettingsAndroid) GetFirebaseAuthenticationSettingsEnum() FirebaseAuthenticationSettingsEnum {
	return FirebaseAuthenticationSettingsAndroidType
}

// FirebaseAuthenticationSettingsIos Settings for Firebase Authentication in the official iOS application
type FirebaseAuthenticationSettingsIos struct {
	tdCommon
	DeviceToken  string `json:"device_token"`   // Device token from Apple Push Notification service
	IsAppSandbox bool   `json:"is_app_sandbox"` // True, if App Sandbox is enabled
}

// MessageType return the string telegram-type of FirebaseAuthenticationSettingsIos
func (firebaseAuthenticationSettingsIos *FirebaseAuthenticationSettingsIos) MessageType() string {
	return "firebaseAuthenticationSettingsIos"
}

// NewFirebaseAuthenticationSettingsIos creates a new FirebaseAuthenticationSettingsIos
//
// @param deviceToken Device token from Apple Push Notification service
// @param isAppSandbox True, if App Sandbox is enabled
func NewFirebaseAuthenticationSettingsIos(deviceToken string, isAppSandbox bool) *FirebaseAuthenticationSettingsIos {
	firebaseAuthenticationSettingsIosTemp := FirebaseAuthenticationSettingsIos{
		tdCommon:     tdCommon{Type: "firebaseAuthenticationSettingsIos"},
		DeviceToken:  deviceToken,
		IsAppSandbox: isAppSandbox,
	}

	return &firebaseAuthenticationSettingsIosTemp
}

// UnmarshalJSON unmarshal to json
func (firebaseAuthenticationSettingsIos *FirebaseAuthenticationSettingsIos) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		DeviceToken  string `json:"device_token"`   // Device token from Apple Push Notification service
		IsAppSandbox bool   `json:"is_app_sandbox"` // True, if App Sandbox is enabled
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	firebaseAuthenticationSettingsIos.tdCommon = tempObj.tdCommon
	firebaseAuthenticationSettingsIos.DeviceToken = tempObj.DeviceToken
	firebaseAuthenticationSettingsIos.IsAppSandbox = tempObj.IsAppSandbox

	return nil
}

// GetFirebaseAuthenticationSettingsEnum return the enum type of this object
func (firebaseAuthenticationSettingsIos *FirebaseAuthenticationSettingsIos) GetFirebaseAuthenticationSettingsEnum() FirebaseAuthenticationSettingsEnum {
	return FirebaseAuthenticationSettingsIosType
}

// PhoneNumberAuthenticationSettings Contains settings for the authentication of the user's phone number
type PhoneNumberAuthenticationSettings struct {
	tdCommon
	AllowFlashCall                 bool                           `json:"allow_flash_call"`                 // Pass true if the authentication code may be sent via a flash call to the specified phone number
	AllowMissedCall                bool                           `json:"allow_missed_call"`                // Pass true if the authentication code may be sent via a missed call to the specified phone number
	IsCurrentPhoneNumber           bool                           `json:"is_current_phone_number"`          // Pass true if the authenticated phone number is used on the current device
	HasUnknownPhoneNumber          bool                           `json:"has_unknown_phone_number"`         // Pass true if there is a SIM card in the current device, but it is not possible to check whether phone number matches
	AllowSmsRetrieverAPI           bool                           `json:"allow_sms_retriever_api"`          // For official applications only. True, if the application can use Android SMS Retriever API (requires Google Play Services >= 10.2) to automatically receive the authentication code from the SMS. See https://developers.google.com/identity/sms-retriever/ for more details
	FirebaseAuthenticationSettings FirebaseAuthenticationSettings `json:"firebase_authentication_settings"` // For official Android and iOS applications only; pass null otherwise. Settings for Firebase Authentication
	AuthenticationTokens           []string                       `json:"authentication_tokens"`            // List of up to 20 authentication tokens, recently received in updateOption("authentication_token") in previously logged out sessions
}

// MessageType return the string telegram-type of PhoneNumberAuthenticationSettings
func (phoneNumberAuthenticationSettings *PhoneNumberAuthenticationSettings) MessageType() string {
	return "phoneNumberAuthenticationSettings"
}

// NewPhoneNumberAuthenticationSettings creates a new PhoneNumberAuthenticationSettings
//
// @param allowFlashCall Pass true if the authentication code may be sent via a flash call to the specified phone number
// @param allowMissedCall Pass true if the authentication code may be sent via a missed call to the specified phone number
// @param isCurrentPhoneNumber Pass true if the authenticated phone number is used on the current device
// @param hasUnknownPhoneNumber Pass true if there is a SIM card in the current device, but it is not possible to check whether phone number matches
// @param allowSmsRetrieverAPI For official applications only. True, if the application can use Android SMS Retriever API (requires Google Play Services >= 10.2) to automatically receive the authentication code from the SMS. See https://developers.google.com/identity/sms-retriever/ for more details
// @param firebaseAuthenticationSettings For official Android and iOS applications only; pass null otherwise. Settings for Firebase Authentication
// @param authenticationTokens List of up to 20 authentication tokens, recently received in updateOption("authentication_token") in previously logged out sessions
func NewPhoneNumberAuthenticationSettings(allowFlashCall bool, allowMissedCall bool, isCurrentPhoneNumber bool, hasUnknownPhoneNumber bool, allowSmsRetrieverAPI bool, firebaseAuthenticationSettings FirebaseAuthenticationSettings, authenticationTokens []string) *PhoneNumberAuthenticationSettings {
	phoneNumberAuthenticationSettingsTemp := PhoneNumberAuthenticationSettings{
		tdCommon:                       tdCommon{Type: "phoneNumberAuthenticationSettings"},
		AllowFlashCall:                 allowFlashCall,
		AllowMissedCall:                allowMissedCall,
		IsCurrentPhoneNumber:           isCurrentPhoneNumber,
		HasUnknownPhoneNumber:          hasUnknownPhoneNumber,
		AllowSmsRetrieverAPI:           allowSmsRetrieverAPI,
		FirebaseAuthenticationSettings: firebaseAuthenticationSettings,
		AuthenticationTokens:           authenticationTokens,
	}

	return &phoneNumberAuthenticationSettingsTemp
}

// UnmarshalJSON unmarshal to json
func (phoneNumberAuthenticationSettings *PhoneNumberAuthenticationSettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		AllowFlashCall        bool     `json:"allow_flash_call"`         // Pass true if the authentication code may be sent via a flash call to the specified phone number
		AllowMissedCall       bool     `json:"allow_missed_call"`        // Pass true if the authentication code may be sent via a missed call to the specified phone number
		IsCurrentPhoneNumber  bool     `json:"is_current_phone_number"`  // Pass true if the authenticated phone number is used on the current device
		HasUnknownPhoneNumber bool     `json:"has_unknown_phone_number"` // Pass true if there is a SIM card in the current device, but it is not possible to check whether phone number matches
		AllowSmsRetrieverAPI  bool     `json:"allow_sms_retriever_api"`  // For official applications only. True, if the application can use Android SMS Retriever API (requires Google Play Services >= 10.2) to automatically receive the authentication code from the SMS. See https://developers.google.com/identity/sms-retriever/ for more details
		AuthenticationTokens  []string `json:"authentication_tokens"`    // List of up to 20 authentication tokens, recently received in updateOption("authentication_token") in previously logged out sessions
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	phoneNumberAuthenticationSettings.tdCommon = tempObj.tdCommon
	phoneNumberAuthenticationSettings.AllowFlashCall = tempObj.AllowFlashCall
	phoneNumberAuthenticationSettings.AllowMissedCall = tempObj.AllowMissedCall
	phoneNumberAuthenticationSettings.IsCurrentPhoneNumber = tempObj.IsCurrentPhoneNumber
	phoneNumberAuthenticationSettings.HasUnknownPhoneNumber = tempObj.HasUnknownPhoneNumber
	phoneNumberAuthenticationSettings.AllowSmsRetrieverAPI = tempObj.AllowSmsRetrieverAPI
	phoneNumberAuthenticationSettings.AuthenticationTokens = tempObj.AuthenticationTokens

	fieldFirebaseAuthenticationSettings, _ := unmarshalFirebaseAuthenticationSettings(objMap["firebase_authentication_settings"])
	phoneNumberAuthenticationSettings.FirebaseAuthenticationSettings = fieldFirebaseAuthenticationSettings

	return nil
}

// AddedReaction Represents a reaction applied to a message
type AddedReaction struct {
	tdCommon
	Type       ReactionType  `json:"type"`        // Type of the reaction
	SenderID   MessageSender `json:"sender_id"`   // Identifier of the chat member, applied the reaction
	IsOutgoing bool          `json:"is_outgoing"` // True, if the reaction was added by the current user
	Date       int32         `json:"date"`        // Point in time (Unix timestamp) when the reaction was added
}

// MessageType return the string telegram-type of AddedReaction
func (addedReaction *AddedReaction) MessageType() string {
	return "addedReaction"
}

// NewAddedReaction creates a new AddedReaction
//
// @param typeParam Type of the reaction
// @param senderID Identifier of the chat member, applied the reaction
// @param isOutgoing True, if the reaction was added by the current user
// @param date Point in time (Unix timestamp) when the reaction was added
func NewAddedReaction(typeParam ReactionType, senderID MessageSender, isOutgoing bool, date int32) *AddedReaction {
	addedReactionTemp := AddedReaction{
		tdCommon:   tdCommon{Type: "addedReaction"},
		Type:       typeParam,
		SenderID:   senderID,
		IsOutgoing: isOutgoing,
		Date:       date,
	}

	return &addedReactionTemp
}

// UnmarshalJSON unmarshal to json
func (addedReaction *AddedReaction) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsOutgoing bool  `json:"is_outgoing"` // True, if the reaction was added by the current user
		Date       int32 `json:"date"`        // Point in time (Unix timestamp) when the reaction was added
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	addedReaction.tdCommon = tempObj.tdCommon
	addedReaction.IsOutgoing = tempObj.IsOutgoing
	addedReaction.Date = tempObj.Date

	fieldType, _ := unmarshalReactionType(objMap["type"])
	addedReaction.Type = fieldType

	fieldSenderID, _ := unmarshalMessageSender(objMap["sender_id"])
	addedReaction.SenderID = fieldSenderID

	return nil
}

// AddedReactions Represents a list of reactions added to a message
type AddedReactions struct {
	tdCommon
	TotalCount int32           `json:"total_count"` // The total number of found reactions
	Reactions  []AddedReaction `json:"reactions"`   // The list of added reactions
	NextOffset string          `json:"next_offset"` // The offset for the next request. If empty, then there are no more results
}

// MessageType return the string telegram-type of AddedReactions
func (addedReactions *AddedReactions) MessageType() string {
	return "addedReactions"
}

// NewAddedReactions creates a new AddedReactions
//
// @param totalCount The total number of found reactions
// @param reactions The list of added reactions
// @param nextOffset The offset for the next request. If empty, then there are no more results
func NewAddedReactions(totalCount int32, reactions []AddedReaction, nextOffset string) *AddedReactions {
	addedReactionsTemp := AddedReactions{
		tdCommon:   tdCommon{Type: "addedReactions"},
		TotalCount: totalCount,
		Reactions:  reactions,
		NextOffset: nextOffset,
	}

	return &addedReactionsTemp
}

// UnmarshalJSON unmarshal to json
func (addedReactions *AddedReactions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32           `json:"total_count"` // The total number of found reactions
		Reactions  []AddedReaction `json:"reactions"`   // The list of added reactions
		NextOffset string          `json:"next_offset"` // The offset for the next request. If empty, then there are no more results
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	addedReactions.tdCommon = tempObj.tdCommon
	addedReactions.TotalCount = tempObj.TotalCount
	addedReactions.Reactions = tempObj.Reactions
	addedReactions.NextOffset = tempObj.NextOffset

	return nil
}

// AvailableReaction Represents an available reaction
type AvailableReaction struct {
	tdCommon
	Type         ReactionType `json:"type"`          // Type of the reaction
	NeedsPremium bool         `json:"needs_premium"` // True, if Telegram Premium is needed to send the reaction
}

// MessageType return the string telegram-type of AvailableReaction
func (availableReaction *AvailableReaction) MessageType() string {
	return "availableReaction"
}

// NewAvailableReaction creates a new AvailableReaction
//
// @param typeParam Type of the reaction
// @param needsPremium True, if Telegram Premium is needed to send the reaction
func NewAvailableReaction(typeParam ReactionType, needsPremium bool) *AvailableReaction {
	availableReactionTemp := AvailableReaction{
		tdCommon:     tdCommon{Type: "availableReaction"},
		Type:         typeParam,
		NeedsPremium: needsPremium,
	}

	return &availableReactionTemp
}

// UnmarshalJSON unmarshal to json
func (availableReaction *AvailableReaction) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		NeedsPremium bool `json:"needs_premium"` // True, if Telegram Premium is needed to send the reaction
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	availableReaction.tdCommon = tempObj.tdCommon
	availableReaction.NeedsPremium = tempObj.NeedsPremium

	fieldType, _ := unmarshalReactionType(objMap["type"])
	availableReaction.Type = fieldType

	return nil
}

// AvailableReactions Represents a list of reactions that can be added to a message
type AvailableReactions struct {
	tdCommon
	TopReactions         []AvailableReaction           `json:"top_reactions"`         // List of reactions to be shown at the top
	RecentReactions      []AvailableReaction           `json:"recent_reactions"`      // List of recently used reactions
	PopularReactions     []AvailableReaction           `json:"popular_reactions"`     // List of popular reactions
	AllowCustomEmoji     bool                          `json:"allow_custom_emoji"`    // True, if any custom emoji reaction can be added by Telegram Premium subscribers
	AreTags              bool                          `json:"are_tags"`              // True, if the reactions will be tags and the message can be found by them
	UnavailabilityReason *ReactionUnavailabilityReason `json:"unavailability_reason"` // The reason why the current user can't add reactions to the message, despite some other users can; may be null if none
}

// MessageType return the string telegram-type of AvailableReactions
func (availableReactions *AvailableReactions) MessageType() string {
	return "availableReactions"
}

// NewAvailableReactions creates a new AvailableReactions
//
// @param topReactions List of reactions to be shown at the top
// @param recentReactions List of recently used reactions
// @param popularReactions List of popular reactions
// @param allowCustomEmoji True, if any custom emoji reaction can be added by Telegram Premium subscribers
// @param areTags True, if the reactions will be tags and the message can be found by them
// @param unavailabilityReason The reason why the current user can't add reactions to the message, despite some other users can; may be null if none
func NewAvailableReactions(topReactions []AvailableReaction, recentReactions []AvailableReaction, popularReactions []AvailableReaction, allowCustomEmoji bool, areTags bool, unavailabilityReason *ReactionUnavailabilityReason) *AvailableReactions {
	availableReactionsTemp := AvailableReactions{
		tdCommon:             tdCommon{Type: "availableReactions"},
		TopReactions:         topReactions,
		RecentReactions:      recentReactions,
		PopularReactions:     popularReactions,
		AllowCustomEmoji:     allowCustomEmoji,
		AreTags:              areTags,
		UnavailabilityReason: unavailabilityReason,
	}

	return &availableReactionsTemp
}

// UnmarshalJSON unmarshal to json
func (availableReactions *AvailableReactions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TopReactions     []AvailableReaction `json:"top_reactions"`      // List of reactions to be shown at the top
		RecentReactions  []AvailableReaction `json:"recent_reactions"`   // List of recently used reactions
		PopularReactions []AvailableReaction `json:"popular_reactions"`  // List of popular reactions
		AllowCustomEmoji bool                `json:"allow_custom_emoji"` // True, if any custom emoji reaction can be added by Telegram Premium subscribers
		AreTags          bool                `json:"are_tags"`           // True, if the reactions will be tags and the message can be found by them

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	availableReactions.tdCommon = tempObj.tdCommon
	availableReactions.TopReactions = tempObj.TopReactions
	availableReactions.RecentReactions = tempObj.RecentReactions
	availableReactions.PopularReactions = tempObj.PopularReactions
	availableReactions.AllowCustomEmoji = tempObj.AllowCustomEmoji
	availableReactions.AreTags = tempObj.AreTags

	fieldUnavailabilityReason, _ := unmarshalReactionUnavailabilityReason(objMap["unavailability_reason"])
	availableReactions.UnavailabilityReason = &fieldUnavailabilityReason

	return nil
}

// EmojiReaction Contains information about an emoji reaction
type EmojiReaction struct {
	tdCommon
	Emoji             string   `json:"emoji"`              // Text representation of the reaction
	Title             string   `json:"title"`              // Reaction title
	IsActive          bool     `json:"is_active"`          // True, if the reaction can be added to new messages and enabled in chats
	StaticIcon        *Sticker `json:"static_icon"`        // Static icon for the reaction
	AppearAnimation   *Sticker `json:"appear_animation"`   // Appear animation for the reaction
	SelectAnimation   *Sticker `json:"select_animation"`   // Select animation for the reaction
	ActivateAnimation *Sticker `json:"activate_animation"` // Activate animation for the reaction
	EffectAnimation   *Sticker `json:"effect_animation"`   // Effect animation for the reaction
	AroundAnimation   *Sticker `json:"around_animation"`   // Around animation for the reaction; may be null
	CenterAnimation   *Sticker `json:"center_animation"`   // Center animation for the reaction; may be null
}

// MessageType return the string telegram-type of EmojiReaction
func (emojiReaction *EmojiReaction) MessageType() string {
	return "emojiReaction"
}

// NewEmojiReaction creates a new EmojiReaction
//
// @param emoji Text representation of the reaction
// @param title Reaction title
// @param isActive True, if the reaction can be added to new messages and enabled in chats
// @param staticIcon Static icon for the reaction
// @param appearAnimation Appear animation for the reaction
// @param selectAnimation Select animation for the reaction
// @param activateAnimation Activate animation for the reaction
// @param effectAnimation Effect animation for the reaction
// @param aroundAnimation Around animation for the reaction; may be null
// @param centerAnimation Center animation for the reaction; may be null
func NewEmojiReaction(emoji string, title string, isActive bool, staticIcon *Sticker, appearAnimation *Sticker, selectAnimation *Sticker, activateAnimation *Sticker, effectAnimation *Sticker, aroundAnimation *Sticker, centerAnimation *Sticker) *EmojiReaction {
	emojiReactionTemp := EmojiReaction{
		tdCommon:          tdCommon{Type: "emojiReaction"},
		Emoji:             emoji,
		Title:             title,
		IsActive:          isActive,
		StaticIcon:        staticIcon,
		AppearAnimation:   appearAnimation,
		SelectAnimation:   selectAnimation,
		ActivateAnimation: activateAnimation,
		EffectAnimation:   effectAnimation,
		AroundAnimation:   aroundAnimation,
		CenterAnimation:   centerAnimation,
	}

	return &emojiReactionTemp
}

// UnmarshalJSON unmarshal to json
func (emojiReaction *EmojiReaction) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Emoji    string `json:"emoji"`     // Text representation of the reaction
		Title    string `json:"title"`     // Reaction title
		IsActive bool   `json:"is_active"` // True, if the reaction can be added to new messages and enabled in chats

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	emojiReaction.tdCommon = tempObj.tdCommon
	emojiReaction.Emoji = tempObj.Emoji
	emojiReaction.Title = tempObj.Title
	emojiReaction.IsActive = tempObj.IsActive

	var staticIcon Sticker
	if objMap["static_icon"] != nil {
		err = staticIcon.UnmarshalJSON(*objMap["static_icon"])
		if err != nil {
			return err
		}
	}

	emojiReaction.StaticIcon = &staticIcon

	var appearAnimation Sticker
	if objMap["appear_animation"] != nil {
		err = appearAnimation.UnmarshalJSON(*objMap["appear_animation"])
		if err != nil {
			return err
		}
	}

	emojiReaction.AppearAnimation = &appearAnimation

	var selectAnimation Sticker
	if objMap["select_animation"] != nil {
		err = selectAnimation.UnmarshalJSON(*objMap["select_animation"])
		if err != nil {
			return err
		}
	}

	emojiReaction.SelectAnimation = &selectAnimation

	var activateAnimation Sticker
	if objMap["activate_animation"] != nil {
		err = activateAnimation.UnmarshalJSON(*objMap["activate_animation"])
		if err != nil {
			return err
		}
	}

	emojiReaction.ActivateAnimation = &activateAnimation

	var effectAnimation Sticker
	if objMap["effect_animation"] != nil {
		err = effectAnimation.UnmarshalJSON(*objMap["effect_animation"])
		if err != nil {
			return err
		}
	}

	emojiReaction.EffectAnimation = &effectAnimation

	var aroundAnimation Sticker
	if objMap["around_animation"] != nil {
		err = aroundAnimation.UnmarshalJSON(*objMap["around_animation"])
		if err != nil {
			return err
		}
	}

	emojiReaction.AroundAnimation = &aroundAnimation

	var centerAnimation Sticker
	if objMap["center_animation"] != nil {
		err = centerAnimation.UnmarshalJSON(*objMap["center_animation"])
		if err != nil {
			return err
		}
	}

	emojiReaction.CenterAnimation = &centerAnimation

	return nil
}

// ReactionUnavailabilityReasonAnonymousAdministrator The user is an anonymous administrator in the supergroup, but isn't a creator of it, so they can't vote on behalf of the supergroup
type ReactionUnavailabilityReasonAnonymousAdministrator struct {
	tdCommon
}

// MessageType return the string telegram-type of ReactionUnavailabilityReasonAnonymousAdministrator
func (reactionUnavailabilityReasonAnonymousAdministrator *ReactionUnavailabilityReasonAnonymousAdministrator) MessageType() string {
	return "reactionUnavailabilityReasonAnonymousAdministrator"
}

// NewReactionUnavailabilityReasonAnonymousAdministrator creates a new ReactionUnavailabilityReasonAnonymousAdministrator
//
func NewReactionUnavailabilityReasonAnonymousAdministrator() *ReactionUnavailabilityReasonAnonymousAdministrator {
	reactionUnavailabilityReasonAnonymousAdministratorTemp := ReactionUnavailabilityReasonAnonymousAdministrator{
		tdCommon: tdCommon{Type: "reactionUnavailabilityReasonAnonymousAdministrator"},
	}

	return &reactionUnavailabilityReasonAnonymousAdministratorTemp
}

// UnmarshalJSON unmarshal to json
func (reactionUnavailabilityReasonAnonymousAdministrator *ReactionUnavailabilityReasonAnonymousAdministrator) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reactionUnavailabilityReasonAnonymousAdministrator.tdCommon = tempObj.tdCommon

	return nil
}

// GetReactionUnavailabilityReasonEnum return the enum type of this object
func (reactionUnavailabilityReasonAnonymousAdministrator *ReactionUnavailabilityReasonAnonymousAdministrator) GetReactionUnavailabilityReasonEnum() ReactionUnavailabilityReasonEnum {
	return ReactionUnavailabilityReasonAnonymousAdministratorType
}

// ReactionUnavailabilityReasonGuest The user isn't a member of the supergroup and can't send messages and reactions there without joining
type ReactionUnavailabilityReasonGuest struct {
	tdCommon
}

// MessageType return the string telegram-type of ReactionUnavailabilityReasonGuest
func (reactionUnavailabilityReasonGuest *ReactionUnavailabilityReasonGuest) MessageType() string {
	return "reactionUnavailabilityReasonGuest"
}

// NewReactionUnavailabilityReasonGuest creates a new ReactionUnavailabilityReasonGuest
//
func NewReactionUnavailabilityReasonGuest() *ReactionUnavailabilityReasonGuest {
	reactionUnavailabilityReasonGuestTemp := ReactionUnavailabilityReasonGuest{
		tdCommon: tdCommon{Type: "reactionUnavailabilityReasonGuest"},
	}

	return &reactionUnavailabilityReasonGuestTemp
}

// UnmarshalJSON unmarshal to json
func (reactionUnavailabilityReasonGuest *ReactionUnavailabilityReasonGuest) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reactionUnavailabilityReasonGuest.tdCommon = tempObj.tdCommon

	return nil
}

// GetReactionUnavailabilityReasonEnum return the enum type of this object
func (reactionUnavailabilityReasonGuest *ReactionUnavailabilityReasonGuest) GetReactionUnavailabilityReasonEnum() ReactionUnavailabilityReasonEnum {
	return ReactionUnavailabilityReasonGuestType
}

// Animations Represents a list of animations
type Animations struct {
	tdCommon
	Animations []Animation `json:"animations"` // List of animations
}

// MessageType return the string telegram-type of Animations
func (animations *Animations) MessageType() string {
	return "animations"
}

// NewAnimations creates a new Animations
//
// @param animations List of animations
func NewAnimations(animations []Animation) *Animations {
	animationsTemp := Animations{
		tdCommon:   tdCommon{Type: "animations"},
		Animations: animations,
	}

	return &animationsTemp
}

// UnmarshalJSON unmarshal to json
func (animations *Animations) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Animations []Animation `json:"animations"` // List of animations
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	animations.tdCommon = tempObj.tdCommon
	animations.Animations = tempObj.Animations

	return nil
}

// DiceStickersRegular A regular animated sticker
type DiceStickersRegular struct {
	tdCommon
	Sticker *Sticker `json:"sticker"` // The animated sticker with the dice animation
}

// MessageType return the string telegram-type of DiceStickersRegular
func (diceStickersRegular *DiceStickersRegular) MessageType() string {
	return "diceStickersRegular"
}

// NewDiceStickersRegular creates a new DiceStickersRegular
//
// @param sticker The animated sticker with the dice animation
func NewDiceStickersRegular(sticker *Sticker) *DiceStickersRegular {
	diceStickersRegularTemp := DiceStickersRegular{
		tdCommon: tdCommon{Type: "diceStickersRegular"},
		Sticker:  sticker,
	}

	return &diceStickersRegularTemp
}

// UnmarshalJSON unmarshal to json
func (diceStickersRegular *DiceStickersRegular) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	diceStickersRegular.tdCommon = tempObj.tdCommon

	var sticker Sticker
	if objMap["sticker"] != nil {
		err = sticker.UnmarshalJSON(*objMap["sticker"])
		if err != nil {
			return err
		}
	}

	diceStickersRegular.Sticker = &sticker

	return nil
}

// GetDiceStickersEnum return the enum type of this object
func (diceStickersRegular *DiceStickersRegular) GetDiceStickersEnum() DiceStickersEnum {
	return DiceStickersRegularType
}

// DiceStickersSlotMachine Animated stickers to be combined into a slot machine
type DiceStickersSlotMachine struct {
	tdCommon
	Background *Sticker `json:"background"`  // The animated sticker with the slot machine background. The background animation must start playing after all reel animations finish
	Lever      *Sticker `json:"lever"`       // The animated sticker with the lever animation. The lever animation must play once in the initial dice state
	LeftReel   *Sticker `json:"left_reel"`   // The animated sticker with the left reel
	CenterReel *Sticker `json:"center_reel"` // The animated sticker with the center reel
	RightReel  *Sticker `json:"right_reel"`  // The animated sticker with the right reel
}

// MessageType return the string telegram-type of DiceStickersSlotMachine
func (diceStickersSlotMachine *DiceStickersSlotMachine) MessageType() string {
	return "diceStickersSlotMachine"
}

// NewDiceStickersSlotMachine creates a new DiceStickersSlotMachine
//
// @param background The animated sticker with the slot machine background. The background animation must start playing after all reel animations finish
// @param lever The animated sticker with the lever animation. The lever animation must play once in the initial dice state
// @param leftReel The animated sticker with the left reel
// @param centerReel The animated sticker with the center reel
// @param rightReel The animated sticker with the right reel
func NewDiceStickersSlotMachine(background *Sticker, lever *Sticker, leftReel *Sticker, centerReel *Sticker, rightReel *Sticker) *DiceStickersSlotMachine {
	diceStickersSlotMachineTemp := DiceStickersSlotMachine{
		tdCommon:   tdCommon{Type: "diceStickersSlotMachine"},
		Background: background,
		Lever:      lever,
		LeftReel:   leftReel,
		CenterReel: centerReel,
		RightReel:  rightReel,
	}

	return &diceStickersSlotMachineTemp
}

// UnmarshalJSON unmarshal to json
func (diceStickersSlotMachine *DiceStickersSlotMachine) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	diceStickersSlotMachine.tdCommon = tempObj.tdCommon

	var background Sticker
	if objMap["background"] != nil {
		err = background.UnmarshalJSON(*objMap["background"])
		if err != nil {
			return err
		}
	}

	diceStickersSlotMachine.Background = &background

	var lever Sticker
	if objMap["lever"] != nil {
		err = lever.UnmarshalJSON(*objMap["lever"])
		if err != nil {
			return err
		}
	}

	diceStickersSlotMachine.Lever = &lever

	var leftReel Sticker
	if objMap["left_reel"] != nil {
		err = leftReel.UnmarshalJSON(*objMap["left_reel"])
		if err != nil {
			return err
		}
	}

	diceStickersSlotMachine.LeftReel = &leftReel

	var centerReel Sticker
	if objMap["center_reel"] != nil {
		err = centerReel.UnmarshalJSON(*objMap["center_reel"])
		if err != nil {
			return err
		}
	}

	diceStickersSlotMachine.CenterReel = &centerReel

	var rightReel Sticker
	if objMap["right_reel"] != nil {
		err = rightReel.UnmarshalJSON(*objMap["right_reel"])
		if err != nil {
			return err
		}
	}

	diceStickersSlotMachine.RightReel = &rightReel

	return nil
}

// GetDiceStickersEnum return the enum type of this object
func (diceStickersSlotMachine *DiceStickersSlotMachine) GetDiceStickersEnum() DiceStickersEnum {
	return DiceStickersSlotMachineType
}

// ImportedContacts Represents the result of an importContacts request
type ImportedContacts struct {
	tdCommon
	UserIDs       []int64 `json:"user_ids"`       // User identifiers of the imported contacts in the same order as they were specified in the request; 0 if the contact is not yet a registered user
	ImporterCount []int32 `json:"importer_count"` // The number of users that imported the corresponding contact; 0 for already registered users or if unavailable
}

// MessageType return the string telegram-type of ImportedContacts
func (importedContacts *ImportedContacts) MessageType() string {
	return "importedContacts"
}

// NewImportedContacts creates a new ImportedContacts
//
// @param userIDs User identifiers of the imported contacts in the same order as they were specified in the request; 0 if the contact is not yet a registered user
// @param importerCount The number of users that imported the corresponding contact; 0 for already registered users or if unavailable
func NewImportedContacts(userIDs []int64, importerCount []int32) *ImportedContacts {
	importedContactsTemp := ImportedContacts{
		tdCommon:      tdCommon{Type: "importedContacts"},
		UserIDs:       userIDs,
		ImporterCount: importerCount,
	}

	return &importedContactsTemp
}

// UnmarshalJSON unmarshal to json
func (importedContacts *ImportedContacts) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserIDs       []int64 `json:"user_ids"`       // User identifiers of the imported contacts in the same order as they were specified in the request; 0 if the contact is not yet a registered user
		ImporterCount []int32 `json:"importer_count"` // The number of users that imported the corresponding contact; 0 for already registered users or if unavailable
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	importedContacts.tdCommon = tempObj.tdCommon
	importedContacts.UserIDs = tempObj.UserIDs
	importedContacts.ImporterCount = tempObj.ImporterCount

	return nil
}

// SpeechRecognitionResultPending The speech recognition is ongoing
type SpeechRecognitionResultPending struct {
	tdCommon
	PartialText string `json:"partial_text"` // Partially recognized text
}

// MessageType return the string telegram-type of SpeechRecognitionResultPending
func (speechRecognitionResultPending *SpeechRecognitionResultPending) MessageType() string {
	return "speechRecognitionResultPending"
}

// NewSpeechRecognitionResultPending creates a new SpeechRecognitionResultPending
//
// @param partialText Partially recognized text
func NewSpeechRecognitionResultPending(partialText string) *SpeechRecognitionResultPending {
	speechRecognitionResultPendingTemp := SpeechRecognitionResultPending{
		tdCommon:    tdCommon{Type: "speechRecognitionResultPending"},
		PartialText: partialText,
	}

	return &speechRecognitionResultPendingTemp
}

// UnmarshalJSON unmarshal to json
func (speechRecognitionResultPending *SpeechRecognitionResultPending) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PartialText string `json:"partial_text"` // Partially recognized text
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	speechRecognitionResultPending.tdCommon = tempObj.tdCommon
	speechRecognitionResultPending.PartialText = tempObj.PartialText

	return nil
}

// GetSpeechRecognitionResultEnum return the enum type of this object
func (speechRecognitionResultPending *SpeechRecognitionResultPending) GetSpeechRecognitionResultEnum() SpeechRecognitionResultEnum {
	return SpeechRecognitionResultPendingType
}

// SpeechRecognitionResultText The speech recognition successfully finished
type SpeechRecognitionResultText struct {
	tdCommon
	Text string `json:"text"` // Recognized text
}

// MessageType return the string telegram-type of SpeechRecognitionResultText
func (speechRecognitionResultText *SpeechRecognitionResultText) MessageType() string {
	return "speechRecognitionResultText"
}

// NewSpeechRecognitionResultText creates a new SpeechRecognitionResultText
//
// @param text Recognized text
func NewSpeechRecognitionResultText(text string) *SpeechRecognitionResultText {
	speechRecognitionResultTextTemp := SpeechRecognitionResultText{
		tdCommon: tdCommon{Type: "speechRecognitionResultText"},
		Text:     text,
	}

	return &speechRecognitionResultTextTemp
}

// UnmarshalJSON unmarshal to json
func (speechRecognitionResultText *SpeechRecognitionResultText) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Text string `json:"text"` // Recognized text
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	speechRecognitionResultText.tdCommon = tempObj.tdCommon
	speechRecognitionResultText.Text = tempObj.Text

	return nil
}

// GetSpeechRecognitionResultEnum return the enum type of this object
func (speechRecognitionResultText *SpeechRecognitionResultText) GetSpeechRecognitionResultEnum() SpeechRecognitionResultEnum {
	return SpeechRecognitionResultTextType
}

// SpeechRecognitionResultError The speech recognition failed
type SpeechRecognitionResultError struct {
	tdCommon
	Error *Error `json:"error"` // Recognition error. An error with a message "MSG_VOICE_TOO_LONG" is returned when media duration is too big to be recognized
}

// MessageType return the string telegram-type of SpeechRecognitionResultError
func (speechRecognitionResultError *SpeechRecognitionResultError) MessageType() string {
	return "speechRecognitionResultError"
}

// NewSpeechRecognitionResultError creates a new SpeechRecognitionResultError
//
// @param errParam Recognition error. An error with a message "MSG_VOICE_TOO_LONG" is returned when media duration is too big to be recognized
func NewSpeechRecognitionResultError(errParam *Error) *SpeechRecognitionResultError {
	speechRecognitionResultErrorTemp := SpeechRecognitionResultError{
		tdCommon: tdCommon{Type: "speechRecognitionResultError"},
		Error:    errParam,
	}

	return &speechRecognitionResultErrorTemp
}

// UnmarshalJSON unmarshal to json
func (speechRecognitionResultError *SpeechRecognitionResultError) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Error *Error `json:"error"` // Recognition error. An error with a message "MSG_VOICE_TOO_LONG" is returned when media duration is too big to be recognized
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	speechRecognitionResultError.tdCommon = tempObj.tdCommon
	speechRecognitionResultError.Error = tempObj.Error

	return nil
}

// GetSpeechRecognitionResultEnum return the enum type of this object
func (speechRecognitionResultError *SpeechRecognitionResultError) GetSpeechRecognitionResultEnum() SpeechRecognitionResultEnum {
	return SpeechRecognitionResultErrorType
}

// BusinessConnection Describes a connection of the bot with a business account
type BusinessConnection struct {
	tdCommon
	ID         string `json:"id"`           // Unique identifier of the connection
	UserID     int64  `json:"user_id"`      // Identifier of the business user that created the connection
	UserChatID int64  `json:"user_chat_id"` // Chat identifier of the private chat with the user
	Date       int32  `json:"date"`         // Point in time (Unix timestamp) when the connection was established
	CanReply   bool   `json:"can_reply"`    // True, if the bot can send messages to the connected user; false otherwise
	IsEnabled  bool   `json:"is_enabled"`   // True, if the connection is enabled; false otherwise
}

// MessageType return the string telegram-type of BusinessConnection
func (businessConnection *BusinessConnection) MessageType() string {
	return "businessConnection"
}

// NewBusinessConnection creates a new BusinessConnection
//
// @param iD Unique identifier of the connection
// @param userID Identifier of the business user that created the connection
// @param userChatID Chat identifier of the private chat with the user
// @param date Point in time (Unix timestamp) when the connection was established
// @param canReply True, if the bot can send messages to the connected user; false otherwise
// @param isEnabled True, if the connection is enabled; false otherwise
func NewBusinessConnection(iD string, userID int64, userChatID int64, date int32, canReply bool, isEnabled bool) *BusinessConnection {
	businessConnectionTemp := BusinessConnection{
		tdCommon:   tdCommon{Type: "businessConnection"},
		ID:         iD,
		UserID:     userID,
		UserChatID: userChatID,
		Date:       date,
		CanReply:   canReply,
		IsEnabled:  isEnabled,
	}

	return &businessConnectionTemp
}

// UnmarshalJSON unmarshal to json
func (businessConnection *BusinessConnection) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID         string `json:"id"`           // Unique identifier of the connection
		UserID     int64  `json:"user_id"`      // Identifier of the business user that created the connection
		UserChatID int64  `json:"user_chat_id"` // Chat identifier of the private chat with the user
		Date       int32  `json:"date"`         // Point in time (Unix timestamp) when the connection was established
		CanReply   bool   `json:"can_reply"`    // True, if the bot can send messages to the connected user; false otherwise
		IsEnabled  bool   `json:"is_enabled"`   // True, if the connection is enabled; false otherwise
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessConnection.tdCommon = tempObj.tdCommon
	businessConnection.ID = tempObj.ID
	businessConnection.UserID = tempObj.UserID
	businessConnection.UserChatID = tempObj.UserChatID
	businessConnection.Date = tempObj.Date
	businessConnection.CanReply = tempObj.CanReply
	businessConnection.IsEnabled = tempObj.IsEnabled

	return nil
}

// AttachmentMenuBotColor Describes a color to highlight a bot added to attachment menu
type AttachmentMenuBotColor struct {
	tdCommon
	LightColor int32 `json:"light_color"` // Color in the RGB24 format for light themes
	DarkColor  int32 `json:"dark_color"`  // Color in the RGB24 format for dark themes
}

// MessageType return the string telegram-type of AttachmentMenuBotColor
func (attachmentMenuBotColor *AttachmentMenuBotColor) MessageType() string {
	return "attachmentMenuBotColor"
}

// NewAttachmentMenuBotColor creates a new AttachmentMenuBotColor
//
// @param lightColor Color in the RGB24 format for light themes
// @param darkColor Color in the RGB24 format for dark themes
func NewAttachmentMenuBotColor(lightColor int32, darkColor int32) *AttachmentMenuBotColor {
	attachmentMenuBotColorTemp := AttachmentMenuBotColor{
		tdCommon:   tdCommon{Type: "attachmentMenuBotColor"},
		LightColor: lightColor,
		DarkColor:  darkColor,
	}

	return &attachmentMenuBotColorTemp
}

// UnmarshalJSON unmarshal to json
func (attachmentMenuBotColor *AttachmentMenuBotColor) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		LightColor int32 `json:"light_color"` // Color in the RGB24 format for light themes
		DarkColor  int32 `json:"dark_color"`  // Color in the RGB24 format for dark themes
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	attachmentMenuBotColor.tdCommon = tempObj.tdCommon
	attachmentMenuBotColor.LightColor = tempObj.LightColor
	attachmentMenuBotColor.DarkColor = tempObj.DarkColor

	return nil
}

// AttachmentMenuBot Represents a bot, which can be added to attachment or side menu
type AttachmentMenuBot struct {
	tdCommon
	BotUserID                int64                   `json:"bot_user_id"`                  // User identifier of the bot
	SupportsSelfChat         bool                    `json:"supports_self_chat"`           // True, if the bot supports opening from attachment menu in the chat with the bot
	SupportsUserChats        bool                    `json:"supports_user_chats"`          // True, if the bot supports opening from attachment menu in private chats with ordinary users
	SupportsBotChats         bool                    `json:"supports_bot_chats"`           // True, if the bot supports opening from attachment menu in private chats with other bots
	SupportsGroupChats       bool                    `json:"supports_group_chats"`         // True, if the bot supports opening from attachment menu in basic group and supergroup chats
	SupportsChannelChats     bool                    `json:"supports_channel_chats"`       // True, if the bot supports opening from attachment menu in channel chats
	RequestWriteAccess       bool                    `json:"request_write_access"`         // True, if the user must be asked for the permission to send messages to the bot
	IsAdded                  bool                    `json:"is_added"`                     // True, if the bot was explicitly added by the user. If the bot isn't added, then on the first bot launch toggleBotIsAddedToAttachmentMenu must be called and the bot must be added or removed
	ShowInAttachmentMenu     bool                    `json:"show_in_attachment_menu"`      // True, if the bot must be shown in the attachment menu
	ShowInSideMenu           bool                    `json:"show_in_side_menu"`            // True, if the bot must be shown in the side menu
	ShowDisclaimerInSideMenu bool                    `json:"show_disclaimer_in_side_menu"` // True, if a disclaimer, why the bot is shown in the side menu, is needed
	Name                     string                  `json:"name"`                         // Name for the bot in attachment menu
	NameColor                *AttachmentMenuBotColor `json:"name_color"`                   // Color to highlight selected name of the bot if appropriate; may be null
	DefaultIcon              *File                   `json:"default_icon"`                 // Default icon for the bot in SVG format; may be null
	IosStaticIcon            *File                   `json:"ios_static_icon"`              // Icon for the bot in SVG format for the official iOS app; may be null
	IosAnimatedIcon          *File                   `json:"ios_animated_icon"`            // Icon for the bot in TGS format for the official iOS app; may be null
	IosSideMenuIcon          *File                   `json:"ios_side_menu_icon"`           // Icon for the bot in PNG format for the official iOS app side menu; may be null
	AndroidIcon              *File                   `json:"android_icon"`                 // Icon for the bot in TGS format for the official Android app; may be null
	AndroidSideMenuIcon      *File                   `json:"android_side_menu_icon"`       // Icon for the bot in SVG format for the official Android app side menu; may be null
	MacosIcon                *File                   `json:"macos_icon"`                   // Icon for the bot in TGS format for the official native macOS app; may be null
	MacosSideMenuIcon        *File                   `json:"macos_side_menu_icon"`         // Icon for the bot in PNG format for the official macOS app side menu; may be null
	IconColor                *AttachmentMenuBotColor `json:"icon_color"`                   // Color to highlight selected icon of the bot if appropriate; may be null
	WebAppPlaceholder        *File                   `json:"web_app_placeholder"`          // Default placeholder for opened Web Apps in SVG format; may be null
}

// MessageType return the string telegram-type of AttachmentMenuBot
func (attachmentMenuBot *AttachmentMenuBot) MessageType() string {
	return "attachmentMenuBot"
}

// NewAttachmentMenuBot creates a new AttachmentMenuBot
//
// @param botUserID User identifier of the bot
// @param supportsSelfChat True, if the bot supports opening from attachment menu in the chat with the bot
// @param supportsUserChats True, if the bot supports opening from attachment menu in private chats with ordinary users
// @param supportsBotChats True, if the bot supports opening from attachment menu in private chats with other bots
// @param supportsGroupChats True, if the bot supports opening from attachment menu in basic group and supergroup chats
// @param supportsChannelChats True, if the bot supports opening from attachment menu in channel chats
// @param requestWriteAccess True, if the user must be asked for the permission to send messages to the bot
// @param isAdded True, if the bot was explicitly added by the user. If the bot isn't added, then on the first bot launch toggleBotIsAddedToAttachmentMenu must be called and the bot must be added or removed
// @param showInAttachmentMenu True, if the bot must be shown in the attachment menu
// @param showInSideMenu True, if the bot must be shown in the side menu
// @param showDisclaimerInSideMenu True, if a disclaimer, why the bot is shown in the side menu, is needed
// @param name Name for the bot in attachment menu
// @param nameColor Color to highlight selected name of the bot if appropriate; may be null
// @param defaultIcon Default icon for the bot in SVG format; may be null
// @param iosStaticIcon Icon for the bot in SVG format for the official iOS app; may be null
// @param iosAnimatedIcon Icon for the bot in TGS format for the official iOS app; may be null
// @param iosSideMenuIcon Icon for the bot in PNG format for the official iOS app side menu; may be null
// @param androidIcon Icon for the bot in TGS format for the official Android app; may be null
// @param androidSideMenuIcon Icon for the bot in SVG format for the official Android app side menu; may be null
// @param macosIcon Icon for the bot in TGS format for the official native macOS app; may be null
// @param macosSideMenuIcon Icon for the bot in PNG format for the official macOS app side menu; may be null
// @param iconColor Color to highlight selected icon of the bot if appropriate; may be null
// @param webAppPlaceholder Default placeholder for opened Web Apps in SVG format; may be null
func NewAttachmentMenuBot(botUserID int64, supportsSelfChat bool, supportsUserChats bool, supportsBotChats bool, supportsGroupChats bool, supportsChannelChats bool, requestWriteAccess bool, isAdded bool, showInAttachmentMenu bool, showInSideMenu bool, showDisclaimerInSideMenu bool, name string, nameColor *AttachmentMenuBotColor, defaultIcon *File, iosStaticIcon *File, iosAnimatedIcon *File, iosSideMenuIcon *File, androidIcon *File, androidSideMenuIcon *File, macosIcon *File, macosSideMenuIcon *File, iconColor *AttachmentMenuBotColor, webAppPlaceholder *File) *AttachmentMenuBot {
	attachmentMenuBotTemp := AttachmentMenuBot{
		tdCommon:                 tdCommon{Type: "attachmentMenuBot"},
		BotUserID:                botUserID,
		SupportsSelfChat:         supportsSelfChat,
		SupportsUserChats:        supportsUserChats,
		SupportsBotChats:         supportsBotChats,
		SupportsGroupChats:       supportsGroupChats,
		SupportsChannelChats:     supportsChannelChats,
		RequestWriteAccess:       requestWriteAccess,
		IsAdded:                  isAdded,
		ShowInAttachmentMenu:     showInAttachmentMenu,
		ShowInSideMenu:           showInSideMenu,
		ShowDisclaimerInSideMenu: showDisclaimerInSideMenu,
		Name:                     name,
		NameColor:                nameColor,
		DefaultIcon:              defaultIcon,
		IosStaticIcon:            iosStaticIcon,
		IosAnimatedIcon:          iosAnimatedIcon,
		IosSideMenuIcon:          iosSideMenuIcon,
		AndroidIcon:              androidIcon,
		AndroidSideMenuIcon:      androidSideMenuIcon,
		MacosIcon:                macosIcon,
		MacosSideMenuIcon:        macosSideMenuIcon,
		IconColor:                iconColor,
		WebAppPlaceholder:        webAppPlaceholder,
	}

	return &attachmentMenuBotTemp
}

// UnmarshalJSON unmarshal to json
func (attachmentMenuBot *AttachmentMenuBot) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BotUserID                int64                   `json:"bot_user_id"`                  // User identifier of the bot
		SupportsSelfChat         bool                    `json:"supports_self_chat"`           // True, if the bot supports opening from attachment menu in the chat with the bot
		SupportsUserChats        bool                    `json:"supports_user_chats"`          // True, if the bot supports opening from attachment menu in private chats with ordinary users
		SupportsBotChats         bool                    `json:"supports_bot_chats"`           // True, if the bot supports opening from attachment menu in private chats with other bots
		SupportsGroupChats       bool                    `json:"supports_group_chats"`         // True, if the bot supports opening from attachment menu in basic group and supergroup chats
		SupportsChannelChats     bool                    `json:"supports_channel_chats"`       // True, if the bot supports opening from attachment menu in channel chats
		RequestWriteAccess       bool                    `json:"request_write_access"`         // True, if the user must be asked for the permission to send messages to the bot
		IsAdded                  bool                    `json:"is_added"`                     // True, if the bot was explicitly added by the user. If the bot isn't added, then on the first bot launch toggleBotIsAddedToAttachmentMenu must be called and the bot must be added or removed
		ShowInAttachmentMenu     bool                    `json:"show_in_attachment_menu"`      // True, if the bot must be shown in the attachment menu
		ShowInSideMenu           bool                    `json:"show_in_side_menu"`            // True, if the bot must be shown in the side menu
		ShowDisclaimerInSideMenu bool                    `json:"show_disclaimer_in_side_menu"` // True, if a disclaimer, why the bot is shown in the side menu, is needed
		Name                     string                  `json:"name"`                         // Name for the bot in attachment menu
		NameColor                *AttachmentMenuBotColor `json:"name_color"`                   // Color to highlight selected name of the bot if appropriate; may be null
		DefaultIcon              *File                   `json:"default_icon"`                 // Default icon for the bot in SVG format; may be null
		IosStaticIcon            *File                   `json:"ios_static_icon"`              // Icon for the bot in SVG format for the official iOS app; may be null
		IosAnimatedIcon          *File                   `json:"ios_animated_icon"`            // Icon for the bot in TGS format for the official iOS app; may be null
		IosSideMenuIcon          *File                   `json:"ios_side_menu_icon"`           // Icon for the bot in PNG format for the official iOS app side menu; may be null
		AndroidIcon              *File                   `json:"android_icon"`                 // Icon for the bot in TGS format for the official Android app; may be null
		AndroidSideMenuIcon      *File                   `json:"android_side_menu_icon"`       // Icon for the bot in SVG format for the official Android app side menu; may be null
		MacosIcon                *File                   `json:"macos_icon"`                   // Icon for the bot in TGS format for the official native macOS app; may be null
		MacosSideMenuIcon        *File                   `json:"macos_side_menu_icon"`         // Icon for the bot in PNG format for the official macOS app side menu; may be null
		IconColor                *AttachmentMenuBotColor `json:"icon_color"`                   // Color to highlight selected icon of the bot if appropriate; may be null
		WebAppPlaceholder        *File                   `json:"web_app_placeholder"`          // Default placeholder for opened Web Apps in SVG format; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	attachmentMenuBot.tdCommon = tempObj.tdCommon
	attachmentMenuBot.BotUserID = tempObj.BotUserID
	attachmentMenuBot.SupportsSelfChat = tempObj.SupportsSelfChat
	attachmentMenuBot.SupportsUserChats = tempObj.SupportsUserChats
	attachmentMenuBot.SupportsBotChats = tempObj.SupportsBotChats
	attachmentMenuBot.SupportsGroupChats = tempObj.SupportsGroupChats
	attachmentMenuBot.SupportsChannelChats = tempObj.SupportsChannelChats
	attachmentMenuBot.RequestWriteAccess = tempObj.RequestWriteAccess
	attachmentMenuBot.IsAdded = tempObj.IsAdded
	attachmentMenuBot.ShowInAttachmentMenu = tempObj.ShowInAttachmentMenu
	attachmentMenuBot.ShowInSideMenu = tempObj.ShowInSideMenu
	attachmentMenuBot.ShowDisclaimerInSideMenu = tempObj.ShowDisclaimerInSideMenu
	attachmentMenuBot.Name = tempObj.Name
	attachmentMenuBot.NameColor = tempObj.NameColor
	attachmentMenuBot.DefaultIcon = tempObj.DefaultIcon
	attachmentMenuBot.IosStaticIcon = tempObj.IosStaticIcon
	attachmentMenuBot.IosAnimatedIcon = tempObj.IosAnimatedIcon
	attachmentMenuBot.IosSideMenuIcon = tempObj.IosSideMenuIcon
	attachmentMenuBot.AndroidIcon = tempObj.AndroidIcon
	attachmentMenuBot.AndroidSideMenuIcon = tempObj.AndroidSideMenuIcon
	attachmentMenuBot.MacosIcon = tempObj.MacosIcon
	attachmentMenuBot.MacosSideMenuIcon = tempObj.MacosSideMenuIcon
	attachmentMenuBot.IconColor = tempObj.IconColor
	attachmentMenuBot.WebAppPlaceholder = tempObj.WebAppPlaceholder

	return nil
}

// SentWebAppMessage Information about the message sent by answerWebAppQuery
type SentWebAppMessage struct {
	tdCommon
	InlineMessageID string `json:"inline_message_id"` // Identifier of the sent inline message, if known
}

// MessageType return the string telegram-type of SentWebAppMessage
func (sentWebAppMessage *SentWebAppMessage) MessageType() string {
	return "sentWebAppMessage"
}

// NewSentWebAppMessage creates a new SentWebAppMessage
//
// @param inlineMessageID Identifier of the sent inline message, if known
func NewSentWebAppMessage(inlineMessageID string) *SentWebAppMessage {
	sentWebAppMessageTemp := SentWebAppMessage{
		tdCommon:        tdCommon{Type: "sentWebAppMessage"},
		InlineMessageID: inlineMessageID,
	}

	return &sentWebAppMessageTemp
}

// UnmarshalJSON unmarshal to json
func (sentWebAppMessage *SentWebAppMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		InlineMessageID string `json:"inline_message_id"` // Identifier of the sent inline message, if known
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sentWebAppMessage.tdCommon = tempObj.tdCommon
	sentWebAppMessage.InlineMessageID = tempObj.InlineMessageID

	return nil
}

// BotWriteAccessAllowReasonConnectedWebsite The user connected a website by logging in using Telegram Login Widget on it
type BotWriteAccessAllowReasonConnectedWebsite struct {
	tdCommon
	DomainName string `json:"domain_name"` // Domain name of the connected website
}

// MessageType return the string telegram-type of BotWriteAccessAllowReasonConnectedWebsite
func (botWriteAccessAllowReasonConnectedWebsite *BotWriteAccessAllowReasonConnectedWebsite) MessageType() string {
	return "botWriteAccessAllowReasonConnectedWebsite"
}

// NewBotWriteAccessAllowReasonConnectedWebsite creates a new BotWriteAccessAllowReasonConnectedWebsite
//
// @param domainName Domain name of the connected website
func NewBotWriteAccessAllowReasonConnectedWebsite(domainName string) *BotWriteAccessAllowReasonConnectedWebsite {
	botWriteAccessAllowReasonConnectedWebsiteTemp := BotWriteAccessAllowReasonConnectedWebsite{
		tdCommon:   tdCommon{Type: "botWriteAccessAllowReasonConnectedWebsite"},
		DomainName: domainName,
	}

	return &botWriteAccessAllowReasonConnectedWebsiteTemp
}

// UnmarshalJSON unmarshal to json
func (botWriteAccessAllowReasonConnectedWebsite *BotWriteAccessAllowReasonConnectedWebsite) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		DomainName string `json:"domain_name"` // Domain name of the connected website
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	botWriteAccessAllowReasonConnectedWebsite.tdCommon = tempObj.tdCommon
	botWriteAccessAllowReasonConnectedWebsite.DomainName = tempObj.DomainName

	return nil
}

// GetBotWriteAccessAllowReasonEnum return the enum type of this object
func (botWriteAccessAllowReasonConnectedWebsite *BotWriteAccessAllowReasonConnectedWebsite) GetBotWriteAccessAllowReasonEnum() BotWriteAccessAllowReasonEnum {
	return BotWriteAccessAllowReasonConnectedWebsiteType
}

// BotWriteAccessAllowReasonAddedToAttachmentMenu The user added the bot to attachment or side menu using toggleBotIsAddedToAttachmentMenu
type BotWriteAccessAllowReasonAddedToAttachmentMenu struct {
	tdCommon
}

// MessageType return the string telegram-type of BotWriteAccessAllowReasonAddedToAttachmentMenu
func (botWriteAccessAllowReasonAddedToAttachmentMenu *BotWriteAccessAllowReasonAddedToAttachmentMenu) MessageType() string {
	return "botWriteAccessAllowReasonAddedToAttachmentMenu"
}

// NewBotWriteAccessAllowReasonAddedToAttachmentMenu creates a new BotWriteAccessAllowReasonAddedToAttachmentMenu
//
func NewBotWriteAccessAllowReasonAddedToAttachmentMenu() *BotWriteAccessAllowReasonAddedToAttachmentMenu {
	botWriteAccessAllowReasonAddedToAttachmentMenuTemp := BotWriteAccessAllowReasonAddedToAttachmentMenu{
		tdCommon: tdCommon{Type: "botWriteAccessAllowReasonAddedToAttachmentMenu"},
	}

	return &botWriteAccessAllowReasonAddedToAttachmentMenuTemp
}

// UnmarshalJSON unmarshal to json
func (botWriteAccessAllowReasonAddedToAttachmentMenu *BotWriteAccessAllowReasonAddedToAttachmentMenu) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	botWriteAccessAllowReasonAddedToAttachmentMenu.tdCommon = tempObj.tdCommon

	return nil
}

// GetBotWriteAccessAllowReasonEnum return the enum type of this object
func (botWriteAccessAllowReasonAddedToAttachmentMenu *BotWriteAccessAllowReasonAddedToAttachmentMenu) GetBotWriteAccessAllowReasonEnum() BotWriteAccessAllowReasonEnum {
	return BotWriteAccessAllowReasonAddedToAttachmentMenuType
}

// BotWriteAccessAllowReasonLaunchedWebApp The user launched a Web App using getWebAppLinkUrl
type BotWriteAccessAllowReasonLaunchedWebApp struct {
	tdCommon
	WebApp *WebApp `json:"web_app"` // Information about the Web App
}

// MessageType return the string telegram-type of BotWriteAccessAllowReasonLaunchedWebApp
func (botWriteAccessAllowReasonLaunchedWebApp *BotWriteAccessAllowReasonLaunchedWebApp) MessageType() string {
	return "botWriteAccessAllowReasonLaunchedWebApp"
}

// NewBotWriteAccessAllowReasonLaunchedWebApp creates a new BotWriteAccessAllowReasonLaunchedWebApp
//
// @param webApp Information about the Web App
func NewBotWriteAccessAllowReasonLaunchedWebApp(webApp *WebApp) *BotWriteAccessAllowReasonLaunchedWebApp {
	botWriteAccessAllowReasonLaunchedWebAppTemp := BotWriteAccessAllowReasonLaunchedWebApp{
		tdCommon: tdCommon{Type: "botWriteAccessAllowReasonLaunchedWebApp"},
		WebApp:   webApp,
	}

	return &botWriteAccessAllowReasonLaunchedWebAppTemp
}

// UnmarshalJSON unmarshal to json
func (botWriteAccessAllowReasonLaunchedWebApp *BotWriteAccessAllowReasonLaunchedWebApp) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		WebApp *WebApp `json:"web_app"` // Information about the Web App
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	botWriteAccessAllowReasonLaunchedWebApp.tdCommon = tempObj.tdCommon
	botWriteAccessAllowReasonLaunchedWebApp.WebApp = tempObj.WebApp

	return nil
}

// GetBotWriteAccessAllowReasonEnum return the enum type of this object
func (botWriteAccessAllowReasonLaunchedWebApp *BotWriteAccessAllowReasonLaunchedWebApp) GetBotWriteAccessAllowReasonEnum() BotWriteAccessAllowReasonEnum {
	return BotWriteAccessAllowReasonLaunchedWebAppType
}

// BotWriteAccessAllowReasonAcceptedRequest The user accepted bot's request to send messages with allowBotToSendMessages
type BotWriteAccessAllowReasonAcceptedRequest struct {
	tdCommon
}

// MessageType return the string telegram-type of BotWriteAccessAllowReasonAcceptedRequest
func (botWriteAccessAllowReasonAcceptedRequest *BotWriteAccessAllowReasonAcceptedRequest) MessageType() string {
	return "botWriteAccessAllowReasonAcceptedRequest"
}

// NewBotWriteAccessAllowReasonAcceptedRequest creates a new BotWriteAccessAllowReasonAcceptedRequest
//
func NewBotWriteAccessAllowReasonAcceptedRequest() *BotWriteAccessAllowReasonAcceptedRequest {
	botWriteAccessAllowReasonAcceptedRequestTemp := BotWriteAccessAllowReasonAcceptedRequest{
		tdCommon: tdCommon{Type: "botWriteAccessAllowReasonAcceptedRequest"},
	}

	return &botWriteAccessAllowReasonAcceptedRequestTemp
}

// UnmarshalJSON unmarshal to json
func (botWriteAccessAllowReasonAcceptedRequest *BotWriteAccessAllowReasonAcceptedRequest) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	botWriteAccessAllowReasonAcceptedRequest.tdCommon = tempObj.tdCommon

	return nil
}

// GetBotWriteAccessAllowReasonEnum return the enum type of this object
func (botWriteAccessAllowReasonAcceptedRequest *BotWriteAccessAllowReasonAcceptedRequest) GetBotWriteAccessAllowReasonEnum() BotWriteAccessAllowReasonEnum {
	return BotWriteAccessAllowReasonAcceptedRequestType
}

// HttpURL Contains an HTTP URL
type HttpURL struct {
	tdCommon
	URL string `json:"url"` // The URL
}

// MessageType return the string telegram-type of HttpURL
func (httpURL *HttpURL) MessageType() string {
	return "httpUrl"
}

// NewHttpURL creates a new HttpURL
//
// @param uRL The URL
func NewHttpURL(uRL string) *HttpURL {
	httpURLTemp := HttpURL{
		tdCommon: tdCommon{Type: "httpUrl"},
		URL:      uRL,
	}

	return &httpURLTemp
}

// UnmarshalJSON unmarshal to json
func (httpURL *HttpURL) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL string `json:"url"` // The URL
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	httpURL.tdCommon = tempObj.tdCommon
	httpURL.URL = tempObj.URL

	return nil
}

// UserLink Contains an HTTPS URL, which can be used to get information about a user
type UserLink struct {
	tdCommon
	URL       string `json:"url"`        // The URL
	ExpiresIn int32  `json:"expires_in"` // Left time for which the link is valid, in seconds; 0 if the link is a public username link
}

// MessageType return the string telegram-type of UserLink
func (userLink *UserLink) MessageType() string {
	return "userLink"
}

// NewUserLink creates a new UserLink
//
// @param uRL The URL
// @param expiresIn Left time for which the link is valid, in seconds; 0 if the link is a public username link
func NewUserLink(uRL string, expiresIn int32) *UserLink {
	userLinkTemp := UserLink{
		tdCommon:  tdCommon{Type: "userLink"},
		URL:       uRL,
		ExpiresIn: expiresIn,
	}

	return &userLinkTemp
}

// UnmarshalJSON unmarshal to json
func (userLink *UserLink) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL       string `json:"url"`        // The URL
		ExpiresIn int32  `json:"expires_in"` // Left time for which the link is valid, in seconds; 0 if the link is a public username link
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userLink.tdCommon = tempObj.tdCommon
	userLink.URL = tempObj.URL
	userLink.ExpiresIn = tempObj.ExpiresIn

	return nil
}

// InputInlineQueryResultAnimation Represents a link to an animated GIF or an animated (i.e., without sound) H.264/MPEG-4 AVC video
type InputInlineQueryResultAnimation struct {
	tdCommon
	ID                  string              `json:"id"`                    // Unique identifier of the query result
	Title               string              `json:"title"`                 // Title of the query result
	ThumbnailURL        string              `json:"thumbnail_url"`         // URL of the result thumbnail (JPEG, GIF, or MPEG4), if it exists
	ThumbnailMimeType   string              `json:"thumbnail_mime_type"`   // MIME type of the video thumbnail. If non-empty, must be one of "image/jpeg", "image/gif" and "video/mp4"
	VideoURL            string              `json:"video_url"`             // The URL of the video file (file size must not exceed 1MB)
	VideoMimeType       string              `json:"video_mime_type"`       // MIME type of the video file. Must be one of "image/gif" and "video/mp4"
	VideoDuration       int32               `json:"video_duration"`        // Duration of the video, in seconds
	VideoWidth          int32               `json:"video_width"`           // Width of the video
	VideoHeight         int32               `json:"video_height"`          // Height of the video
	ReplyMarkup         ReplyMarkup         `json:"reply_markup"`          // The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	InputMessageContent InputMessageContent `json:"input_message_content"` // The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageAnimation, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
}

// MessageType return the string telegram-type of InputInlineQueryResultAnimation
func (inputInlineQueryResultAnimation *InputInlineQueryResultAnimation) MessageType() string {
	return "inputInlineQueryResultAnimation"
}

// NewInputInlineQueryResultAnimation creates a new InputInlineQueryResultAnimation
//
// @param iD Unique identifier of the query result
// @param title Title of the query result
// @param thumbnailURL URL of the result thumbnail (JPEG, GIF, or MPEG4), if it exists
// @param thumbnailMimeType MIME type of the video thumbnail. If non-empty, must be one of "image/jpeg", "image/gif" and "video/mp4"
// @param videoURL The URL of the video file (file size must not exceed 1MB)
// @param videoMimeType MIME type of the video file. Must be one of "image/gif" and "video/mp4"
// @param videoDuration Duration of the video, in seconds
// @param videoWidth Width of the video
// @param videoHeight Height of the video
// @param replyMarkup The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
// @param inputMessageContent The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageAnimation, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
func NewInputInlineQueryResultAnimation(iD string, title string, thumbnailURL string, thumbnailMimeType string, videoURL string, videoMimeType string, videoDuration int32, videoWidth int32, videoHeight int32, replyMarkup ReplyMarkup, inputMessageContent InputMessageContent) *InputInlineQueryResultAnimation {
	inputInlineQueryResultAnimationTemp := InputInlineQueryResultAnimation{
		tdCommon:            tdCommon{Type: "inputInlineQueryResultAnimation"},
		ID:                  iD,
		Title:               title,
		ThumbnailURL:        thumbnailURL,
		ThumbnailMimeType:   thumbnailMimeType,
		VideoURL:            videoURL,
		VideoMimeType:       videoMimeType,
		VideoDuration:       videoDuration,
		VideoWidth:          videoWidth,
		VideoHeight:         videoHeight,
		ReplyMarkup:         replyMarkup,
		InputMessageContent: inputMessageContent,
	}

	return &inputInlineQueryResultAnimationTemp
}

// UnmarshalJSON unmarshal to json
func (inputInlineQueryResultAnimation *InputInlineQueryResultAnimation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID                string `json:"id"`                  // Unique identifier of the query result
		Title             string `json:"title"`               // Title of the query result
		ThumbnailURL      string `json:"thumbnail_url"`       // URL of the result thumbnail (JPEG, GIF, or MPEG4), if it exists
		ThumbnailMimeType string `json:"thumbnail_mime_type"` // MIME type of the video thumbnail. If non-empty, must be one of "image/jpeg", "image/gif" and "video/mp4"
		VideoURL          string `json:"video_url"`           // The URL of the video file (file size must not exceed 1MB)
		VideoMimeType     string `json:"video_mime_type"`     // MIME type of the video file. Must be one of "image/gif" and "video/mp4"
		VideoDuration     int32  `json:"video_duration"`      // Duration of the video, in seconds
		VideoWidth        int32  `json:"video_width"`         // Width of the video
		VideoHeight       int32  `json:"video_height"`        // Height of the video

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputInlineQueryResultAnimation.tdCommon = tempObj.tdCommon
	inputInlineQueryResultAnimation.ID = tempObj.ID
	inputInlineQueryResultAnimation.Title = tempObj.Title
	inputInlineQueryResultAnimation.ThumbnailURL = tempObj.ThumbnailURL
	inputInlineQueryResultAnimation.ThumbnailMimeType = tempObj.ThumbnailMimeType
	inputInlineQueryResultAnimation.VideoURL = tempObj.VideoURL
	inputInlineQueryResultAnimation.VideoMimeType = tempObj.VideoMimeType
	inputInlineQueryResultAnimation.VideoDuration = tempObj.VideoDuration
	inputInlineQueryResultAnimation.VideoWidth = tempObj.VideoWidth
	inputInlineQueryResultAnimation.VideoHeight = tempObj.VideoHeight

	fieldReplyMarkup, _ := unmarshalReplyMarkup(objMap["reply_markup"])
	inputInlineQueryResultAnimation.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := unmarshalInputMessageContent(objMap["input_message_content"])
	inputInlineQueryResultAnimation.InputMessageContent = fieldInputMessageContent

	return nil
}

// GetInputInlineQueryResultEnum return the enum type of this object
func (inputInlineQueryResultAnimation *InputInlineQueryResultAnimation) GetInputInlineQueryResultEnum() InputInlineQueryResultEnum {
	return InputInlineQueryResultAnimationType
}

// InputInlineQueryResultArticle Represents a link to an article or web page
type InputInlineQueryResultArticle struct {
	tdCommon
	ID                  string              `json:"id"`                    // Unique identifier of the query result
	URL                 string              `json:"url"`                   // URL of the result, if it exists
	HideURL             bool                `json:"hide_url"`              // True, if the URL must be not shown
	Title               string              `json:"title"`                 // Title of the result
	Description         string              `json:"description"`           // A short description of the result
	ThumbnailURL        string              `json:"thumbnail_url"`         // URL of the result thumbnail, if it exists
	ThumbnailWidth      int32               `json:"thumbnail_width"`       // Thumbnail width, if known
	ThumbnailHeight     int32               `json:"thumbnail_height"`      // Thumbnail height, if known
	ReplyMarkup         ReplyMarkup         `json:"reply_markup"`          // The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	InputMessageContent InputMessageContent `json:"input_message_content"` // The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
}

// MessageType return the string telegram-type of InputInlineQueryResultArticle
func (inputInlineQueryResultArticle *InputInlineQueryResultArticle) MessageType() string {
	return "inputInlineQueryResultArticle"
}

// NewInputInlineQueryResultArticle creates a new InputInlineQueryResultArticle
//
// @param iD Unique identifier of the query result
// @param uRL URL of the result, if it exists
// @param hideURL True, if the URL must be not shown
// @param title Title of the result
// @param description A short description of the result
// @param thumbnailURL URL of the result thumbnail, if it exists
// @param thumbnailWidth Thumbnail width, if known
// @param thumbnailHeight Thumbnail height, if known
// @param replyMarkup The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
// @param inputMessageContent The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
func NewInputInlineQueryResultArticle(iD string, uRL string, hideURL bool, title string, description string, thumbnailURL string, thumbnailWidth int32, thumbnailHeight int32, replyMarkup ReplyMarkup, inputMessageContent InputMessageContent) *InputInlineQueryResultArticle {
	inputInlineQueryResultArticleTemp := InputInlineQueryResultArticle{
		tdCommon:            tdCommon{Type: "inputInlineQueryResultArticle"},
		ID:                  iD,
		URL:                 uRL,
		HideURL:             hideURL,
		Title:               title,
		Description:         description,
		ThumbnailURL:        thumbnailURL,
		ThumbnailWidth:      thumbnailWidth,
		ThumbnailHeight:     thumbnailHeight,
		ReplyMarkup:         replyMarkup,
		InputMessageContent: inputMessageContent,
	}

	return &inputInlineQueryResultArticleTemp
}

// UnmarshalJSON unmarshal to json
func (inputInlineQueryResultArticle *InputInlineQueryResultArticle) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID              string `json:"id"`               // Unique identifier of the query result
		URL             string `json:"url"`              // URL of the result, if it exists
		HideURL         bool   `json:"hide_url"`         // True, if the URL must be not shown
		Title           string `json:"title"`            // Title of the result
		Description     string `json:"description"`      // A short description of the result
		ThumbnailURL    string `json:"thumbnail_url"`    // URL of the result thumbnail, if it exists
		ThumbnailWidth  int32  `json:"thumbnail_width"`  // Thumbnail width, if known
		ThumbnailHeight int32  `json:"thumbnail_height"` // Thumbnail height, if known

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputInlineQueryResultArticle.tdCommon = tempObj.tdCommon
	inputInlineQueryResultArticle.ID = tempObj.ID
	inputInlineQueryResultArticle.URL = tempObj.URL
	inputInlineQueryResultArticle.HideURL = tempObj.HideURL
	inputInlineQueryResultArticle.Title = tempObj.Title
	inputInlineQueryResultArticle.Description = tempObj.Description
	inputInlineQueryResultArticle.ThumbnailURL = tempObj.ThumbnailURL
	inputInlineQueryResultArticle.ThumbnailWidth = tempObj.ThumbnailWidth
	inputInlineQueryResultArticle.ThumbnailHeight = tempObj.ThumbnailHeight

	fieldReplyMarkup, _ := unmarshalReplyMarkup(objMap["reply_markup"])
	inputInlineQueryResultArticle.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := unmarshalInputMessageContent(objMap["input_message_content"])
	inputInlineQueryResultArticle.InputMessageContent = fieldInputMessageContent

	return nil
}

// GetInputInlineQueryResultEnum return the enum type of this object
func (inputInlineQueryResultArticle *InputInlineQueryResultArticle) GetInputInlineQueryResultEnum() InputInlineQueryResultEnum {
	return InputInlineQueryResultArticleType
}

// InputInlineQueryResultAudio Represents a link to an MP3 audio file
type InputInlineQueryResultAudio struct {
	tdCommon
	ID                  string              `json:"id"`                    // Unique identifier of the query result
	Title               string              `json:"title"`                 // Title of the audio file
	Performer           string              `json:"performer"`             // Performer of the audio file
	AudioURL            string              `json:"audio_url"`             // The URL of the audio file
	AudioDuration       int32               `json:"audio_duration"`        // Audio file duration, in seconds
	ReplyMarkup         ReplyMarkup         `json:"reply_markup"`          // The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	InputMessageContent InputMessageContent `json:"input_message_content"` // The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageAudio, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
}

// MessageType return the string telegram-type of InputInlineQueryResultAudio
func (inputInlineQueryResultAudio *InputInlineQueryResultAudio) MessageType() string {
	return "inputInlineQueryResultAudio"
}

// NewInputInlineQueryResultAudio creates a new InputInlineQueryResultAudio
//
// @param iD Unique identifier of the query result
// @param title Title of the audio file
// @param performer Performer of the audio file
// @param audioURL The URL of the audio file
// @param audioDuration Audio file duration, in seconds
// @param replyMarkup The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
// @param inputMessageContent The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageAudio, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
func NewInputInlineQueryResultAudio(iD string, title string, performer string, audioURL string, audioDuration int32, replyMarkup ReplyMarkup, inputMessageContent InputMessageContent) *InputInlineQueryResultAudio {
	inputInlineQueryResultAudioTemp := InputInlineQueryResultAudio{
		tdCommon:            tdCommon{Type: "inputInlineQueryResultAudio"},
		ID:                  iD,
		Title:               title,
		Performer:           performer,
		AudioURL:            audioURL,
		AudioDuration:       audioDuration,
		ReplyMarkup:         replyMarkup,
		InputMessageContent: inputMessageContent,
	}

	return &inputInlineQueryResultAudioTemp
}

// UnmarshalJSON unmarshal to json
func (inputInlineQueryResultAudio *InputInlineQueryResultAudio) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID            string `json:"id"`             // Unique identifier of the query result
		Title         string `json:"title"`          // Title of the audio file
		Performer     string `json:"performer"`      // Performer of the audio file
		AudioURL      string `json:"audio_url"`      // The URL of the audio file
		AudioDuration int32  `json:"audio_duration"` // Audio file duration, in seconds

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputInlineQueryResultAudio.tdCommon = tempObj.tdCommon
	inputInlineQueryResultAudio.ID = tempObj.ID
	inputInlineQueryResultAudio.Title = tempObj.Title
	inputInlineQueryResultAudio.Performer = tempObj.Performer
	inputInlineQueryResultAudio.AudioURL = tempObj.AudioURL
	inputInlineQueryResultAudio.AudioDuration = tempObj.AudioDuration

	fieldReplyMarkup, _ := unmarshalReplyMarkup(objMap["reply_markup"])
	inputInlineQueryResultAudio.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := unmarshalInputMessageContent(objMap["input_message_content"])
	inputInlineQueryResultAudio.InputMessageContent = fieldInputMessageContent

	return nil
}

// GetInputInlineQueryResultEnum return the enum type of this object
func (inputInlineQueryResultAudio *InputInlineQueryResultAudio) GetInputInlineQueryResultEnum() InputInlineQueryResultEnum {
	return InputInlineQueryResultAudioType
}

// InputInlineQueryResultContact Represents a user contact
type InputInlineQueryResultContact struct {
	tdCommon
	ID                  string              `json:"id"`                    // Unique identifier of the query result
	Contact             *Contact            `json:"contact"`               // User contact
	ThumbnailURL        string              `json:"thumbnail_url"`         // URL of the result thumbnail, if it exists
	ThumbnailWidth      int32               `json:"thumbnail_width"`       // Thumbnail width, if known
	ThumbnailHeight     int32               `json:"thumbnail_height"`      // Thumbnail height, if known
	ReplyMarkup         ReplyMarkup         `json:"reply_markup"`          // The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	InputMessageContent InputMessageContent `json:"input_message_content"` // The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
}

// MessageType return the string telegram-type of InputInlineQueryResultContact
func (inputInlineQueryResultContact *InputInlineQueryResultContact) MessageType() string {
	return "inputInlineQueryResultContact"
}

// NewInputInlineQueryResultContact creates a new InputInlineQueryResultContact
//
// @param iD Unique identifier of the query result
// @param contact User contact
// @param thumbnailURL URL of the result thumbnail, if it exists
// @param thumbnailWidth Thumbnail width, if known
// @param thumbnailHeight Thumbnail height, if known
// @param replyMarkup The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
// @param inputMessageContent The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
func NewInputInlineQueryResultContact(iD string, contact *Contact, thumbnailURL string, thumbnailWidth int32, thumbnailHeight int32, replyMarkup ReplyMarkup, inputMessageContent InputMessageContent) *InputInlineQueryResultContact {
	inputInlineQueryResultContactTemp := InputInlineQueryResultContact{
		tdCommon:            tdCommon{Type: "inputInlineQueryResultContact"},
		ID:                  iD,
		Contact:             contact,
		ThumbnailURL:        thumbnailURL,
		ThumbnailWidth:      thumbnailWidth,
		ThumbnailHeight:     thumbnailHeight,
		ReplyMarkup:         replyMarkup,
		InputMessageContent: inputMessageContent,
	}

	return &inputInlineQueryResultContactTemp
}

// UnmarshalJSON unmarshal to json
func (inputInlineQueryResultContact *InputInlineQueryResultContact) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID              string   `json:"id"`               // Unique identifier of the query result
		Contact         *Contact `json:"contact"`          // User contact
		ThumbnailURL    string   `json:"thumbnail_url"`    // URL of the result thumbnail, if it exists
		ThumbnailWidth  int32    `json:"thumbnail_width"`  // Thumbnail width, if known
		ThumbnailHeight int32    `json:"thumbnail_height"` // Thumbnail height, if known

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputInlineQueryResultContact.tdCommon = tempObj.tdCommon
	inputInlineQueryResultContact.ID = tempObj.ID
	inputInlineQueryResultContact.Contact = tempObj.Contact
	inputInlineQueryResultContact.ThumbnailURL = tempObj.ThumbnailURL
	inputInlineQueryResultContact.ThumbnailWidth = tempObj.ThumbnailWidth
	inputInlineQueryResultContact.ThumbnailHeight = tempObj.ThumbnailHeight

	fieldReplyMarkup, _ := unmarshalReplyMarkup(objMap["reply_markup"])
	inputInlineQueryResultContact.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := unmarshalInputMessageContent(objMap["input_message_content"])
	inputInlineQueryResultContact.InputMessageContent = fieldInputMessageContent

	return nil
}

// GetInputInlineQueryResultEnum return the enum type of this object
func (inputInlineQueryResultContact *InputInlineQueryResultContact) GetInputInlineQueryResultEnum() InputInlineQueryResultEnum {
	return InputInlineQueryResultContactType
}

// InputInlineQueryResultDocument Represents a link to a file
type InputInlineQueryResultDocument struct {
	tdCommon
	ID                  string              `json:"id"`                    // Unique identifier of the query result
	Title               string              `json:"title"`                 // Title of the resulting file
	Description         string              `json:"description"`           // Short description of the result, if known
	DocumentURL         string              `json:"document_url"`          // URL of the file
	MimeType            string              `json:"mime_type"`             // MIME type of the file content; only "application/pdf" and "application/zip" are currently allowed
	ThumbnailURL        string              `json:"thumbnail_url"`         // The URL of the file thumbnail, if it exists
	ThumbnailWidth      int32               `json:"thumbnail_width"`       // Width of the thumbnail
	ThumbnailHeight     int32               `json:"thumbnail_height"`      // Height of the thumbnail
	ReplyMarkup         ReplyMarkup         `json:"reply_markup"`          // The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	InputMessageContent InputMessageContent `json:"input_message_content"` // The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageDocument, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
}

// MessageType return the string telegram-type of InputInlineQueryResultDocument
func (inputInlineQueryResultDocument *InputInlineQueryResultDocument) MessageType() string {
	return "inputInlineQueryResultDocument"
}

// NewInputInlineQueryResultDocument creates a new InputInlineQueryResultDocument
//
// @param iD Unique identifier of the query result
// @param title Title of the resulting file
// @param description Short description of the result, if known
// @param documentURL URL of the file
// @param mimeType MIME type of the file content; only "application/pdf" and "application/zip" are currently allowed
// @param thumbnailURL The URL of the file thumbnail, if it exists
// @param thumbnailWidth Width of the thumbnail
// @param thumbnailHeight Height of the thumbnail
// @param replyMarkup The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
// @param inputMessageContent The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageDocument, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
func NewInputInlineQueryResultDocument(iD string, title string, description string, documentURL string, mimeType string, thumbnailURL string, thumbnailWidth int32, thumbnailHeight int32, replyMarkup ReplyMarkup, inputMessageContent InputMessageContent) *InputInlineQueryResultDocument {
	inputInlineQueryResultDocumentTemp := InputInlineQueryResultDocument{
		tdCommon:            tdCommon{Type: "inputInlineQueryResultDocument"},
		ID:                  iD,
		Title:               title,
		Description:         description,
		DocumentURL:         documentURL,
		MimeType:            mimeType,
		ThumbnailURL:        thumbnailURL,
		ThumbnailWidth:      thumbnailWidth,
		ThumbnailHeight:     thumbnailHeight,
		ReplyMarkup:         replyMarkup,
		InputMessageContent: inputMessageContent,
	}

	return &inputInlineQueryResultDocumentTemp
}

// UnmarshalJSON unmarshal to json
func (inputInlineQueryResultDocument *InputInlineQueryResultDocument) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID              string `json:"id"`               // Unique identifier of the query result
		Title           string `json:"title"`            // Title of the resulting file
		Description     string `json:"description"`      // Short description of the result, if known
		DocumentURL     string `json:"document_url"`     // URL of the file
		MimeType        string `json:"mime_type"`        // MIME type of the file content; only "application/pdf" and "application/zip" are currently allowed
		ThumbnailURL    string `json:"thumbnail_url"`    // The URL of the file thumbnail, if it exists
		ThumbnailWidth  int32  `json:"thumbnail_width"`  // Width of the thumbnail
		ThumbnailHeight int32  `json:"thumbnail_height"` // Height of the thumbnail

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputInlineQueryResultDocument.tdCommon = tempObj.tdCommon
	inputInlineQueryResultDocument.ID = tempObj.ID
	inputInlineQueryResultDocument.Title = tempObj.Title
	inputInlineQueryResultDocument.Description = tempObj.Description
	inputInlineQueryResultDocument.DocumentURL = tempObj.DocumentURL
	inputInlineQueryResultDocument.MimeType = tempObj.MimeType
	inputInlineQueryResultDocument.ThumbnailURL = tempObj.ThumbnailURL
	inputInlineQueryResultDocument.ThumbnailWidth = tempObj.ThumbnailWidth
	inputInlineQueryResultDocument.ThumbnailHeight = tempObj.ThumbnailHeight

	fieldReplyMarkup, _ := unmarshalReplyMarkup(objMap["reply_markup"])
	inputInlineQueryResultDocument.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := unmarshalInputMessageContent(objMap["input_message_content"])
	inputInlineQueryResultDocument.InputMessageContent = fieldInputMessageContent

	return nil
}

// GetInputInlineQueryResultEnum return the enum type of this object
func (inputInlineQueryResultDocument *InputInlineQueryResultDocument) GetInputInlineQueryResultEnum() InputInlineQueryResultEnum {
	return InputInlineQueryResultDocumentType
}

// InputInlineQueryResultGame Represents a game
type InputInlineQueryResultGame struct {
	tdCommon
	ID            string      `json:"id"`              // Unique identifier of the query result
	GameShortName string      `json:"game_short_name"` // Short name of the game
	ReplyMarkup   ReplyMarkup `json:"reply_markup"`    // The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
}

// MessageType return the string telegram-type of InputInlineQueryResultGame
func (inputInlineQueryResultGame *InputInlineQueryResultGame) MessageType() string {
	return "inputInlineQueryResultGame"
}

// NewInputInlineQueryResultGame creates a new InputInlineQueryResultGame
//
// @param iD Unique identifier of the query result
// @param gameShortName Short name of the game
// @param replyMarkup The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
func NewInputInlineQueryResultGame(iD string, gameShortName string, replyMarkup ReplyMarkup) *InputInlineQueryResultGame {
	inputInlineQueryResultGameTemp := InputInlineQueryResultGame{
		tdCommon:      tdCommon{Type: "inputInlineQueryResultGame"},
		ID:            iD,
		GameShortName: gameShortName,
		ReplyMarkup:   replyMarkup,
	}

	return &inputInlineQueryResultGameTemp
}

// UnmarshalJSON unmarshal to json
func (inputInlineQueryResultGame *InputInlineQueryResultGame) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID            string `json:"id"`              // Unique identifier of the query result
		GameShortName string `json:"game_short_name"` // Short name of the game

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputInlineQueryResultGame.tdCommon = tempObj.tdCommon
	inputInlineQueryResultGame.ID = tempObj.ID
	inputInlineQueryResultGame.GameShortName = tempObj.GameShortName

	fieldReplyMarkup, _ := unmarshalReplyMarkup(objMap["reply_markup"])
	inputInlineQueryResultGame.ReplyMarkup = fieldReplyMarkup

	return nil
}

// GetInputInlineQueryResultEnum return the enum type of this object
func (inputInlineQueryResultGame *InputInlineQueryResultGame) GetInputInlineQueryResultEnum() InputInlineQueryResultEnum {
	return InputInlineQueryResultGameType
}

// InputInlineQueryResultLocation Represents a point on the map
type InputInlineQueryResultLocation struct {
	tdCommon
	ID                  string              `json:"id"`                    // Unique identifier of the query result
	Location            *Location           `json:"location"`              // Location result
	LivePeriod          int32               `json:"live_period"`           // Amount of time relative to the message sent time until the location can be updated, in seconds
	Title               string              `json:"title"`                 // Title of the result
	ThumbnailURL        string              `json:"thumbnail_url"`         // URL of the result thumbnail, if it exists
	ThumbnailWidth      int32               `json:"thumbnail_width"`       // Thumbnail width, if known
	ThumbnailHeight     int32               `json:"thumbnail_height"`      // Thumbnail height, if known
	ReplyMarkup         ReplyMarkup         `json:"reply_markup"`          // The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	InputMessageContent InputMessageContent `json:"input_message_content"` // The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
}

// MessageType return the string telegram-type of InputInlineQueryResultLocation
func (inputInlineQueryResultLocation *InputInlineQueryResultLocation) MessageType() string {
	return "inputInlineQueryResultLocation"
}

// NewInputInlineQueryResultLocation creates a new InputInlineQueryResultLocation
//
// @param iD Unique identifier of the query result
// @param location Location result
// @param livePeriod Amount of time relative to the message sent time until the location can be updated, in seconds
// @param title Title of the result
// @param thumbnailURL URL of the result thumbnail, if it exists
// @param thumbnailWidth Thumbnail width, if known
// @param thumbnailHeight Thumbnail height, if known
// @param replyMarkup The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
// @param inputMessageContent The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
func NewInputInlineQueryResultLocation(iD string, location *Location, livePeriod int32, title string, thumbnailURL string, thumbnailWidth int32, thumbnailHeight int32, replyMarkup ReplyMarkup, inputMessageContent InputMessageContent) *InputInlineQueryResultLocation {
	inputInlineQueryResultLocationTemp := InputInlineQueryResultLocation{
		tdCommon:            tdCommon{Type: "inputInlineQueryResultLocation"},
		ID:                  iD,
		Location:            location,
		LivePeriod:          livePeriod,
		Title:               title,
		ThumbnailURL:        thumbnailURL,
		ThumbnailWidth:      thumbnailWidth,
		ThumbnailHeight:     thumbnailHeight,
		ReplyMarkup:         replyMarkup,
		InputMessageContent: inputMessageContent,
	}

	return &inputInlineQueryResultLocationTemp
}

// UnmarshalJSON unmarshal to json
func (inputInlineQueryResultLocation *InputInlineQueryResultLocation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID              string    `json:"id"`               // Unique identifier of the query result
		Location        *Location `json:"location"`         // Location result
		LivePeriod      int32     `json:"live_period"`      // Amount of time relative to the message sent time until the location can be updated, in seconds
		Title           string    `json:"title"`            // Title of the result
		ThumbnailURL    string    `json:"thumbnail_url"`    // URL of the result thumbnail, if it exists
		ThumbnailWidth  int32     `json:"thumbnail_width"`  // Thumbnail width, if known
		ThumbnailHeight int32     `json:"thumbnail_height"` // Thumbnail height, if known

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputInlineQueryResultLocation.tdCommon = tempObj.tdCommon
	inputInlineQueryResultLocation.ID = tempObj.ID
	inputInlineQueryResultLocation.Location = tempObj.Location
	inputInlineQueryResultLocation.LivePeriod = tempObj.LivePeriod
	inputInlineQueryResultLocation.Title = tempObj.Title
	inputInlineQueryResultLocation.ThumbnailURL = tempObj.ThumbnailURL
	inputInlineQueryResultLocation.ThumbnailWidth = tempObj.ThumbnailWidth
	inputInlineQueryResultLocation.ThumbnailHeight = tempObj.ThumbnailHeight

	fieldReplyMarkup, _ := unmarshalReplyMarkup(objMap["reply_markup"])
	inputInlineQueryResultLocation.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := unmarshalInputMessageContent(objMap["input_message_content"])
	inputInlineQueryResultLocation.InputMessageContent = fieldInputMessageContent

	return nil
}

// GetInputInlineQueryResultEnum return the enum type of this object
func (inputInlineQueryResultLocation *InputInlineQueryResultLocation) GetInputInlineQueryResultEnum() InputInlineQueryResultEnum {
	return InputInlineQueryResultLocationType
}

// InputInlineQueryResultPhoto Represents link to a JPEG image
type InputInlineQueryResultPhoto struct {
	tdCommon
	ID                  string              `json:"id"`                    // Unique identifier of the query result
	Title               string              `json:"title"`                 // Title of the result, if known
	Description         string              `json:"description"`           // A short description of the result, if known
	ThumbnailURL        string              `json:"thumbnail_url"`         // URL of the photo thumbnail, if it exists
	PhotoURL            string              `json:"photo_url"`             // The URL of the JPEG photo (photo size must not exceed 5MB)
	PhotoWidth          int32               `json:"photo_width"`           // Width of the photo
	PhotoHeight         int32               `json:"photo_height"`          // Height of the photo
	ReplyMarkup         ReplyMarkup         `json:"reply_markup"`          // The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	InputMessageContent InputMessageContent `json:"input_message_content"` // The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessagePhoto, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
}

// MessageType return the string telegram-type of InputInlineQueryResultPhoto
func (inputInlineQueryResultPhoto *InputInlineQueryResultPhoto) MessageType() string {
	return "inputInlineQueryResultPhoto"
}

// NewInputInlineQueryResultPhoto creates a new InputInlineQueryResultPhoto
//
// @param iD Unique identifier of the query result
// @param title Title of the result, if known
// @param description A short description of the result, if known
// @param thumbnailURL URL of the photo thumbnail, if it exists
// @param photoURL The URL of the JPEG photo (photo size must not exceed 5MB)
// @param photoWidth Width of the photo
// @param photoHeight Height of the photo
// @param replyMarkup The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
// @param inputMessageContent The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessagePhoto, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
func NewInputInlineQueryResultPhoto(iD string, title string, description string, thumbnailURL string, photoURL string, photoWidth int32, photoHeight int32, replyMarkup ReplyMarkup, inputMessageContent InputMessageContent) *InputInlineQueryResultPhoto {
	inputInlineQueryResultPhotoTemp := InputInlineQueryResultPhoto{
		tdCommon:            tdCommon{Type: "inputInlineQueryResultPhoto"},
		ID:                  iD,
		Title:               title,
		Description:         description,
		ThumbnailURL:        thumbnailURL,
		PhotoURL:            photoURL,
		PhotoWidth:          photoWidth,
		PhotoHeight:         photoHeight,
		ReplyMarkup:         replyMarkup,
		InputMessageContent: inputMessageContent,
	}

	return &inputInlineQueryResultPhotoTemp
}

// UnmarshalJSON unmarshal to json
func (inputInlineQueryResultPhoto *InputInlineQueryResultPhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID           string `json:"id"`            // Unique identifier of the query result
		Title        string `json:"title"`         // Title of the result, if known
		Description  string `json:"description"`   // A short description of the result, if known
		ThumbnailURL string `json:"thumbnail_url"` // URL of the photo thumbnail, if it exists
		PhotoURL     string `json:"photo_url"`     // The URL of the JPEG photo (photo size must not exceed 5MB)
		PhotoWidth   int32  `json:"photo_width"`   // Width of the photo
		PhotoHeight  int32  `json:"photo_height"`  // Height of the photo

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputInlineQueryResultPhoto.tdCommon = tempObj.tdCommon
	inputInlineQueryResultPhoto.ID = tempObj.ID
	inputInlineQueryResultPhoto.Title = tempObj.Title
	inputInlineQueryResultPhoto.Description = tempObj.Description
	inputInlineQueryResultPhoto.ThumbnailURL = tempObj.ThumbnailURL
	inputInlineQueryResultPhoto.PhotoURL = tempObj.PhotoURL
	inputInlineQueryResultPhoto.PhotoWidth = tempObj.PhotoWidth
	inputInlineQueryResultPhoto.PhotoHeight = tempObj.PhotoHeight

	fieldReplyMarkup, _ := unmarshalReplyMarkup(objMap["reply_markup"])
	inputInlineQueryResultPhoto.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := unmarshalInputMessageContent(objMap["input_message_content"])
	inputInlineQueryResultPhoto.InputMessageContent = fieldInputMessageContent

	return nil
}

// GetInputInlineQueryResultEnum return the enum type of this object
func (inputInlineQueryResultPhoto *InputInlineQueryResultPhoto) GetInputInlineQueryResultEnum() InputInlineQueryResultEnum {
	return InputInlineQueryResultPhotoType
}

// InputInlineQueryResultSticker Represents a link to a WEBP, TGS, or WEBM sticker
type InputInlineQueryResultSticker struct {
	tdCommon
	ID                  string              `json:"id"`                    // Unique identifier of the query result
	ThumbnailURL        string              `json:"thumbnail_url"`         // URL of the sticker thumbnail, if it exists
	StickerURL          string              `json:"sticker_url"`           // The URL of the WEBP, TGS, or WEBM sticker (sticker file size must not exceed 5MB)
	StickerWidth        int32               `json:"sticker_width"`         // Width of the sticker
	StickerHeight       int32               `json:"sticker_height"`        // Height of the sticker
	ReplyMarkup         ReplyMarkup         `json:"reply_markup"`          // The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	InputMessageContent InputMessageContent `json:"input_message_content"` // The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageSticker, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
}

// MessageType return the string telegram-type of InputInlineQueryResultSticker
func (inputInlineQueryResultSticker *InputInlineQueryResultSticker) MessageType() string {
	return "inputInlineQueryResultSticker"
}

// NewInputInlineQueryResultSticker creates a new InputInlineQueryResultSticker
//
// @param iD Unique identifier of the query result
// @param thumbnailURL URL of the sticker thumbnail, if it exists
// @param stickerURL The URL of the WEBP, TGS, or WEBM sticker (sticker file size must not exceed 5MB)
// @param stickerWidth Width of the sticker
// @param stickerHeight Height of the sticker
// @param replyMarkup The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
// @param inputMessageContent The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageSticker, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
func NewInputInlineQueryResultSticker(iD string, thumbnailURL string, stickerURL string, stickerWidth int32, stickerHeight int32, replyMarkup ReplyMarkup, inputMessageContent InputMessageContent) *InputInlineQueryResultSticker {
	inputInlineQueryResultStickerTemp := InputInlineQueryResultSticker{
		tdCommon:            tdCommon{Type: "inputInlineQueryResultSticker"},
		ID:                  iD,
		ThumbnailURL:        thumbnailURL,
		StickerURL:          stickerURL,
		StickerWidth:        stickerWidth,
		StickerHeight:       stickerHeight,
		ReplyMarkup:         replyMarkup,
		InputMessageContent: inputMessageContent,
	}

	return &inputInlineQueryResultStickerTemp
}

// UnmarshalJSON unmarshal to json
func (inputInlineQueryResultSticker *InputInlineQueryResultSticker) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID            string `json:"id"`             // Unique identifier of the query result
		ThumbnailURL  string `json:"thumbnail_url"`  // URL of the sticker thumbnail, if it exists
		StickerURL    string `json:"sticker_url"`    // The URL of the WEBP, TGS, or WEBM sticker (sticker file size must not exceed 5MB)
		StickerWidth  int32  `json:"sticker_width"`  // Width of the sticker
		StickerHeight int32  `json:"sticker_height"` // Height of the sticker

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputInlineQueryResultSticker.tdCommon = tempObj.tdCommon
	inputInlineQueryResultSticker.ID = tempObj.ID
	inputInlineQueryResultSticker.ThumbnailURL = tempObj.ThumbnailURL
	inputInlineQueryResultSticker.StickerURL = tempObj.StickerURL
	inputInlineQueryResultSticker.StickerWidth = tempObj.StickerWidth
	inputInlineQueryResultSticker.StickerHeight = tempObj.StickerHeight

	fieldReplyMarkup, _ := unmarshalReplyMarkup(objMap["reply_markup"])
	inputInlineQueryResultSticker.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := unmarshalInputMessageContent(objMap["input_message_content"])
	inputInlineQueryResultSticker.InputMessageContent = fieldInputMessageContent

	return nil
}

// GetInputInlineQueryResultEnum return the enum type of this object
func (inputInlineQueryResultSticker *InputInlineQueryResultSticker) GetInputInlineQueryResultEnum() InputInlineQueryResultEnum {
	return InputInlineQueryResultStickerType
}

// InputInlineQueryResultVenue Represents information about a venue
type InputInlineQueryResultVenue struct {
	tdCommon
	ID                  string              `json:"id"`                    // Unique identifier of the query result
	Venue               *Venue              `json:"venue"`                 // Venue result
	ThumbnailURL        string              `json:"thumbnail_url"`         // URL of the result thumbnail, if it exists
	ThumbnailWidth      int32               `json:"thumbnail_width"`       // Thumbnail width, if known
	ThumbnailHeight     int32               `json:"thumbnail_height"`      // Thumbnail height, if known
	ReplyMarkup         ReplyMarkup         `json:"reply_markup"`          // The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	InputMessageContent InputMessageContent `json:"input_message_content"` // The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
}

// MessageType return the string telegram-type of InputInlineQueryResultVenue
func (inputInlineQueryResultVenue *InputInlineQueryResultVenue) MessageType() string {
	return "inputInlineQueryResultVenue"
}

// NewInputInlineQueryResultVenue creates a new InputInlineQueryResultVenue
//
// @param iD Unique identifier of the query result
// @param venue Venue result
// @param thumbnailURL URL of the result thumbnail, if it exists
// @param thumbnailWidth Thumbnail width, if known
// @param thumbnailHeight Thumbnail height, if known
// @param replyMarkup The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
// @param inputMessageContent The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
func NewInputInlineQueryResultVenue(iD string, venue *Venue, thumbnailURL string, thumbnailWidth int32, thumbnailHeight int32, replyMarkup ReplyMarkup, inputMessageContent InputMessageContent) *InputInlineQueryResultVenue {
	inputInlineQueryResultVenueTemp := InputInlineQueryResultVenue{
		tdCommon:            tdCommon{Type: "inputInlineQueryResultVenue"},
		ID:                  iD,
		Venue:               venue,
		ThumbnailURL:        thumbnailURL,
		ThumbnailWidth:      thumbnailWidth,
		ThumbnailHeight:     thumbnailHeight,
		ReplyMarkup:         replyMarkup,
		InputMessageContent: inputMessageContent,
	}

	return &inputInlineQueryResultVenueTemp
}

// UnmarshalJSON unmarshal to json
func (inputInlineQueryResultVenue *InputInlineQueryResultVenue) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID              string `json:"id"`               // Unique identifier of the query result
		Venue           *Venue `json:"venue"`            // Venue result
		ThumbnailURL    string `json:"thumbnail_url"`    // URL of the result thumbnail, if it exists
		ThumbnailWidth  int32  `json:"thumbnail_width"`  // Thumbnail width, if known
		ThumbnailHeight int32  `json:"thumbnail_height"` // Thumbnail height, if known

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputInlineQueryResultVenue.tdCommon = tempObj.tdCommon
	inputInlineQueryResultVenue.ID = tempObj.ID
	inputInlineQueryResultVenue.Venue = tempObj.Venue
	inputInlineQueryResultVenue.ThumbnailURL = tempObj.ThumbnailURL
	inputInlineQueryResultVenue.ThumbnailWidth = tempObj.ThumbnailWidth
	inputInlineQueryResultVenue.ThumbnailHeight = tempObj.ThumbnailHeight

	fieldReplyMarkup, _ := unmarshalReplyMarkup(objMap["reply_markup"])
	inputInlineQueryResultVenue.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := unmarshalInputMessageContent(objMap["input_message_content"])
	inputInlineQueryResultVenue.InputMessageContent = fieldInputMessageContent

	return nil
}

// GetInputInlineQueryResultEnum return the enum type of this object
func (inputInlineQueryResultVenue *InputInlineQueryResultVenue) GetInputInlineQueryResultEnum() InputInlineQueryResultEnum {
	return InputInlineQueryResultVenueType
}

// InputInlineQueryResultVideo Represents a link to a page containing an embedded video player or a video file
type InputInlineQueryResultVideo struct {
	tdCommon
	ID                  string              `json:"id"`                    // Unique identifier of the query result
	Title               string              `json:"title"`                 // Title of the result
	Description         string              `json:"description"`           // A short description of the result, if known
	ThumbnailURL        string              `json:"thumbnail_url"`         // The URL of the video thumbnail (JPEG), if it exists
	VideoURL            string              `json:"video_url"`             // URL of the embedded video player or video file
	MimeType            string              `json:"mime_type"`             // MIME type of the content of the video URL, only "text/html" or "video/mp4" are currently supported
	VideoWidth          int32               `json:"video_width"`           // Width of the video
	VideoHeight         int32               `json:"video_height"`          // Height of the video
	VideoDuration       int32               `json:"video_duration"`        // Video duration, in seconds
	ReplyMarkup         ReplyMarkup         `json:"reply_markup"`          // The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	InputMessageContent InputMessageContent `json:"input_message_content"` // The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageVideo, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
}

// MessageType return the string telegram-type of InputInlineQueryResultVideo
func (inputInlineQueryResultVideo *InputInlineQueryResultVideo) MessageType() string {
	return "inputInlineQueryResultVideo"
}

// NewInputInlineQueryResultVideo creates a new InputInlineQueryResultVideo
//
// @param iD Unique identifier of the query result
// @param title Title of the result
// @param description A short description of the result, if known
// @param thumbnailURL The URL of the video thumbnail (JPEG), if it exists
// @param videoURL URL of the embedded video player or video file
// @param mimeType MIME type of the content of the video URL, only "text/html" or "video/mp4" are currently supported
// @param videoWidth Width of the video
// @param videoHeight Height of the video
// @param videoDuration Video duration, in seconds
// @param replyMarkup The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
// @param inputMessageContent The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageVideo, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
func NewInputInlineQueryResultVideo(iD string, title string, description string, thumbnailURL string, videoURL string, mimeType string, videoWidth int32, videoHeight int32, videoDuration int32, replyMarkup ReplyMarkup, inputMessageContent InputMessageContent) *InputInlineQueryResultVideo {
	inputInlineQueryResultVideoTemp := InputInlineQueryResultVideo{
		tdCommon:            tdCommon{Type: "inputInlineQueryResultVideo"},
		ID:                  iD,
		Title:               title,
		Description:         description,
		ThumbnailURL:        thumbnailURL,
		VideoURL:            videoURL,
		MimeType:            mimeType,
		VideoWidth:          videoWidth,
		VideoHeight:         videoHeight,
		VideoDuration:       videoDuration,
		ReplyMarkup:         replyMarkup,
		InputMessageContent: inputMessageContent,
	}

	return &inputInlineQueryResultVideoTemp
}

// UnmarshalJSON unmarshal to json
func (inputInlineQueryResultVideo *InputInlineQueryResultVideo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID            string `json:"id"`             // Unique identifier of the query result
		Title         string `json:"title"`          // Title of the result
		Description   string `json:"description"`    // A short description of the result, if known
		ThumbnailURL  string `json:"thumbnail_url"`  // The URL of the video thumbnail (JPEG), if it exists
		VideoURL      string `json:"video_url"`      // URL of the embedded video player or video file
		MimeType      string `json:"mime_type"`      // MIME type of the content of the video URL, only "text/html" or "video/mp4" are currently supported
		VideoWidth    int32  `json:"video_width"`    // Width of the video
		VideoHeight   int32  `json:"video_height"`   // Height of the video
		VideoDuration int32  `json:"video_duration"` // Video duration, in seconds

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputInlineQueryResultVideo.tdCommon = tempObj.tdCommon
	inputInlineQueryResultVideo.ID = tempObj.ID
	inputInlineQueryResultVideo.Title = tempObj.Title
	inputInlineQueryResultVideo.Description = tempObj.Description
	inputInlineQueryResultVideo.ThumbnailURL = tempObj.ThumbnailURL
	inputInlineQueryResultVideo.VideoURL = tempObj.VideoURL
	inputInlineQueryResultVideo.MimeType = tempObj.MimeType
	inputInlineQueryResultVideo.VideoWidth = tempObj.VideoWidth
	inputInlineQueryResultVideo.VideoHeight = tempObj.VideoHeight
	inputInlineQueryResultVideo.VideoDuration = tempObj.VideoDuration

	fieldReplyMarkup, _ := unmarshalReplyMarkup(objMap["reply_markup"])
	inputInlineQueryResultVideo.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := unmarshalInputMessageContent(objMap["input_message_content"])
	inputInlineQueryResultVideo.InputMessageContent = fieldInputMessageContent

	return nil
}

// GetInputInlineQueryResultEnum return the enum type of this object
func (inputInlineQueryResultVideo *InputInlineQueryResultVideo) GetInputInlineQueryResultEnum() InputInlineQueryResultEnum {
	return InputInlineQueryResultVideoType
}

// InputInlineQueryResultVoiceNote Represents a link to an opus-encoded audio file within an OGG container, single channel audio
type InputInlineQueryResultVoiceNote struct {
	tdCommon
	ID                  string              `json:"id"`                    // Unique identifier of the query result
	Title               string              `json:"title"`                 // Title of the voice note
	VoiceNoteURL        string              `json:"voice_note_url"`        // The URL of the voice note file
	VoiceNoteDuration   int32               `json:"voice_note_duration"`   // Duration of the voice note, in seconds
	ReplyMarkup         ReplyMarkup         `json:"reply_markup"`          // The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
	InputMessageContent InputMessageContent `json:"input_message_content"` // The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageVoiceNote, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
}

// MessageType return the string telegram-type of InputInlineQueryResultVoiceNote
func (inputInlineQueryResultVoiceNote *InputInlineQueryResultVoiceNote) MessageType() string {
	return "inputInlineQueryResultVoiceNote"
}

// NewInputInlineQueryResultVoiceNote creates a new InputInlineQueryResultVoiceNote
//
// @param iD Unique identifier of the query result
// @param title Title of the voice note
// @param voiceNoteURL The URL of the voice note file
// @param voiceNoteDuration Duration of the voice note, in seconds
// @param replyMarkup The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
// @param inputMessageContent The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageVoiceNote, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
func NewInputInlineQueryResultVoiceNote(iD string, title string, voiceNoteURL string, voiceNoteDuration int32, replyMarkup ReplyMarkup, inputMessageContent InputMessageContent) *InputInlineQueryResultVoiceNote {
	inputInlineQueryResultVoiceNoteTemp := InputInlineQueryResultVoiceNote{
		tdCommon:            tdCommon{Type: "inputInlineQueryResultVoiceNote"},
		ID:                  iD,
		Title:               title,
		VoiceNoteURL:        voiceNoteURL,
		VoiceNoteDuration:   voiceNoteDuration,
		ReplyMarkup:         replyMarkup,
		InputMessageContent: inputMessageContent,
	}

	return &inputInlineQueryResultVoiceNoteTemp
}

// UnmarshalJSON unmarshal to json
func (inputInlineQueryResultVoiceNote *InputInlineQueryResultVoiceNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID                string `json:"id"`                  // Unique identifier of the query result
		Title             string `json:"title"`               // Title of the voice note
		VoiceNoteURL      string `json:"voice_note_url"`      // The URL of the voice note file
		VoiceNoteDuration int32  `json:"voice_note_duration"` // Duration of the voice note, in seconds

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputInlineQueryResultVoiceNote.tdCommon = tempObj.tdCommon
	inputInlineQueryResultVoiceNote.ID = tempObj.ID
	inputInlineQueryResultVoiceNote.Title = tempObj.Title
	inputInlineQueryResultVoiceNote.VoiceNoteURL = tempObj.VoiceNoteURL
	inputInlineQueryResultVoiceNote.VoiceNoteDuration = tempObj.VoiceNoteDuration

	fieldReplyMarkup, _ := unmarshalReplyMarkup(objMap["reply_markup"])
	inputInlineQueryResultVoiceNote.ReplyMarkup = fieldReplyMarkup

	fieldInputMessageContent, _ := unmarshalInputMessageContent(objMap["input_message_content"])
	inputInlineQueryResultVoiceNote.InputMessageContent = fieldInputMessageContent

	return nil
}

// GetInputInlineQueryResultEnum return the enum type of this object
func (inputInlineQueryResultVoiceNote *InputInlineQueryResultVoiceNote) GetInputInlineQueryResultEnum() InputInlineQueryResultEnum {
	return InputInlineQueryResultVoiceNoteType
}

// InlineQueryResultArticle Represents a link to an article or web page
type InlineQueryResultArticle struct {
	tdCommon
	ID          string     `json:"id"`          // Unique identifier of the query result
	URL         string     `json:"url"`         // URL of the result, if it exists
	HideURL     bool       `json:"hide_url"`    // True, if the URL must be not shown
	Title       string     `json:"title"`       // Title of the result
	Description string     `json:"description"` // A short description of the result
	Thumbnail   *Thumbnail `json:"thumbnail"`   // Result thumbnail in JPEG format; may be null
}

// MessageType return the string telegram-type of InlineQueryResultArticle
func (inlineQueryResultArticle *InlineQueryResultArticle) MessageType() string {
	return "inlineQueryResultArticle"
}

// NewInlineQueryResultArticle creates a new InlineQueryResultArticle
//
// @param iD Unique identifier of the query result
// @param uRL URL of the result, if it exists
// @param hideURL True, if the URL must be not shown
// @param title Title of the result
// @param description A short description of the result
// @param thumbnail Result thumbnail in JPEG format; may be null
func NewInlineQueryResultArticle(iD string, uRL string, hideURL bool, title string, description string, thumbnail *Thumbnail) *InlineQueryResultArticle {
	inlineQueryResultArticleTemp := InlineQueryResultArticle{
		tdCommon:    tdCommon{Type: "inlineQueryResultArticle"},
		ID:          iD,
		URL:         uRL,
		HideURL:     hideURL,
		Title:       title,
		Description: description,
		Thumbnail:   thumbnail,
	}

	return &inlineQueryResultArticleTemp
}

// UnmarshalJSON unmarshal to json
func (inlineQueryResultArticle *InlineQueryResultArticle) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID          string `json:"id"`          // Unique identifier of the query result
		URL         string `json:"url"`         // URL of the result, if it exists
		HideURL     bool   `json:"hide_url"`    // True, if the URL must be not shown
		Title       string `json:"title"`       // Title of the result
		Description string `json:"description"` // A short description of the result

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineQueryResultArticle.tdCommon = tempObj.tdCommon
	inlineQueryResultArticle.ID = tempObj.ID
	inlineQueryResultArticle.URL = tempObj.URL
	inlineQueryResultArticle.HideURL = tempObj.HideURL
	inlineQueryResultArticle.Title = tempObj.Title
	inlineQueryResultArticle.Description = tempObj.Description

	var thumbnail Thumbnail
	if objMap["thumbnail"] != nil {
		err = thumbnail.UnmarshalJSON(*objMap["thumbnail"])
		if err != nil {
			return err
		}
	}

	inlineQueryResultArticle.Thumbnail = &thumbnail

	return nil
}

// GetInlineQueryResultEnum return the enum type of this object
func (inlineQueryResultArticle *InlineQueryResultArticle) GetInlineQueryResultEnum() InlineQueryResultEnum {
	return InlineQueryResultArticleType
}

// InlineQueryResultContact Represents a user contact
type InlineQueryResultContact struct {
	tdCommon
	ID        string     `json:"id"`        // Unique identifier of the query result
	Contact   *Contact   `json:"contact"`   // A user contact
	Thumbnail *Thumbnail `json:"thumbnail"` // Result thumbnail in JPEG format; may be null
}

// MessageType return the string telegram-type of InlineQueryResultContact
func (inlineQueryResultContact *InlineQueryResultContact) MessageType() string {
	return "inlineQueryResultContact"
}

// NewInlineQueryResultContact creates a new InlineQueryResultContact
//
// @param iD Unique identifier of the query result
// @param contact A user contact
// @param thumbnail Result thumbnail in JPEG format; may be null
func NewInlineQueryResultContact(iD string, contact *Contact, thumbnail *Thumbnail) *InlineQueryResultContact {
	inlineQueryResultContactTemp := InlineQueryResultContact{
		tdCommon:  tdCommon{Type: "inlineQueryResultContact"},
		ID:        iD,
		Contact:   contact,
		Thumbnail: thumbnail,
	}

	return &inlineQueryResultContactTemp
}

// UnmarshalJSON unmarshal to json
func (inlineQueryResultContact *InlineQueryResultContact) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID      string   `json:"id"`      // Unique identifier of the query result
		Contact *Contact `json:"contact"` // A user contact

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineQueryResultContact.tdCommon = tempObj.tdCommon
	inlineQueryResultContact.ID = tempObj.ID
	inlineQueryResultContact.Contact = tempObj.Contact

	var thumbnail Thumbnail
	if objMap["thumbnail"] != nil {
		err = thumbnail.UnmarshalJSON(*objMap["thumbnail"])
		if err != nil {
			return err
		}
	}

	inlineQueryResultContact.Thumbnail = &thumbnail

	return nil
}

// GetInlineQueryResultEnum return the enum type of this object
func (inlineQueryResultContact *InlineQueryResultContact) GetInlineQueryResultEnum() InlineQueryResultEnum {
	return InlineQueryResultContactType
}

// InlineQueryResultLocation Represents a point on the map
type InlineQueryResultLocation struct {
	tdCommon
	ID        string     `json:"id"`        // Unique identifier of the query result
	Location  *Location  `json:"location"`  // Location result
	Title     string     `json:"title"`     // Title of the result
	Thumbnail *Thumbnail `json:"thumbnail"` // Result thumbnail in JPEG format; may be null
}

// MessageType return the string telegram-type of InlineQueryResultLocation
func (inlineQueryResultLocation *InlineQueryResultLocation) MessageType() string {
	return "inlineQueryResultLocation"
}

// NewInlineQueryResultLocation creates a new InlineQueryResultLocation
//
// @param iD Unique identifier of the query result
// @param location Location result
// @param title Title of the result
// @param thumbnail Result thumbnail in JPEG format; may be null
func NewInlineQueryResultLocation(iD string, location *Location, title string, thumbnail *Thumbnail) *InlineQueryResultLocation {
	inlineQueryResultLocationTemp := InlineQueryResultLocation{
		tdCommon:  tdCommon{Type: "inlineQueryResultLocation"},
		ID:        iD,
		Location:  location,
		Title:     title,
		Thumbnail: thumbnail,
	}

	return &inlineQueryResultLocationTemp
}

// UnmarshalJSON unmarshal to json
func (inlineQueryResultLocation *InlineQueryResultLocation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID       string    `json:"id"`       // Unique identifier of the query result
		Location *Location `json:"location"` // Location result
		Title    string    `json:"title"`    // Title of the result

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineQueryResultLocation.tdCommon = tempObj.tdCommon
	inlineQueryResultLocation.ID = tempObj.ID
	inlineQueryResultLocation.Location = tempObj.Location
	inlineQueryResultLocation.Title = tempObj.Title

	var thumbnail Thumbnail
	if objMap["thumbnail"] != nil {
		err = thumbnail.UnmarshalJSON(*objMap["thumbnail"])
		if err != nil {
			return err
		}
	}

	inlineQueryResultLocation.Thumbnail = &thumbnail

	return nil
}

// GetInlineQueryResultEnum return the enum type of this object
func (inlineQueryResultLocation *InlineQueryResultLocation) GetInlineQueryResultEnum() InlineQueryResultEnum {
	return InlineQueryResultLocationType
}

// InlineQueryResultVenue Represents information about a venue
type InlineQueryResultVenue struct {
	tdCommon
	ID        string     `json:"id"`        // Unique identifier of the query result
	Venue     *Venue     `json:"venue"`     // Venue result
	Thumbnail *Thumbnail `json:"thumbnail"` // Result thumbnail in JPEG format; may be null
}

// MessageType return the string telegram-type of InlineQueryResultVenue
func (inlineQueryResultVenue *InlineQueryResultVenue) MessageType() string {
	return "inlineQueryResultVenue"
}

// NewInlineQueryResultVenue creates a new InlineQueryResultVenue
//
// @param iD Unique identifier of the query result
// @param venue Venue result
// @param thumbnail Result thumbnail in JPEG format; may be null
func NewInlineQueryResultVenue(iD string, venue *Venue, thumbnail *Thumbnail) *InlineQueryResultVenue {
	inlineQueryResultVenueTemp := InlineQueryResultVenue{
		tdCommon:  tdCommon{Type: "inlineQueryResultVenue"},
		ID:        iD,
		Venue:     venue,
		Thumbnail: thumbnail,
	}

	return &inlineQueryResultVenueTemp
}

// UnmarshalJSON unmarshal to json
func (inlineQueryResultVenue *InlineQueryResultVenue) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID    string `json:"id"`    // Unique identifier of the query result
		Venue *Venue `json:"venue"` // Venue result

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineQueryResultVenue.tdCommon = tempObj.tdCommon
	inlineQueryResultVenue.ID = tempObj.ID
	inlineQueryResultVenue.Venue = tempObj.Venue

	var thumbnail Thumbnail
	if objMap["thumbnail"] != nil {
		err = thumbnail.UnmarshalJSON(*objMap["thumbnail"])
		if err != nil {
			return err
		}
	}

	inlineQueryResultVenue.Thumbnail = &thumbnail

	return nil
}

// GetInlineQueryResultEnum return the enum type of this object
func (inlineQueryResultVenue *InlineQueryResultVenue) GetInlineQueryResultEnum() InlineQueryResultEnum {
	return InlineQueryResultVenueType
}

// InlineQueryResultGame Represents information about a game
type InlineQueryResultGame struct {
	tdCommon
	ID   string `json:"id"`   // Unique identifier of the query result
	Game *Game  `json:"game"` // Game result
}

// MessageType return the string telegram-type of InlineQueryResultGame
func (inlineQueryResultGame *InlineQueryResultGame) MessageType() string {
	return "inlineQueryResultGame"
}

// NewInlineQueryResultGame creates a new InlineQueryResultGame
//
// @param iD Unique identifier of the query result
// @param game Game result
func NewInlineQueryResultGame(iD string, game *Game) *InlineQueryResultGame {
	inlineQueryResultGameTemp := InlineQueryResultGame{
		tdCommon: tdCommon{Type: "inlineQueryResultGame"},
		ID:       iD,
		Game:     game,
	}

	return &inlineQueryResultGameTemp
}

// UnmarshalJSON unmarshal to json
func (inlineQueryResultGame *InlineQueryResultGame) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID   string `json:"id"`   // Unique identifier of the query result
		Game *Game  `json:"game"` // Game result
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineQueryResultGame.tdCommon = tempObj.tdCommon
	inlineQueryResultGame.ID = tempObj.ID
	inlineQueryResultGame.Game = tempObj.Game

	return nil
}

// GetInlineQueryResultEnum return the enum type of this object
func (inlineQueryResultGame *InlineQueryResultGame) GetInlineQueryResultEnum() InlineQueryResultEnum {
	return InlineQueryResultGameType
}

// InlineQueryResultAnimation Represents an animation file
type InlineQueryResultAnimation struct {
	tdCommon
	ID        string     `json:"id"`        // Unique identifier of the query result
	Animation *Animation `json:"animation"` // Animation file
	Title     string     `json:"title"`     // Animation title
}

// MessageType return the string telegram-type of InlineQueryResultAnimation
func (inlineQueryResultAnimation *InlineQueryResultAnimation) MessageType() string {
	return "inlineQueryResultAnimation"
}

// NewInlineQueryResultAnimation creates a new InlineQueryResultAnimation
//
// @param iD Unique identifier of the query result
// @param animation Animation file
// @param title Animation title
func NewInlineQueryResultAnimation(iD string, animation *Animation, title string) *InlineQueryResultAnimation {
	inlineQueryResultAnimationTemp := InlineQueryResultAnimation{
		tdCommon:  tdCommon{Type: "inlineQueryResultAnimation"},
		ID:        iD,
		Animation: animation,
		Title:     title,
	}

	return &inlineQueryResultAnimationTemp
}

// UnmarshalJSON unmarshal to json
func (inlineQueryResultAnimation *InlineQueryResultAnimation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID        string     `json:"id"`        // Unique identifier of the query result
		Animation *Animation `json:"animation"` // Animation file
		Title     string     `json:"title"`     // Animation title
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineQueryResultAnimation.tdCommon = tempObj.tdCommon
	inlineQueryResultAnimation.ID = tempObj.ID
	inlineQueryResultAnimation.Animation = tempObj.Animation
	inlineQueryResultAnimation.Title = tempObj.Title

	return nil
}

// GetInlineQueryResultEnum return the enum type of this object
func (inlineQueryResultAnimation *InlineQueryResultAnimation) GetInlineQueryResultEnum() InlineQueryResultEnum {
	return InlineQueryResultAnimationType
}

// InlineQueryResultAudio Represents an audio file
type InlineQueryResultAudio struct {
	tdCommon
	ID    string `json:"id"`    // Unique identifier of the query result
	Audio *Audio `json:"audio"` // Audio file
}

// MessageType return the string telegram-type of InlineQueryResultAudio
func (inlineQueryResultAudio *InlineQueryResultAudio) MessageType() string {
	return "inlineQueryResultAudio"
}

// NewInlineQueryResultAudio creates a new InlineQueryResultAudio
//
// @param iD Unique identifier of the query result
// @param audio Audio file
func NewInlineQueryResultAudio(iD string, audio *Audio) *InlineQueryResultAudio {
	inlineQueryResultAudioTemp := InlineQueryResultAudio{
		tdCommon: tdCommon{Type: "inlineQueryResultAudio"},
		ID:       iD,
		Audio:    audio,
	}

	return &inlineQueryResultAudioTemp
}

// UnmarshalJSON unmarshal to json
func (inlineQueryResultAudio *InlineQueryResultAudio) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID    string `json:"id"`    // Unique identifier of the query result
		Audio *Audio `json:"audio"` // Audio file
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineQueryResultAudio.tdCommon = tempObj.tdCommon
	inlineQueryResultAudio.ID = tempObj.ID
	inlineQueryResultAudio.Audio = tempObj.Audio

	return nil
}

// GetInlineQueryResultEnum return the enum type of this object
func (inlineQueryResultAudio *InlineQueryResultAudio) GetInlineQueryResultEnum() InlineQueryResultEnum {
	return InlineQueryResultAudioType
}

// InlineQueryResultDocument Represents a document
type InlineQueryResultDocument struct {
	tdCommon
	ID          string    `json:"id"`          // Unique identifier of the query result
	Document    *Document `json:"document"`    // Document
	Title       string    `json:"title"`       // Document title
	Description string    `json:"description"` // Document description
}

// MessageType return the string telegram-type of InlineQueryResultDocument
func (inlineQueryResultDocument *InlineQueryResultDocument) MessageType() string {
	return "inlineQueryResultDocument"
}

// NewInlineQueryResultDocument creates a new InlineQueryResultDocument
//
// @param iD Unique identifier of the query result
// @param document Document
// @param title Document title
// @param description Document description
func NewInlineQueryResultDocument(iD string, document *Document, title string, description string) *InlineQueryResultDocument {
	inlineQueryResultDocumentTemp := InlineQueryResultDocument{
		tdCommon:    tdCommon{Type: "inlineQueryResultDocument"},
		ID:          iD,
		Document:    document,
		Title:       title,
		Description: description,
	}

	return &inlineQueryResultDocumentTemp
}

// UnmarshalJSON unmarshal to json
func (inlineQueryResultDocument *InlineQueryResultDocument) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID          string    `json:"id"`          // Unique identifier of the query result
		Document    *Document `json:"document"`    // Document
		Title       string    `json:"title"`       // Document title
		Description string    `json:"description"` // Document description
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineQueryResultDocument.tdCommon = tempObj.tdCommon
	inlineQueryResultDocument.ID = tempObj.ID
	inlineQueryResultDocument.Document = tempObj.Document
	inlineQueryResultDocument.Title = tempObj.Title
	inlineQueryResultDocument.Description = tempObj.Description

	return nil
}

// GetInlineQueryResultEnum return the enum type of this object
func (inlineQueryResultDocument *InlineQueryResultDocument) GetInlineQueryResultEnum() InlineQueryResultEnum {
	return InlineQueryResultDocumentType
}

// InlineQueryResultPhoto Represents a photo
type InlineQueryResultPhoto struct {
	tdCommon
	ID          string `json:"id"`          // Unique identifier of the query result
	Photo       *Photo `json:"photo"`       // Photo
	Title       string `json:"title"`       // Title of the result, if known
	Description string `json:"description"` // A short description of the result, if known
}

// MessageType return the string telegram-type of InlineQueryResultPhoto
func (inlineQueryResultPhoto *InlineQueryResultPhoto) MessageType() string {
	return "inlineQueryResultPhoto"
}

// NewInlineQueryResultPhoto creates a new InlineQueryResultPhoto
//
// @param iD Unique identifier of the query result
// @param photo Photo
// @param title Title of the result, if known
// @param description A short description of the result, if known
func NewInlineQueryResultPhoto(iD string, photo *Photo, title string, description string) *InlineQueryResultPhoto {
	inlineQueryResultPhotoTemp := InlineQueryResultPhoto{
		tdCommon:    tdCommon{Type: "inlineQueryResultPhoto"},
		ID:          iD,
		Photo:       photo,
		Title:       title,
		Description: description,
	}

	return &inlineQueryResultPhotoTemp
}

// UnmarshalJSON unmarshal to json
func (inlineQueryResultPhoto *InlineQueryResultPhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID          string `json:"id"`          // Unique identifier of the query result
		Photo       *Photo `json:"photo"`       // Photo
		Title       string `json:"title"`       // Title of the result, if known
		Description string `json:"description"` // A short description of the result, if known
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineQueryResultPhoto.tdCommon = tempObj.tdCommon
	inlineQueryResultPhoto.ID = tempObj.ID
	inlineQueryResultPhoto.Photo = tempObj.Photo
	inlineQueryResultPhoto.Title = tempObj.Title
	inlineQueryResultPhoto.Description = tempObj.Description

	return nil
}

// GetInlineQueryResultEnum return the enum type of this object
func (inlineQueryResultPhoto *InlineQueryResultPhoto) GetInlineQueryResultEnum() InlineQueryResultEnum {
	return InlineQueryResultPhotoType
}

// InlineQueryResultSticker Represents a sticker
type InlineQueryResultSticker struct {
	tdCommon
	ID      string   `json:"id"`      // Unique identifier of the query result
	Sticker *Sticker `json:"sticker"` // Sticker
}

// MessageType return the string telegram-type of InlineQueryResultSticker
func (inlineQueryResultSticker *InlineQueryResultSticker) MessageType() string {
	return "inlineQueryResultSticker"
}

// NewInlineQueryResultSticker creates a new InlineQueryResultSticker
//
// @param iD Unique identifier of the query result
// @param sticker Sticker
func NewInlineQueryResultSticker(iD string, sticker *Sticker) *InlineQueryResultSticker {
	inlineQueryResultStickerTemp := InlineQueryResultSticker{
		tdCommon: tdCommon{Type: "inlineQueryResultSticker"},
		ID:       iD,
		Sticker:  sticker,
	}

	return &inlineQueryResultStickerTemp
}

// UnmarshalJSON unmarshal to json
func (inlineQueryResultSticker *InlineQueryResultSticker) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID string `json:"id"` // Unique identifier of the query result

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineQueryResultSticker.tdCommon = tempObj.tdCommon
	inlineQueryResultSticker.ID = tempObj.ID

	var sticker Sticker
	if objMap["sticker"] != nil {
		err = sticker.UnmarshalJSON(*objMap["sticker"])
		if err != nil {
			return err
		}
	}

	inlineQueryResultSticker.Sticker = &sticker

	return nil
}

// GetInlineQueryResultEnum return the enum type of this object
func (inlineQueryResultSticker *InlineQueryResultSticker) GetInlineQueryResultEnum() InlineQueryResultEnum {
	return InlineQueryResultStickerType
}

// InlineQueryResultVideo Represents a video
type InlineQueryResultVideo struct {
	tdCommon
	ID          string `json:"id"`          // Unique identifier of the query result
	Video       *Video `json:"video"`       // Video
	Title       string `json:"title"`       // Title of the video
	Description string `json:"description"` // Description of the video
}

// MessageType return the string telegram-type of InlineQueryResultVideo
func (inlineQueryResultVideo *InlineQueryResultVideo) MessageType() string {
	return "inlineQueryResultVideo"
}

// NewInlineQueryResultVideo creates a new InlineQueryResultVideo
//
// @param iD Unique identifier of the query result
// @param video Video
// @param title Title of the video
// @param description Description of the video
func NewInlineQueryResultVideo(iD string, video *Video, title string, description string) *InlineQueryResultVideo {
	inlineQueryResultVideoTemp := InlineQueryResultVideo{
		tdCommon:    tdCommon{Type: "inlineQueryResultVideo"},
		ID:          iD,
		Video:       video,
		Title:       title,
		Description: description,
	}

	return &inlineQueryResultVideoTemp
}

// UnmarshalJSON unmarshal to json
func (inlineQueryResultVideo *InlineQueryResultVideo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID          string `json:"id"`          // Unique identifier of the query result
		Video       *Video `json:"video"`       // Video
		Title       string `json:"title"`       // Title of the video
		Description string `json:"description"` // Description of the video
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineQueryResultVideo.tdCommon = tempObj.tdCommon
	inlineQueryResultVideo.ID = tempObj.ID
	inlineQueryResultVideo.Video = tempObj.Video
	inlineQueryResultVideo.Title = tempObj.Title
	inlineQueryResultVideo.Description = tempObj.Description

	return nil
}

// GetInlineQueryResultEnum return the enum type of this object
func (inlineQueryResultVideo *InlineQueryResultVideo) GetInlineQueryResultEnum() InlineQueryResultEnum {
	return InlineQueryResultVideoType
}

// InlineQueryResultVoiceNote Represents a voice note
type InlineQueryResultVoiceNote struct {
	tdCommon
	ID        string     `json:"id"`         // Unique identifier of the query result
	VoiceNote *VoiceNote `json:"voice_note"` // Voice note
	Title     string     `json:"title"`      // Title of the voice note
}

// MessageType return the string telegram-type of InlineQueryResultVoiceNote
func (inlineQueryResultVoiceNote *InlineQueryResultVoiceNote) MessageType() string {
	return "inlineQueryResultVoiceNote"
}

// NewInlineQueryResultVoiceNote creates a new InlineQueryResultVoiceNote
//
// @param iD Unique identifier of the query result
// @param voiceNote Voice note
// @param title Title of the voice note
func NewInlineQueryResultVoiceNote(iD string, voiceNote *VoiceNote, title string) *InlineQueryResultVoiceNote {
	inlineQueryResultVoiceNoteTemp := InlineQueryResultVoiceNote{
		tdCommon:  tdCommon{Type: "inlineQueryResultVoiceNote"},
		ID:        iD,
		VoiceNote: voiceNote,
		Title:     title,
	}

	return &inlineQueryResultVoiceNoteTemp
}

// UnmarshalJSON unmarshal to json
func (inlineQueryResultVoiceNote *InlineQueryResultVoiceNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID    string `json:"id"`    // Unique identifier of the query result
		Title string `json:"title"` // Title of the voice note
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineQueryResultVoiceNote.tdCommon = tempObj.tdCommon
	inlineQueryResultVoiceNote.ID = tempObj.ID
	inlineQueryResultVoiceNote.Title = tempObj.Title

	var voiceNote VoiceNote
	if objMap["voice_note"] != nil {
		err = voiceNote.UnmarshalJSON(*objMap["voice_note"])
		if err != nil {
			return err
		}
	}

	inlineQueryResultVoiceNote.VoiceNote = &voiceNote

	return nil
}

// GetInlineQueryResultEnum return the enum type of this object
func (inlineQueryResultVoiceNote *InlineQueryResultVoiceNote) GetInlineQueryResultEnum() InlineQueryResultEnum {
	return InlineQueryResultVoiceNoteType
}

// InlineQueryResultsButtonTypeStartBot Describes the button that opens a private chat with the bot and sends a start message to the bot with the given parameter
type InlineQueryResultsButtonTypeStartBot struct {
	tdCommon
	Parameter string `json:"parameter"` // The parameter for the bot start message
}

// MessageType return the string telegram-type of InlineQueryResultsButtonTypeStartBot
func (inlineQueryResultsButtonTypeStartBot *InlineQueryResultsButtonTypeStartBot) MessageType() string {
	return "inlineQueryResultsButtonTypeStartBot"
}

// NewInlineQueryResultsButtonTypeStartBot creates a new InlineQueryResultsButtonTypeStartBot
//
// @param parameter The parameter for the bot start message
func NewInlineQueryResultsButtonTypeStartBot(parameter string) *InlineQueryResultsButtonTypeStartBot {
	inlineQueryResultsButtonTypeStartBotTemp := InlineQueryResultsButtonTypeStartBot{
		tdCommon:  tdCommon{Type: "inlineQueryResultsButtonTypeStartBot"},
		Parameter: parameter,
	}

	return &inlineQueryResultsButtonTypeStartBotTemp
}

// UnmarshalJSON unmarshal to json
func (inlineQueryResultsButtonTypeStartBot *InlineQueryResultsButtonTypeStartBot) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Parameter string `json:"parameter"` // The parameter for the bot start message
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineQueryResultsButtonTypeStartBot.tdCommon = tempObj.tdCommon
	inlineQueryResultsButtonTypeStartBot.Parameter = tempObj.Parameter

	return nil
}

// GetInlineQueryResultsButtonTypeEnum return the enum type of this object
func (inlineQueryResultsButtonTypeStartBot *InlineQueryResultsButtonTypeStartBot) GetInlineQueryResultsButtonTypeEnum() InlineQueryResultsButtonTypeEnum {
	return InlineQueryResultsButtonTypeStartBotType
}

// InlineQueryResultsButtonTypeWebApp Describes the button that opens a Web App by calling getWebAppUrl
type InlineQueryResultsButtonTypeWebApp struct {
	tdCommon
	URL string `json:"url"` // An HTTP URL to pass to getWebAppUrl
}

// MessageType return the string telegram-type of InlineQueryResultsButtonTypeWebApp
func (inlineQueryResultsButtonTypeWebApp *InlineQueryResultsButtonTypeWebApp) MessageType() string {
	return "inlineQueryResultsButtonTypeWebApp"
}

// NewInlineQueryResultsButtonTypeWebApp creates a new InlineQueryResultsButtonTypeWebApp
//
// @param uRL An HTTP URL to pass to getWebAppUrl
func NewInlineQueryResultsButtonTypeWebApp(uRL string) *InlineQueryResultsButtonTypeWebApp {
	inlineQueryResultsButtonTypeWebAppTemp := InlineQueryResultsButtonTypeWebApp{
		tdCommon: tdCommon{Type: "inlineQueryResultsButtonTypeWebApp"},
		URL:      uRL,
	}

	return &inlineQueryResultsButtonTypeWebAppTemp
}

// UnmarshalJSON unmarshal to json
func (inlineQueryResultsButtonTypeWebApp *InlineQueryResultsButtonTypeWebApp) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL string `json:"url"` // An HTTP URL to pass to getWebAppUrl
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineQueryResultsButtonTypeWebApp.tdCommon = tempObj.tdCommon
	inlineQueryResultsButtonTypeWebApp.URL = tempObj.URL

	return nil
}

// GetInlineQueryResultsButtonTypeEnum return the enum type of this object
func (inlineQueryResultsButtonTypeWebApp *InlineQueryResultsButtonTypeWebApp) GetInlineQueryResultsButtonTypeEnum() InlineQueryResultsButtonTypeEnum {
	return InlineQueryResultsButtonTypeWebAppType
}

// InlineQueryResultsButton Represents a button to be shown above inline query results
type InlineQueryResultsButton struct {
	tdCommon
	Text string                       `json:"text"` // The text of the button
	Type InlineQueryResultsButtonType `json:"type"` // Type of the button
}

// MessageType return the string telegram-type of InlineQueryResultsButton
func (inlineQueryResultsButton *InlineQueryResultsButton) MessageType() string {
	return "inlineQueryResultsButton"
}

// NewInlineQueryResultsButton creates a new InlineQueryResultsButton
//
// @param text The text of the button
// @param typeParam Type of the button
func NewInlineQueryResultsButton(text string, typeParam InlineQueryResultsButtonType) *InlineQueryResultsButton {
	inlineQueryResultsButtonTemp := InlineQueryResultsButton{
		tdCommon: tdCommon{Type: "inlineQueryResultsButton"},
		Text:     text,
		Type:     typeParam,
	}

	return &inlineQueryResultsButtonTemp
}

// UnmarshalJSON unmarshal to json
func (inlineQueryResultsButton *InlineQueryResultsButton) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Text string `json:"text"` // The text of the button

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineQueryResultsButton.tdCommon = tempObj.tdCommon
	inlineQueryResultsButton.Text = tempObj.Text

	fieldType, _ := unmarshalInlineQueryResultsButtonType(objMap["type"])
	inlineQueryResultsButton.Type = fieldType

	return nil
}

// InlineQueryResults Represents the results of the inline query. Use sendInlineQueryResultMessage to send the result of the query
type InlineQueryResults struct {
	tdCommon
	InlineQueryID JSONInt64                 `json:"inline_query_id"` // Unique identifier of the inline query
	Button        *InlineQueryResultsButton `json:"button"`          // Button to be shown above inline query results; may be null
	Results       []InlineQueryResult       `json:"results"`         // Results of the query
	NextOffset    string                    `json:"next_offset"`     // The offset for the next request. If empty, then there are no more results
}

// MessageType return the string telegram-type of InlineQueryResults
func (inlineQueryResults *InlineQueryResults) MessageType() string {
	return "inlineQueryResults"
}

// NewInlineQueryResults creates a new InlineQueryResults
//
// @param inlineQueryID Unique identifier of the inline query
// @param button Button to be shown above inline query results; may be null
// @param results Results of the query
// @param nextOffset The offset for the next request. If empty, then there are no more results
func NewInlineQueryResults(inlineQueryID JSONInt64, button *InlineQueryResultsButton, results []InlineQueryResult, nextOffset string) *InlineQueryResults {
	inlineQueryResultsTemp := InlineQueryResults{
		tdCommon:      tdCommon{Type: "inlineQueryResults"},
		InlineQueryID: inlineQueryID,
		Button:        button,
		Results:       results,
		NextOffset:    nextOffset,
	}

	return &inlineQueryResultsTemp
}

// UnmarshalJSON unmarshal to json
func (inlineQueryResults *InlineQueryResults) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		InlineQueryID JSONInt64 `json:"inline_query_id"` // Unique identifier of the inline query
		NextOffset    string    `json:"next_offset"`     // The offset for the next request. If empty, then there are no more results
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inlineQueryResults.tdCommon = tempObj.tdCommon
	inlineQueryResults.InlineQueryID = tempObj.InlineQueryID
	inlineQueryResults.NextOffset = tempObj.NextOffset

	var button InlineQueryResultsButton
	if objMap["button"] != nil {
		err = button.UnmarshalJSON(*objMap["button"])
		if err != nil {
			return err
		}
	}

	inlineQueryResults.Button = &button

	fieldResults, _ := unmarshalInlineQueryResultSlice(objMap["results"])
	inlineQueryResults.Results = fieldResults

	return nil
}

// CallbackQueryPayloadData The payload for a general callback button
type CallbackQueryPayloadData struct {
	tdCommon
	Data []byte `json:"data"` // Data that was attached to the callback button
}

// MessageType return the string telegram-type of CallbackQueryPayloadData
func (callbackQueryPayloadData *CallbackQueryPayloadData) MessageType() string {
	return "callbackQueryPayloadData"
}

// NewCallbackQueryPayloadData creates a new CallbackQueryPayloadData
//
// @param data Data that was attached to the callback button
func NewCallbackQueryPayloadData(data []byte) *CallbackQueryPayloadData {
	callbackQueryPayloadDataTemp := CallbackQueryPayloadData{
		tdCommon: tdCommon{Type: "callbackQueryPayloadData"},
		Data:     data,
	}

	return &callbackQueryPayloadDataTemp
}

// UnmarshalJSON unmarshal to json
func (callbackQueryPayloadData *CallbackQueryPayloadData) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Data []byte `json:"data"` // Data that was attached to the callback button
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callbackQueryPayloadData.tdCommon = tempObj.tdCommon
	callbackQueryPayloadData.Data = tempObj.Data

	return nil
}

// GetCallbackQueryPayloadEnum return the enum type of this object
func (callbackQueryPayloadData *CallbackQueryPayloadData) GetCallbackQueryPayloadEnum() CallbackQueryPayloadEnum {
	return CallbackQueryPayloadDataType
}

// CallbackQueryPayloadDataWithPassword The payload for a callback button requiring password
type CallbackQueryPayloadDataWithPassword struct {
	tdCommon
	Password string `json:"password"` // The 2-step verification password for the current user
	Data     []byte `json:"data"`     // Data that was attached to the callback button
}

// MessageType return the string telegram-type of CallbackQueryPayloadDataWithPassword
func (callbackQueryPayloadDataWithPassword *CallbackQueryPayloadDataWithPassword) MessageType() string {
	return "callbackQueryPayloadDataWithPassword"
}

// NewCallbackQueryPayloadDataWithPassword creates a new CallbackQueryPayloadDataWithPassword
//
// @param password The 2-step verification password for the current user
// @param data Data that was attached to the callback button
func NewCallbackQueryPayloadDataWithPassword(password string, data []byte) *CallbackQueryPayloadDataWithPassword {
	callbackQueryPayloadDataWithPasswordTemp := CallbackQueryPayloadDataWithPassword{
		tdCommon: tdCommon{Type: "callbackQueryPayloadDataWithPassword"},
		Password: password,
		Data:     data,
	}

	return &callbackQueryPayloadDataWithPasswordTemp
}

// UnmarshalJSON unmarshal to json
func (callbackQueryPayloadDataWithPassword *CallbackQueryPayloadDataWithPassword) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Password string `json:"password"` // The 2-step verification password for the current user
		Data     []byte `json:"data"`     // Data that was attached to the callback button
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callbackQueryPayloadDataWithPassword.tdCommon = tempObj.tdCommon
	callbackQueryPayloadDataWithPassword.Password = tempObj.Password
	callbackQueryPayloadDataWithPassword.Data = tempObj.Data

	return nil
}

// GetCallbackQueryPayloadEnum return the enum type of this object
func (callbackQueryPayloadDataWithPassword *CallbackQueryPayloadDataWithPassword) GetCallbackQueryPayloadEnum() CallbackQueryPayloadEnum {
	return CallbackQueryPayloadDataWithPasswordType
}

// CallbackQueryPayloadGame The payload for a game callback button
type CallbackQueryPayloadGame struct {
	tdCommon
	GameShortName string `json:"game_short_name"` // A short name of the game that was attached to the callback button
}

// MessageType return the string telegram-type of CallbackQueryPayloadGame
func (callbackQueryPayloadGame *CallbackQueryPayloadGame) MessageType() string {
	return "callbackQueryPayloadGame"
}

// NewCallbackQueryPayloadGame creates a new CallbackQueryPayloadGame
//
// @param gameShortName A short name of the game that was attached to the callback button
func NewCallbackQueryPayloadGame(gameShortName string) *CallbackQueryPayloadGame {
	callbackQueryPayloadGameTemp := CallbackQueryPayloadGame{
		tdCommon:      tdCommon{Type: "callbackQueryPayloadGame"},
		GameShortName: gameShortName,
	}

	return &callbackQueryPayloadGameTemp
}

// UnmarshalJSON unmarshal to json
func (callbackQueryPayloadGame *CallbackQueryPayloadGame) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		GameShortName string `json:"game_short_name"` // A short name of the game that was attached to the callback button
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callbackQueryPayloadGame.tdCommon = tempObj.tdCommon
	callbackQueryPayloadGame.GameShortName = tempObj.GameShortName

	return nil
}

// GetCallbackQueryPayloadEnum return the enum type of this object
func (callbackQueryPayloadGame *CallbackQueryPayloadGame) GetCallbackQueryPayloadEnum() CallbackQueryPayloadEnum {
	return CallbackQueryPayloadGameType
}

// CallbackQueryAnswer Contains a bot's answer to a callback query
type CallbackQueryAnswer struct {
	tdCommon
	Text      string `json:"text"`       // Text of the answer
	ShowAlert bool   `json:"show_alert"` // True, if an alert must be shown to the user instead of a toast notification
	URL       string `json:"url"`        // URL to be opened
}

// MessageType return the string telegram-type of CallbackQueryAnswer
func (callbackQueryAnswer *CallbackQueryAnswer) MessageType() string {
	return "callbackQueryAnswer"
}

// NewCallbackQueryAnswer creates a new CallbackQueryAnswer
//
// @param text Text of the answer
// @param showAlert True, if an alert must be shown to the user instead of a toast notification
// @param uRL URL to be opened
func NewCallbackQueryAnswer(text string, showAlert bool, uRL string) *CallbackQueryAnswer {
	callbackQueryAnswerTemp := CallbackQueryAnswer{
		tdCommon:  tdCommon{Type: "callbackQueryAnswer"},
		Text:      text,
		ShowAlert: showAlert,
		URL:       uRL,
	}

	return &callbackQueryAnswerTemp
}

// UnmarshalJSON unmarshal to json
func (callbackQueryAnswer *CallbackQueryAnswer) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Text      string `json:"text"`       // Text of the answer
		ShowAlert bool   `json:"show_alert"` // True, if an alert must be shown to the user instead of a toast notification
		URL       string `json:"url"`        // URL to be opened
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	callbackQueryAnswer.tdCommon = tempObj.tdCommon
	callbackQueryAnswer.Text = tempObj.Text
	callbackQueryAnswer.ShowAlert = tempObj.ShowAlert
	callbackQueryAnswer.URL = tempObj.URL

	return nil
}

// CustomRequestResult Contains the result of a custom request
type CustomRequestResult struct {
	tdCommon
	Result string `json:"result"` // A JSON-serialized result
}

// MessageType return the string telegram-type of CustomRequestResult
func (customRequestResult *CustomRequestResult) MessageType() string {
	return "customRequestResult"
}

// NewCustomRequestResult creates a new CustomRequestResult
//
// @param result A JSON-serialized result
func NewCustomRequestResult(result string) *CustomRequestResult {
	customRequestResultTemp := CustomRequestResult{
		tdCommon: tdCommon{Type: "customRequestResult"},
		Result:   result,
	}

	return &customRequestResultTemp
}

// UnmarshalJSON unmarshal to json
func (customRequestResult *CustomRequestResult) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Result string `json:"result"` // A JSON-serialized result
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	customRequestResult.tdCommon = tempObj.tdCommon
	customRequestResult.Result = tempObj.Result

	return nil
}

// GameHighScore Contains one row of the game high score table
type GameHighScore struct {
	tdCommon
	Position int32 `json:"position"` // Position in the high score table
	UserID   int64 `json:"user_id"`  // User identifier
	Score    int32 `json:"score"`    // User score
}

// MessageType return the string telegram-type of GameHighScore
func (gameHighScore *GameHighScore) MessageType() string {
	return "gameHighScore"
}

// NewGameHighScore creates a new GameHighScore
//
// @param position Position in the high score table
// @param userID User identifier
// @param score User score
func NewGameHighScore(position int32, userID int64, score int32) *GameHighScore {
	gameHighScoreTemp := GameHighScore{
		tdCommon: tdCommon{Type: "gameHighScore"},
		Position: position,
		UserID:   userID,
		Score:    score,
	}

	return &gameHighScoreTemp
}

// UnmarshalJSON unmarshal to json
func (gameHighScore *GameHighScore) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Position int32 `json:"position"` // Position in the high score table
		UserID   int64 `json:"user_id"`  // User identifier
		Score    int32 `json:"score"`    // User score
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	gameHighScore.tdCommon = tempObj.tdCommon
	gameHighScore.Position = tempObj.Position
	gameHighScore.UserID = tempObj.UserID
	gameHighScore.Score = tempObj.Score

	return nil
}

// GameHighScores Contains a list of game high scores
type GameHighScores struct {
	tdCommon
	Scores []GameHighScore `json:"scores"` // A list of game high scores
}

// MessageType return the string telegram-type of GameHighScores
func (gameHighScores *GameHighScores) MessageType() string {
	return "gameHighScores"
}

// NewGameHighScores creates a new GameHighScores
//
// @param scores A list of game high scores
func NewGameHighScores(scores []GameHighScore) *GameHighScores {
	gameHighScoresTemp := GameHighScores{
		tdCommon: tdCommon{Type: "gameHighScores"},
		Scores:   scores,
	}

	return &gameHighScoresTemp
}

// UnmarshalJSON unmarshal to json
func (gameHighScores *GameHighScores) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Scores []GameHighScore `json:"scores"` // A list of game high scores
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	gameHighScores.tdCommon = tempObj.tdCommon
	gameHighScores.Scores = tempObj.Scores

	return nil
}

// ChatEventMessageEdited A message was edited
type ChatEventMessageEdited struct {
	tdCommon
	OldMessage *Message `json:"old_message"` // The original message before the edit
	NewMessage *Message `json:"new_message"` // The message after it was edited
}

// MessageType return the string telegram-type of ChatEventMessageEdited
func (chatEventMessageEdited *ChatEventMessageEdited) MessageType() string {
	return "chatEventMessageEdited"
}

// NewChatEventMessageEdited creates a new ChatEventMessageEdited
//
// @param oldMessage The original message before the edit
// @param newMessage The message after it was edited
func NewChatEventMessageEdited(oldMessage *Message, newMessage *Message) *ChatEventMessageEdited {
	chatEventMessageEditedTemp := ChatEventMessageEdited{
		tdCommon:   tdCommon{Type: "chatEventMessageEdited"},
		OldMessage: oldMessage,
		NewMessage: newMessage,
	}

	return &chatEventMessageEditedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventMessageEdited *ChatEventMessageEdited) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventMessageEdited.tdCommon = tempObj.tdCommon

	var oldMessage Message
	if objMap["old_message"] != nil {
		err = oldMessage.UnmarshalJSON(*objMap["old_message"])
		if err != nil {
			return err
		}
	}

	chatEventMessageEdited.OldMessage = &oldMessage

	var newMessage Message
	if objMap["new_message"] != nil {
		err = newMessage.UnmarshalJSON(*objMap["new_message"])
		if err != nil {
			return err
		}
	}

	chatEventMessageEdited.NewMessage = &newMessage

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventMessageEdited *ChatEventMessageEdited) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventMessageEditedType
}

// ChatEventMessageDeleted A message was deleted
type ChatEventMessageDeleted struct {
	tdCommon
	Message                        *Message `json:"message"`                             // Deleted message
	CanReportAntiSpamFalsePositive bool     `json:"can_report_anti_spam_false_positive"` // True, if the message deletion can be reported via reportSupergroupAntiSpamFalsePositive
}

// MessageType return the string telegram-type of ChatEventMessageDeleted
func (chatEventMessageDeleted *ChatEventMessageDeleted) MessageType() string {
	return "chatEventMessageDeleted"
}

// NewChatEventMessageDeleted creates a new ChatEventMessageDeleted
//
// @param message Deleted message
// @param canReportAntiSpamFalsePositive True, if the message deletion can be reported via reportSupergroupAntiSpamFalsePositive
func NewChatEventMessageDeleted(message *Message, canReportAntiSpamFalsePositive bool) *ChatEventMessageDeleted {
	chatEventMessageDeletedTemp := ChatEventMessageDeleted{
		tdCommon:                       tdCommon{Type: "chatEventMessageDeleted"},
		Message:                        message,
		CanReportAntiSpamFalsePositive: canReportAntiSpamFalsePositive,
	}

	return &chatEventMessageDeletedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventMessageDeleted *ChatEventMessageDeleted) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CanReportAntiSpamFalsePositive bool `json:"can_report_anti_spam_false_positive"` // True, if the message deletion can be reported via reportSupergroupAntiSpamFalsePositive
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventMessageDeleted.tdCommon = tempObj.tdCommon
	chatEventMessageDeleted.CanReportAntiSpamFalsePositive = tempObj.CanReportAntiSpamFalsePositive

	var message Message
	if objMap["message"] != nil {
		err = message.UnmarshalJSON(*objMap["message"])
		if err != nil {
			return err
		}
	}

	chatEventMessageDeleted.Message = &message

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventMessageDeleted *ChatEventMessageDeleted) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventMessageDeletedType
}

// ChatEventMessagePinned A message was pinned
type ChatEventMessagePinned struct {
	tdCommon
	Message *Message `json:"message"` // Pinned message
}

// MessageType return the string telegram-type of ChatEventMessagePinned
func (chatEventMessagePinned *ChatEventMessagePinned) MessageType() string {
	return "chatEventMessagePinned"
}

// NewChatEventMessagePinned creates a new ChatEventMessagePinned
//
// @param message Pinned message
func NewChatEventMessagePinned(message *Message) *ChatEventMessagePinned {
	chatEventMessagePinnedTemp := ChatEventMessagePinned{
		tdCommon: tdCommon{Type: "chatEventMessagePinned"},
		Message:  message,
	}

	return &chatEventMessagePinnedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventMessagePinned *ChatEventMessagePinned) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventMessagePinned.tdCommon = tempObj.tdCommon

	var message Message
	if objMap["message"] != nil {
		err = message.UnmarshalJSON(*objMap["message"])
		if err != nil {
			return err
		}
	}

	chatEventMessagePinned.Message = &message

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventMessagePinned *ChatEventMessagePinned) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventMessagePinnedType
}

// ChatEventMessageUnpinned A message was unpinned
type ChatEventMessageUnpinned struct {
	tdCommon
	Message *Message `json:"message"` // Unpinned message
}

// MessageType return the string telegram-type of ChatEventMessageUnpinned
func (chatEventMessageUnpinned *ChatEventMessageUnpinned) MessageType() string {
	return "chatEventMessageUnpinned"
}

// NewChatEventMessageUnpinned creates a new ChatEventMessageUnpinned
//
// @param message Unpinned message
func NewChatEventMessageUnpinned(message *Message) *ChatEventMessageUnpinned {
	chatEventMessageUnpinnedTemp := ChatEventMessageUnpinned{
		tdCommon: tdCommon{Type: "chatEventMessageUnpinned"},
		Message:  message,
	}

	return &chatEventMessageUnpinnedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventMessageUnpinned *ChatEventMessageUnpinned) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventMessageUnpinned.tdCommon = tempObj.tdCommon

	var message Message
	if objMap["message"] != nil {
		err = message.UnmarshalJSON(*objMap["message"])
		if err != nil {
			return err
		}
	}

	chatEventMessageUnpinned.Message = &message

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventMessageUnpinned *ChatEventMessageUnpinned) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventMessageUnpinnedType
}

// ChatEventPollStopped A poll in a message was stopped
type ChatEventPollStopped struct {
	tdCommon
	Message *Message `json:"message"` // The message with the poll
}

// MessageType return the string telegram-type of ChatEventPollStopped
func (chatEventPollStopped *ChatEventPollStopped) MessageType() string {
	return "chatEventPollStopped"
}

// NewChatEventPollStopped creates a new ChatEventPollStopped
//
// @param message The message with the poll
func NewChatEventPollStopped(message *Message) *ChatEventPollStopped {
	chatEventPollStoppedTemp := ChatEventPollStopped{
		tdCommon: tdCommon{Type: "chatEventPollStopped"},
		Message:  message,
	}

	return &chatEventPollStoppedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventPollStopped *ChatEventPollStopped) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventPollStopped.tdCommon = tempObj.tdCommon

	var message Message
	if objMap["message"] != nil {
		err = message.UnmarshalJSON(*objMap["message"])
		if err != nil {
			return err
		}
	}

	chatEventPollStopped.Message = &message

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventPollStopped *ChatEventPollStopped) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventPollStoppedType
}

// ChatEventMemberJoined A new member joined the chat
type ChatEventMemberJoined struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatEventMemberJoined
func (chatEventMemberJoined *ChatEventMemberJoined) MessageType() string {
	return "chatEventMemberJoined"
}

// NewChatEventMemberJoined creates a new ChatEventMemberJoined
//
func NewChatEventMemberJoined() *ChatEventMemberJoined {
	chatEventMemberJoinedTemp := ChatEventMemberJoined{
		tdCommon: tdCommon{Type: "chatEventMemberJoined"},
	}

	return &chatEventMemberJoinedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventMemberJoined *ChatEventMemberJoined) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventMemberJoined.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventMemberJoined *ChatEventMemberJoined) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventMemberJoinedType
}

// ChatEventMemberJoinedByInviteLink A new member joined the chat via an invite link
type ChatEventMemberJoinedByInviteLink struct {
	tdCommon
	InviteLink              *ChatInviteLink `json:"invite_link"`                 // Invite link used to join the chat
	ViaChatFolderInviteLink bool            `json:"via_chat_folder_invite_link"` // True, if the user has joined the chat using an invite link for a chat folder
}

// MessageType return the string telegram-type of ChatEventMemberJoinedByInviteLink
func (chatEventMemberJoinedByInviteLink *ChatEventMemberJoinedByInviteLink) MessageType() string {
	return "chatEventMemberJoinedByInviteLink"
}

// NewChatEventMemberJoinedByInviteLink creates a new ChatEventMemberJoinedByInviteLink
//
// @param inviteLink Invite link used to join the chat
// @param viaChatFolderInviteLink True, if the user has joined the chat using an invite link for a chat folder
func NewChatEventMemberJoinedByInviteLink(inviteLink *ChatInviteLink, viaChatFolderInviteLink bool) *ChatEventMemberJoinedByInviteLink {
	chatEventMemberJoinedByInviteLinkTemp := ChatEventMemberJoinedByInviteLink{
		tdCommon:                tdCommon{Type: "chatEventMemberJoinedByInviteLink"},
		InviteLink:              inviteLink,
		ViaChatFolderInviteLink: viaChatFolderInviteLink,
	}

	return &chatEventMemberJoinedByInviteLinkTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventMemberJoinedByInviteLink *ChatEventMemberJoinedByInviteLink) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		InviteLink              *ChatInviteLink `json:"invite_link"`                 // Invite link used to join the chat
		ViaChatFolderInviteLink bool            `json:"via_chat_folder_invite_link"` // True, if the user has joined the chat using an invite link for a chat folder
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventMemberJoinedByInviteLink.tdCommon = tempObj.tdCommon
	chatEventMemberJoinedByInviteLink.InviteLink = tempObj.InviteLink
	chatEventMemberJoinedByInviteLink.ViaChatFolderInviteLink = tempObj.ViaChatFolderInviteLink

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventMemberJoinedByInviteLink *ChatEventMemberJoinedByInviteLink) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventMemberJoinedByInviteLinkType
}

// ChatEventMemberJoinedByRequest A new member was accepted to the chat by an administrator
type ChatEventMemberJoinedByRequest struct {
	tdCommon
	ApproverUserID int64           `json:"approver_user_id"` // User identifier of the chat administrator, approved user join request
	InviteLink     *ChatInviteLink `json:"invite_link"`      // Invite link used to join the chat; may be null
}

// MessageType return the string telegram-type of ChatEventMemberJoinedByRequest
func (chatEventMemberJoinedByRequest *ChatEventMemberJoinedByRequest) MessageType() string {
	return "chatEventMemberJoinedByRequest"
}

// NewChatEventMemberJoinedByRequest creates a new ChatEventMemberJoinedByRequest
//
// @param approverUserID User identifier of the chat administrator, approved user join request
// @param inviteLink Invite link used to join the chat; may be null
func NewChatEventMemberJoinedByRequest(approverUserID int64, inviteLink *ChatInviteLink) *ChatEventMemberJoinedByRequest {
	chatEventMemberJoinedByRequestTemp := ChatEventMemberJoinedByRequest{
		tdCommon:       tdCommon{Type: "chatEventMemberJoinedByRequest"},
		ApproverUserID: approverUserID,
		InviteLink:     inviteLink,
	}

	return &chatEventMemberJoinedByRequestTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventMemberJoinedByRequest *ChatEventMemberJoinedByRequest) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ApproverUserID int64           `json:"approver_user_id"` // User identifier of the chat administrator, approved user join request
		InviteLink     *ChatInviteLink `json:"invite_link"`      // Invite link used to join the chat; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventMemberJoinedByRequest.tdCommon = tempObj.tdCommon
	chatEventMemberJoinedByRequest.ApproverUserID = tempObj.ApproverUserID
	chatEventMemberJoinedByRequest.InviteLink = tempObj.InviteLink

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventMemberJoinedByRequest *ChatEventMemberJoinedByRequest) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventMemberJoinedByRequestType
}

// ChatEventMemberInvited A new chat member was invited
type ChatEventMemberInvited struct {
	tdCommon
	UserID int64            `json:"user_id"` // New member user identifier
	Status ChatMemberStatus `json:"status"`  // New member status
}

// MessageType return the string telegram-type of ChatEventMemberInvited
func (chatEventMemberInvited *ChatEventMemberInvited) MessageType() string {
	return "chatEventMemberInvited"
}

// NewChatEventMemberInvited creates a new ChatEventMemberInvited
//
// @param userID New member user identifier
// @param status New member status
func NewChatEventMemberInvited(userID int64, status ChatMemberStatus) *ChatEventMemberInvited {
	chatEventMemberInvitedTemp := ChatEventMemberInvited{
		tdCommon: tdCommon{Type: "chatEventMemberInvited"},
		UserID:   userID,
		Status:   status,
	}

	return &chatEventMemberInvitedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventMemberInvited *ChatEventMemberInvited) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID int64 `json:"user_id"` // New member user identifier

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventMemberInvited.tdCommon = tempObj.tdCommon
	chatEventMemberInvited.UserID = tempObj.UserID

	fieldStatus, _ := unmarshalChatMemberStatus(objMap["status"])
	chatEventMemberInvited.Status = fieldStatus

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventMemberInvited *ChatEventMemberInvited) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventMemberInvitedType
}

// ChatEventMemberLeft A member left the chat
type ChatEventMemberLeft struct {
	tdCommon
}

// MessageType return the string telegram-type of ChatEventMemberLeft
func (chatEventMemberLeft *ChatEventMemberLeft) MessageType() string {
	return "chatEventMemberLeft"
}

// NewChatEventMemberLeft creates a new ChatEventMemberLeft
//
func NewChatEventMemberLeft() *ChatEventMemberLeft {
	chatEventMemberLeftTemp := ChatEventMemberLeft{
		tdCommon: tdCommon{Type: "chatEventMemberLeft"},
	}

	return &chatEventMemberLeftTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventMemberLeft *ChatEventMemberLeft) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventMemberLeft.tdCommon = tempObj.tdCommon

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventMemberLeft *ChatEventMemberLeft) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventMemberLeftType
}

// ChatEventMemberPromoted A chat member has gained/lost administrator status, or the list of their administrator privileges has changed
type ChatEventMemberPromoted struct {
	tdCommon
	UserID    int64            `json:"user_id"`    // Affected chat member user identifier
	OldStatus ChatMemberStatus `json:"old_status"` // Previous status of the chat member
	NewStatus ChatMemberStatus `json:"new_status"` // New status of the chat member
}

// MessageType return the string telegram-type of ChatEventMemberPromoted
func (chatEventMemberPromoted *ChatEventMemberPromoted) MessageType() string {
	return "chatEventMemberPromoted"
}

// NewChatEventMemberPromoted creates a new ChatEventMemberPromoted
//
// @param userID Affected chat member user identifier
// @param oldStatus Previous status of the chat member
// @param newStatus New status of the chat member
func NewChatEventMemberPromoted(userID int64, oldStatus ChatMemberStatus, newStatus ChatMemberStatus) *ChatEventMemberPromoted {
	chatEventMemberPromotedTemp := ChatEventMemberPromoted{
		tdCommon:  tdCommon{Type: "chatEventMemberPromoted"},
		UserID:    userID,
		OldStatus: oldStatus,
		NewStatus: newStatus,
	}

	return &chatEventMemberPromotedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventMemberPromoted *ChatEventMemberPromoted) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID int64 `json:"user_id"` // Affected chat member user identifier

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventMemberPromoted.tdCommon = tempObj.tdCommon
	chatEventMemberPromoted.UserID = tempObj.UserID

	fieldOldStatus, _ := unmarshalChatMemberStatus(objMap["old_status"])
	chatEventMemberPromoted.OldStatus = fieldOldStatus

	fieldNewStatus, _ := unmarshalChatMemberStatus(objMap["new_status"])
	chatEventMemberPromoted.NewStatus = fieldNewStatus

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventMemberPromoted *ChatEventMemberPromoted) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventMemberPromotedType
}

// ChatEventMemberRestricted A chat member was restricted/unrestricted or banned/unbanned, or the list of their restrictions has changed
type ChatEventMemberRestricted struct {
	tdCommon
	MemberID  MessageSender    `json:"member_id"`  // Affected chat member identifier
	OldStatus ChatMemberStatus `json:"old_status"` // Previous status of the chat member
	NewStatus ChatMemberStatus `json:"new_status"` // New status of the chat member
}

// MessageType return the string telegram-type of ChatEventMemberRestricted
func (chatEventMemberRestricted *ChatEventMemberRestricted) MessageType() string {
	return "chatEventMemberRestricted"
}

// NewChatEventMemberRestricted creates a new ChatEventMemberRestricted
//
// @param memberID Affected chat member identifier
// @param oldStatus Previous status of the chat member
// @param newStatus New status of the chat member
func NewChatEventMemberRestricted(memberID MessageSender, oldStatus ChatMemberStatus, newStatus ChatMemberStatus) *ChatEventMemberRestricted {
	chatEventMemberRestrictedTemp := ChatEventMemberRestricted{
		tdCommon:  tdCommon{Type: "chatEventMemberRestricted"},
		MemberID:  memberID,
		OldStatus: oldStatus,
		NewStatus: newStatus,
	}

	return &chatEventMemberRestrictedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventMemberRestricted *ChatEventMemberRestricted) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventMemberRestricted.tdCommon = tempObj.tdCommon

	fieldMemberID, _ := unmarshalMessageSender(objMap["member_id"])
	chatEventMemberRestricted.MemberID = fieldMemberID

	fieldOldStatus, _ := unmarshalChatMemberStatus(objMap["old_status"])
	chatEventMemberRestricted.OldStatus = fieldOldStatus

	fieldNewStatus, _ := unmarshalChatMemberStatus(objMap["new_status"])
	chatEventMemberRestricted.NewStatus = fieldNewStatus

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventMemberRestricted *ChatEventMemberRestricted) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventMemberRestrictedType
}

// ChatEventMemberSubscriptionExtended A chat member extended their subscription to the chat
type ChatEventMemberSubscriptionExtended struct {
	tdCommon
	UserID    int64            `json:"user_id"`    // Affected chat member user identifier
	OldStatus ChatMemberStatus `json:"old_status"` // Previous status of the chat member
	NewStatus ChatMemberStatus `json:"new_status"` // New status of the chat member
}

// MessageType return the string telegram-type of ChatEventMemberSubscriptionExtended
func (chatEventMemberSubscriptionExtended *ChatEventMemberSubscriptionExtended) MessageType() string {
	return "chatEventMemberSubscriptionExtended"
}

// NewChatEventMemberSubscriptionExtended creates a new ChatEventMemberSubscriptionExtended
//
// @param userID Affected chat member user identifier
// @param oldStatus Previous status of the chat member
// @param newStatus New status of the chat member
func NewChatEventMemberSubscriptionExtended(userID int64, oldStatus ChatMemberStatus, newStatus ChatMemberStatus) *ChatEventMemberSubscriptionExtended {
	chatEventMemberSubscriptionExtendedTemp := ChatEventMemberSubscriptionExtended{
		tdCommon:  tdCommon{Type: "chatEventMemberSubscriptionExtended"},
		UserID:    userID,
		OldStatus: oldStatus,
		NewStatus: newStatus,
	}

	return &chatEventMemberSubscriptionExtendedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventMemberSubscriptionExtended *ChatEventMemberSubscriptionExtended) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID int64 `json:"user_id"` // Affected chat member user identifier

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventMemberSubscriptionExtended.tdCommon = tempObj.tdCommon
	chatEventMemberSubscriptionExtended.UserID = tempObj.UserID

	fieldOldStatus, _ := unmarshalChatMemberStatus(objMap["old_status"])
	chatEventMemberSubscriptionExtended.OldStatus = fieldOldStatus

	fieldNewStatus, _ := unmarshalChatMemberStatus(objMap["new_status"])
	chatEventMemberSubscriptionExtended.NewStatus = fieldNewStatus

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventMemberSubscriptionExtended *ChatEventMemberSubscriptionExtended) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventMemberSubscriptionExtendedType
}

// ChatEventAvailableReactionsChanged The chat available reactions were changed
type ChatEventAvailableReactionsChanged struct {
	tdCommon
	OldAvailableReactions ChatAvailableReactions `json:"old_available_reactions"` // Previous chat available reactions
	NewAvailableReactions ChatAvailableReactions `json:"new_available_reactions"` // New chat available reactions
}

// MessageType return the string telegram-type of ChatEventAvailableReactionsChanged
func (chatEventAvailableReactionsChanged *ChatEventAvailableReactionsChanged) MessageType() string {
	return "chatEventAvailableReactionsChanged"
}

// NewChatEventAvailableReactionsChanged creates a new ChatEventAvailableReactionsChanged
//
// @param oldAvailableReactions Previous chat available reactions
// @param newAvailableReactions New chat available reactions
func NewChatEventAvailableReactionsChanged(oldAvailableReactions ChatAvailableReactions, newAvailableReactions ChatAvailableReactions) *ChatEventAvailableReactionsChanged {
	chatEventAvailableReactionsChangedTemp := ChatEventAvailableReactionsChanged{
		tdCommon:              tdCommon{Type: "chatEventAvailableReactionsChanged"},
		OldAvailableReactions: oldAvailableReactions,
		NewAvailableReactions: newAvailableReactions,
	}

	return &chatEventAvailableReactionsChangedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventAvailableReactionsChanged *ChatEventAvailableReactionsChanged) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventAvailableReactionsChanged.tdCommon = tempObj.tdCommon

	fieldOldAvailableReactions, _ := unmarshalChatAvailableReactions(objMap["old_available_reactions"])
	chatEventAvailableReactionsChanged.OldAvailableReactions = fieldOldAvailableReactions

	fieldNewAvailableReactions, _ := unmarshalChatAvailableReactions(objMap["new_available_reactions"])
	chatEventAvailableReactionsChanged.NewAvailableReactions = fieldNewAvailableReactions

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventAvailableReactionsChanged *ChatEventAvailableReactionsChanged) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventAvailableReactionsChangedType
}

// ChatEventBackgroundChanged The chat background was changed
type ChatEventBackgroundChanged struct {
	tdCommon
	OldBackground *ChatBackground `json:"old_background"` // Previous background; may be null if none
	NewBackground *ChatBackground `json:"new_background"` // New background; may be null if none
}

// MessageType return the string telegram-type of ChatEventBackgroundChanged
func (chatEventBackgroundChanged *ChatEventBackgroundChanged) MessageType() string {
	return "chatEventBackgroundChanged"
}

// NewChatEventBackgroundChanged creates a new ChatEventBackgroundChanged
//
// @param oldBackground Previous background; may be null if none
// @param newBackground New background; may be null if none
func NewChatEventBackgroundChanged(oldBackground *ChatBackground, newBackground *ChatBackground) *ChatEventBackgroundChanged {
	chatEventBackgroundChangedTemp := ChatEventBackgroundChanged{
		tdCommon:      tdCommon{Type: "chatEventBackgroundChanged"},
		OldBackground: oldBackground,
		NewBackground: newBackground,
	}

	return &chatEventBackgroundChangedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventBackgroundChanged *ChatEventBackgroundChanged) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OldBackground *ChatBackground `json:"old_background"` // Previous background; may be null if none
		NewBackground *ChatBackground `json:"new_background"` // New background; may be null if none
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventBackgroundChanged.tdCommon = tempObj.tdCommon
	chatEventBackgroundChanged.OldBackground = tempObj.OldBackground
	chatEventBackgroundChanged.NewBackground = tempObj.NewBackground

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventBackgroundChanged *ChatEventBackgroundChanged) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventBackgroundChangedType
}

// ChatEventDescriptionChanged The chat description was changed
type ChatEventDescriptionChanged struct {
	tdCommon
	OldDescription string `json:"old_description"` // Previous chat description
	NewDescription string `json:"new_description"` // New chat description
}

// MessageType return the string telegram-type of ChatEventDescriptionChanged
func (chatEventDescriptionChanged *ChatEventDescriptionChanged) MessageType() string {
	return "chatEventDescriptionChanged"
}

// NewChatEventDescriptionChanged creates a new ChatEventDescriptionChanged
//
// @param oldDescription Previous chat description
// @param newDescription New chat description
func NewChatEventDescriptionChanged(oldDescription string, newDescription string) *ChatEventDescriptionChanged {
	chatEventDescriptionChangedTemp := ChatEventDescriptionChanged{
		tdCommon:       tdCommon{Type: "chatEventDescriptionChanged"},
		OldDescription: oldDescription,
		NewDescription: newDescription,
	}

	return &chatEventDescriptionChangedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventDescriptionChanged *ChatEventDescriptionChanged) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OldDescription string `json:"old_description"` // Previous chat description
		NewDescription string `json:"new_description"` // New chat description
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventDescriptionChanged.tdCommon = tempObj.tdCommon
	chatEventDescriptionChanged.OldDescription = tempObj.OldDescription
	chatEventDescriptionChanged.NewDescription = tempObj.NewDescription

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventDescriptionChanged *ChatEventDescriptionChanged) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventDescriptionChangedType
}

// ChatEventEmojiStatusChanged The chat emoji status was changed
type ChatEventEmojiStatusChanged struct {
	tdCommon
	OldEmojiStatus *EmojiStatus `json:"old_emoji_status"` // Previous emoji status; may be null if none
	NewEmojiStatus *EmojiStatus `json:"new_emoji_status"` // New emoji status; may be null if none
}

// MessageType return the string telegram-type of ChatEventEmojiStatusChanged
func (chatEventEmojiStatusChanged *ChatEventEmojiStatusChanged) MessageType() string {
	return "chatEventEmojiStatusChanged"
}

// NewChatEventEmojiStatusChanged creates a new ChatEventEmojiStatusChanged
//
// @param oldEmojiStatus Previous emoji status; may be null if none
// @param newEmojiStatus New emoji status; may be null if none
func NewChatEventEmojiStatusChanged(oldEmojiStatus *EmojiStatus, newEmojiStatus *EmojiStatus) *ChatEventEmojiStatusChanged {
	chatEventEmojiStatusChangedTemp := ChatEventEmojiStatusChanged{
		tdCommon:       tdCommon{Type: "chatEventEmojiStatusChanged"},
		OldEmojiStatus: oldEmojiStatus,
		NewEmojiStatus: newEmojiStatus,
	}

	return &chatEventEmojiStatusChangedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventEmojiStatusChanged *ChatEventEmojiStatusChanged) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OldEmojiStatus *EmojiStatus `json:"old_emoji_status"` // Previous emoji status; may be null if none
		NewEmojiStatus *EmojiStatus `json:"new_emoji_status"` // New emoji status; may be null if none
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventEmojiStatusChanged.tdCommon = tempObj.tdCommon
	chatEventEmojiStatusChanged.OldEmojiStatus = tempObj.OldEmojiStatus
	chatEventEmojiStatusChanged.NewEmojiStatus = tempObj.NewEmojiStatus

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventEmojiStatusChanged *ChatEventEmojiStatusChanged) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventEmojiStatusChangedType
}

// ChatEventLinkedChatChanged The linked chat of a supergroup was changed
type ChatEventLinkedChatChanged struct {
	tdCommon
	OldLinkedChatID int64 `json:"old_linked_chat_id"` // Previous supergroup linked chat identifier
	NewLinkedChatID int64 `json:"new_linked_chat_id"` // New supergroup linked chat identifier
}

// MessageType return the string telegram-type of ChatEventLinkedChatChanged
func (chatEventLinkedChatChanged *ChatEventLinkedChatChanged) MessageType() string {
	return "chatEventLinkedChatChanged"
}

// NewChatEventLinkedChatChanged creates a new ChatEventLinkedChatChanged
//
// @param oldLinkedChatID Previous supergroup linked chat identifier
// @param newLinkedChatID New supergroup linked chat identifier
func NewChatEventLinkedChatChanged(oldLinkedChatID int64, newLinkedChatID int64) *ChatEventLinkedChatChanged {
	chatEventLinkedChatChangedTemp := ChatEventLinkedChatChanged{
		tdCommon:        tdCommon{Type: "chatEventLinkedChatChanged"},
		OldLinkedChatID: oldLinkedChatID,
		NewLinkedChatID: newLinkedChatID,
	}

	return &chatEventLinkedChatChangedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventLinkedChatChanged *ChatEventLinkedChatChanged) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OldLinkedChatID int64 `json:"old_linked_chat_id"` // Previous supergroup linked chat identifier
		NewLinkedChatID int64 `json:"new_linked_chat_id"` // New supergroup linked chat identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventLinkedChatChanged.tdCommon = tempObj.tdCommon
	chatEventLinkedChatChanged.OldLinkedChatID = tempObj.OldLinkedChatID
	chatEventLinkedChatChanged.NewLinkedChatID = tempObj.NewLinkedChatID

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventLinkedChatChanged *ChatEventLinkedChatChanged) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventLinkedChatChangedType
}

// ChatEventLocationChanged The supergroup location was changed
type ChatEventLocationChanged struct {
	tdCommon
	OldLocation *ChatLocation `json:"old_location"` // Previous location; may be null
	NewLocation *ChatLocation `json:"new_location"` // New location; may be null
}

// MessageType return the string telegram-type of ChatEventLocationChanged
func (chatEventLocationChanged *ChatEventLocationChanged) MessageType() string {
	return "chatEventLocationChanged"
}

// NewChatEventLocationChanged creates a new ChatEventLocationChanged
//
// @param oldLocation Previous location; may be null
// @param newLocation New location; may be null
func NewChatEventLocationChanged(oldLocation *ChatLocation, newLocation *ChatLocation) *ChatEventLocationChanged {
	chatEventLocationChangedTemp := ChatEventLocationChanged{
		tdCommon:    tdCommon{Type: "chatEventLocationChanged"},
		OldLocation: oldLocation,
		NewLocation: newLocation,
	}

	return &chatEventLocationChangedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventLocationChanged *ChatEventLocationChanged) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OldLocation *ChatLocation `json:"old_location"` // Previous location; may be null
		NewLocation *ChatLocation `json:"new_location"` // New location; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventLocationChanged.tdCommon = tempObj.tdCommon
	chatEventLocationChanged.OldLocation = tempObj.OldLocation
	chatEventLocationChanged.NewLocation = tempObj.NewLocation

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventLocationChanged *ChatEventLocationChanged) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventLocationChangedType
}

// ChatEventMessageAutoDeleteTimeChanged The message auto-delete timer was changed
type ChatEventMessageAutoDeleteTimeChanged struct {
	tdCommon
	OldMessageAutoDeleteTime int32 `json:"old_message_auto_delete_time"` // Previous value of message_auto_delete_time
	NewMessageAutoDeleteTime int32 `json:"new_message_auto_delete_time"` // New value of message_auto_delete_time
}

// MessageType return the string telegram-type of ChatEventMessageAutoDeleteTimeChanged
func (chatEventMessageAutoDeleteTimeChanged *ChatEventMessageAutoDeleteTimeChanged) MessageType() string {
	return "chatEventMessageAutoDeleteTimeChanged"
}

// NewChatEventMessageAutoDeleteTimeChanged creates a new ChatEventMessageAutoDeleteTimeChanged
//
// @param oldMessageAutoDeleteTime Previous value of message_auto_delete_time
// @param newMessageAutoDeleteTime New value of message_auto_delete_time
func NewChatEventMessageAutoDeleteTimeChanged(oldMessageAutoDeleteTime int32, newMessageAutoDeleteTime int32) *ChatEventMessageAutoDeleteTimeChanged {
	chatEventMessageAutoDeleteTimeChangedTemp := ChatEventMessageAutoDeleteTimeChanged{
		tdCommon:                 tdCommon{Type: "chatEventMessageAutoDeleteTimeChanged"},
		OldMessageAutoDeleteTime: oldMessageAutoDeleteTime,
		NewMessageAutoDeleteTime: newMessageAutoDeleteTime,
	}

	return &chatEventMessageAutoDeleteTimeChangedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventMessageAutoDeleteTimeChanged *ChatEventMessageAutoDeleteTimeChanged) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OldMessageAutoDeleteTime int32 `json:"old_message_auto_delete_time"` // Previous value of message_auto_delete_time
		NewMessageAutoDeleteTime int32 `json:"new_message_auto_delete_time"` // New value of message_auto_delete_time
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventMessageAutoDeleteTimeChanged.tdCommon = tempObj.tdCommon
	chatEventMessageAutoDeleteTimeChanged.OldMessageAutoDeleteTime = tempObj.OldMessageAutoDeleteTime
	chatEventMessageAutoDeleteTimeChanged.NewMessageAutoDeleteTime = tempObj.NewMessageAutoDeleteTime

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventMessageAutoDeleteTimeChanged *ChatEventMessageAutoDeleteTimeChanged) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventMessageAutoDeleteTimeChangedType
}

// ChatEventPermissionsChanged The chat permissions were changed
type ChatEventPermissionsChanged struct {
	tdCommon
	OldPermissions *ChatPermissions `json:"old_permissions"` // Previous chat permissions
	NewPermissions *ChatPermissions `json:"new_permissions"` // New chat permissions
}

// MessageType return the string telegram-type of ChatEventPermissionsChanged
func (chatEventPermissionsChanged *ChatEventPermissionsChanged) MessageType() string {
	return "chatEventPermissionsChanged"
}

// NewChatEventPermissionsChanged creates a new ChatEventPermissionsChanged
//
// @param oldPermissions Previous chat permissions
// @param newPermissions New chat permissions
func NewChatEventPermissionsChanged(oldPermissions *ChatPermissions, newPermissions *ChatPermissions) *ChatEventPermissionsChanged {
	chatEventPermissionsChangedTemp := ChatEventPermissionsChanged{
		tdCommon:       tdCommon{Type: "chatEventPermissionsChanged"},
		OldPermissions: oldPermissions,
		NewPermissions: newPermissions,
	}

	return &chatEventPermissionsChangedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventPermissionsChanged *ChatEventPermissionsChanged) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OldPermissions *ChatPermissions `json:"old_permissions"` // Previous chat permissions
		NewPermissions *ChatPermissions `json:"new_permissions"` // New chat permissions
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventPermissionsChanged.tdCommon = tempObj.tdCommon
	chatEventPermissionsChanged.OldPermissions = tempObj.OldPermissions
	chatEventPermissionsChanged.NewPermissions = tempObj.NewPermissions

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventPermissionsChanged *ChatEventPermissionsChanged) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventPermissionsChangedType
}

// ChatEventPhotoChanged The chat photo was changed
type ChatEventPhotoChanged struct {
	tdCommon
	OldPhoto *ChatPhoto `json:"old_photo"` // Previous chat photo value; may be null
	NewPhoto *ChatPhoto `json:"new_photo"` // New chat photo value; may be null
}

// MessageType return the string telegram-type of ChatEventPhotoChanged
func (chatEventPhotoChanged *ChatEventPhotoChanged) MessageType() string {
	return "chatEventPhotoChanged"
}

// NewChatEventPhotoChanged creates a new ChatEventPhotoChanged
//
// @param oldPhoto Previous chat photo value; may be null
// @param newPhoto New chat photo value; may be null
func NewChatEventPhotoChanged(oldPhoto *ChatPhoto, newPhoto *ChatPhoto) *ChatEventPhotoChanged {
	chatEventPhotoChangedTemp := ChatEventPhotoChanged{
		tdCommon: tdCommon{Type: "chatEventPhotoChanged"},
		OldPhoto: oldPhoto,
		NewPhoto: newPhoto,
	}

	return &chatEventPhotoChangedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventPhotoChanged *ChatEventPhotoChanged) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OldPhoto *ChatPhoto `json:"old_photo"` // Previous chat photo value; may be null
		NewPhoto *ChatPhoto `json:"new_photo"` // New chat photo value; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventPhotoChanged.tdCommon = tempObj.tdCommon
	chatEventPhotoChanged.OldPhoto = tempObj.OldPhoto
	chatEventPhotoChanged.NewPhoto = tempObj.NewPhoto

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventPhotoChanged *ChatEventPhotoChanged) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventPhotoChangedType
}

// ChatEventSlowModeDelayChanged The slow_mode_delay setting of a supergroup was changed
type ChatEventSlowModeDelayChanged struct {
	tdCommon
	OldSlowModeDelay int32 `json:"old_slow_mode_delay"` // Previous value of slow_mode_delay, in seconds
	NewSlowModeDelay int32 `json:"new_slow_mode_delay"` // New value of slow_mode_delay, in seconds
}

// MessageType return the string telegram-type of ChatEventSlowModeDelayChanged
func (chatEventSlowModeDelayChanged *ChatEventSlowModeDelayChanged) MessageType() string {
	return "chatEventSlowModeDelayChanged"
}

// NewChatEventSlowModeDelayChanged creates a new ChatEventSlowModeDelayChanged
//
// @param oldSlowModeDelay Previous value of slow_mode_delay, in seconds
// @param newSlowModeDelay New value of slow_mode_delay, in seconds
func NewChatEventSlowModeDelayChanged(oldSlowModeDelay int32, newSlowModeDelay int32) *ChatEventSlowModeDelayChanged {
	chatEventSlowModeDelayChangedTemp := ChatEventSlowModeDelayChanged{
		tdCommon:         tdCommon{Type: "chatEventSlowModeDelayChanged"},
		OldSlowModeDelay: oldSlowModeDelay,
		NewSlowModeDelay: newSlowModeDelay,
	}

	return &chatEventSlowModeDelayChangedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventSlowModeDelayChanged *ChatEventSlowModeDelayChanged) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OldSlowModeDelay int32 `json:"old_slow_mode_delay"` // Previous value of slow_mode_delay, in seconds
		NewSlowModeDelay int32 `json:"new_slow_mode_delay"` // New value of slow_mode_delay, in seconds
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventSlowModeDelayChanged.tdCommon = tempObj.tdCommon
	chatEventSlowModeDelayChanged.OldSlowModeDelay = tempObj.OldSlowModeDelay
	chatEventSlowModeDelayChanged.NewSlowModeDelay = tempObj.NewSlowModeDelay

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventSlowModeDelayChanged *ChatEventSlowModeDelayChanged) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventSlowModeDelayChangedType
}

// ChatEventStickerSetChanged The supergroup sticker set was changed
type ChatEventStickerSetChanged struct {
	tdCommon
	OldStickerSetID JSONInt64 `json:"old_sticker_set_id"` // Previous identifier of the chat sticker set; 0 if none
	NewStickerSetID JSONInt64 `json:"new_sticker_set_id"` // New identifier of the chat sticker set; 0 if none
}

// MessageType return the string telegram-type of ChatEventStickerSetChanged
func (chatEventStickerSetChanged *ChatEventStickerSetChanged) MessageType() string {
	return "chatEventStickerSetChanged"
}

// NewChatEventStickerSetChanged creates a new ChatEventStickerSetChanged
//
// @param oldStickerSetID Previous identifier of the chat sticker set; 0 if none
// @param newStickerSetID New identifier of the chat sticker set; 0 if none
func NewChatEventStickerSetChanged(oldStickerSetID JSONInt64, newStickerSetID JSONInt64) *ChatEventStickerSetChanged {
	chatEventStickerSetChangedTemp := ChatEventStickerSetChanged{
		tdCommon:        tdCommon{Type: "chatEventStickerSetChanged"},
		OldStickerSetID: oldStickerSetID,
		NewStickerSetID: newStickerSetID,
	}

	return &chatEventStickerSetChangedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventStickerSetChanged *ChatEventStickerSetChanged) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OldStickerSetID JSONInt64 `json:"old_sticker_set_id"` // Previous identifier of the chat sticker set; 0 if none
		NewStickerSetID JSONInt64 `json:"new_sticker_set_id"` // New identifier of the chat sticker set; 0 if none
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventStickerSetChanged.tdCommon = tempObj.tdCommon
	chatEventStickerSetChanged.OldStickerSetID = tempObj.OldStickerSetID
	chatEventStickerSetChanged.NewStickerSetID = tempObj.NewStickerSetID

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventStickerSetChanged *ChatEventStickerSetChanged) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventStickerSetChangedType
}

// ChatEventCustomEmojiStickerSetChanged The supergroup sticker set with allowed custom emoji was changed
type ChatEventCustomEmojiStickerSetChanged struct {
	tdCommon
	OldStickerSetID JSONInt64 `json:"old_sticker_set_id"` // Previous identifier of the chat sticker set; 0 if none
	NewStickerSetID JSONInt64 `json:"new_sticker_set_id"` // New identifier of the chat sticker set; 0 if none
}

// MessageType return the string telegram-type of ChatEventCustomEmojiStickerSetChanged
func (chatEventCustomEmojiStickerSetChanged *ChatEventCustomEmojiStickerSetChanged) MessageType() string {
	return "chatEventCustomEmojiStickerSetChanged"
}

// NewChatEventCustomEmojiStickerSetChanged creates a new ChatEventCustomEmojiStickerSetChanged
//
// @param oldStickerSetID Previous identifier of the chat sticker set; 0 if none
// @param newStickerSetID New identifier of the chat sticker set; 0 if none
func NewChatEventCustomEmojiStickerSetChanged(oldStickerSetID JSONInt64, newStickerSetID JSONInt64) *ChatEventCustomEmojiStickerSetChanged {
	chatEventCustomEmojiStickerSetChangedTemp := ChatEventCustomEmojiStickerSetChanged{
		tdCommon:        tdCommon{Type: "chatEventCustomEmojiStickerSetChanged"},
		OldStickerSetID: oldStickerSetID,
		NewStickerSetID: newStickerSetID,
	}

	return &chatEventCustomEmojiStickerSetChangedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventCustomEmojiStickerSetChanged *ChatEventCustomEmojiStickerSetChanged) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OldStickerSetID JSONInt64 `json:"old_sticker_set_id"` // Previous identifier of the chat sticker set; 0 if none
		NewStickerSetID JSONInt64 `json:"new_sticker_set_id"` // New identifier of the chat sticker set; 0 if none
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventCustomEmojiStickerSetChanged.tdCommon = tempObj.tdCommon
	chatEventCustomEmojiStickerSetChanged.OldStickerSetID = tempObj.OldStickerSetID
	chatEventCustomEmojiStickerSetChanged.NewStickerSetID = tempObj.NewStickerSetID

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventCustomEmojiStickerSetChanged *ChatEventCustomEmojiStickerSetChanged) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventCustomEmojiStickerSetChangedType
}

// ChatEventTitleChanged The chat title was changed
type ChatEventTitleChanged struct {
	tdCommon
	OldTitle string `json:"old_title"` // Previous chat title
	NewTitle string `json:"new_title"` // New chat title
}

// MessageType return the string telegram-type of ChatEventTitleChanged
func (chatEventTitleChanged *ChatEventTitleChanged) MessageType() string {
	return "chatEventTitleChanged"
}

// NewChatEventTitleChanged creates a new ChatEventTitleChanged
//
// @param oldTitle Previous chat title
// @param newTitle New chat title
func NewChatEventTitleChanged(oldTitle string, newTitle string) *ChatEventTitleChanged {
	chatEventTitleChangedTemp := ChatEventTitleChanged{
		tdCommon: tdCommon{Type: "chatEventTitleChanged"},
		OldTitle: oldTitle,
		NewTitle: newTitle,
	}

	return &chatEventTitleChangedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventTitleChanged *ChatEventTitleChanged) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OldTitle string `json:"old_title"` // Previous chat title
		NewTitle string `json:"new_title"` // New chat title
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventTitleChanged.tdCommon = tempObj.tdCommon
	chatEventTitleChanged.OldTitle = tempObj.OldTitle
	chatEventTitleChanged.NewTitle = tempObj.NewTitle

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventTitleChanged *ChatEventTitleChanged) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventTitleChangedType
}

// ChatEventUsernameChanged The chat editable username was changed
type ChatEventUsernameChanged struct {
	tdCommon
	OldUsername string `json:"old_username"` // Previous chat username
	NewUsername string `json:"new_username"` // New chat username
}

// MessageType return the string telegram-type of ChatEventUsernameChanged
func (chatEventUsernameChanged *ChatEventUsernameChanged) MessageType() string {
	return "chatEventUsernameChanged"
}

// NewChatEventUsernameChanged creates a new ChatEventUsernameChanged
//
// @param oldUsername Previous chat username
// @param newUsername New chat username
func NewChatEventUsernameChanged(oldUsername string, newUsername string) *ChatEventUsernameChanged {
	chatEventUsernameChangedTemp := ChatEventUsernameChanged{
		tdCommon:    tdCommon{Type: "chatEventUsernameChanged"},
		OldUsername: oldUsername,
		NewUsername: newUsername,
	}

	return &chatEventUsernameChangedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventUsernameChanged *ChatEventUsernameChanged) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OldUsername string `json:"old_username"` // Previous chat username
		NewUsername string `json:"new_username"` // New chat username
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventUsernameChanged.tdCommon = tempObj.tdCommon
	chatEventUsernameChanged.OldUsername = tempObj.OldUsername
	chatEventUsernameChanged.NewUsername = tempObj.NewUsername

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventUsernameChanged *ChatEventUsernameChanged) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventUsernameChangedType
}

// ChatEventActiveUsernamesChanged The chat active usernames were changed
type ChatEventActiveUsernamesChanged struct {
	tdCommon
	OldUsernames []string `json:"old_usernames"` // Previous list of active usernames
	NewUsernames []string `json:"new_usernames"` // New list of active usernames
}

// MessageType return the string telegram-type of ChatEventActiveUsernamesChanged
func (chatEventActiveUsernamesChanged *ChatEventActiveUsernamesChanged) MessageType() string {
	return "chatEventActiveUsernamesChanged"
}

// NewChatEventActiveUsernamesChanged creates a new ChatEventActiveUsernamesChanged
//
// @param oldUsernames Previous list of active usernames
// @param newUsernames New list of active usernames
func NewChatEventActiveUsernamesChanged(oldUsernames []string, newUsernames []string) *ChatEventActiveUsernamesChanged {
	chatEventActiveUsernamesChangedTemp := ChatEventActiveUsernamesChanged{
		tdCommon:     tdCommon{Type: "chatEventActiveUsernamesChanged"},
		OldUsernames: oldUsernames,
		NewUsernames: newUsernames,
	}

	return &chatEventActiveUsernamesChangedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventActiveUsernamesChanged *ChatEventActiveUsernamesChanged) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OldUsernames []string `json:"old_usernames"` // Previous list of active usernames
		NewUsernames []string `json:"new_usernames"` // New list of active usernames
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventActiveUsernamesChanged.tdCommon = tempObj.tdCommon
	chatEventActiveUsernamesChanged.OldUsernames = tempObj.OldUsernames
	chatEventActiveUsernamesChanged.NewUsernames = tempObj.NewUsernames

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventActiveUsernamesChanged *ChatEventActiveUsernamesChanged) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventActiveUsernamesChangedType
}

// ChatEventAccentColorChanged The chat accent color or background custom emoji were changed
type ChatEventAccentColorChanged struct {
	tdCommon
	OldAccentColorID           int32     `json:"old_accent_color_id"`            // Previous identifier of chat accent color
	OldBackgroundCustomEmojiID JSONInt64 `json:"old_background_custom_emoji_id"` // Previous identifier of the custom emoji; 0 if none
	NewAccentColorID           int32     `json:"new_accent_color_id"`            // New identifier of chat accent color
	NewBackgroundCustomEmojiID JSONInt64 `json:"new_background_custom_emoji_id"` // New identifier of the custom emoji; 0 if none
}

// MessageType return the string telegram-type of ChatEventAccentColorChanged
func (chatEventAccentColorChanged *ChatEventAccentColorChanged) MessageType() string {
	return "chatEventAccentColorChanged"
}

// NewChatEventAccentColorChanged creates a new ChatEventAccentColorChanged
//
// @param oldAccentColorID Previous identifier of chat accent color
// @param oldBackgroundCustomEmojiID Previous identifier of the custom emoji; 0 if none
// @param newAccentColorID New identifier of chat accent color
// @param newBackgroundCustomEmojiID New identifier of the custom emoji; 0 if none
func NewChatEventAccentColorChanged(oldAccentColorID int32, oldBackgroundCustomEmojiID JSONInt64, newAccentColorID int32, newBackgroundCustomEmojiID JSONInt64) *ChatEventAccentColorChanged {
	chatEventAccentColorChangedTemp := ChatEventAccentColorChanged{
		tdCommon:                   tdCommon{Type: "chatEventAccentColorChanged"},
		OldAccentColorID:           oldAccentColorID,
		OldBackgroundCustomEmojiID: oldBackgroundCustomEmojiID,
		NewAccentColorID:           newAccentColorID,
		NewBackgroundCustomEmojiID: newBackgroundCustomEmojiID,
	}

	return &chatEventAccentColorChangedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventAccentColorChanged *ChatEventAccentColorChanged) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OldAccentColorID           int32     `json:"old_accent_color_id"`            // Previous identifier of chat accent color
		OldBackgroundCustomEmojiID JSONInt64 `json:"old_background_custom_emoji_id"` // Previous identifier of the custom emoji; 0 if none
		NewAccentColorID           int32     `json:"new_accent_color_id"`            // New identifier of chat accent color
		NewBackgroundCustomEmojiID JSONInt64 `json:"new_background_custom_emoji_id"` // New identifier of the custom emoji; 0 if none
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventAccentColorChanged.tdCommon = tempObj.tdCommon
	chatEventAccentColorChanged.OldAccentColorID = tempObj.OldAccentColorID
	chatEventAccentColorChanged.OldBackgroundCustomEmojiID = tempObj.OldBackgroundCustomEmojiID
	chatEventAccentColorChanged.NewAccentColorID = tempObj.NewAccentColorID
	chatEventAccentColorChanged.NewBackgroundCustomEmojiID = tempObj.NewBackgroundCustomEmojiID

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventAccentColorChanged *ChatEventAccentColorChanged) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventAccentColorChangedType
}

// ChatEventProfileAccentColorChanged The chat's profile accent color or profile background custom emoji were changed
type ChatEventProfileAccentColorChanged struct {
	tdCommon
	OldProfileAccentColorID           int32     `json:"old_profile_accent_color_id"`            // Previous identifier of chat's profile accent color; -1 if none
	OldProfileBackgroundCustomEmojiID JSONInt64 `json:"old_profile_background_custom_emoji_id"` // Previous identifier of the custom emoji; 0 if none
	NewProfileAccentColorID           int32     `json:"new_profile_accent_color_id"`            // New identifier of chat's profile accent color; -1 if none
	NewProfileBackgroundCustomEmojiID JSONInt64 `json:"new_profile_background_custom_emoji_id"` // New identifier of the custom emoji; 0 if none
}

// MessageType return the string telegram-type of ChatEventProfileAccentColorChanged
func (chatEventProfileAccentColorChanged *ChatEventProfileAccentColorChanged) MessageType() string {
	return "chatEventProfileAccentColorChanged"
}

// NewChatEventProfileAccentColorChanged creates a new ChatEventProfileAccentColorChanged
//
// @param oldProfileAccentColorID Previous identifier of chat's profile accent color; -1 if none
// @param oldProfileBackgroundCustomEmojiID Previous identifier of the custom emoji; 0 if none
// @param newProfileAccentColorID New identifier of chat's profile accent color; -1 if none
// @param newProfileBackgroundCustomEmojiID New identifier of the custom emoji; 0 if none
func NewChatEventProfileAccentColorChanged(oldProfileAccentColorID int32, oldProfileBackgroundCustomEmojiID JSONInt64, newProfileAccentColorID int32, newProfileBackgroundCustomEmojiID JSONInt64) *ChatEventProfileAccentColorChanged {
	chatEventProfileAccentColorChangedTemp := ChatEventProfileAccentColorChanged{
		tdCommon:                          tdCommon{Type: "chatEventProfileAccentColorChanged"},
		OldProfileAccentColorID:           oldProfileAccentColorID,
		OldProfileBackgroundCustomEmojiID: oldProfileBackgroundCustomEmojiID,
		NewProfileAccentColorID:           newProfileAccentColorID,
		NewProfileBackgroundCustomEmojiID: newProfileBackgroundCustomEmojiID,
	}

	return &chatEventProfileAccentColorChangedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventProfileAccentColorChanged *ChatEventProfileAccentColorChanged) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OldProfileAccentColorID           int32     `json:"old_profile_accent_color_id"`            // Previous identifier of chat's profile accent color; -1 if none
		OldProfileBackgroundCustomEmojiID JSONInt64 `json:"old_profile_background_custom_emoji_id"` // Previous identifier of the custom emoji; 0 if none
		NewProfileAccentColorID           int32     `json:"new_profile_accent_color_id"`            // New identifier of chat's profile accent color; -1 if none
		NewProfileBackgroundCustomEmojiID JSONInt64 `json:"new_profile_background_custom_emoji_id"` // New identifier of the custom emoji; 0 if none
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventProfileAccentColorChanged.tdCommon = tempObj.tdCommon
	chatEventProfileAccentColorChanged.OldProfileAccentColorID = tempObj.OldProfileAccentColorID
	chatEventProfileAccentColorChanged.OldProfileBackgroundCustomEmojiID = tempObj.OldProfileBackgroundCustomEmojiID
	chatEventProfileAccentColorChanged.NewProfileAccentColorID = tempObj.NewProfileAccentColorID
	chatEventProfileAccentColorChanged.NewProfileBackgroundCustomEmojiID = tempObj.NewProfileBackgroundCustomEmojiID

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventProfileAccentColorChanged *ChatEventProfileAccentColorChanged) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventProfileAccentColorChangedType
}

// ChatEventHasProtectedContentToggled The has_protected_content setting of a channel was toggled
type ChatEventHasProtectedContentToggled struct {
	tdCommon
	HasProtectedContent bool `json:"has_protected_content"` // New value of has_protected_content
}

// MessageType return the string telegram-type of ChatEventHasProtectedContentToggled
func (chatEventHasProtectedContentToggled *ChatEventHasProtectedContentToggled) MessageType() string {
	return "chatEventHasProtectedContentToggled"
}

// NewChatEventHasProtectedContentToggled creates a new ChatEventHasProtectedContentToggled
//
// @param hasProtectedContent New value of has_protected_content
func NewChatEventHasProtectedContentToggled(hasProtectedContent bool) *ChatEventHasProtectedContentToggled {
	chatEventHasProtectedContentToggledTemp := ChatEventHasProtectedContentToggled{
		tdCommon:            tdCommon{Type: "chatEventHasProtectedContentToggled"},
		HasProtectedContent: hasProtectedContent,
	}

	return &chatEventHasProtectedContentToggledTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventHasProtectedContentToggled *ChatEventHasProtectedContentToggled) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		HasProtectedContent bool `json:"has_protected_content"` // New value of has_protected_content
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventHasProtectedContentToggled.tdCommon = tempObj.tdCommon
	chatEventHasProtectedContentToggled.HasProtectedContent = tempObj.HasProtectedContent

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventHasProtectedContentToggled *ChatEventHasProtectedContentToggled) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventHasProtectedContentToggledType
}

// ChatEventInvitesToggled The can_invite_users permission of a supergroup chat was toggled
type ChatEventInvitesToggled struct {
	tdCommon
	CanInviteUsers bool `json:"can_invite_users"` // New value of can_invite_users permission
}

// MessageType return the string telegram-type of ChatEventInvitesToggled
func (chatEventInvitesToggled *ChatEventInvitesToggled) MessageType() string {
	return "chatEventInvitesToggled"
}

// NewChatEventInvitesToggled creates a new ChatEventInvitesToggled
//
// @param canInviteUsers New value of can_invite_users permission
func NewChatEventInvitesToggled(canInviteUsers bool) *ChatEventInvitesToggled {
	chatEventInvitesToggledTemp := ChatEventInvitesToggled{
		tdCommon:       tdCommon{Type: "chatEventInvitesToggled"},
		CanInviteUsers: canInviteUsers,
	}

	return &chatEventInvitesToggledTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventInvitesToggled *ChatEventInvitesToggled) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CanInviteUsers bool `json:"can_invite_users"` // New value of can_invite_users permission
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventInvitesToggled.tdCommon = tempObj.tdCommon
	chatEventInvitesToggled.CanInviteUsers = tempObj.CanInviteUsers

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventInvitesToggled *ChatEventInvitesToggled) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventInvitesToggledType
}

// ChatEventIsAllHistoryAvailableToggled The is_all_history_available setting of a supergroup was toggled
type ChatEventIsAllHistoryAvailableToggled struct {
	tdCommon
	IsAllHistoryAvailable bool `json:"is_all_history_available"` // New value of is_all_history_available
}

// MessageType return the string telegram-type of ChatEventIsAllHistoryAvailableToggled
func (chatEventIsAllHistoryAvailableToggled *ChatEventIsAllHistoryAvailableToggled) MessageType() string {
	return "chatEventIsAllHistoryAvailableToggled"
}

// NewChatEventIsAllHistoryAvailableToggled creates a new ChatEventIsAllHistoryAvailableToggled
//
// @param isAllHistoryAvailable New value of is_all_history_available
func NewChatEventIsAllHistoryAvailableToggled(isAllHistoryAvailable bool) *ChatEventIsAllHistoryAvailableToggled {
	chatEventIsAllHistoryAvailableToggledTemp := ChatEventIsAllHistoryAvailableToggled{
		tdCommon:              tdCommon{Type: "chatEventIsAllHistoryAvailableToggled"},
		IsAllHistoryAvailable: isAllHistoryAvailable,
	}

	return &chatEventIsAllHistoryAvailableToggledTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventIsAllHistoryAvailableToggled *ChatEventIsAllHistoryAvailableToggled) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsAllHistoryAvailable bool `json:"is_all_history_available"` // New value of is_all_history_available
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventIsAllHistoryAvailableToggled.tdCommon = tempObj.tdCommon
	chatEventIsAllHistoryAvailableToggled.IsAllHistoryAvailable = tempObj.IsAllHistoryAvailable

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventIsAllHistoryAvailableToggled *ChatEventIsAllHistoryAvailableToggled) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventIsAllHistoryAvailableToggledType
}

// ChatEventHasAggressiveAntiSpamEnabledToggled The has_aggressive_anti_spam_enabled setting of a supergroup was toggled
type ChatEventHasAggressiveAntiSpamEnabledToggled struct {
	tdCommon
	HasAggressiveAntiSpamEnabled bool `json:"has_aggressive_anti_spam_enabled"` // New value of has_aggressive_anti_spam_enabled
}

// MessageType return the string telegram-type of ChatEventHasAggressiveAntiSpamEnabledToggled
func (chatEventHasAggressiveAntiSpamEnabledToggled *ChatEventHasAggressiveAntiSpamEnabledToggled) MessageType() string {
	return "chatEventHasAggressiveAntiSpamEnabledToggled"
}

// NewChatEventHasAggressiveAntiSpamEnabledToggled creates a new ChatEventHasAggressiveAntiSpamEnabledToggled
//
// @param hasAggressiveAntiSpamEnabled New value of has_aggressive_anti_spam_enabled
func NewChatEventHasAggressiveAntiSpamEnabledToggled(hasAggressiveAntiSpamEnabled bool) *ChatEventHasAggressiveAntiSpamEnabledToggled {
	chatEventHasAggressiveAntiSpamEnabledToggledTemp := ChatEventHasAggressiveAntiSpamEnabledToggled{
		tdCommon:                     tdCommon{Type: "chatEventHasAggressiveAntiSpamEnabledToggled"},
		HasAggressiveAntiSpamEnabled: hasAggressiveAntiSpamEnabled,
	}

	return &chatEventHasAggressiveAntiSpamEnabledToggledTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventHasAggressiveAntiSpamEnabledToggled *ChatEventHasAggressiveAntiSpamEnabledToggled) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		HasAggressiveAntiSpamEnabled bool `json:"has_aggressive_anti_spam_enabled"` // New value of has_aggressive_anti_spam_enabled
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventHasAggressiveAntiSpamEnabledToggled.tdCommon = tempObj.tdCommon
	chatEventHasAggressiveAntiSpamEnabledToggled.HasAggressiveAntiSpamEnabled = tempObj.HasAggressiveAntiSpamEnabled

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventHasAggressiveAntiSpamEnabledToggled *ChatEventHasAggressiveAntiSpamEnabledToggled) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventHasAggressiveAntiSpamEnabledToggledType
}

// ChatEventSignMessagesToggled The sign_messages setting of a channel was toggled
type ChatEventSignMessagesToggled struct {
	tdCommon
	SignMessages bool `json:"sign_messages"` // New value of sign_messages
}

// MessageType return the string telegram-type of ChatEventSignMessagesToggled
func (chatEventSignMessagesToggled *ChatEventSignMessagesToggled) MessageType() string {
	return "chatEventSignMessagesToggled"
}

// NewChatEventSignMessagesToggled creates a new ChatEventSignMessagesToggled
//
// @param signMessages New value of sign_messages
func NewChatEventSignMessagesToggled(signMessages bool) *ChatEventSignMessagesToggled {
	chatEventSignMessagesToggledTemp := ChatEventSignMessagesToggled{
		tdCommon:     tdCommon{Type: "chatEventSignMessagesToggled"},
		SignMessages: signMessages,
	}

	return &chatEventSignMessagesToggledTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventSignMessagesToggled *ChatEventSignMessagesToggled) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SignMessages bool `json:"sign_messages"` // New value of sign_messages
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventSignMessagesToggled.tdCommon = tempObj.tdCommon
	chatEventSignMessagesToggled.SignMessages = tempObj.SignMessages

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventSignMessagesToggled *ChatEventSignMessagesToggled) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventSignMessagesToggledType
}

// ChatEventShowMessageSenderToggled The show_message_sender setting of a channel was toggled
type ChatEventShowMessageSenderToggled struct {
	tdCommon
	ShowMessageSender bool `json:"show_message_sender"` // New value of show_message_sender
}

// MessageType return the string telegram-type of ChatEventShowMessageSenderToggled
func (chatEventShowMessageSenderToggled *ChatEventShowMessageSenderToggled) MessageType() string {
	return "chatEventShowMessageSenderToggled"
}

// NewChatEventShowMessageSenderToggled creates a new ChatEventShowMessageSenderToggled
//
// @param showMessageSender New value of show_message_sender
func NewChatEventShowMessageSenderToggled(showMessageSender bool) *ChatEventShowMessageSenderToggled {
	chatEventShowMessageSenderToggledTemp := ChatEventShowMessageSenderToggled{
		tdCommon:          tdCommon{Type: "chatEventShowMessageSenderToggled"},
		ShowMessageSender: showMessageSender,
	}

	return &chatEventShowMessageSenderToggledTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventShowMessageSenderToggled *ChatEventShowMessageSenderToggled) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ShowMessageSender bool `json:"show_message_sender"` // New value of show_message_sender
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventShowMessageSenderToggled.tdCommon = tempObj.tdCommon
	chatEventShowMessageSenderToggled.ShowMessageSender = tempObj.ShowMessageSender

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventShowMessageSenderToggled *ChatEventShowMessageSenderToggled) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventShowMessageSenderToggledType
}

// ChatEventInviteLinkEdited A chat invite link was edited
type ChatEventInviteLinkEdited struct {
	tdCommon
	OldInviteLink *ChatInviteLink `json:"old_invite_link"` // Previous information about the invite link
	NewInviteLink *ChatInviteLink `json:"new_invite_link"` // New information about the invite link
}

// MessageType return the string telegram-type of ChatEventInviteLinkEdited
func (chatEventInviteLinkEdited *ChatEventInviteLinkEdited) MessageType() string {
	return "chatEventInviteLinkEdited"
}

// NewChatEventInviteLinkEdited creates a new ChatEventInviteLinkEdited
//
// @param oldInviteLink Previous information about the invite link
// @param newInviteLink New information about the invite link
func NewChatEventInviteLinkEdited(oldInviteLink *ChatInviteLink, newInviteLink *ChatInviteLink) *ChatEventInviteLinkEdited {
	chatEventInviteLinkEditedTemp := ChatEventInviteLinkEdited{
		tdCommon:      tdCommon{Type: "chatEventInviteLinkEdited"},
		OldInviteLink: oldInviteLink,
		NewInviteLink: newInviteLink,
	}

	return &chatEventInviteLinkEditedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventInviteLinkEdited *ChatEventInviteLinkEdited) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OldInviteLink *ChatInviteLink `json:"old_invite_link"` // Previous information about the invite link
		NewInviteLink *ChatInviteLink `json:"new_invite_link"` // New information about the invite link
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventInviteLinkEdited.tdCommon = tempObj.tdCommon
	chatEventInviteLinkEdited.OldInviteLink = tempObj.OldInviteLink
	chatEventInviteLinkEdited.NewInviteLink = tempObj.NewInviteLink

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventInviteLinkEdited *ChatEventInviteLinkEdited) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventInviteLinkEditedType
}

// ChatEventInviteLinkRevoked A chat invite link was revoked
type ChatEventInviteLinkRevoked struct {
	tdCommon
	InviteLink *ChatInviteLink `json:"invite_link"` // The invite link
}

// MessageType return the string telegram-type of ChatEventInviteLinkRevoked
func (chatEventInviteLinkRevoked *ChatEventInviteLinkRevoked) MessageType() string {
	return "chatEventInviteLinkRevoked"
}

// NewChatEventInviteLinkRevoked creates a new ChatEventInviteLinkRevoked
//
// @param inviteLink The invite link
func NewChatEventInviteLinkRevoked(inviteLink *ChatInviteLink) *ChatEventInviteLinkRevoked {
	chatEventInviteLinkRevokedTemp := ChatEventInviteLinkRevoked{
		tdCommon:   tdCommon{Type: "chatEventInviteLinkRevoked"},
		InviteLink: inviteLink,
	}

	return &chatEventInviteLinkRevokedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventInviteLinkRevoked *ChatEventInviteLinkRevoked) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		InviteLink *ChatInviteLink `json:"invite_link"` // The invite link
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventInviteLinkRevoked.tdCommon = tempObj.tdCommon
	chatEventInviteLinkRevoked.InviteLink = tempObj.InviteLink

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventInviteLinkRevoked *ChatEventInviteLinkRevoked) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventInviteLinkRevokedType
}

// ChatEventInviteLinkDeleted A revoked chat invite link was deleted
type ChatEventInviteLinkDeleted struct {
	tdCommon
	InviteLink *ChatInviteLink `json:"invite_link"` // The invite link
}

// MessageType return the string telegram-type of ChatEventInviteLinkDeleted
func (chatEventInviteLinkDeleted *ChatEventInviteLinkDeleted) MessageType() string {
	return "chatEventInviteLinkDeleted"
}

// NewChatEventInviteLinkDeleted creates a new ChatEventInviteLinkDeleted
//
// @param inviteLink The invite link
func NewChatEventInviteLinkDeleted(inviteLink *ChatInviteLink) *ChatEventInviteLinkDeleted {
	chatEventInviteLinkDeletedTemp := ChatEventInviteLinkDeleted{
		tdCommon:   tdCommon{Type: "chatEventInviteLinkDeleted"},
		InviteLink: inviteLink,
	}

	return &chatEventInviteLinkDeletedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventInviteLinkDeleted *ChatEventInviteLinkDeleted) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		InviteLink *ChatInviteLink `json:"invite_link"` // The invite link
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventInviteLinkDeleted.tdCommon = tempObj.tdCommon
	chatEventInviteLinkDeleted.InviteLink = tempObj.InviteLink

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventInviteLinkDeleted *ChatEventInviteLinkDeleted) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventInviteLinkDeletedType
}

// ChatEventVideoChatCreated A video chat was created
type ChatEventVideoChatCreated struct {
	tdCommon
	GroupCallID int32 `json:"group_call_id"` // Identifier of the video chat. The video chat can be received through the method getGroupCall
}

// MessageType return the string telegram-type of ChatEventVideoChatCreated
func (chatEventVideoChatCreated *ChatEventVideoChatCreated) MessageType() string {
	return "chatEventVideoChatCreated"
}

// NewChatEventVideoChatCreated creates a new ChatEventVideoChatCreated
//
// @param groupCallID Identifier of the video chat. The video chat can be received through the method getGroupCall
func NewChatEventVideoChatCreated(groupCallID int32) *ChatEventVideoChatCreated {
	chatEventVideoChatCreatedTemp := ChatEventVideoChatCreated{
		tdCommon:    tdCommon{Type: "chatEventVideoChatCreated"},
		GroupCallID: groupCallID,
	}

	return &chatEventVideoChatCreatedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventVideoChatCreated *ChatEventVideoChatCreated) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		GroupCallID int32 `json:"group_call_id"` // Identifier of the video chat. The video chat can be received through the method getGroupCall
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventVideoChatCreated.tdCommon = tempObj.tdCommon
	chatEventVideoChatCreated.GroupCallID = tempObj.GroupCallID

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventVideoChatCreated *ChatEventVideoChatCreated) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventVideoChatCreatedType
}

// ChatEventVideoChatEnded A video chat was ended
type ChatEventVideoChatEnded struct {
	tdCommon
	GroupCallID int32 `json:"group_call_id"` // Identifier of the video chat. The video chat can be received through the method getGroupCall
}

// MessageType return the string telegram-type of ChatEventVideoChatEnded
func (chatEventVideoChatEnded *ChatEventVideoChatEnded) MessageType() string {
	return "chatEventVideoChatEnded"
}

// NewChatEventVideoChatEnded creates a new ChatEventVideoChatEnded
//
// @param groupCallID Identifier of the video chat. The video chat can be received through the method getGroupCall
func NewChatEventVideoChatEnded(groupCallID int32) *ChatEventVideoChatEnded {
	chatEventVideoChatEndedTemp := ChatEventVideoChatEnded{
		tdCommon:    tdCommon{Type: "chatEventVideoChatEnded"},
		GroupCallID: groupCallID,
	}

	return &chatEventVideoChatEndedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventVideoChatEnded *ChatEventVideoChatEnded) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		GroupCallID int32 `json:"group_call_id"` // Identifier of the video chat. The video chat can be received through the method getGroupCall
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventVideoChatEnded.tdCommon = tempObj.tdCommon
	chatEventVideoChatEnded.GroupCallID = tempObj.GroupCallID

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventVideoChatEnded *ChatEventVideoChatEnded) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventVideoChatEndedType
}

// ChatEventVideoChatMuteNewParticipantsToggled The mute_new_participants setting of a video chat was toggled
type ChatEventVideoChatMuteNewParticipantsToggled struct {
	tdCommon
	MuteNewParticipants bool `json:"mute_new_participants"` // New value of the mute_new_participants setting
}

// MessageType return the string telegram-type of ChatEventVideoChatMuteNewParticipantsToggled
func (chatEventVideoChatMuteNewParticipantsToggled *ChatEventVideoChatMuteNewParticipantsToggled) MessageType() string {
	return "chatEventVideoChatMuteNewParticipantsToggled"
}

// NewChatEventVideoChatMuteNewParticipantsToggled creates a new ChatEventVideoChatMuteNewParticipantsToggled
//
// @param muteNewParticipants New value of the mute_new_participants setting
func NewChatEventVideoChatMuteNewParticipantsToggled(muteNewParticipants bool) *ChatEventVideoChatMuteNewParticipantsToggled {
	chatEventVideoChatMuteNewParticipantsToggledTemp := ChatEventVideoChatMuteNewParticipantsToggled{
		tdCommon:            tdCommon{Type: "chatEventVideoChatMuteNewParticipantsToggled"},
		MuteNewParticipants: muteNewParticipants,
	}

	return &chatEventVideoChatMuteNewParticipantsToggledTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventVideoChatMuteNewParticipantsToggled *ChatEventVideoChatMuteNewParticipantsToggled) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MuteNewParticipants bool `json:"mute_new_participants"` // New value of the mute_new_participants setting
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventVideoChatMuteNewParticipantsToggled.tdCommon = tempObj.tdCommon
	chatEventVideoChatMuteNewParticipantsToggled.MuteNewParticipants = tempObj.MuteNewParticipants

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventVideoChatMuteNewParticipantsToggled *ChatEventVideoChatMuteNewParticipantsToggled) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventVideoChatMuteNewParticipantsToggledType
}

// ChatEventVideoChatParticipantIsMutedToggled A video chat participant was muted or unmuted
type ChatEventVideoChatParticipantIsMutedToggled struct {
	tdCommon
	ParticipantID MessageSender `json:"participant_id"` // Identifier of the affected group call participant
	IsMuted       bool          `json:"is_muted"`       // New value of is_muted
}

// MessageType return the string telegram-type of ChatEventVideoChatParticipantIsMutedToggled
func (chatEventVideoChatParticipantIsMutedToggled *ChatEventVideoChatParticipantIsMutedToggled) MessageType() string {
	return "chatEventVideoChatParticipantIsMutedToggled"
}

// NewChatEventVideoChatParticipantIsMutedToggled creates a new ChatEventVideoChatParticipantIsMutedToggled
//
// @param participantID Identifier of the affected group call participant
// @param isMuted New value of is_muted
func NewChatEventVideoChatParticipantIsMutedToggled(participantID MessageSender, isMuted bool) *ChatEventVideoChatParticipantIsMutedToggled {
	chatEventVideoChatParticipantIsMutedToggledTemp := ChatEventVideoChatParticipantIsMutedToggled{
		tdCommon:      tdCommon{Type: "chatEventVideoChatParticipantIsMutedToggled"},
		ParticipantID: participantID,
		IsMuted:       isMuted,
	}

	return &chatEventVideoChatParticipantIsMutedToggledTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventVideoChatParticipantIsMutedToggled *ChatEventVideoChatParticipantIsMutedToggled) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsMuted bool `json:"is_muted"` // New value of is_muted
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventVideoChatParticipantIsMutedToggled.tdCommon = tempObj.tdCommon
	chatEventVideoChatParticipantIsMutedToggled.IsMuted = tempObj.IsMuted

	fieldParticipantID, _ := unmarshalMessageSender(objMap["participant_id"])
	chatEventVideoChatParticipantIsMutedToggled.ParticipantID = fieldParticipantID

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventVideoChatParticipantIsMutedToggled *ChatEventVideoChatParticipantIsMutedToggled) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventVideoChatParticipantIsMutedToggledType
}

// ChatEventVideoChatParticipantVolumeLevelChanged A video chat participant volume level was changed
type ChatEventVideoChatParticipantVolumeLevelChanged struct {
	tdCommon
	ParticipantID MessageSender `json:"participant_id"` // Identifier of the affected group call participant
	VolumeLevel   int32         `json:"volume_level"`   // New value of volume_level; 1-20000 in hundreds of percents
}

// MessageType return the string telegram-type of ChatEventVideoChatParticipantVolumeLevelChanged
func (chatEventVideoChatParticipantVolumeLevelChanged *ChatEventVideoChatParticipantVolumeLevelChanged) MessageType() string {
	return "chatEventVideoChatParticipantVolumeLevelChanged"
}

// NewChatEventVideoChatParticipantVolumeLevelChanged creates a new ChatEventVideoChatParticipantVolumeLevelChanged
//
// @param participantID Identifier of the affected group call participant
// @param volumeLevel New value of volume_level; 1-20000 in hundreds of percents
func NewChatEventVideoChatParticipantVolumeLevelChanged(participantID MessageSender, volumeLevel int32) *ChatEventVideoChatParticipantVolumeLevelChanged {
	chatEventVideoChatParticipantVolumeLevelChangedTemp := ChatEventVideoChatParticipantVolumeLevelChanged{
		tdCommon:      tdCommon{Type: "chatEventVideoChatParticipantVolumeLevelChanged"},
		ParticipantID: participantID,
		VolumeLevel:   volumeLevel,
	}

	return &chatEventVideoChatParticipantVolumeLevelChangedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventVideoChatParticipantVolumeLevelChanged *ChatEventVideoChatParticipantVolumeLevelChanged) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		VolumeLevel int32 `json:"volume_level"` // New value of volume_level; 1-20000 in hundreds of percents
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventVideoChatParticipantVolumeLevelChanged.tdCommon = tempObj.tdCommon
	chatEventVideoChatParticipantVolumeLevelChanged.VolumeLevel = tempObj.VolumeLevel

	fieldParticipantID, _ := unmarshalMessageSender(objMap["participant_id"])
	chatEventVideoChatParticipantVolumeLevelChanged.ParticipantID = fieldParticipantID

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventVideoChatParticipantVolumeLevelChanged *ChatEventVideoChatParticipantVolumeLevelChanged) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventVideoChatParticipantVolumeLevelChangedType
}

// ChatEventIsForumToggled The is_forum setting of a channel was toggled
type ChatEventIsForumToggled struct {
	tdCommon
	IsForum bool `json:"is_forum"` // New value of is_forum
}

// MessageType return the string telegram-type of ChatEventIsForumToggled
func (chatEventIsForumToggled *ChatEventIsForumToggled) MessageType() string {
	return "chatEventIsForumToggled"
}

// NewChatEventIsForumToggled creates a new ChatEventIsForumToggled
//
// @param isForum New value of is_forum
func NewChatEventIsForumToggled(isForum bool) *ChatEventIsForumToggled {
	chatEventIsForumToggledTemp := ChatEventIsForumToggled{
		tdCommon: tdCommon{Type: "chatEventIsForumToggled"},
		IsForum:  isForum,
	}

	return &chatEventIsForumToggledTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventIsForumToggled *ChatEventIsForumToggled) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsForum bool `json:"is_forum"` // New value of is_forum
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventIsForumToggled.tdCommon = tempObj.tdCommon
	chatEventIsForumToggled.IsForum = tempObj.IsForum

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventIsForumToggled *ChatEventIsForumToggled) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventIsForumToggledType
}

// ChatEventForumTopicCreated A new forum topic was created
type ChatEventForumTopicCreated struct {
	tdCommon
	TopicInfo *ForumTopicInfo `json:"topic_info"` // Information about the topic
}

// MessageType return the string telegram-type of ChatEventForumTopicCreated
func (chatEventForumTopicCreated *ChatEventForumTopicCreated) MessageType() string {
	return "chatEventForumTopicCreated"
}

// NewChatEventForumTopicCreated creates a new ChatEventForumTopicCreated
//
// @param topicInfo Information about the topic
func NewChatEventForumTopicCreated(topicInfo *ForumTopicInfo) *ChatEventForumTopicCreated {
	chatEventForumTopicCreatedTemp := ChatEventForumTopicCreated{
		tdCommon:  tdCommon{Type: "chatEventForumTopicCreated"},
		TopicInfo: topicInfo,
	}

	return &chatEventForumTopicCreatedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventForumTopicCreated *ChatEventForumTopicCreated) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventForumTopicCreated.tdCommon = tempObj.tdCommon

	var topicInfo ForumTopicInfo
	if objMap["topic_info"] != nil {
		err = topicInfo.UnmarshalJSON(*objMap["topic_info"])
		if err != nil {
			return err
		}
	}

	chatEventForumTopicCreated.TopicInfo = &topicInfo

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventForumTopicCreated *ChatEventForumTopicCreated) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventForumTopicCreatedType
}

// ChatEventForumTopicEdited A forum topic was edited
type ChatEventForumTopicEdited struct {
	tdCommon
	OldTopicInfo *ForumTopicInfo `json:"old_topic_info"` // Old information about the topic
	NewTopicInfo *ForumTopicInfo `json:"new_topic_info"` // New information about the topic
}

// MessageType return the string telegram-type of ChatEventForumTopicEdited
func (chatEventForumTopicEdited *ChatEventForumTopicEdited) MessageType() string {
	return "chatEventForumTopicEdited"
}

// NewChatEventForumTopicEdited creates a new ChatEventForumTopicEdited
//
// @param oldTopicInfo Old information about the topic
// @param newTopicInfo New information about the topic
func NewChatEventForumTopicEdited(oldTopicInfo *ForumTopicInfo, newTopicInfo *ForumTopicInfo) *ChatEventForumTopicEdited {
	chatEventForumTopicEditedTemp := ChatEventForumTopicEdited{
		tdCommon:     tdCommon{Type: "chatEventForumTopicEdited"},
		OldTopicInfo: oldTopicInfo,
		NewTopicInfo: newTopicInfo,
	}

	return &chatEventForumTopicEditedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventForumTopicEdited *ChatEventForumTopicEdited) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventForumTopicEdited.tdCommon = tempObj.tdCommon

	var oldTopicInfo ForumTopicInfo
	if objMap["old_topic_info"] != nil {
		err = oldTopicInfo.UnmarshalJSON(*objMap["old_topic_info"])
		if err != nil {
			return err
		}
	}

	chatEventForumTopicEdited.OldTopicInfo = &oldTopicInfo

	var newTopicInfo ForumTopicInfo
	if objMap["new_topic_info"] != nil {
		err = newTopicInfo.UnmarshalJSON(*objMap["new_topic_info"])
		if err != nil {
			return err
		}
	}

	chatEventForumTopicEdited.NewTopicInfo = &newTopicInfo

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventForumTopicEdited *ChatEventForumTopicEdited) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventForumTopicEditedType
}

// ChatEventForumTopicToggleIsClosed A forum topic was closed or reopened
type ChatEventForumTopicToggleIsClosed struct {
	tdCommon
	TopicInfo *ForumTopicInfo `json:"topic_info"` // New information about the topic
}

// MessageType return the string telegram-type of ChatEventForumTopicToggleIsClosed
func (chatEventForumTopicToggleIsClosed *ChatEventForumTopicToggleIsClosed) MessageType() string {
	return "chatEventForumTopicToggleIsClosed"
}

// NewChatEventForumTopicToggleIsClosed creates a new ChatEventForumTopicToggleIsClosed
//
// @param topicInfo New information about the topic
func NewChatEventForumTopicToggleIsClosed(topicInfo *ForumTopicInfo) *ChatEventForumTopicToggleIsClosed {
	chatEventForumTopicToggleIsClosedTemp := ChatEventForumTopicToggleIsClosed{
		tdCommon:  tdCommon{Type: "chatEventForumTopicToggleIsClosed"},
		TopicInfo: topicInfo,
	}

	return &chatEventForumTopicToggleIsClosedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventForumTopicToggleIsClosed *ChatEventForumTopicToggleIsClosed) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventForumTopicToggleIsClosed.tdCommon = tempObj.tdCommon

	var topicInfo ForumTopicInfo
	if objMap["topic_info"] != nil {
		err = topicInfo.UnmarshalJSON(*objMap["topic_info"])
		if err != nil {
			return err
		}
	}

	chatEventForumTopicToggleIsClosed.TopicInfo = &topicInfo

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventForumTopicToggleIsClosed *ChatEventForumTopicToggleIsClosed) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventForumTopicToggleIsClosedType
}

// ChatEventForumTopicToggleIsHidden The General forum topic was hidden or unhidden
type ChatEventForumTopicToggleIsHidden struct {
	tdCommon
	TopicInfo *ForumTopicInfo `json:"topic_info"` // New information about the topic
}

// MessageType return the string telegram-type of ChatEventForumTopicToggleIsHidden
func (chatEventForumTopicToggleIsHidden *ChatEventForumTopicToggleIsHidden) MessageType() string {
	return "chatEventForumTopicToggleIsHidden"
}

// NewChatEventForumTopicToggleIsHidden creates a new ChatEventForumTopicToggleIsHidden
//
// @param topicInfo New information about the topic
func NewChatEventForumTopicToggleIsHidden(topicInfo *ForumTopicInfo) *ChatEventForumTopicToggleIsHidden {
	chatEventForumTopicToggleIsHiddenTemp := ChatEventForumTopicToggleIsHidden{
		tdCommon:  tdCommon{Type: "chatEventForumTopicToggleIsHidden"},
		TopicInfo: topicInfo,
	}

	return &chatEventForumTopicToggleIsHiddenTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventForumTopicToggleIsHidden *ChatEventForumTopicToggleIsHidden) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventForumTopicToggleIsHidden.tdCommon = tempObj.tdCommon

	var topicInfo ForumTopicInfo
	if objMap["topic_info"] != nil {
		err = topicInfo.UnmarshalJSON(*objMap["topic_info"])
		if err != nil {
			return err
		}
	}

	chatEventForumTopicToggleIsHidden.TopicInfo = &topicInfo

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventForumTopicToggleIsHidden *ChatEventForumTopicToggleIsHidden) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventForumTopicToggleIsHiddenType
}

// ChatEventForumTopicDeleted A forum topic was deleted
type ChatEventForumTopicDeleted struct {
	tdCommon
	TopicInfo *ForumTopicInfo `json:"topic_info"` // Information about the topic
}

// MessageType return the string telegram-type of ChatEventForumTopicDeleted
func (chatEventForumTopicDeleted *ChatEventForumTopicDeleted) MessageType() string {
	return "chatEventForumTopicDeleted"
}

// NewChatEventForumTopicDeleted creates a new ChatEventForumTopicDeleted
//
// @param topicInfo Information about the topic
func NewChatEventForumTopicDeleted(topicInfo *ForumTopicInfo) *ChatEventForumTopicDeleted {
	chatEventForumTopicDeletedTemp := ChatEventForumTopicDeleted{
		tdCommon:  tdCommon{Type: "chatEventForumTopicDeleted"},
		TopicInfo: topicInfo,
	}

	return &chatEventForumTopicDeletedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventForumTopicDeleted *ChatEventForumTopicDeleted) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventForumTopicDeleted.tdCommon = tempObj.tdCommon

	var topicInfo ForumTopicInfo
	if objMap["topic_info"] != nil {
		err = topicInfo.UnmarshalJSON(*objMap["topic_info"])
		if err != nil {
			return err
		}
	}

	chatEventForumTopicDeleted.TopicInfo = &topicInfo

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventForumTopicDeleted *ChatEventForumTopicDeleted) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventForumTopicDeletedType
}

// ChatEventForumTopicPinned A pinned forum topic was changed
type ChatEventForumTopicPinned struct {
	tdCommon
	OldTopicInfo *ForumTopicInfo `json:"old_topic_info"` // Information about the old pinned topic; may be null
	NewTopicInfo *ForumTopicInfo `json:"new_topic_info"` // Information about the new pinned topic; may be null
}

// MessageType return the string telegram-type of ChatEventForumTopicPinned
func (chatEventForumTopicPinned *ChatEventForumTopicPinned) MessageType() string {
	return "chatEventForumTopicPinned"
}

// NewChatEventForumTopicPinned creates a new ChatEventForumTopicPinned
//
// @param oldTopicInfo Information about the old pinned topic; may be null
// @param newTopicInfo Information about the new pinned topic; may be null
func NewChatEventForumTopicPinned(oldTopicInfo *ForumTopicInfo, newTopicInfo *ForumTopicInfo) *ChatEventForumTopicPinned {
	chatEventForumTopicPinnedTemp := ChatEventForumTopicPinned{
		tdCommon:     tdCommon{Type: "chatEventForumTopicPinned"},
		OldTopicInfo: oldTopicInfo,
		NewTopicInfo: newTopicInfo,
	}

	return &chatEventForumTopicPinnedTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventForumTopicPinned *ChatEventForumTopicPinned) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventForumTopicPinned.tdCommon = tempObj.tdCommon

	var oldTopicInfo ForumTopicInfo
	if objMap["old_topic_info"] != nil {
		err = oldTopicInfo.UnmarshalJSON(*objMap["old_topic_info"])
		if err != nil {
			return err
		}
	}

	chatEventForumTopicPinned.OldTopicInfo = &oldTopicInfo

	var newTopicInfo ForumTopicInfo
	if objMap["new_topic_info"] != nil {
		err = newTopicInfo.UnmarshalJSON(*objMap["new_topic_info"])
		if err != nil {
			return err
		}
	}

	chatEventForumTopicPinned.NewTopicInfo = &newTopicInfo

	return nil
}

// GetChatEventActionEnum return the enum type of this object
func (chatEventForumTopicPinned *ChatEventForumTopicPinned) GetChatEventActionEnum() ChatEventActionEnum {
	return ChatEventForumTopicPinnedType
}

// ChatEvent Represents a chat event
type ChatEvent struct {
	tdCommon
	ID       JSONInt64       `json:"id"`        // Chat event identifier
	Date     int32           `json:"date"`      // Point in time (Unix timestamp) when the event happened
	MemberID MessageSender   `json:"member_id"` // Identifier of the user or chat who performed the action
	Action   ChatEventAction `json:"action"`    // The action
}

// MessageType return the string telegram-type of ChatEvent
func (chatEvent *ChatEvent) MessageType() string {
	return "chatEvent"
}

// NewChatEvent creates a new ChatEvent
//
// @param iD Chat event identifier
// @param date Point in time (Unix timestamp) when the event happened
// @param memberID Identifier of the user or chat who performed the action
// @param action The action
func NewChatEvent(iD JSONInt64, date int32, memberID MessageSender, action ChatEventAction) *ChatEvent {
	chatEventTemp := ChatEvent{
		tdCommon: tdCommon{Type: "chatEvent"},
		ID:       iD,
		Date:     date,
		MemberID: memberID,
		Action:   action,
	}

	return &chatEventTemp
}

// UnmarshalJSON unmarshal to json
func (chatEvent *ChatEvent) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID   JSONInt64 `json:"id"`   // Chat event identifier
		Date int32     `json:"date"` // Point in time (Unix timestamp) when the event happened

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEvent.tdCommon = tempObj.tdCommon
	chatEvent.ID = tempObj.ID
	chatEvent.Date = tempObj.Date

	fieldMemberID, _ := unmarshalMessageSender(objMap["member_id"])
	chatEvent.MemberID = fieldMemberID

	fieldAction, _ := unmarshalChatEventAction(objMap["action"])
	chatEvent.Action = fieldAction

	return nil
}

// ChatEvents Contains a list of chat events
type ChatEvents struct {
	tdCommon
	Events []ChatEvent `json:"events"` // List of events
}

// MessageType return the string telegram-type of ChatEvents
func (chatEvents *ChatEvents) MessageType() string {
	return "chatEvents"
}

// NewChatEvents creates a new ChatEvents
//
// @param events List of events
func NewChatEvents(events []ChatEvent) *ChatEvents {
	chatEventsTemp := ChatEvents{
		tdCommon: tdCommon{Type: "chatEvents"},
		Events:   events,
	}

	return &chatEventsTemp
}

// UnmarshalJSON unmarshal to json
func (chatEvents *ChatEvents) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Events []ChatEvent `json:"events"` // List of events
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEvents.tdCommon = tempObj.tdCommon
	chatEvents.Events = tempObj.Events

	return nil
}

// ChatEventLogFilters Represents a set of filters used to obtain a chat event log
type ChatEventLogFilters struct {
	tdCommon
	MessageEdits           bool `json:"message_edits"`           // True, if message edits need to be returned
	MessageDeletions       bool `json:"message_deletions"`       // True, if message deletions need to be returned
	MessagePins            bool `json:"message_pins"`            // True, if pin/unpin events need to be returned
	MemberJoins            bool `json:"member_joins"`            // True, if members joining events need to be returned
	MemberLeaves           bool `json:"member_leaves"`           // True, if members leaving events need to be returned
	MemberInvites          bool `json:"member_invites"`          // True, if invited member events need to be returned
	MemberPromotions       bool `json:"member_promotions"`       // True, if member promotion/demotion events need to be returned
	MemberRestrictions     bool `json:"member_restrictions"`     // True, if member restricted/unrestricted/banned/unbanned events need to be returned
	InfoChanges            bool `json:"info_changes"`            // True, if changes in chat information need to be returned
	SettingChanges         bool `json:"setting_changes"`         // True, if changes in chat settings need to be returned
	InviteLinkChanges      bool `json:"invite_link_changes"`     // True, if changes to invite links need to be returned
	VideoChatChanges       bool `json:"video_chat_changes"`      // True, if video chat actions need to be returned
	ForumChanges           bool `json:"forum_changes"`           // True, if forum-related actions need to be returned
	SubscriptionExtensions bool `json:"subscription_extensions"` // True, if subscription extensions need to be returned
}

// MessageType return the string telegram-type of ChatEventLogFilters
func (chatEventLogFilters *ChatEventLogFilters) MessageType() string {
	return "chatEventLogFilters"
}

// NewChatEventLogFilters creates a new ChatEventLogFilters
//
// @param messageEdits True, if message edits need to be returned
// @param messageDeletions True, if message deletions need to be returned
// @param messagePins True, if pin/unpin events need to be returned
// @param memberJoins True, if members joining events need to be returned
// @param memberLeaves True, if members leaving events need to be returned
// @param memberInvites True, if invited member events need to be returned
// @param memberPromotions True, if member promotion/demotion events need to be returned
// @param memberRestrictions True, if member restricted/unrestricted/banned/unbanned events need to be returned
// @param infoChanges True, if changes in chat information need to be returned
// @param settingChanges True, if changes in chat settings need to be returned
// @param inviteLinkChanges True, if changes to invite links need to be returned
// @param videoChatChanges True, if video chat actions need to be returned
// @param forumChanges True, if forum-related actions need to be returned
// @param subscriptionExtensions True, if subscription extensions need to be returned
func NewChatEventLogFilters(messageEdits bool, messageDeletions bool, messagePins bool, memberJoins bool, memberLeaves bool, memberInvites bool, memberPromotions bool, memberRestrictions bool, infoChanges bool, settingChanges bool, inviteLinkChanges bool, videoChatChanges bool, forumChanges bool, subscriptionExtensions bool) *ChatEventLogFilters {
	chatEventLogFiltersTemp := ChatEventLogFilters{
		tdCommon:               tdCommon{Type: "chatEventLogFilters"},
		MessageEdits:           messageEdits,
		MessageDeletions:       messageDeletions,
		MessagePins:            messagePins,
		MemberJoins:            memberJoins,
		MemberLeaves:           memberLeaves,
		MemberInvites:          memberInvites,
		MemberPromotions:       memberPromotions,
		MemberRestrictions:     memberRestrictions,
		InfoChanges:            infoChanges,
		SettingChanges:         settingChanges,
		InviteLinkChanges:      inviteLinkChanges,
		VideoChatChanges:       videoChatChanges,
		ForumChanges:           forumChanges,
		SubscriptionExtensions: subscriptionExtensions,
	}

	return &chatEventLogFiltersTemp
}

// UnmarshalJSON unmarshal to json
func (chatEventLogFilters *ChatEventLogFilters) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MessageEdits           bool `json:"message_edits"`           // True, if message edits need to be returned
		MessageDeletions       bool `json:"message_deletions"`       // True, if message deletions need to be returned
		MessagePins            bool `json:"message_pins"`            // True, if pin/unpin events need to be returned
		MemberJoins            bool `json:"member_joins"`            // True, if members joining events need to be returned
		MemberLeaves           bool `json:"member_leaves"`           // True, if members leaving events need to be returned
		MemberInvites          bool `json:"member_invites"`          // True, if invited member events need to be returned
		MemberPromotions       bool `json:"member_promotions"`       // True, if member promotion/demotion events need to be returned
		MemberRestrictions     bool `json:"member_restrictions"`     // True, if member restricted/unrestricted/banned/unbanned events need to be returned
		InfoChanges            bool `json:"info_changes"`            // True, if changes in chat information need to be returned
		SettingChanges         bool `json:"setting_changes"`         // True, if changes in chat settings need to be returned
		InviteLinkChanges      bool `json:"invite_link_changes"`     // True, if changes to invite links need to be returned
		VideoChatChanges       bool `json:"video_chat_changes"`      // True, if video chat actions need to be returned
		ForumChanges           bool `json:"forum_changes"`           // True, if forum-related actions need to be returned
		SubscriptionExtensions bool `json:"subscription_extensions"` // True, if subscription extensions need to be returned
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatEventLogFilters.tdCommon = tempObj.tdCommon
	chatEventLogFilters.MessageEdits = tempObj.MessageEdits
	chatEventLogFilters.MessageDeletions = tempObj.MessageDeletions
	chatEventLogFilters.MessagePins = tempObj.MessagePins
	chatEventLogFilters.MemberJoins = tempObj.MemberJoins
	chatEventLogFilters.MemberLeaves = tempObj.MemberLeaves
	chatEventLogFilters.MemberInvites = tempObj.MemberInvites
	chatEventLogFilters.MemberPromotions = tempObj.MemberPromotions
	chatEventLogFilters.MemberRestrictions = tempObj.MemberRestrictions
	chatEventLogFilters.InfoChanges = tempObj.InfoChanges
	chatEventLogFilters.SettingChanges = tempObj.SettingChanges
	chatEventLogFilters.InviteLinkChanges = tempObj.InviteLinkChanges
	chatEventLogFilters.VideoChatChanges = tempObj.VideoChatChanges
	chatEventLogFilters.ForumChanges = tempObj.ForumChanges
	chatEventLogFilters.SubscriptionExtensions = tempObj.SubscriptionExtensions

	return nil
}

// LanguagePackStringValueOrdinary An ordinary language pack string
type LanguagePackStringValueOrdinary struct {
	tdCommon
	Value string `json:"value"` // String value
}

// MessageType return the string telegram-type of LanguagePackStringValueOrdinary
func (languagePackStringValueOrdinary *LanguagePackStringValueOrdinary) MessageType() string {
	return "languagePackStringValueOrdinary"
}

// NewLanguagePackStringValueOrdinary creates a new LanguagePackStringValueOrdinary
//
// @param value String value
func NewLanguagePackStringValueOrdinary(value string) *LanguagePackStringValueOrdinary {
	languagePackStringValueOrdinaryTemp := LanguagePackStringValueOrdinary{
		tdCommon: tdCommon{Type: "languagePackStringValueOrdinary"},
		Value:    value,
	}

	return &languagePackStringValueOrdinaryTemp
}

// UnmarshalJSON unmarshal to json
func (languagePackStringValueOrdinary *LanguagePackStringValueOrdinary) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Value string `json:"value"` // String value
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	languagePackStringValueOrdinary.tdCommon = tempObj.tdCommon
	languagePackStringValueOrdinary.Value = tempObj.Value

	return nil
}

// GetLanguagePackStringValueEnum return the enum type of this object
func (languagePackStringValueOrdinary *LanguagePackStringValueOrdinary) GetLanguagePackStringValueEnum() LanguagePackStringValueEnum {
	return LanguagePackStringValueOrdinaryType
}

// LanguagePackStringValuePluralized A language pack string which has different forms based on the number of some object it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more information
type LanguagePackStringValuePluralized struct {
	tdCommon
	ZeroValue  string `json:"zero_value"`  // Value for zero objects
	OneValue   string `json:"one_value"`   // Value for one object
	TwoValue   string `json:"two_value"`   // Value for two objects
	FewValue   string `json:"few_value"`   // Value for few objects
	ManyValue  string `json:"many_value"`  // Value for many objects
	OtherValue string `json:"other_value"` // Default value
}

// MessageType return the string telegram-type of LanguagePackStringValuePluralized
func (languagePackStringValuePluralized *LanguagePackStringValuePluralized) MessageType() string {
	return "languagePackStringValuePluralized"
}

// NewLanguagePackStringValuePluralized creates a new LanguagePackStringValuePluralized
//
// @param zeroValue Value for zero objects
// @param oneValue Value for one object
// @param twoValue Value for two objects
// @param fewValue Value for few objects
// @param manyValue Value for many objects
// @param otherValue Default value
func NewLanguagePackStringValuePluralized(zeroValue string, oneValue string, twoValue string, fewValue string, manyValue string, otherValue string) *LanguagePackStringValuePluralized {
	languagePackStringValuePluralizedTemp := LanguagePackStringValuePluralized{
		tdCommon:   tdCommon{Type: "languagePackStringValuePluralized"},
		ZeroValue:  zeroValue,
		OneValue:   oneValue,
		TwoValue:   twoValue,
		FewValue:   fewValue,
		ManyValue:  manyValue,
		OtherValue: otherValue,
	}

	return &languagePackStringValuePluralizedTemp
}

// UnmarshalJSON unmarshal to json
func (languagePackStringValuePluralized *LanguagePackStringValuePluralized) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ZeroValue  string `json:"zero_value"`  // Value for zero objects
		OneValue   string `json:"one_value"`   // Value for one object
		TwoValue   string `json:"two_value"`   // Value for two objects
		FewValue   string `json:"few_value"`   // Value for few objects
		ManyValue  string `json:"many_value"`  // Value for many objects
		OtherValue string `json:"other_value"` // Default value
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	languagePackStringValuePluralized.tdCommon = tempObj.tdCommon
	languagePackStringValuePluralized.ZeroValue = tempObj.ZeroValue
	languagePackStringValuePluralized.OneValue = tempObj.OneValue
	languagePackStringValuePluralized.TwoValue = tempObj.TwoValue
	languagePackStringValuePluralized.FewValue = tempObj.FewValue
	languagePackStringValuePluralized.ManyValue = tempObj.ManyValue
	languagePackStringValuePluralized.OtherValue = tempObj.OtherValue

	return nil
}

// GetLanguagePackStringValueEnum return the enum type of this object
func (languagePackStringValuePluralized *LanguagePackStringValuePluralized) GetLanguagePackStringValueEnum() LanguagePackStringValueEnum {
	return LanguagePackStringValuePluralizedType
}

// LanguagePackStringValueDeleted A deleted language pack string, the value must be taken from the built-in English language pack
type LanguagePackStringValueDeleted struct {
	tdCommon
}

// MessageType return the string telegram-type of LanguagePackStringValueDeleted
func (languagePackStringValueDeleted *LanguagePackStringValueDeleted) MessageType() string {
	return "languagePackStringValueDeleted"
}

// NewLanguagePackStringValueDeleted creates a new LanguagePackStringValueDeleted
//
func NewLanguagePackStringValueDeleted() *LanguagePackStringValueDeleted {
	languagePackStringValueDeletedTemp := LanguagePackStringValueDeleted{
		tdCommon: tdCommon{Type: "languagePackStringValueDeleted"},
	}

	return &languagePackStringValueDeletedTemp
}

// UnmarshalJSON unmarshal to json
func (languagePackStringValueDeleted *LanguagePackStringValueDeleted) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	languagePackStringValueDeleted.tdCommon = tempObj.tdCommon

	return nil
}

// GetLanguagePackStringValueEnum return the enum type of this object
func (languagePackStringValueDeleted *LanguagePackStringValueDeleted) GetLanguagePackStringValueEnum() LanguagePackStringValueEnum {
	return LanguagePackStringValueDeletedType
}

// LanguagePackString Represents one language pack string
type LanguagePackString struct {
	tdCommon
	Key   string                  `json:"key"`   // String key
	Value LanguagePackStringValue `json:"value"` // String value; pass null if the string needs to be taken from the built-in English language pack
}

// MessageType return the string telegram-type of LanguagePackString
func (languagePackString *LanguagePackString) MessageType() string {
	return "languagePackString"
}

// NewLanguagePackString creates a new LanguagePackString
//
// @param key String key
// @param value String value; pass null if the string needs to be taken from the built-in English language pack
func NewLanguagePackString(key string, value LanguagePackStringValue) *LanguagePackString {
	languagePackStringTemp := LanguagePackString{
		tdCommon: tdCommon{Type: "languagePackString"},
		Key:      key,
		Value:    value,
	}

	return &languagePackStringTemp
}

// UnmarshalJSON unmarshal to json
func (languagePackString *LanguagePackString) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Key string `json:"key"` // String key

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	languagePackString.tdCommon = tempObj.tdCommon
	languagePackString.Key = tempObj.Key

	fieldValue, _ := unmarshalLanguagePackStringValue(objMap["value"])
	languagePackString.Value = fieldValue

	return nil
}

// LanguagePackStrings Contains a list of language pack strings
type LanguagePackStrings struct {
	tdCommon
	Strings []LanguagePackString `json:"strings"` // A list of language pack strings
}

// MessageType return the string telegram-type of LanguagePackStrings
func (languagePackStrings *LanguagePackStrings) MessageType() string {
	return "languagePackStrings"
}

// NewLanguagePackStrings creates a new LanguagePackStrings
//
// @param strings A list of language pack strings
func NewLanguagePackStrings(strings []LanguagePackString) *LanguagePackStrings {
	languagePackStringsTemp := LanguagePackStrings{
		tdCommon: tdCommon{Type: "languagePackStrings"},
		Strings:  strings,
	}

	return &languagePackStringsTemp
}

// UnmarshalJSON unmarshal to json
func (languagePackStrings *LanguagePackStrings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Strings []LanguagePackString `json:"strings"` // A list of language pack strings
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	languagePackStrings.tdCommon = tempObj.tdCommon
	languagePackStrings.Strings = tempObj.Strings

	return nil
}

// LanguagePackInfo Contains information about a language pack
type LanguagePackInfo struct {
	tdCommon
	ID                    string `json:"id"`                      // Unique language pack identifier
	BaseLanguagePackID    string `json:"base_language_pack_id"`   // Identifier of a base language pack; may be empty. If a string is missed in the language pack, then it must be fetched from base language pack. Unsupported in custom language packs
	Name                  string `json:"name"`                    // Language name
	NativeName            string `json:"native_name"`             // Name of the language in that language
	PluralCode            string `json:"plural_code"`             // A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more information
	IsOfficial            bool   `json:"is_official"`             // True, if the language pack is official
	IsRtl                 bool   `json:"is_rtl"`                  // True, if the language pack strings are RTL
	IsBeta                bool   `json:"is_beta"`                 // True, if the language pack is a beta language pack
	IsInstalled           bool   `json:"is_installed"`            // True, if the language pack is installed by the current user
	TotalStringCount      int32  `json:"total_string_count"`      // Total number of non-deleted strings from the language pack
	TranslatedStringCount int32  `json:"translated_string_count"` // Total number of translated strings from the language pack
	LocalStringCount      int32  `json:"local_string_count"`      // Total number of non-deleted strings from the language pack available locally
	TranslationURL        string `json:"translation_url"`         // Link to language translation interface; empty for custom local language packs
}

// MessageType return the string telegram-type of LanguagePackInfo
func (languagePackInfo *LanguagePackInfo) MessageType() string {
	return "languagePackInfo"
}

// NewLanguagePackInfo creates a new LanguagePackInfo
//
// @param iD Unique language pack identifier
// @param baseLanguagePackID Identifier of a base language pack; may be empty. If a string is missed in the language pack, then it must be fetched from base language pack. Unsupported in custom language packs
// @param name Language name
// @param nativeName Name of the language in that language
// @param pluralCode A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more information
// @param isOfficial True, if the language pack is official
// @param isRtl True, if the language pack strings are RTL
// @param isBeta True, if the language pack is a beta language pack
// @param isInstalled True, if the language pack is installed by the current user
// @param totalStringCount Total number of non-deleted strings from the language pack
// @param translatedStringCount Total number of translated strings from the language pack
// @param localStringCount Total number of non-deleted strings from the language pack available locally
// @param translationURL Link to language translation interface; empty for custom local language packs
func NewLanguagePackInfo(iD string, baseLanguagePackID string, name string, nativeName string, pluralCode string, isOfficial bool, isRtl bool, isBeta bool, isInstalled bool, totalStringCount int32, translatedStringCount int32, localStringCount int32, translationURL string) *LanguagePackInfo {
	languagePackInfoTemp := LanguagePackInfo{
		tdCommon:              tdCommon{Type: "languagePackInfo"},
		ID:                    iD,
		BaseLanguagePackID:    baseLanguagePackID,
		Name:                  name,
		NativeName:            nativeName,
		PluralCode:            pluralCode,
		IsOfficial:            isOfficial,
		IsRtl:                 isRtl,
		IsBeta:                isBeta,
		IsInstalled:           isInstalled,
		TotalStringCount:      totalStringCount,
		TranslatedStringCount: translatedStringCount,
		LocalStringCount:      localStringCount,
		TranslationURL:        translationURL,
	}

	return &languagePackInfoTemp
}

// UnmarshalJSON unmarshal to json
func (languagePackInfo *LanguagePackInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID                    string `json:"id"`                      // Unique language pack identifier
		BaseLanguagePackID    string `json:"base_language_pack_id"`   // Identifier of a base language pack; may be empty. If a string is missed in the language pack, then it must be fetched from base language pack. Unsupported in custom language packs
		Name                  string `json:"name"`                    // Language name
		NativeName            string `json:"native_name"`             // Name of the language in that language
		PluralCode            string `json:"plural_code"`             // A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more information
		IsOfficial            bool   `json:"is_official"`             // True, if the language pack is official
		IsRtl                 bool   `json:"is_rtl"`                  // True, if the language pack strings are RTL
		IsBeta                bool   `json:"is_beta"`                 // True, if the language pack is a beta language pack
		IsInstalled           bool   `json:"is_installed"`            // True, if the language pack is installed by the current user
		TotalStringCount      int32  `json:"total_string_count"`      // Total number of non-deleted strings from the language pack
		TranslatedStringCount int32  `json:"translated_string_count"` // Total number of translated strings from the language pack
		LocalStringCount      int32  `json:"local_string_count"`      // Total number of non-deleted strings from the language pack available locally
		TranslationURL        string `json:"translation_url"`         // Link to language translation interface; empty for custom local language packs
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	languagePackInfo.tdCommon = tempObj.tdCommon
	languagePackInfo.ID = tempObj.ID
	languagePackInfo.BaseLanguagePackID = tempObj.BaseLanguagePackID
	languagePackInfo.Name = tempObj.Name
	languagePackInfo.NativeName = tempObj.NativeName
	languagePackInfo.PluralCode = tempObj.PluralCode
	languagePackInfo.IsOfficial = tempObj.IsOfficial
	languagePackInfo.IsRtl = tempObj.IsRtl
	languagePackInfo.IsBeta = tempObj.IsBeta
	languagePackInfo.IsInstalled = tempObj.IsInstalled
	languagePackInfo.TotalStringCount = tempObj.TotalStringCount
	languagePackInfo.TranslatedStringCount = tempObj.TranslatedStringCount
	languagePackInfo.LocalStringCount = tempObj.LocalStringCount
	languagePackInfo.TranslationURL = tempObj.TranslationURL

	return nil
}

// LocalizationTargetInfo Contains information about the current localization target
type LocalizationTargetInfo struct {
	tdCommon
	LanguagePacks []LanguagePackInfo `json:"language_packs"` // List of available language packs for this application
}

// MessageType return the string telegram-type of LocalizationTargetInfo
func (localizationTargetInfo *LocalizationTargetInfo) MessageType() string {
	return "localizationTargetInfo"
}

// NewLocalizationTargetInfo creates a new LocalizationTargetInfo
//
// @param languagePacks List of available language packs for this application
func NewLocalizationTargetInfo(languagePacks []LanguagePackInfo) *LocalizationTargetInfo {
	localizationTargetInfoTemp := LocalizationTargetInfo{
		tdCommon:      tdCommon{Type: "localizationTargetInfo"},
		LanguagePacks: languagePacks,
	}

	return &localizationTargetInfoTemp
}

// UnmarshalJSON unmarshal to json
func (localizationTargetInfo *LocalizationTargetInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		LanguagePacks []LanguagePackInfo `json:"language_packs"` // List of available language packs for this application
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	localizationTargetInfo.tdCommon = tempObj.tdCommon
	localizationTargetInfo.LanguagePacks = tempObj.LanguagePacks

	return nil
}

// PremiumLimitTypeSupergroupCount The maximum number of joined supergroups and channels
type PremiumLimitTypeSupergroupCount struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumLimitTypeSupergroupCount
func (premiumLimitTypeSupergroupCount *PremiumLimitTypeSupergroupCount) MessageType() string {
	return "premiumLimitTypeSupergroupCount"
}

// NewPremiumLimitTypeSupergroupCount creates a new PremiumLimitTypeSupergroupCount
//
func NewPremiumLimitTypeSupergroupCount() *PremiumLimitTypeSupergroupCount {
	premiumLimitTypeSupergroupCountTemp := PremiumLimitTypeSupergroupCount{
		tdCommon: tdCommon{Type: "premiumLimitTypeSupergroupCount"},
	}

	return &premiumLimitTypeSupergroupCountTemp
}

// UnmarshalJSON unmarshal to json
func (premiumLimitTypeSupergroupCount *PremiumLimitTypeSupergroupCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumLimitTypeSupergroupCount.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumLimitTypeEnum return the enum type of this object
func (premiumLimitTypeSupergroupCount *PremiumLimitTypeSupergroupCount) GetPremiumLimitTypeEnum() PremiumLimitTypeEnum {
	return PremiumLimitTypeSupergroupCountType
}

// PremiumLimitTypePinnedChatCount The maximum number of pinned chats in the main chat list
type PremiumLimitTypePinnedChatCount struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumLimitTypePinnedChatCount
func (premiumLimitTypePinnedChatCount *PremiumLimitTypePinnedChatCount) MessageType() string {
	return "premiumLimitTypePinnedChatCount"
}

// NewPremiumLimitTypePinnedChatCount creates a new PremiumLimitTypePinnedChatCount
//
func NewPremiumLimitTypePinnedChatCount() *PremiumLimitTypePinnedChatCount {
	premiumLimitTypePinnedChatCountTemp := PremiumLimitTypePinnedChatCount{
		tdCommon: tdCommon{Type: "premiumLimitTypePinnedChatCount"},
	}

	return &premiumLimitTypePinnedChatCountTemp
}

// UnmarshalJSON unmarshal to json
func (premiumLimitTypePinnedChatCount *PremiumLimitTypePinnedChatCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumLimitTypePinnedChatCount.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumLimitTypeEnum return the enum type of this object
func (premiumLimitTypePinnedChatCount *PremiumLimitTypePinnedChatCount) GetPremiumLimitTypeEnum() PremiumLimitTypeEnum {
	return PremiumLimitTypePinnedChatCountType
}

// PremiumLimitTypeCreatedPublicChatCount The maximum number of created public chats
type PremiumLimitTypeCreatedPublicChatCount struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumLimitTypeCreatedPublicChatCount
func (premiumLimitTypeCreatedPublicChatCount *PremiumLimitTypeCreatedPublicChatCount) MessageType() string {
	return "premiumLimitTypeCreatedPublicChatCount"
}

// NewPremiumLimitTypeCreatedPublicChatCount creates a new PremiumLimitTypeCreatedPublicChatCount
//
func NewPremiumLimitTypeCreatedPublicChatCount() *PremiumLimitTypeCreatedPublicChatCount {
	premiumLimitTypeCreatedPublicChatCountTemp := PremiumLimitTypeCreatedPublicChatCount{
		tdCommon: tdCommon{Type: "premiumLimitTypeCreatedPublicChatCount"},
	}

	return &premiumLimitTypeCreatedPublicChatCountTemp
}

// UnmarshalJSON unmarshal to json
func (premiumLimitTypeCreatedPublicChatCount *PremiumLimitTypeCreatedPublicChatCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumLimitTypeCreatedPublicChatCount.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumLimitTypeEnum return the enum type of this object
func (premiumLimitTypeCreatedPublicChatCount *PremiumLimitTypeCreatedPublicChatCount) GetPremiumLimitTypeEnum() PremiumLimitTypeEnum {
	return PremiumLimitTypeCreatedPublicChatCountType
}

// PremiumLimitTypeSavedAnimationCount The maximum number of saved animations
type PremiumLimitTypeSavedAnimationCount struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumLimitTypeSavedAnimationCount
func (premiumLimitTypeSavedAnimationCount *PremiumLimitTypeSavedAnimationCount) MessageType() string {
	return "premiumLimitTypeSavedAnimationCount"
}

// NewPremiumLimitTypeSavedAnimationCount creates a new PremiumLimitTypeSavedAnimationCount
//
func NewPremiumLimitTypeSavedAnimationCount() *PremiumLimitTypeSavedAnimationCount {
	premiumLimitTypeSavedAnimationCountTemp := PremiumLimitTypeSavedAnimationCount{
		tdCommon: tdCommon{Type: "premiumLimitTypeSavedAnimationCount"},
	}

	return &premiumLimitTypeSavedAnimationCountTemp
}

// UnmarshalJSON unmarshal to json
func (premiumLimitTypeSavedAnimationCount *PremiumLimitTypeSavedAnimationCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumLimitTypeSavedAnimationCount.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumLimitTypeEnum return the enum type of this object
func (premiumLimitTypeSavedAnimationCount *PremiumLimitTypeSavedAnimationCount) GetPremiumLimitTypeEnum() PremiumLimitTypeEnum {
	return PremiumLimitTypeSavedAnimationCountType
}

// PremiumLimitTypeFavoriteStickerCount The maximum number of favorite stickers
type PremiumLimitTypeFavoriteStickerCount struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumLimitTypeFavoriteStickerCount
func (premiumLimitTypeFavoriteStickerCount *PremiumLimitTypeFavoriteStickerCount) MessageType() string {
	return "premiumLimitTypeFavoriteStickerCount"
}

// NewPremiumLimitTypeFavoriteStickerCount creates a new PremiumLimitTypeFavoriteStickerCount
//
func NewPremiumLimitTypeFavoriteStickerCount() *PremiumLimitTypeFavoriteStickerCount {
	premiumLimitTypeFavoriteStickerCountTemp := PremiumLimitTypeFavoriteStickerCount{
		tdCommon: tdCommon{Type: "premiumLimitTypeFavoriteStickerCount"},
	}

	return &premiumLimitTypeFavoriteStickerCountTemp
}

// UnmarshalJSON unmarshal to json
func (premiumLimitTypeFavoriteStickerCount *PremiumLimitTypeFavoriteStickerCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumLimitTypeFavoriteStickerCount.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumLimitTypeEnum return the enum type of this object
func (premiumLimitTypeFavoriteStickerCount *PremiumLimitTypeFavoriteStickerCount) GetPremiumLimitTypeEnum() PremiumLimitTypeEnum {
	return PremiumLimitTypeFavoriteStickerCountType
}

// PremiumLimitTypeChatFolderCount The maximum number of chat folders
type PremiumLimitTypeChatFolderCount struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumLimitTypeChatFolderCount
func (premiumLimitTypeChatFolderCount *PremiumLimitTypeChatFolderCount) MessageType() string {
	return "premiumLimitTypeChatFolderCount"
}

// NewPremiumLimitTypeChatFolderCount creates a new PremiumLimitTypeChatFolderCount
//
func NewPremiumLimitTypeChatFolderCount() *PremiumLimitTypeChatFolderCount {
	premiumLimitTypeChatFolderCountTemp := PremiumLimitTypeChatFolderCount{
		tdCommon: tdCommon{Type: "premiumLimitTypeChatFolderCount"},
	}

	return &premiumLimitTypeChatFolderCountTemp
}

// UnmarshalJSON unmarshal to json
func (premiumLimitTypeChatFolderCount *PremiumLimitTypeChatFolderCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumLimitTypeChatFolderCount.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumLimitTypeEnum return the enum type of this object
func (premiumLimitTypeChatFolderCount *PremiumLimitTypeChatFolderCount) GetPremiumLimitTypeEnum() PremiumLimitTypeEnum {
	return PremiumLimitTypeChatFolderCountType
}

// PremiumLimitTypeChatFolderChosenChatCount The maximum number of pinned and always included, or always excluded chats in a chat folder
type PremiumLimitTypeChatFolderChosenChatCount struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumLimitTypeChatFolderChosenChatCount
func (premiumLimitTypeChatFolderChosenChatCount *PremiumLimitTypeChatFolderChosenChatCount) MessageType() string {
	return "premiumLimitTypeChatFolderChosenChatCount"
}

// NewPremiumLimitTypeChatFolderChosenChatCount creates a new PremiumLimitTypeChatFolderChosenChatCount
//
func NewPremiumLimitTypeChatFolderChosenChatCount() *PremiumLimitTypeChatFolderChosenChatCount {
	premiumLimitTypeChatFolderChosenChatCountTemp := PremiumLimitTypeChatFolderChosenChatCount{
		tdCommon: tdCommon{Type: "premiumLimitTypeChatFolderChosenChatCount"},
	}

	return &premiumLimitTypeChatFolderChosenChatCountTemp
}

// UnmarshalJSON unmarshal to json
func (premiumLimitTypeChatFolderChosenChatCount *PremiumLimitTypeChatFolderChosenChatCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumLimitTypeChatFolderChosenChatCount.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumLimitTypeEnum return the enum type of this object
func (premiumLimitTypeChatFolderChosenChatCount *PremiumLimitTypeChatFolderChosenChatCount) GetPremiumLimitTypeEnum() PremiumLimitTypeEnum {
	return PremiumLimitTypeChatFolderChosenChatCountType
}

// PremiumLimitTypePinnedArchivedChatCount The maximum number of pinned chats in the archive chat list
type PremiumLimitTypePinnedArchivedChatCount struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumLimitTypePinnedArchivedChatCount
func (premiumLimitTypePinnedArchivedChatCount *PremiumLimitTypePinnedArchivedChatCount) MessageType() string {
	return "premiumLimitTypePinnedArchivedChatCount"
}

// NewPremiumLimitTypePinnedArchivedChatCount creates a new PremiumLimitTypePinnedArchivedChatCount
//
func NewPremiumLimitTypePinnedArchivedChatCount() *PremiumLimitTypePinnedArchivedChatCount {
	premiumLimitTypePinnedArchivedChatCountTemp := PremiumLimitTypePinnedArchivedChatCount{
		tdCommon: tdCommon{Type: "premiumLimitTypePinnedArchivedChatCount"},
	}

	return &premiumLimitTypePinnedArchivedChatCountTemp
}

// UnmarshalJSON unmarshal to json
func (premiumLimitTypePinnedArchivedChatCount *PremiumLimitTypePinnedArchivedChatCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumLimitTypePinnedArchivedChatCount.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumLimitTypeEnum return the enum type of this object
func (premiumLimitTypePinnedArchivedChatCount *PremiumLimitTypePinnedArchivedChatCount) GetPremiumLimitTypeEnum() PremiumLimitTypeEnum {
	return PremiumLimitTypePinnedArchivedChatCountType
}

// PremiumLimitTypePinnedSavedMessagesTopicCount The maximum number of pinned Saved Messages topics
type PremiumLimitTypePinnedSavedMessagesTopicCount struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumLimitTypePinnedSavedMessagesTopicCount
func (premiumLimitTypePinnedSavedMessagesTopicCount *PremiumLimitTypePinnedSavedMessagesTopicCount) MessageType() string {
	return "premiumLimitTypePinnedSavedMessagesTopicCount"
}

// NewPremiumLimitTypePinnedSavedMessagesTopicCount creates a new PremiumLimitTypePinnedSavedMessagesTopicCount
//
func NewPremiumLimitTypePinnedSavedMessagesTopicCount() *PremiumLimitTypePinnedSavedMessagesTopicCount {
	premiumLimitTypePinnedSavedMessagesTopicCountTemp := PremiumLimitTypePinnedSavedMessagesTopicCount{
		tdCommon: tdCommon{Type: "premiumLimitTypePinnedSavedMessagesTopicCount"},
	}

	return &premiumLimitTypePinnedSavedMessagesTopicCountTemp
}

// UnmarshalJSON unmarshal to json
func (premiumLimitTypePinnedSavedMessagesTopicCount *PremiumLimitTypePinnedSavedMessagesTopicCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumLimitTypePinnedSavedMessagesTopicCount.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumLimitTypeEnum return the enum type of this object
func (premiumLimitTypePinnedSavedMessagesTopicCount *PremiumLimitTypePinnedSavedMessagesTopicCount) GetPremiumLimitTypeEnum() PremiumLimitTypeEnum {
	return PremiumLimitTypePinnedSavedMessagesTopicCountType
}

// PremiumLimitTypeCaptionLength The maximum length of sent media caption
type PremiumLimitTypeCaptionLength struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumLimitTypeCaptionLength
func (premiumLimitTypeCaptionLength *PremiumLimitTypeCaptionLength) MessageType() string {
	return "premiumLimitTypeCaptionLength"
}

// NewPremiumLimitTypeCaptionLength creates a new PremiumLimitTypeCaptionLength
//
func NewPremiumLimitTypeCaptionLength() *PremiumLimitTypeCaptionLength {
	premiumLimitTypeCaptionLengthTemp := PremiumLimitTypeCaptionLength{
		tdCommon: tdCommon{Type: "premiumLimitTypeCaptionLength"},
	}

	return &premiumLimitTypeCaptionLengthTemp
}

// UnmarshalJSON unmarshal to json
func (premiumLimitTypeCaptionLength *PremiumLimitTypeCaptionLength) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumLimitTypeCaptionLength.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumLimitTypeEnum return the enum type of this object
func (premiumLimitTypeCaptionLength *PremiumLimitTypeCaptionLength) GetPremiumLimitTypeEnum() PremiumLimitTypeEnum {
	return PremiumLimitTypeCaptionLengthType
}

// PremiumLimitTypeBioLength The maximum length of the user's bio
type PremiumLimitTypeBioLength struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumLimitTypeBioLength
func (premiumLimitTypeBioLength *PremiumLimitTypeBioLength) MessageType() string {
	return "premiumLimitTypeBioLength"
}

// NewPremiumLimitTypeBioLength creates a new PremiumLimitTypeBioLength
//
func NewPremiumLimitTypeBioLength() *PremiumLimitTypeBioLength {
	premiumLimitTypeBioLengthTemp := PremiumLimitTypeBioLength{
		tdCommon: tdCommon{Type: "premiumLimitTypeBioLength"},
	}

	return &premiumLimitTypeBioLengthTemp
}

// UnmarshalJSON unmarshal to json
func (premiumLimitTypeBioLength *PremiumLimitTypeBioLength) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumLimitTypeBioLength.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumLimitTypeEnum return the enum type of this object
func (premiumLimitTypeBioLength *PremiumLimitTypeBioLength) GetPremiumLimitTypeEnum() PremiumLimitTypeEnum {
	return PremiumLimitTypeBioLengthType
}

// PremiumLimitTypeChatFolderInviteLinkCount The maximum number of invite links for a chat folder
type PremiumLimitTypeChatFolderInviteLinkCount struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumLimitTypeChatFolderInviteLinkCount
func (premiumLimitTypeChatFolderInviteLinkCount *PremiumLimitTypeChatFolderInviteLinkCount) MessageType() string {
	return "premiumLimitTypeChatFolderInviteLinkCount"
}

// NewPremiumLimitTypeChatFolderInviteLinkCount creates a new PremiumLimitTypeChatFolderInviteLinkCount
//
func NewPremiumLimitTypeChatFolderInviteLinkCount() *PremiumLimitTypeChatFolderInviteLinkCount {
	premiumLimitTypeChatFolderInviteLinkCountTemp := PremiumLimitTypeChatFolderInviteLinkCount{
		tdCommon: tdCommon{Type: "premiumLimitTypeChatFolderInviteLinkCount"},
	}

	return &premiumLimitTypeChatFolderInviteLinkCountTemp
}

// UnmarshalJSON unmarshal to json
func (premiumLimitTypeChatFolderInviteLinkCount *PremiumLimitTypeChatFolderInviteLinkCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumLimitTypeChatFolderInviteLinkCount.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumLimitTypeEnum return the enum type of this object
func (premiumLimitTypeChatFolderInviteLinkCount *PremiumLimitTypeChatFolderInviteLinkCount) GetPremiumLimitTypeEnum() PremiumLimitTypeEnum {
	return PremiumLimitTypeChatFolderInviteLinkCountType
}

// PremiumLimitTypeShareableChatFolderCount The maximum number of added shareable chat folders
type PremiumLimitTypeShareableChatFolderCount struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumLimitTypeShareableChatFolderCount
func (premiumLimitTypeShareableChatFolderCount *PremiumLimitTypeShareableChatFolderCount) MessageType() string {
	return "premiumLimitTypeShareableChatFolderCount"
}

// NewPremiumLimitTypeShareableChatFolderCount creates a new PremiumLimitTypeShareableChatFolderCount
//
func NewPremiumLimitTypeShareableChatFolderCount() *PremiumLimitTypeShareableChatFolderCount {
	premiumLimitTypeShareableChatFolderCountTemp := PremiumLimitTypeShareableChatFolderCount{
		tdCommon: tdCommon{Type: "premiumLimitTypeShareableChatFolderCount"},
	}

	return &premiumLimitTypeShareableChatFolderCountTemp
}

// UnmarshalJSON unmarshal to json
func (premiumLimitTypeShareableChatFolderCount *PremiumLimitTypeShareableChatFolderCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumLimitTypeShareableChatFolderCount.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumLimitTypeEnum return the enum type of this object
func (premiumLimitTypeShareableChatFolderCount *PremiumLimitTypeShareableChatFolderCount) GetPremiumLimitTypeEnum() PremiumLimitTypeEnum {
	return PremiumLimitTypeShareableChatFolderCountType
}

// PremiumLimitTypeActiveStoryCount The maximum number of active stories
type PremiumLimitTypeActiveStoryCount struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumLimitTypeActiveStoryCount
func (premiumLimitTypeActiveStoryCount *PremiumLimitTypeActiveStoryCount) MessageType() string {
	return "premiumLimitTypeActiveStoryCount"
}

// NewPremiumLimitTypeActiveStoryCount creates a new PremiumLimitTypeActiveStoryCount
//
func NewPremiumLimitTypeActiveStoryCount() *PremiumLimitTypeActiveStoryCount {
	premiumLimitTypeActiveStoryCountTemp := PremiumLimitTypeActiveStoryCount{
		tdCommon: tdCommon{Type: "premiumLimitTypeActiveStoryCount"},
	}

	return &premiumLimitTypeActiveStoryCountTemp
}

// UnmarshalJSON unmarshal to json
func (premiumLimitTypeActiveStoryCount *PremiumLimitTypeActiveStoryCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumLimitTypeActiveStoryCount.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumLimitTypeEnum return the enum type of this object
func (premiumLimitTypeActiveStoryCount *PremiumLimitTypeActiveStoryCount) GetPremiumLimitTypeEnum() PremiumLimitTypeEnum {
	return PremiumLimitTypeActiveStoryCountType
}

// PremiumLimitTypeWeeklySentStoryCount The maximum number of stories sent per week
type PremiumLimitTypeWeeklySentStoryCount struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumLimitTypeWeeklySentStoryCount
func (premiumLimitTypeWeeklySentStoryCount *PremiumLimitTypeWeeklySentStoryCount) MessageType() string {
	return "premiumLimitTypeWeeklySentStoryCount"
}

// NewPremiumLimitTypeWeeklySentStoryCount creates a new PremiumLimitTypeWeeklySentStoryCount
//
func NewPremiumLimitTypeWeeklySentStoryCount() *PremiumLimitTypeWeeklySentStoryCount {
	premiumLimitTypeWeeklySentStoryCountTemp := PremiumLimitTypeWeeklySentStoryCount{
		tdCommon: tdCommon{Type: "premiumLimitTypeWeeklySentStoryCount"},
	}

	return &premiumLimitTypeWeeklySentStoryCountTemp
}

// UnmarshalJSON unmarshal to json
func (premiumLimitTypeWeeklySentStoryCount *PremiumLimitTypeWeeklySentStoryCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumLimitTypeWeeklySentStoryCount.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumLimitTypeEnum return the enum type of this object
func (premiumLimitTypeWeeklySentStoryCount *PremiumLimitTypeWeeklySentStoryCount) GetPremiumLimitTypeEnum() PremiumLimitTypeEnum {
	return PremiumLimitTypeWeeklySentStoryCountType
}

// PremiumLimitTypeMonthlySentStoryCount The maximum number of stories sent per month
type PremiumLimitTypeMonthlySentStoryCount struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumLimitTypeMonthlySentStoryCount
func (premiumLimitTypeMonthlySentStoryCount *PremiumLimitTypeMonthlySentStoryCount) MessageType() string {
	return "premiumLimitTypeMonthlySentStoryCount"
}

// NewPremiumLimitTypeMonthlySentStoryCount creates a new PremiumLimitTypeMonthlySentStoryCount
//
func NewPremiumLimitTypeMonthlySentStoryCount() *PremiumLimitTypeMonthlySentStoryCount {
	premiumLimitTypeMonthlySentStoryCountTemp := PremiumLimitTypeMonthlySentStoryCount{
		tdCommon: tdCommon{Type: "premiumLimitTypeMonthlySentStoryCount"},
	}

	return &premiumLimitTypeMonthlySentStoryCountTemp
}

// UnmarshalJSON unmarshal to json
func (premiumLimitTypeMonthlySentStoryCount *PremiumLimitTypeMonthlySentStoryCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumLimitTypeMonthlySentStoryCount.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumLimitTypeEnum return the enum type of this object
func (premiumLimitTypeMonthlySentStoryCount *PremiumLimitTypeMonthlySentStoryCount) GetPremiumLimitTypeEnum() PremiumLimitTypeEnum {
	return PremiumLimitTypeMonthlySentStoryCountType
}

// PremiumLimitTypeStoryCaptionLength The maximum length of captions of sent stories
type PremiumLimitTypeStoryCaptionLength struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumLimitTypeStoryCaptionLength
func (premiumLimitTypeStoryCaptionLength *PremiumLimitTypeStoryCaptionLength) MessageType() string {
	return "premiumLimitTypeStoryCaptionLength"
}

// NewPremiumLimitTypeStoryCaptionLength creates a new PremiumLimitTypeStoryCaptionLength
//
func NewPremiumLimitTypeStoryCaptionLength() *PremiumLimitTypeStoryCaptionLength {
	premiumLimitTypeStoryCaptionLengthTemp := PremiumLimitTypeStoryCaptionLength{
		tdCommon: tdCommon{Type: "premiumLimitTypeStoryCaptionLength"},
	}

	return &premiumLimitTypeStoryCaptionLengthTemp
}

// UnmarshalJSON unmarshal to json
func (premiumLimitTypeStoryCaptionLength *PremiumLimitTypeStoryCaptionLength) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumLimitTypeStoryCaptionLength.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumLimitTypeEnum return the enum type of this object
func (premiumLimitTypeStoryCaptionLength *PremiumLimitTypeStoryCaptionLength) GetPremiumLimitTypeEnum() PremiumLimitTypeEnum {
	return PremiumLimitTypeStoryCaptionLengthType
}

// PremiumLimitTypeStorySuggestedReactionAreaCount The maximum number of suggested reaction areas on a story
type PremiumLimitTypeStorySuggestedReactionAreaCount struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumLimitTypeStorySuggestedReactionAreaCount
func (premiumLimitTypeStorySuggestedReactionAreaCount *PremiumLimitTypeStorySuggestedReactionAreaCount) MessageType() string {
	return "premiumLimitTypeStorySuggestedReactionAreaCount"
}

// NewPremiumLimitTypeStorySuggestedReactionAreaCount creates a new PremiumLimitTypeStorySuggestedReactionAreaCount
//
func NewPremiumLimitTypeStorySuggestedReactionAreaCount() *PremiumLimitTypeStorySuggestedReactionAreaCount {
	premiumLimitTypeStorySuggestedReactionAreaCountTemp := PremiumLimitTypeStorySuggestedReactionAreaCount{
		tdCommon: tdCommon{Type: "premiumLimitTypeStorySuggestedReactionAreaCount"},
	}

	return &premiumLimitTypeStorySuggestedReactionAreaCountTemp
}

// UnmarshalJSON unmarshal to json
func (premiumLimitTypeStorySuggestedReactionAreaCount *PremiumLimitTypeStorySuggestedReactionAreaCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumLimitTypeStorySuggestedReactionAreaCount.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumLimitTypeEnum return the enum type of this object
func (premiumLimitTypeStorySuggestedReactionAreaCount *PremiumLimitTypeStorySuggestedReactionAreaCount) GetPremiumLimitTypeEnum() PremiumLimitTypeEnum {
	return PremiumLimitTypeStorySuggestedReactionAreaCountType
}

// PremiumLimitTypeSimilarChatCount The maximum number of received similar chats
type PremiumLimitTypeSimilarChatCount struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumLimitTypeSimilarChatCount
func (premiumLimitTypeSimilarChatCount *PremiumLimitTypeSimilarChatCount) MessageType() string {
	return "premiumLimitTypeSimilarChatCount"
}

// NewPremiumLimitTypeSimilarChatCount creates a new PremiumLimitTypeSimilarChatCount
//
func NewPremiumLimitTypeSimilarChatCount() *PremiumLimitTypeSimilarChatCount {
	premiumLimitTypeSimilarChatCountTemp := PremiumLimitTypeSimilarChatCount{
		tdCommon: tdCommon{Type: "premiumLimitTypeSimilarChatCount"},
	}

	return &premiumLimitTypeSimilarChatCountTemp
}

// UnmarshalJSON unmarshal to json
func (premiumLimitTypeSimilarChatCount *PremiumLimitTypeSimilarChatCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumLimitTypeSimilarChatCount.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumLimitTypeEnum return the enum type of this object
func (premiumLimitTypeSimilarChatCount *PremiumLimitTypeSimilarChatCount) GetPremiumLimitTypeEnum() PremiumLimitTypeEnum {
	return PremiumLimitTypeSimilarChatCountType
}

// PremiumFeatureIncreasedLimits Increased limits
type PremiumFeatureIncreasedLimits struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureIncreasedLimits
func (premiumFeatureIncreasedLimits *PremiumFeatureIncreasedLimits) MessageType() string {
	return "premiumFeatureIncreasedLimits"
}

// NewPremiumFeatureIncreasedLimits creates a new PremiumFeatureIncreasedLimits
//
func NewPremiumFeatureIncreasedLimits() *PremiumFeatureIncreasedLimits {
	premiumFeatureIncreasedLimitsTemp := PremiumFeatureIncreasedLimits{
		tdCommon: tdCommon{Type: "premiumFeatureIncreasedLimits"},
	}

	return &premiumFeatureIncreasedLimitsTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureIncreasedLimits *PremiumFeatureIncreasedLimits) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureIncreasedLimits.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureIncreasedLimits *PremiumFeatureIncreasedLimits) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureIncreasedLimitsType
}

// PremiumFeatureIncreasedUploadFileSize Increased maximum upload file size
type PremiumFeatureIncreasedUploadFileSize struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureIncreasedUploadFileSize
func (premiumFeatureIncreasedUploadFileSize *PremiumFeatureIncreasedUploadFileSize) MessageType() string {
	return "premiumFeatureIncreasedUploadFileSize"
}

// NewPremiumFeatureIncreasedUploadFileSize creates a new PremiumFeatureIncreasedUploadFileSize
//
func NewPremiumFeatureIncreasedUploadFileSize() *PremiumFeatureIncreasedUploadFileSize {
	premiumFeatureIncreasedUploadFileSizeTemp := PremiumFeatureIncreasedUploadFileSize{
		tdCommon: tdCommon{Type: "premiumFeatureIncreasedUploadFileSize"},
	}

	return &premiumFeatureIncreasedUploadFileSizeTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureIncreasedUploadFileSize *PremiumFeatureIncreasedUploadFileSize) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureIncreasedUploadFileSize.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureIncreasedUploadFileSize *PremiumFeatureIncreasedUploadFileSize) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureIncreasedUploadFileSizeType
}

// PremiumFeatureImprovedDownloadSpeed Improved download speed
type PremiumFeatureImprovedDownloadSpeed struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureImprovedDownloadSpeed
func (premiumFeatureImprovedDownloadSpeed *PremiumFeatureImprovedDownloadSpeed) MessageType() string {
	return "premiumFeatureImprovedDownloadSpeed"
}

// NewPremiumFeatureImprovedDownloadSpeed creates a new PremiumFeatureImprovedDownloadSpeed
//
func NewPremiumFeatureImprovedDownloadSpeed() *PremiumFeatureImprovedDownloadSpeed {
	premiumFeatureImprovedDownloadSpeedTemp := PremiumFeatureImprovedDownloadSpeed{
		tdCommon: tdCommon{Type: "premiumFeatureImprovedDownloadSpeed"},
	}

	return &premiumFeatureImprovedDownloadSpeedTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureImprovedDownloadSpeed *PremiumFeatureImprovedDownloadSpeed) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureImprovedDownloadSpeed.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureImprovedDownloadSpeed *PremiumFeatureImprovedDownloadSpeed) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureImprovedDownloadSpeedType
}

// PremiumFeatureVoiceRecognition The ability to convert voice notes to text
type PremiumFeatureVoiceRecognition struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureVoiceRecognition
func (premiumFeatureVoiceRecognition *PremiumFeatureVoiceRecognition) MessageType() string {
	return "premiumFeatureVoiceRecognition"
}

// NewPremiumFeatureVoiceRecognition creates a new PremiumFeatureVoiceRecognition
//
func NewPremiumFeatureVoiceRecognition() *PremiumFeatureVoiceRecognition {
	premiumFeatureVoiceRecognitionTemp := PremiumFeatureVoiceRecognition{
		tdCommon: tdCommon{Type: "premiumFeatureVoiceRecognition"},
	}

	return &premiumFeatureVoiceRecognitionTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureVoiceRecognition *PremiumFeatureVoiceRecognition) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureVoiceRecognition.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureVoiceRecognition *PremiumFeatureVoiceRecognition) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureVoiceRecognitionType
}

// PremiumFeatureDisabledAds Disabled ads
type PremiumFeatureDisabledAds struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureDisabledAds
func (premiumFeatureDisabledAds *PremiumFeatureDisabledAds) MessageType() string {
	return "premiumFeatureDisabledAds"
}

// NewPremiumFeatureDisabledAds creates a new PremiumFeatureDisabledAds
//
func NewPremiumFeatureDisabledAds() *PremiumFeatureDisabledAds {
	premiumFeatureDisabledAdsTemp := PremiumFeatureDisabledAds{
		tdCommon: tdCommon{Type: "premiumFeatureDisabledAds"},
	}

	return &premiumFeatureDisabledAdsTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureDisabledAds *PremiumFeatureDisabledAds) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureDisabledAds.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureDisabledAds *PremiumFeatureDisabledAds) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureDisabledAdsType
}

// PremiumFeatureUniqueReactions Allowed to use more reactions
type PremiumFeatureUniqueReactions struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureUniqueReactions
func (premiumFeatureUniqueReactions *PremiumFeatureUniqueReactions) MessageType() string {
	return "premiumFeatureUniqueReactions"
}

// NewPremiumFeatureUniqueReactions creates a new PremiumFeatureUniqueReactions
//
func NewPremiumFeatureUniqueReactions() *PremiumFeatureUniqueReactions {
	premiumFeatureUniqueReactionsTemp := PremiumFeatureUniqueReactions{
		tdCommon: tdCommon{Type: "premiumFeatureUniqueReactions"},
	}

	return &premiumFeatureUniqueReactionsTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureUniqueReactions *PremiumFeatureUniqueReactions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureUniqueReactions.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureUniqueReactions *PremiumFeatureUniqueReactions) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureUniqueReactionsType
}

// PremiumFeatureUniqueStickers Allowed to use premium stickers with unique effects
type PremiumFeatureUniqueStickers struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureUniqueStickers
func (premiumFeatureUniqueStickers *PremiumFeatureUniqueStickers) MessageType() string {
	return "premiumFeatureUniqueStickers"
}

// NewPremiumFeatureUniqueStickers creates a new PremiumFeatureUniqueStickers
//
func NewPremiumFeatureUniqueStickers() *PremiumFeatureUniqueStickers {
	premiumFeatureUniqueStickersTemp := PremiumFeatureUniqueStickers{
		tdCommon: tdCommon{Type: "premiumFeatureUniqueStickers"},
	}

	return &premiumFeatureUniqueStickersTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureUniqueStickers *PremiumFeatureUniqueStickers) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureUniqueStickers.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureUniqueStickers *PremiumFeatureUniqueStickers) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureUniqueStickersType
}

// PremiumFeatureCustomEmoji Allowed to use custom emoji stickers in message texts and captions
type PremiumFeatureCustomEmoji struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureCustomEmoji
func (premiumFeatureCustomEmoji *PremiumFeatureCustomEmoji) MessageType() string {
	return "premiumFeatureCustomEmoji"
}

// NewPremiumFeatureCustomEmoji creates a new PremiumFeatureCustomEmoji
//
func NewPremiumFeatureCustomEmoji() *PremiumFeatureCustomEmoji {
	premiumFeatureCustomEmojiTemp := PremiumFeatureCustomEmoji{
		tdCommon: tdCommon{Type: "premiumFeatureCustomEmoji"},
	}

	return &premiumFeatureCustomEmojiTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureCustomEmoji *PremiumFeatureCustomEmoji) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureCustomEmoji.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureCustomEmoji *PremiumFeatureCustomEmoji) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureCustomEmojiType
}

// PremiumFeatureAdvancedChatManagement Ability to change position of the main chat list, archive and mute all new chats from non-contacts, and completely disable notifications about the user's contacts joined Telegram
type PremiumFeatureAdvancedChatManagement struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureAdvancedChatManagement
func (premiumFeatureAdvancedChatManagement *PremiumFeatureAdvancedChatManagement) MessageType() string {
	return "premiumFeatureAdvancedChatManagement"
}

// NewPremiumFeatureAdvancedChatManagement creates a new PremiumFeatureAdvancedChatManagement
//
func NewPremiumFeatureAdvancedChatManagement() *PremiumFeatureAdvancedChatManagement {
	premiumFeatureAdvancedChatManagementTemp := PremiumFeatureAdvancedChatManagement{
		tdCommon: tdCommon{Type: "premiumFeatureAdvancedChatManagement"},
	}

	return &premiumFeatureAdvancedChatManagementTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureAdvancedChatManagement *PremiumFeatureAdvancedChatManagement) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureAdvancedChatManagement.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureAdvancedChatManagement *PremiumFeatureAdvancedChatManagement) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureAdvancedChatManagementType
}

// PremiumFeatureProfileBadge A badge in the user's profile
type PremiumFeatureProfileBadge struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureProfileBadge
func (premiumFeatureProfileBadge *PremiumFeatureProfileBadge) MessageType() string {
	return "premiumFeatureProfileBadge"
}

// NewPremiumFeatureProfileBadge creates a new PremiumFeatureProfileBadge
//
func NewPremiumFeatureProfileBadge() *PremiumFeatureProfileBadge {
	premiumFeatureProfileBadgeTemp := PremiumFeatureProfileBadge{
		tdCommon: tdCommon{Type: "premiumFeatureProfileBadge"},
	}

	return &premiumFeatureProfileBadgeTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureProfileBadge *PremiumFeatureProfileBadge) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureProfileBadge.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureProfileBadge *PremiumFeatureProfileBadge) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureProfileBadgeType
}

// PremiumFeatureEmojiStatus The ability to show an emoji status along with the user's name
type PremiumFeatureEmojiStatus struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureEmojiStatus
func (premiumFeatureEmojiStatus *PremiumFeatureEmojiStatus) MessageType() string {
	return "premiumFeatureEmojiStatus"
}

// NewPremiumFeatureEmojiStatus creates a new PremiumFeatureEmojiStatus
//
func NewPremiumFeatureEmojiStatus() *PremiumFeatureEmojiStatus {
	premiumFeatureEmojiStatusTemp := PremiumFeatureEmojiStatus{
		tdCommon: tdCommon{Type: "premiumFeatureEmojiStatus"},
	}

	return &premiumFeatureEmojiStatusTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureEmojiStatus *PremiumFeatureEmojiStatus) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureEmojiStatus.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureEmojiStatus *PremiumFeatureEmojiStatus) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureEmojiStatusType
}

// PremiumFeatureAnimatedProfilePhoto Profile photo animation on message and chat screens
type PremiumFeatureAnimatedProfilePhoto struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureAnimatedProfilePhoto
func (premiumFeatureAnimatedProfilePhoto *PremiumFeatureAnimatedProfilePhoto) MessageType() string {
	return "premiumFeatureAnimatedProfilePhoto"
}

// NewPremiumFeatureAnimatedProfilePhoto creates a new PremiumFeatureAnimatedProfilePhoto
//
func NewPremiumFeatureAnimatedProfilePhoto() *PremiumFeatureAnimatedProfilePhoto {
	premiumFeatureAnimatedProfilePhotoTemp := PremiumFeatureAnimatedProfilePhoto{
		tdCommon: tdCommon{Type: "premiumFeatureAnimatedProfilePhoto"},
	}

	return &premiumFeatureAnimatedProfilePhotoTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureAnimatedProfilePhoto *PremiumFeatureAnimatedProfilePhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureAnimatedProfilePhoto.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureAnimatedProfilePhoto *PremiumFeatureAnimatedProfilePhoto) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureAnimatedProfilePhotoType
}

// PremiumFeatureForumTopicIcon The ability to set a custom emoji as a forum topic icon
type PremiumFeatureForumTopicIcon struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureForumTopicIcon
func (premiumFeatureForumTopicIcon *PremiumFeatureForumTopicIcon) MessageType() string {
	return "premiumFeatureForumTopicIcon"
}

// NewPremiumFeatureForumTopicIcon creates a new PremiumFeatureForumTopicIcon
//
func NewPremiumFeatureForumTopicIcon() *PremiumFeatureForumTopicIcon {
	premiumFeatureForumTopicIconTemp := PremiumFeatureForumTopicIcon{
		tdCommon: tdCommon{Type: "premiumFeatureForumTopicIcon"},
	}

	return &premiumFeatureForumTopicIconTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureForumTopicIcon *PremiumFeatureForumTopicIcon) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureForumTopicIcon.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureForumTopicIcon *PremiumFeatureForumTopicIcon) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureForumTopicIconType
}

// PremiumFeatureAppIcons Allowed to set a premium application icons
type PremiumFeatureAppIcons struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureAppIcons
func (premiumFeatureAppIcons *PremiumFeatureAppIcons) MessageType() string {
	return "premiumFeatureAppIcons"
}

// NewPremiumFeatureAppIcons creates a new PremiumFeatureAppIcons
//
func NewPremiumFeatureAppIcons() *PremiumFeatureAppIcons {
	premiumFeatureAppIconsTemp := PremiumFeatureAppIcons{
		tdCommon: tdCommon{Type: "premiumFeatureAppIcons"},
	}

	return &premiumFeatureAppIconsTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureAppIcons *PremiumFeatureAppIcons) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureAppIcons.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureAppIcons *PremiumFeatureAppIcons) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureAppIconsType
}

// PremiumFeatureRealTimeChatTranslation Allowed to translate chat messages real-time
type PremiumFeatureRealTimeChatTranslation struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureRealTimeChatTranslation
func (premiumFeatureRealTimeChatTranslation *PremiumFeatureRealTimeChatTranslation) MessageType() string {
	return "premiumFeatureRealTimeChatTranslation"
}

// NewPremiumFeatureRealTimeChatTranslation creates a new PremiumFeatureRealTimeChatTranslation
//
func NewPremiumFeatureRealTimeChatTranslation() *PremiumFeatureRealTimeChatTranslation {
	premiumFeatureRealTimeChatTranslationTemp := PremiumFeatureRealTimeChatTranslation{
		tdCommon: tdCommon{Type: "premiumFeatureRealTimeChatTranslation"},
	}

	return &premiumFeatureRealTimeChatTranslationTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureRealTimeChatTranslation *PremiumFeatureRealTimeChatTranslation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureRealTimeChatTranslation.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureRealTimeChatTranslation *PremiumFeatureRealTimeChatTranslation) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureRealTimeChatTranslationType
}

// PremiumFeatureUpgradedStories Allowed to use many additional features for stories
type PremiumFeatureUpgradedStories struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureUpgradedStories
func (premiumFeatureUpgradedStories *PremiumFeatureUpgradedStories) MessageType() string {
	return "premiumFeatureUpgradedStories"
}

// NewPremiumFeatureUpgradedStories creates a new PremiumFeatureUpgradedStories
//
func NewPremiumFeatureUpgradedStories() *PremiumFeatureUpgradedStories {
	premiumFeatureUpgradedStoriesTemp := PremiumFeatureUpgradedStories{
		tdCommon: tdCommon{Type: "premiumFeatureUpgradedStories"},
	}

	return &premiumFeatureUpgradedStoriesTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureUpgradedStories *PremiumFeatureUpgradedStories) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureUpgradedStories.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureUpgradedStories *PremiumFeatureUpgradedStories) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureUpgradedStoriesType
}

// PremiumFeatureChatBoost The ability to boost chats
type PremiumFeatureChatBoost struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureChatBoost
func (premiumFeatureChatBoost *PremiumFeatureChatBoost) MessageType() string {
	return "premiumFeatureChatBoost"
}

// NewPremiumFeatureChatBoost creates a new PremiumFeatureChatBoost
//
func NewPremiumFeatureChatBoost() *PremiumFeatureChatBoost {
	premiumFeatureChatBoostTemp := PremiumFeatureChatBoost{
		tdCommon: tdCommon{Type: "premiumFeatureChatBoost"},
	}

	return &premiumFeatureChatBoostTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureChatBoost *PremiumFeatureChatBoost) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureChatBoost.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureChatBoost *PremiumFeatureChatBoost) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureChatBoostType
}

// PremiumFeatureAccentColor The ability to choose accent color for replies and user profile
type PremiumFeatureAccentColor struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureAccentColor
func (premiumFeatureAccentColor *PremiumFeatureAccentColor) MessageType() string {
	return "premiumFeatureAccentColor"
}

// NewPremiumFeatureAccentColor creates a new PremiumFeatureAccentColor
//
func NewPremiumFeatureAccentColor() *PremiumFeatureAccentColor {
	premiumFeatureAccentColorTemp := PremiumFeatureAccentColor{
		tdCommon: tdCommon{Type: "premiumFeatureAccentColor"},
	}

	return &premiumFeatureAccentColorTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureAccentColor *PremiumFeatureAccentColor) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureAccentColor.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureAccentColor *PremiumFeatureAccentColor) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureAccentColorType
}

// PremiumFeatureBackgroundForBoth The ability to set private chat background for both users
type PremiumFeatureBackgroundForBoth struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureBackgroundForBoth
func (premiumFeatureBackgroundForBoth *PremiumFeatureBackgroundForBoth) MessageType() string {
	return "premiumFeatureBackgroundForBoth"
}

// NewPremiumFeatureBackgroundForBoth creates a new PremiumFeatureBackgroundForBoth
//
func NewPremiumFeatureBackgroundForBoth() *PremiumFeatureBackgroundForBoth {
	premiumFeatureBackgroundForBothTemp := PremiumFeatureBackgroundForBoth{
		tdCommon: tdCommon{Type: "premiumFeatureBackgroundForBoth"},
	}

	return &premiumFeatureBackgroundForBothTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureBackgroundForBoth *PremiumFeatureBackgroundForBoth) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureBackgroundForBoth.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureBackgroundForBoth *PremiumFeatureBackgroundForBoth) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureBackgroundForBothType
}

// PremiumFeatureSavedMessagesTags The ability to use tags in Saved Messages
type PremiumFeatureSavedMessagesTags struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureSavedMessagesTags
func (premiumFeatureSavedMessagesTags *PremiumFeatureSavedMessagesTags) MessageType() string {
	return "premiumFeatureSavedMessagesTags"
}

// NewPremiumFeatureSavedMessagesTags creates a new PremiumFeatureSavedMessagesTags
//
func NewPremiumFeatureSavedMessagesTags() *PremiumFeatureSavedMessagesTags {
	premiumFeatureSavedMessagesTagsTemp := PremiumFeatureSavedMessagesTags{
		tdCommon: tdCommon{Type: "premiumFeatureSavedMessagesTags"},
	}

	return &premiumFeatureSavedMessagesTagsTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureSavedMessagesTags *PremiumFeatureSavedMessagesTags) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureSavedMessagesTags.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureSavedMessagesTags *PremiumFeatureSavedMessagesTags) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureSavedMessagesTagsType
}

// PremiumFeatureMessagePrivacy The ability to disallow incoming voice and video note messages in private chats using setUserPrivacySettingRules with userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages and to restrict incoming messages from non-contacts using setNewChatPrivacySettings
type PremiumFeatureMessagePrivacy struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureMessagePrivacy
func (premiumFeatureMessagePrivacy *PremiumFeatureMessagePrivacy) MessageType() string {
	return "premiumFeatureMessagePrivacy"
}

// NewPremiumFeatureMessagePrivacy creates a new PremiumFeatureMessagePrivacy
//
func NewPremiumFeatureMessagePrivacy() *PremiumFeatureMessagePrivacy {
	premiumFeatureMessagePrivacyTemp := PremiumFeatureMessagePrivacy{
		tdCommon: tdCommon{Type: "premiumFeatureMessagePrivacy"},
	}

	return &premiumFeatureMessagePrivacyTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureMessagePrivacy *PremiumFeatureMessagePrivacy) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureMessagePrivacy.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureMessagePrivacy *PremiumFeatureMessagePrivacy) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureMessagePrivacyType
}

// PremiumFeatureLastSeenTimes The ability to view last seen and read times of other users even they can't view last seen or read time for the current user
type PremiumFeatureLastSeenTimes struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureLastSeenTimes
func (premiumFeatureLastSeenTimes *PremiumFeatureLastSeenTimes) MessageType() string {
	return "premiumFeatureLastSeenTimes"
}

// NewPremiumFeatureLastSeenTimes creates a new PremiumFeatureLastSeenTimes
//
func NewPremiumFeatureLastSeenTimes() *PremiumFeatureLastSeenTimes {
	premiumFeatureLastSeenTimesTemp := PremiumFeatureLastSeenTimes{
		tdCommon: tdCommon{Type: "premiumFeatureLastSeenTimes"},
	}

	return &premiumFeatureLastSeenTimesTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureLastSeenTimes *PremiumFeatureLastSeenTimes) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureLastSeenTimes.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureLastSeenTimes *PremiumFeatureLastSeenTimes) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureLastSeenTimesType
}

// PremiumFeatureBusiness The ability to use Business features
type PremiumFeatureBusiness struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureBusiness
func (premiumFeatureBusiness *PremiumFeatureBusiness) MessageType() string {
	return "premiumFeatureBusiness"
}

// NewPremiumFeatureBusiness creates a new PremiumFeatureBusiness
//
func NewPremiumFeatureBusiness() *PremiumFeatureBusiness {
	premiumFeatureBusinessTemp := PremiumFeatureBusiness{
		tdCommon: tdCommon{Type: "premiumFeatureBusiness"},
	}

	return &premiumFeatureBusinessTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureBusiness *PremiumFeatureBusiness) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureBusiness.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureBusiness *PremiumFeatureBusiness) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureBusinessType
}

// PremiumFeatureMessageEffects The ability to use all available message effects
type PremiumFeatureMessageEffects struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumFeatureMessageEffects
func (premiumFeatureMessageEffects *PremiumFeatureMessageEffects) MessageType() string {
	return "premiumFeatureMessageEffects"
}

// NewPremiumFeatureMessageEffects creates a new PremiumFeatureMessageEffects
//
func NewPremiumFeatureMessageEffects() *PremiumFeatureMessageEffects {
	premiumFeatureMessageEffectsTemp := PremiumFeatureMessageEffects{
		tdCommon: tdCommon{Type: "premiumFeatureMessageEffects"},
	}

	return &premiumFeatureMessageEffectsTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatureMessageEffects *PremiumFeatureMessageEffects) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatureMessageEffects.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumFeatureEnum return the enum type of this object
func (premiumFeatureMessageEffects *PremiumFeatureMessageEffects) GetPremiumFeatureEnum() PremiumFeatureEnum {
	return PremiumFeatureMessageEffectsType
}

// BusinessFeatureLocation The ability to set location
type BusinessFeatureLocation struct {
	tdCommon
}

// MessageType return the string telegram-type of BusinessFeatureLocation
func (businessFeatureLocation *BusinessFeatureLocation) MessageType() string {
	return "businessFeatureLocation"
}

// NewBusinessFeatureLocation creates a new BusinessFeatureLocation
//
func NewBusinessFeatureLocation() *BusinessFeatureLocation {
	businessFeatureLocationTemp := BusinessFeatureLocation{
		tdCommon: tdCommon{Type: "businessFeatureLocation"},
	}

	return &businessFeatureLocationTemp
}

// UnmarshalJSON unmarshal to json
func (businessFeatureLocation *BusinessFeatureLocation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessFeatureLocation.tdCommon = tempObj.tdCommon

	return nil
}

// GetBusinessFeatureEnum return the enum type of this object
func (businessFeatureLocation *BusinessFeatureLocation) GetBusinessFeatureEnum() BusinessFeatureEnum {
	return BusinessFeatureLocationType
}

// BusinessFeatureOpeningHours The ability to set opening hours
type BusinessFeatureOpeningHours struct {
	tdCommon
}

// MessageType return the string telegram-type of BusinessFeatureOpeningHours
func (businessFeatureOpeningHours *BusinessFeatureOpeningHours) MessageType() string {
	return "businessFeatureOpeningHours"
}

// NewBusinessFeatureOpeningHours creates a new BusinessFeatureOpeningHours
//
func NewBusinessFeatureOpeningHours() *BusinessFeatureOpeningHours {
	businessFeatureOpeningHoursTemp := BusinessFeatureOpeningHours{
		tdCommon: tdCommon{Type: "businessFeatureOpeningHours"},
	}

	return &businessFeatureOpeningHoursTemp
}

// UnmarshalJSON unmarshal to json
func (businessFeatureOpeningHours *BusinessFeatureOpeningHours) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessFeatureOpeningHours.tdCommon = tempObj.tdCommon

	return nil
}

// GetBusinessFeatureEnum return the enum type of this object
func (businessFeatureOpeningHours *BusinessFeatureOpeningHours) GetBusinessFeatureEnum() BusinessFeatureEnum {
	return BusinessFeatureOpeningHoursType
}

// BusinessFeatureQuickReplies The ability to use quick replies
type BusinessFeatureQuickReplies struct {
	tdCommon
}

// MessageType return the string telegram-type of BusinessFeatureQuickReplies
func (businessFeatureQuickReplies *BusinessFeatureQuickReplies) MessageType() string {
	return "businessFeatureQuickReplies"
}

// NewBusinessFeatureQuickReplies creates a new BusinessFeatureQuickReplies
//
func NewBusinessFeatureQuickReplies() *BusinessFeatureQuickReplies {
	businessFeatureQuickRepliesTemp := BusinessFeatureQuickReplies{
		tdCommon: tdCommon{Type: "businessFeatureQuickReplies"},
	}

	return &businessFeatureQuickRepliesTemp
}

// UnmarshalJSON unmarshal to json
func (businessFeatureQuickReplies *BusinessFeatureQuickReplies) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessFeatureQuickReplies.tdCommon = tempObj.tdCommon

	return nil
}

// GetBusinessFeatureEnum return the enum type of this object
func (businessFeatureQuickReplies *BusinessFeatureQuickReplies) GetBusinessFeatureEnum() BusinessFeatureEnum {
	return BusinessFeatureQuickRepliesType
}

// BusinessFeatureGreetingMessage The ability to set up a greeting message
type BusinessFeatureGreetingMessage struct {
	tdCommon
}

// MessageType return the string telegram-type of BusinessFeatureGreetingMessage
func (businessFeatureGreetingMessage *BusinessFeatureGreetingMessage) MessageType() string {
	return "businessFeatureGreetingMessage"
}

// NewBusinessFeatureGreetingMessage creates a new BusinessFeatureGreetingMessage
//
func NewBusinessFeatureGreetingMessage() *BusinessFeatureGreetingMessage {
	businessFeatureGreetingMessageTemp := BusinessFeatureGreetingMessage{
		tdCommon: tdCommon{Type: "businessFeatureGreetingMessage"},
	}

	return &businessFeatureGreetingMessageTemp
}

// UnmarshalJSON unmarshal to json
func (businessFeatureGreetingMessage *BusinessFeatureGreetingMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessFeatureGreetingMessage.tdCommon = tempObj.tdCommon

	return nil
}

// GetBusinessFeatureEnum return the enum type of this object
func (businessFeatureGreetingMessage *BusinessFeatureGreetingMessage) GetBusinessFeatureEnum() BusinessFeatureEnum {
	return BusinessFeatureGreetingMessageType
}

// BusinessFeatureAwayMessage The ability to set up an away message
type BusinessFeatureAwayMessage struct {
	tdCommon
}

// MessageType return the string telegram-type of BusinessFeatureAwayMessage
func (businessFeatureAwayMessage *BusinessFeatureAwayMessage) MessageType() string {
	return "businessFeatureAwayMessage"
}

// NewBusinessFeatureAwayMessage creates a new BusinessFeatureAwayMessage
//
func NewBusinessFeatureAwayMessage() *BusinessFeatureAwayMessage {
	businessFeatureAwayMessageTemp := BusinessFeatureAwayMessage{
		tdCommon: tdCommon{Type: "businessFeatureAwayMessage"},
	}

	return &businessFeatureAwayMessageTemp
}

// UnmarshalJSON unmarshal to json
func (businessFeatureAwayMessage *BusinessFeatureAwayMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessFeatureAwayMessage.tdCommon = tempObj.tdCommon

	return nil
}

// GetBusinessFeatureEnum return the enum type of this object
func (businessFeatureAwayMessage *BusinessFeatureAwayMessage) GetBusinessFeatureEnum() BusinessFeatureEnum {
	return BusinessFeatureAwayMessageType
}

// BusinessFeatureAccountLinks The ability to create links to the business account with predefined message text
type BusinessFeatureAccountLinks struct {
	tdCommon
}

// MessageType return the string telegram-type of BusinessFeatureAccountLinks
func (businessFeatureAccountLinks *BusinessFeatureAccountLinks) MessageType() string {
	return "businessFeatureAccountLinks"
}

// NewBusinessFeatureAccountLinks creates a new BusinessFeatureAccountLinks
//
func NewBusinessFeatureAccountLinks() *BusinessFeatureAccountLinks {
	businessFeatureAccountLinksTemp := BusinessFeatureAccountLinks{
		tdCommon: tdCommon{Type: "businessFeatureAccountLinks"},
	}

	return &businessFeatureAccountLinksTemp
}

// UnmarshalJSON unmarshal to json
func (businessFeatureAccountLinks *BusinessFeatureAccountLinks) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessFeatureAccountLinks.tdCommon = tempObj.tdCommon

	return nil
}

// GetBusinessFeatureEnum return the enum type of this object
func (businessFeatureAccountLinks *BusinessFeatureAccountLinks) GetBusinessFeatureEnum() BusinessFeatureEnum {
	return BusinessFeatureAccountLinksType
}

// BusinessFeatureStartPage The ability to customize start page
type BusinessFeatureStartPage struct {
	tdCommon
}

// MessageType return the string telegram-type of BusinessFeatureStartPage
func (businessFeatureStartPage *BusinessFeatureStartPage) MessageType() string {
	return "businessFeatureStartPage"
}

// NewBusinessFeatureStartPage creates a new BusinessFeatureStartPage
//
func NewBusinessFeatureStartPage() *BusinessFeatureStartPage {
	businessFeatureStartPageTemp := BusinessFeatureStartPage{
		tdCommon: tdCommon{Type: "businessFeatureStartPage"},
	}

	return &businessFeatureStartPageTemp
}

// UnmarshalJSON unmarshal to json
func (businessFeatureStartPage *BusinessFeatureStartPage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessFeatureStartPage.tdCommon = tempObj.tdCommon

	return nil
}

// GetBusinessFeatureEnum return the enum type of this object
func (businessFeatureStartPage *BusinessFeatureStartPage) GetBusinessFeatureEnum() BusinessFeatureEnum {
	return BusinessFeatureStartPageType
}

// BusinessFeatureBots The ability to connect a bot to the account
type BusinessFeatureBots struct {
	tdCommon
}

// MessageType return the string telegram-type of BusinessFeatureBots
func (businessFeatureBots *BusinessFeatureBots) MessageType() string {
	return "businessFeatureBots"
}

// NewBusinessFeatureBots creates a new BusinessFeatureBots
//
func NewBusinessFeatureBots() *BusinessFeatureBots {
	businessFeatureBotsTemp := BusinessFeatureBots{
		tdCommon: tdCommon{Type: "businessFeatureBots"},
	}

	return &businessFeatureBotsTemp
}

// UnmarshalJSON unmarshal to json
func (businessFeatureBots *BusinessFeatureBots) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessFeatureBots.tdCommon = tempObj.tdCommon

	return nil
}

// GetBusinessFeatureEnum return the enum type of this object
func (businessFeatureBots *BusinessFeatureBots) GetBusinessFeatureEnum() BusinessFeatureEnum {
	return BusinessFeatureBotsType
}

// BusinessFeatureEmojiStatus The ability to show an emoji status along with the business name
type BusinessFeatureEmojiStatus struct {
	tdCommon
}

// MessageType return the string telegram-type of BusinessFeatureEmojiStatus
func (businessFeatureEmojiStatus *BusinessFeatureEmojiStatus) MessageType() string {
	return "businessFeatureEmojiStatus"
}

// NewBusinessFeatureEmojiStatus creates a new BusinessFeatureEmojiStatus
//
func NewBusinessFeatureEmojiStatus() *BusinessFeatureEmojiStatus {
	businessFeatureEmojiStatusTemp := BusinessFeatureEmojiStatus{
		tdCommon: tdCommon{Type: "businessFeatureEmojiStatus"},
	}

	return &businessFeatureEmojiStatusTemp
}

// UnmarshalJSON unmarshal to json
func (businessFeatureEmojiStatus *BusinessFeatureEmojiStatus) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessFeatureEmojiStatus.tdCommon = tempObj.tdCommon

	return nil
}

// GetBusinessFeatureEnum return the enum type of this object
func (businessFeatureEmojiStatus *BusinessFeatureEmojiStatus) GetBusinessFeatureEnum() BusinessFeatureEnum {
	return BusinessFeatureEmojiStatusType
}

// BusinessFeatureChatFolderTags The ability to display folder names for each chat in the chat list
type BusinessFeatureChatFolderTags struct {
	tdCommon
}

// MessageType return the string telegram-type of BusinessFeatureChatFolderTags
func (businessFeatureChatFolderTags *BusinessFeatureChatFolderTags) MessageType() string {
	return "businessFeatureChatFolderTags"
}

// NewBusinessFeatureChatFolderTags creates a new BusinessFeatureChatFolderTags
//
func NewBusinessFeatureChatFolderTags() *BusinessFeatureChatFolderTags {
	businessFeatureChatFolderTagsTemp := BusinessFeatureChatFolderTags{
		tdCommon: tdCommon{Type: "businessFeatureChatFolderTags"},
	}

	return &businessFeatureChatFolderTagsTemp
}

// UnmarshalJSON unmarshal to json
func (businessFeatureChatFolderTags *BusinessFeatureChatFolderTags) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessFeatureChatFolderTags.tdCommon = tempObj.tdCommon

	return nil
}

// GetBusinessFeatureEnum return the enum type of this object
func (businessFeatureChatFolderTags *BusinessFeatureChatFolderTags) GetBusinessFeatureEnum() BusinessFeatureEnum {
	return BusinessFeatureChatFolderTagsType
}

// BusinessFeatureUpgradedStories Allowed to use many additional features for stories
type BusinessFeatureUpgradedStories struct {
	tdCommon
}

// MessageType return the string telegram-type of BusinessFeatureUpgradedStories
func (businessFeatureUpgradedStories *BusinessFeatureUpgradedStories) MessageType() string {
	return "businessFeatureUpgradedStories"
}

// NewBusinessFeatureUpgradedStories creates a new BusinessFeatureUpgradedStories
//
func NewBusinessFeatureUpgradedStories() *BusinessFeatureUpgradedStories {
	businessFeatureUpgradedStoriesTemp := BusinessFeatureUpgradedStories{
		tdCommon: tdCommon{Type: "businessFeatureUpgradedStories"},
	}

	return &businessFeatureUpgradedStoriesTemp
}

// UnmarshalJSON unmarshal to json
func (businessFeatureUpgradedStories *BusinessFeatureUpgradedStories) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessFeatureUpgradedStories.tdCommon = tempObj.tdCommon

	return nil
}

// GetBusinessFeatureEnum return the enum type of this object
func (businessFeatureUpgradedStories *BusinessFeatureUpgradedStories) GetBusinessFeatureEnum() BusinessFeatureEnum {
	return BusinessFeatureUpgradedStoriesType
}

// PremiumStoryFeaturePriorityOrder Stories of the current user are displayed before stories of non-Premium contacts, supergroups, and channels
type PremiumStoryFeaturePriorityOrder struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumStoryFeaturePriorityOrder
func (premiumStoryFeaturePriorityOrder *PremiumStoryFeaturePriorityOrder) MessageType() string {
	return "premiumStoryFeaturePriorityOrder"
}

// NewPremiumStoryFeaturePriorityOrder creates a new PremiumStoryFeaturePriorityOrder
//
func NewPremiumStoryFeaturePriorityOrder() *PremiumStoryFeaturePriorityOrder {
	premiumStoryFeaturePriorityOrderTemp := PremiumStoryFeaturePriorityOrder{
		tdCommon: tdCommon{Type: "premiumStoryFeaturePriorityOrder"},
	}

	return &premiumStoryFeaturePriorityOrderTemp
}

// UnmarshalJSON unmarshal to json
func (premiumStoryFeaturePriorityOrder *PremiumStoryFeaturePriorityOrder) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumStoryFeaturePriorityOrder.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumStoryFeatureEnum return the enum type of this object
func (premiumStoryFeaturePriorityOrder *PremiumStoryFeaturePriorityOrder) GetPremiumStoryFeatureEnum() PremiumStoryFeatureEnum {
	return PremiumStoryFeaturePriorityOrderType
}

// PremiumStoryFeatureStealthMode The ability to hide the fact that the user viewed other's stories
type PremiumStoryFeatureStealthMode struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumStoryFeatureStealthMode
func (premiumStoryFeatureStealthMode *PremiumStoryFeatureStealthMode) MessageType() string {
	return "premiumStoryFeatureStealthMode"
}

// NewPremiumStoryFeatureStealthMode creates a new PremiumStoryFeatureStealthMode
//
func NewPremiumStoryFeatureStealthMode() *PremiumStoryFeatureStealthMode {
	premiumStoryFeatureStealthModeTemp := PremiumStoryFeatureStealthMode{
		tdCommon: tdCommon{Type: "premiumStoryFeatureStealthMode"},
	}

	return &premiumStoryFeatureStealthModeTemp
}

// UnmarshalJSON unmarshal to json
func (premiumStoryFeatureStealthMode *PremiumStoryFeatureStealthMode) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumStoryFeatureStealthMode.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumStoryFeatureEnum return the enum type of this object
func (premiumStoryFeatureStealthMode *PremiumStoryFeatureStealthMode) GetPremiumStoryFeatureEnum() PremiumStoryFeatureEnum {
	return PremiumStoryFeatureStealthModeType
}

// PremiumStoryFeaturePermanentViewsHistory The ability to check who opened the current user's stories after they expire
type PremiumStoryFeaturePermanentViewsHistory struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumStoryFeaturePermanentViewsHistory
func (premiumStoryFeaturePermanentViewsHistory *PremiumStoryFeaturePermanentViewsHistory) MessageType() string {
	return "premiumStoryFeaturePermanentViewsHistory"
}

// NewPremiumStoryFeaturePermanentViewsHistory creates a new PremiumStoryFeaturePermanentViewsHistory
//
func NewPremiumStoryFeaturePermanentViewsHistory() *PremiumStoryFeaturePermanentViewsHistory {
	premiumStoryFeaturePermanentViewsHistoryTemp := PremiumStoryFeaturePermanentViewsHistory{
		tdCommon: tdCommon{Type: "premiumStoryFeaturePermanentViewsHistory"},
	}

	return &premiumStoryFeaturePermanentViewsHistoryTemp
}

// UnmarshalJSON unmarshal to json
func (premiumStoryFeaturePermanentViewsHistory *PremiumStoryFeaturePermanentViewsHistory) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumStoryFeaturePermanentViewsHistory.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumStoryFeatureEnum return the enum type of this object
func (premiumStoryFeaturePermanentViewsHistory *PremiumStoryFeaturePermanentViewsHistory) GetPremiumStoryFeatureEnum() PremiumStoryFeatureEnum {
	return PremiumStoryFeaturePermanentViewsHistoryType
}

// PremiumStoryFeatureCustomExpirationDuration The ability to set custom expiration duration for stories
type PremiumStoryFeatureCustomExpirationDuration struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumStoryFeatureCustomExpirationDuration
func (premiumStoryFeatureCustomExpirationDuration *PremiumStoryFeatureCustomExpirationDuration) MessageType() string {
	return "premiumStoryFeatureCustomExpirationDuration"
}

// NewPremiumStoryFeatureCustomExpirationDuration creates a new PremiumStoryFeatureCustomExpirationDuration
//
func NewPremiumStoryFeatureCustomExpirationDuration() *PremiumStoryFeatureCustomExpirationDuration {
	premiumStoryFeatureCustomExpirationDurationTemp := PremiumStoryFeatureCustomExpirationDuration{
		tdCommon: tdCommon{Type: "premiumStoryFeatureCustomExpirationDuration"},
	}

	return &premiumStoryFeatureCustomExpirationDurationTemp
}

// UnmarshalJSON unmarshal to json
func (premiumStoryFeatureCustomExpirationDuration *PremiumStoryFeatureCustomExpirationDuration) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumStoryFeatureCustomExpirationDuration.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumStoryFeatureEnum return the enum type of this object
func (premiumStoryFeatureCustomExpirationDuration *PremiumStoryFeatureCustomExpirationDuration) GetPremiumStoryFeatureEnum() PremiumStoryFeatureEnum {
	return PremiumStoryFeatureCustomExpirationDurationType
}

// PremiumStoryFeatureSaveStories The ability to save other's unprotected stories
type PremiumStoryFeatureSaveStories struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumStoryFeatureSaveStories
func (premiumStoryFeatureSaveStories *PremiumStoryFeatureSaveStories) MessageType() string {
	return "premiumStoryFeatureSaveStories"
}

// NewPremiumStoryFeatureSaveStories creates a new PremiumStoryFeatureSaveStories
//
func NewPremiumStoryFeatureSaveStories() *PremiumStoryFeatureSaveStories {
	premiumStoryFeatureSaveStoriesTemp := PremiumStoryFeatureSaveStories{
		tdCommon: tdCommon{Type: "premiumStoryFeatureSaveStories"},
	}

	return &premiumStoryFeatureSaveStoriesTemp
}

// UnmarshalJSON unmarshal to json
func (premiumStoryFeatureSaveStories *PremiumStoryFeatureSaveStories) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumStoryFeatureSaveStories.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumStoryFeatureEnum return the enum type of this object
func (premiumStoryFeatureSaveStories *PremiumStoryFeatureSaveStories) GetPremiumStoryFeatureEnum() PremiumStoryFeatureEnum {
	return PremiumStoryFeatureSaveStoriesType
}

// PremiumStoryFeatureLinksAndFormatting The ability to use links and formatting in story caption, and use inputStoryAreaTypeLink areas
type PremiumStoryFeatureLinksAndFormatting struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumStoryFeatureLinksAndFormatting
func (premiumStoryFeatureLinksAndFormatting *PremiumStoryFeatureLinksAndFormatting) MessageType() string {
	return "premiumStoryFeatureLinksAndFormatting"
}

// NewPremiumStoryFeatureLinksAndFormatting creates a new PremiumStoryFeatureLinksAndFormatting
//
func NewPremiumStoryFeatureLinksAndFormatting() *PremiumStoryFeatureLinksAndFormatting {
	premiumStoryFeatureLinksAndFormattingTemp := PremiumStoryFeatureLinksAndFormatting{
		tdCommon: tdCommon{Type: "premiumStoryFeatureLinksAndFormatting"},
	}

	return &premiumStoryFeatureLinksAndFormattingTemp
}

// UnmarshalJSON unmarshal to json
func (premiumStoryFeatureLinksAndFormatting *PremiumStoryFeatureLinksAndFormatting) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumStoryFeatureLinksAndFormatting.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumStoryFeatureEnum return the enum type of this object
func (premiumStoryFeatureLinksAndFormatting *PremiumStoryFeatureLinksAndFormatting) GetPremiumStoryFeatureEnum() PremiumStoryFeatureEnum {
	return PremiumStoryFeatureLinksAndFormattingType
}

// PremiumStoryFeatureVideoQuality The ability to choose better quality for viewed stories
type PremiumStoryFeatureVideoQuality struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumStoryFeatureVideoQuality
func (premiumStoryFeatureVideoQuality *PremiumStoryFeatureVideoQuality) MessageType() string {
	return "premiumStoryFeatureVideoQuality"
}

// NewPremiumStoryFeatureVideoQuality creates a new PremiumStoryFeatureVideoQuality
//
func NewPremiumStoryFeatureVideoQuality() *PremiumStoryFeatureVideoQuality {
	premiumStoryFeatureVideoQualityTemp := PremiumStoryFeatureVideoQuality{
		tdCommon: tdCommon{Type: "premiumStoryFeatureVideoQuality"},
	}

	return &premiumStoryFeatureVideoQualityTemp
}

// UnmarshalJSON unmarshal to json
func (premiumStoryFeatureVideoQuality *PremiumStoryFeatureVideoQuality) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumStoryFeatureVideoQuality.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumStoryFeatureEnum return the enum type of this object
func (premiumStoryFeatureVideoQuality *PremiumStoryFeatureVideoQuality) GetPremiumStoryFeatureEnum() PremiumStoryFeatureEnum {
	return PremiumStoryFeatureVideoQualityType
}

// PremiumLimit Contains information about a limit, increased for Premium users
type PremiumLimit struct {
	tdCommon
	Type         PremiumLimitType `json:"type"`          // The type of the limit
	DefaultValue int32            `json:"default_value"` // Default value of the limit
	PremiumValue int32            `json:"premium_value"` // Value of the limit for Premium users
}

// MessageType return the string telegram-type of PremiumLimit
func (premiumLimit *PremiumLimit) MessageType() string {
	return "premiumLimit"
}

// NewPremiumLimit creates a new PremiumLimit
//
// @param typeParam The type of the limit
// @param defaultValue Default value of the limit
// @param premiumValue Value of the limit for Premium users
func NewPremiumLimit(typeParam PremiumLimitType, defaultValue int32, premiumValue int32) *PremiumLimit {
	premiumLimitTemp := PremiumLimit{
		tdCommon:     tdCommon{Type: "premiumLimit"},
		Type:         typeParam,
		DefaultValue: defaultValue,
		PremiumValue: premiumValue,
	}

	return &premiumLimitTemp
}

// UnmarshalJSON unmarshal to json
func (premiumLimit *PremiumLimit) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		DefaultValue int32 `json:"default_value"` // Default value of the limit
		PremiumValue int32 `json:"premium_value"` // Value of the limit for Premium users
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumLimit.tdCommon = tempObj.tdCommon
	premiumLimit.DefaultValue = tempObj.DefaultValue
	premiumLimit.PremiumValue = tempObj.PremiumValue

	fieldType, _ := unmarshalPremiumLimitType(objMap["type"])
	premiumLimit.Type = fieldType

	return nil
}

// PremiumFeatures Contains information about features, available to Premium users
type PremiumFeatures struct {
	tdCommon
	Features    []PremiumFeature  `json:"features"`     // The list of available features
	Limits      []PremiumLimit    `json:"limits"`       // The list of limits, increased for Premium users
	PaymentLink *InternalLinkType `json:"payment_link"` // An internal link to be opened to pay for Telegram Premium if store payment isn't possible; may be null if direct payment isn't available
}

// MessageType return the string telegram-type of PremiumFeatures
func (premiumFeatures *PremiumFeatures) MessageType() string {
	return "premiumFeatures"
}

// NewPremiumFeatures creates a new PremiumFeatures
//
// @param features The list of available features
// @param limits The list of limits, increased for Premium users
// @param paymentLink An internal link to be opened to pay for Telegram Premium if store payment isn't possible; may be null if direct payment isn't available
func NewPremiumFeatures(features []PremiumFeature, limits []PremiumLimit, paymentLink *InternalLinkType) *PremiumFeatures {
	premiumFeaturesTemp := PremiumFeatures{
		tdCommon:    tdCommon{Type: "premiumFeatures"},
		Features:    features,
		Limits:      limits,
		PaymentLink: paymentLink,
	}

	return &premiumFeaturesTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeatures *PremiumFeatures) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Limits []PremiumLimit `json:"limits"` // The list of limits, increased for Premium users

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeatures.tdCommon = tempObj.tdCommon
	premiumFeatures.Limits = tempObj.Limits

	fieldPaymentLink, _ := unmarshalInternalLinkType(objMap["payment_link"])
	premiumFeatures.PaymentLink = &fieldPaymentLink

	fieldFeatures, _ := unmarshalPremiumFeatureSlice(objMap["features"])
	premiumFeatures.Features = fieldFeatures

	return nil
}

// BusinessFeatures Contains information about features, available to Business user accounts
type BusinessFeatures struct {
	tdCommon
	Features []BusinessFeature `json:"features"` // The list of available business features
}

// MessageType return the string telegram-type of BusinessFeatures
func (businessFeatures *BusinessFeatures) MessageType() string {
	return "businessFeatures"
}

// NewBusinessFeatures creates a new BusinessFeatures
//
// @param features The list of available business features
func NewBusinessFeatures(features []BusinessFeature) *BusinessFeatures {
	businessFeaturesTemp := BusinessFeatures{
		tdCommon: tdCommon{Type: "businessFeatures"},
		Features: features,
	}

	return &businessFeaturesTemp
}

// UnmarshalJSON unmarshal to json
func (businessFeatures *BusinessFeatures) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessFeatures.tdCommon = tempObj.tdCommon

	fieldFeatures, _ := unmarshalBusinessFeatureSlice(objMap["features"])
	businessFeatures.Features = fieldFeatures

	return nil
}

// PremiumSourceLimitExceeded A limit was exceeded
type PremiumSourceLimitExceeded struct {
	tdCommon
	LimitType PremiumLimitType `json:"limit_type"` // Type of the exceeded limit
}

// MessageType return the string telegram-type of PremiumSourceLimitExceeded
func (premiumSourceLimitExceeded *PremiumSourceLimitExceeded) MessageType() string {
	return "premiumSourceLimitExceeded"
}

// NewPremiumSourceLimitExceeded creates a new PremiumSourceLimitExceeded
//
// @param limitType Type of the exceeded limit
func NewPremiumSourceLimitExceeded(limitType PremiumLimitType) *PremiumSourceLimitExceeded {
	premiumSourceLimitExceededTemp := PremiumSourceLimitExceeded{
		tdCommon:  tdCommon{Type: "premiumSourceLimitExceeded"},
		LimitType: limitType,
	}

	return &premiumSourceLimitExceededTemp
}

// UnmarshalJSON unmarshal to json
func (premiumSourceLimitExceeded *PremiumSourceLimitExceeded) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumSourceLimitExceeded.tdCommon = tempObj.tdCommon

	fieldLimitType, _ := unmarshalPremiumLimitType(objMap["limit_type"])
	premiumSourceLimitExceeded.LimitType = fieldLimitType

	return nil
}

// GetPremiumSourceEnum return the enum type of this object
func (premiumSourceLimitExceeded *PremiumSourceLimitExceeded) GetPremiumSourceEnum() PremiumSourceEnum {
	return PremiumSourceLimitExceededType
}

// PremiumSourceFeature A user tried to use a Premium feature
type PremiumSourceFeature struct {
	tdCommon
	Feature PremiumFeature `json:"feature"` // The used feature
}

// MessageType return the string telegram-type of PremiumSourceFeature
func (premiumSourceFeature *PremiumSourceFeature) MessageType() string {
	return "premiumSourceFeature"
}

// NewPremiumSourceFeature creates a new PremiumSourceFeature
//
// @param feature The used feature
func NewPremiumSourceFeature(feature PremiumFeature) *PremiumSourceFeature {
	premiumSourceFeatureTemp := PremiumSourceFeature{
		tdCommon: tdCommon{Type: "premiumSourceFeature"},
		Feature:  feature,
	}

	return &premiumSourceFeatureTemp
}

// UnmarshalJSON unmarshal to json
func (premiumSourceFeature *PremiumSourceFeature) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumSourceFeature.tdCommon = tempObj.tdCommon

	fieldFeature, _ := unmarshalPremiumFeature(objMap["feature"])
	premiumSourceFeature.Feature = fieldFeature

	return nil
}

// GetPremiumSourceEnum return the enum type of this object
func (premiumSourceFeature *PremiumSourceFeature) GetPremiumSourceEnum() PremiumSourceEnum {
	return PremiumSourceFeatureType
}

// PremiumSourceBusinessFeature A user tried to use a Business feature
type PremiumSourceBusinessFeature struct {
	tdCommon
	Feature BusinessFeature `json:"feature"` // The used feature; pass null if none specific feature was used
}

// MessageType return the string telegram-type of PremiumSourceBusinessFeature
func (premiumSourceBusinessFeature *PremiumSourceBusinessFeature) MessageType() string {
	return "premiumSourceBusinessFeature"
}

// NewPremiumSourceBusinessFeature creates a new PremiumSourceBusinessFeature
//
// @param feature The used feature; pass null if none specific feature was used
func NewPremiumSourceBusinessFeature(feature BusinessFeature) *PremiumSourceBusinessFeature {
	premiumSourceBusinessFeatureTemp := PremiumSourceBusinessFeature{
		tdCommon: tdCommon{Type: "premiumSourceBusinessFeature"},
		Feature:  feature,
	}

	return &premiumSourceBusinessFeatureTemp
}

// UnmarshalJSON unmarshal to json
func (premiumSourceBusinessFeature *PremiumSourceBusinessFeature) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumSourceBusinessFeature.tdCommon = tempObj.tdCommon

	fieldFeature, _ := unmarshalBusinessFeature(objMap["feature"])
	premiumSourceBusinessFeature.Feature = fieldFeature

	return nil
}

// GetPremiumSourceEnum return the enum type of this object
func (premiumSourceBusinessFeature *PremiumSourceBusinessFeature) GetPremiumSourceEnum() PremiumSourceEnum {
	return PremiumSourceBusinessFeatureType
}

// PremiumSourceStoryFeature A user tried to use a Premium story feature
type PremiumSourceStoryFeature struct {
	tdCommon
	Feature PremiumStoryFeature `json:"feature"` // The used feature
}

// MessageType return the string telegram-type of PremiumSourceStoryFeature
func (premiumSourceStoryFeature *PremiumSourceStoryFeature) MessageType() string {
	return "premiumSourceStoryFeature"
}

// NewPremiumSourceStoryFeature creates a new PremiumSourceStoryFeature
//
// @param feature The used feature
func NewPremiumSourceStoryFeature(feature PremiumStoryFeature) *PremiumSourceStoryFeature {
	premiumSourceStoryFeatureTemp := PremiumSourceStoryFeature{
		tdCommon: tdCommon{Type: "premiumSourceStoryFeature"},
		Feature:  feature,
	}

	return &premiumSourceStoryFeatureTemp
}

// UnmarshalJSON unmarshal to json
func (premiumSourceStoryFeature *PremiumSourceStoryFeature) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumSourceStoryFeature.tdCommon = tempObj.tdCommon

	fieldFeature, _ := unmarshalPremiumStoryFeature(objMap["feature"])
	premiumSourceStoryFeature.Feature = fieldFeature

	return nil
}

// GetPremiumSourceEnum return the enum type of this object
func (premiumSourceStoryFeature *PremiumSourceStoryFeature) GetPremiumSourceEnum() PremiumSourceEnum {
	return PremiumSourceStoryFeatureType
}

// PremiumSourceLink A user opened an internal link of the type internalLinkTypePremiumFeatures
type PremiumSourceLink struct {
	tdCommon
	Referrer string `json:"referrer"` // The referrer from the link
}

// MessageType return the string telegram-type of PremiumSourceLink
func (premiumSourceLink *PremiumSourceLink) MessageType() string {
	return "premiumSourceLink"
}

// NewPremiumSourceLink creates a new PremiumSourceLink
//
// @param referrer The referrer from the link
func NewPremiumSourceLink(referrer string) *PremiumSourceLink {
	premiumSourceLinkTemp := PremiumSourceLink{
		tdCommon: tdCommon{Type: "premiumSourceLink"},
		Referrer: referrer,
	}

	return &premiumSourceLinkTemp
}

// UnmarshalJSON unmarshal to json
func (premiumSourceLink *PremiumSourceLink) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Referrer string `json:"referrer"` // The referrer from the link
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumSourceLink.tdCommon = tempObj.tdCommon
	premiumSourceLink.Referrer = tempObj.Referrer

	return nil
}

// GetPremiumSourceEnum return the enum type of this object
func (premiumSourceLink *PremiumSourceLink) GetPremiumSourceEnum() PremiumSourceEnum {
	return PremiumSourceLinkType
}

// PremiumSourceSettings A user opened the Premium features screen from settings
type PremiumSourceSettings struct {
	tdCommon
}

// MessageType return the string telegram-type of PremiumSourceSettings
func (premiumSourceSettings *PremiumSourceSettings) MessageType() string {
	return "premiumSourceSettings"
}

// NewPremiumSourceSettings creates a new PremiumSourceSettings
//
func NewPremiumSourceSettings() *PremiumSourceSettings {
	premiumSourceSettingsTemp := PremiumSourceSettings{
		tdCommon: tdCommon{Type: "premiumSourceSettings"},
	}

	return &premiumSourceSettingsTemp
}

// UnmarshalJSON unmarshal to json
func (premiumSourceSettings *PremiumSourceSettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumSourceSettings.tdCommon = tempObj.tdCommon

	return nil
}

// GetPremiumSourceEnum return the enum type of this object
func (premiumSourceSettings *PremiumSourceSettings) GetPremiumSourceEnum() PremiumSourceEnum {
	return PremiumSourceSettingsType
}

// PremiumFeaturePromotionAnimation Describes a promotion animation for a Premium feature
type PremiumFeaturePromotionAnimation struct {
	tdCommon
	Feature   PremiumFeature `json:"feature"`   // Premium feature
	Animation *Animation     `json:"animation"` // Promotion animation for the feature
}

// MessageType return the string telegram-type of PremiumFeaturePromotionAnimation
func (premiumFeaturePromotionAnimation *PremiumFeaturePromotionAnimation) MessageType() string {
	return "premiumFeaturePromotionAnimation"
}

// NewPremiumFeaturePromotionAnimation creates a new PremiumFeaturePromotionAnimation
//
// @param feature Premium feature
// @param animation Promotion animation for the feature
func NewPremiumFeaturePromotionAnimation(feature PremiumFeature, animation *Animation) *PremiumFeaturePromotionAnimation {
	premiumFeaturePromotionAnimationTemp := PremiumFeaturePromotionAnimation{
		tdCommon:  tdCommon{Type: "premiumFeaturePromotionAnimation"},
		Feature:   feature,
		Animation: animation,
	}

	return &premiumFeaturePromotionAnimationTemp
}

// UnmarshalJSON unmarshal to json
func (premiumFeaturePromotionAnimation *PremiumFeaturePromotionAnimation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Animation *Animation `json:"animation"` // Promotion animation for the feature
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumFeaturePromotionAnimation.tdCommon = tempObj.tdCommon
	premiumFeaturePromotionAnimation.Animation = tempObj.Animation

	fieldFeature, _ := unmarshalPremiumFeature(objMap["feature"])
	premiumFeaturePromotionAnimation.Feature = fieldFeature

	return nil
}

// BusinessFeaturePromotionAnimation Describes a promotion animation for a Business feature
type BusinessFeaturePromotionAnimation struct {
	tdCommon
	Feature   BusinessFeature `json:"feature"`   // Business feature
	Animation *Animation      `json:"animation"` // Promotion animation for the feature
}

// MessageType return the string telegram-type of BusinessFeaturePromotionAnimation
func (businessFeaturePromotionAnimation *BusinessFeaturePromotionAnimation) MessageType() string {
	return "businessFeaturePromotionAnimation"
}

// NewBusinessFeaturePromotionAnimation creates a new BusinessFeaturePromotionAnimation
//
// @param feature Business feature
// @param animation Promotion animation for the feature
func NewBusinessFeaturePromotionAnimation(feature BusinessFeature, animation *Animation) *BusinessFeaturePromotionAnimation {
	businessFeaturePromotionAnimationTemp := BusinessFeaturePromotionAnimation{
		tdCommon:  tdCommon{Type: "businessFeaturePromotionAnimation"},
		Feature:   feature,
		Animation: animation,
	}

	return &businessFeaturePromotionAnimationTemp
}

// UnmarshalJSON unmarshal to json
func (businessFeaturePromotionAnimation *BusinessFeaturePromotionAnimation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Animation *Animation `json:"animation"` // Promotion animation for the feature
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	businessFeaturePromotionAnimation.tdCommon = tempObj.tdCommon
	businessFeaturePromotionAnimation.Animation = tempObj.Animation

	fieldFeature, _ := unmarshalBusinessFeature(objMap["feature"])
	businessFeaturePromotionAnimation.Feature = fieldFeature

	return nil
}

// PremiumState Contains state of Telegram Premium subscription and promotion videos for Premium features
type PremiumState struct {
	tdCommon
	State              *FormattedText                      `json:"state"`               // Text description of the state of the current Premium subscription; may be empty if the current user has no Telegram Premium subscription
	PaymentOptions     []PremiumStatePaymentOption         `json:"payment_options"`     // The list of available options for buying Telegram Premium
	Animations         []PremiumFeaturePromotionAnimation  `json:"animations"`          // The list of available promotion animations for Premium features
	BusinessAnimations []BusinessFeaturePromotionAnimation `json:"business_animations"` // The list of available promotion animations for Business features
}

// MessageType return the string telegram-type of PremiumState
func (premiumState *PremiumState) MessageType() string {
	return "premiumState"
}

// NewPremiumState creates a new PremiumState
//
// @param state Text description of the state of the current Premium subscription; may be empty if the current user has no Telegram Premium subscription
// @param paymentOptions The list of available options for buying Telegram Premium
// @param animations The list of available promotion animations for Premium features
// @param businessAnimations The list of available promotion animations for Business features
func NewPremiumState(state *FormattedText, paymentOptions []PremiumStatePaymentOption, animations []PremiumFeaturePromotionAnimation, businessAnimations []BusinessFeaturePromotionAnimation) *PremiumState {
	premiumStateTemp := PremiumState{
		tdCommon:           tdCommon{Type: "premiumState"},
		State:              state,
		PaymentOptions:     paymentOptions,
		Animations:         animations,
		BusinessAnimations: businessAnimations,
	}

	return &premiumStateTemp
}

// UnmarshalJSON unmarshal to json
func (premiumState *PremiumState) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		State              *FormattedText                      `json:"state"`               // Text description of the state of the current Premium subscription; may be empty if the current user has no Telegram Premium subscription
		PaymentOptions     []PremiumStatePaymentOption         `json:"payment_options"`     // The list of available options for buying Telegram Premium
		Animations         []PremiumFeaturePromotionAnimation  `json:"animations"`          // The list of available promotion animations for Premium features
		BusinessAnimations []BusinessFeaturePromotionAnimation `json:"business_animations"` // The list of available promotion animations for Business features
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	premiumState.tdCommon = tempObj.tdCommon
	premiumState.State = tempObj.State
	premiumState.PaymentOptions = tempObj.PaymentOptions
	premiumState.Animations = tempObj.Animations
	premiumState.BusinessAnimations = tempObj.BusinessAnimations

	return nil
}

// StorePaymentPurposePremiumSubscription The user subscribing to Telegram Premium
type StorePaymentPurposePremiumSubscription struct {
	tdCommon
	IsRestore bool `json:"is_restore"` // Pass true if this is a restore of a Telegram Premium purchase; only for App Store
	IsUpgrade bool `json:"is_upgrade"` // Pass true if this is an upgrade from a monthly subscription to early subscription; only for App Store
}

// MessageType return the string telegram-type of StorePaymentPurposePremiumSubscription
func (storePaymentPurposePremiumSubscription *StorePaymentPurposePremiumSubscription) MessageType() string {
	return "storePaymentPurposePremiumSubscription"
}

// NewStorePaymentPurposePremiumSubscription creates a new StorePaymentPurposePremiumSubscription
//
// @param isRestore Pass true if this is a restore of a Telegram Premium purchase; only for App Store
// @param isUpgrade Pass true if this is an upgrade from a monthly subscription to early subscription; only for App Store
func NewStorePaymentPurposePremiumSubscription(isRestore bool, isUpgrade bool) *StorePaymentPurposePremiumSubscription {
	storePaymentPurposePremiumSubscriptionTemp := StorePaymentPurposePremiumSubscription{
		tdCommon:  tdCommon{Type: "storePaymentPurposePremiumSubscription"},
		IsRestore: isRestore,
		IsUpgrade: isUpgrade,
	}

	return &storePaymentPurposePremiumSubscriptionTemp
}

// UnmarshalJSON unmarshal to json
func (storePaymentPurposePremiumSubscription *StorePaymentPurposePremiumSubscription) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsRestore bool `json:"is_restore"` // Pass true if this is a restore of a Telegram Premium purchase; only for App Store
		IsUpgrade bool `json:"is_upgrade"` // Pass true if this is an upgrade from a monthly subscription to early subscription; only for App Store
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storePaymentPurposePremiumSubscription.tdCommon = tempObj.tdCommon
	storePaymentPurposePremiumSubscription.IsRestore = tempObj.IsRestore
	storePaymentPurposePremiumSubscription.IsUpgrade = tempObj.IsUpgrade

	return nil
}

// GetStorePaymentPurposeEnum return the enum type of this object
func (storePaymentPurposePremiumSubscription *StorePaymentPurposePremiumSubscription) GetStorePaymentPurposeEnum() StorePaymentPurposeEnum {
	return StorePaymentPurposePremiumSubscriptionType
}

// StorePaymentPurposeGiftedPremium The user gifting Telegram Premium to another user
type StorePaymentPurposeGiftedPremium struct {
	tdCommon
	UserID   int64  `json:"user_id"`  // Identifier of the user to which Telegram Premium is gifted
	Currency string `json:"currency"` // ISO 4217 currency code of the payment currency
	Amount   int64  `json:"amount"`   // Paid amount, in the smallest units of the currency
}

// MessageType return the string telegram-type of StorePaymentPurposeGiftedPremium
func (storePaymentPurposeGiftedPremium *StorePaymentPurposeGiftedPremium) MessageType() string {
	return "storePaymentPurposeGiftedPremium"
}

// NewStorePaymentPurposeGiftedPremium creates a new StorePaymentPurposeGiftedPremium
//
// @param userID Identifier of the user to which Telegram Premium is gifted
// @param currency ISO 4217 currency code of the payment currency
// @param amount Paid amount, in the smallest units of the currency
func NewStorePaymentPurposeGiftedPremium(userID int64, currency string, amount int64) *StorePaymentPurposeGiftedPremium {
	storePaymentPurposeGiftedPremiumTemp := StorePaymentPurposeGiftedPremium{
		tdCommon: tdCommon{Type: "storePaymentPurposeGiftedPremium"},
		UserID:   userID,
		Currency: currency,
		Amount:   amount,
	}

	return &storePaymentPurposeGiftedPremiumTemp
}

// UnmarshalJSON unmarshal to json
func (storePaymentPurposeGiftedPremium *StorePaymentPurposeGiftedPremium) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID   int64  `json:"user_id"`  // Identifier of the user to which Telegram Premium is gifted
		Currency string `json:"currency"` // ISO 4217 currency code of the payment currency
		Amount   int64  `json:"amount"`   // Paid amount, in the smallest units of the currency
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storePaymentPurposeGiftedPremium.tdCommon = tempObj.tdCommon
	storePaymentPurposeGiftedPremium.UserID = tempObj.UserID
	storePaymentPurposeGiftedPremium.Currency = tempObj.Currency
	storePaymentPurposeGiftedPremium.Amount = tempObj.Amount

	return nil
}

// GetStorePaymentPurposeEnum return the enum type of this object
func (storePaymentPurposeGiftedPremium *StorePaymentPurposeGiftedPremium) GetStorePaymentPurposeEnum() StorePaymentPurposeEnum {
	return StorePaymentPurposeGiftedPremiumType
}

// StorePaymentPurposePremiumGiftCodes The user creating Telegram Premium gift codes for other users
type StorePaymentPurposePremiumGiftCodes struct {
	tdCommon
	BoostedChatID int64   `json:"boosted_chat_id"` // Identifier of the supergroup or channel chat, which will be automatically boosted by the users for duration of the Premium subscription and which is administered by the user; 0 if none
	Currency      string  `json:"currency"`        // ISO 4217 currency code of the payment currency
	Amount        int64   `json:"amount"`          // Paid amount, in the smallest units of the currency
	UserIDs       []int64 `json:"user_ids"`        // Identifiers of the users which can activate the gift codes
}

// MessageType return the string telegram-type of StorePaymentPurposePremiumGiftCodes
func (storePaymentPurposePremiumGiftCodes *StorePaymentPurposePremiumGiftCodes) MessageType() string {
	return "storePaymentPurposePremiumGiftCodes"
}

// NewStorePaymentPurposePremiumGiftCodes creates a new StorePaymentPurposePremiumGiftCodes
//
// @param boostedChatID Identifier of the supergroup or channel chat, which will be automatically boosted by the users for duration of the Premium subscription and which is administered by the user; 0 if none
// @param currency ISO 4217 currency code of the payment currency
// @param amount Paid amount, in the smallest units of the currency
// @param userIDs Identifiers of the users which can activate the gift codes
func NewStorePaymentPurposePremiumGiftCodes(boostedChatID int64, currency string, amount int64, userIDs []int64) *StorePaymentPurposePremiumGiftCodes {
	storePaymentPurposePremiumGiftCodesTemp := StorePaymentPurposePremiumGiftCodes{
		tdCommon:      tdCommon{Type: "storePaymentPurposePremiumGiftCodes"},
		BoostedChatID: boostedChatID,
		Currency:      currency,
		Amount:        amount,
		UserIDs:       userIDs,
	}

	return &storePaymentPurposePremiumGiftCodesTemp
}

// UnmarshalJSON unmarshal to json
func (storePaymentPurposePremiumGiftCodes *StorePaymentPurposePremiumGiftCodes) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BoostedChatID int64   `json:"boosted_chat_id"` // Identifier of the supergroup or channel chat, which will be automatically boosted by the users for duration of the Premium subscription and which is administered by the user; 0 if none
		Currency      string  `json:"currency"`        // ISO 4217 currency code of the payment currency
		Amount        int64   `json:"amount"`          // Paid amount, in the smallest units of the currency
		UserIDs       []int64 `json:"user_ids"`        // Identifiers of the users which can activate the gift codes
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storePaymentPurposePremiumGiftCodes.tdCommon = tempObj.tdCommon
	storePaymentPurposePremiumGiftCodes.BoostedChatID = tempObj.BoostedChatID
	storePaymentPurposePremiumGiftCodes.Currency = tempObj.Currency
	storePaymentPurposePremiumGiftCodes.Amount = tempObj.Amount
	storePaymentPurposePremiumGiftCodes.UserIDs = tempObj.UserIDs

	return nil
}

// GetStorePaymentPurposeEnum return the enum type of this object
func (storePaymentPurposePremiumGiftCodes *StorePaymentPurposePremiumGiftCodes) GetStorePaymentPurposeEnum() StorePaymentPurposeEnum {
	return StorePaymentPurposePremiumGiftCodesType
}

// StorePaymentPurposePremiumGiveaway The user creating a Telegram Premium giveaway
type StorePaymentPurposePremiumGiveaway struct {
	tdCommon
	Parameters *GiveawayParameters `json:"parameters"` // Giveaway parameters
	Currency   string              `json:"currency"`   // ISO 4217 currency code of the payment currency
	Amount     int64               `json:"amount"`     // Paid amount, in the smallest units of the currency
}

// MessageType return the string telegram-type of StorePaymentPurposePremiumGiveaway
func (storePaymentPurposePremiumGiveaway *StorePaymentPurposePremiumGiveaway) MessageType() string {
	return "storePaymentPurposePremiumGiveaway"
}

// NewStorePaymentPurposePremiumGiveaway creates a new StorePaymentPurposePremiumGiveaway
//
// @param parameters Giveaway parameters
// @param currency ISO 4217 currency code of the payment currency
// @param amount Paid amount, in the smallest units of the currency
func NewStorePaymentPurposePremiumGiveaway(parameters *GiveawayParameters, currency string, amount int64) *StorePaymentPurposePremiumGiveaway {
	storePaymentPurposePremiumGiveawayTemp := StorePaymentPurposePremiumGiveaway{
		tdCommon:   tdCommon{Type: "storePaymentPurposePremiumGiveaway"},
		Parameters: parameters,
		Currency:   currency,
		Amount:     amount,
	}

	return &storePaymentPurposePremiumGiveawayTemp
}

// UnmarshalJSON unmarshal to json
func (storePaymentPurposePremiumGiveaway *StorePaymentPurposePremiumGiveaway) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Parameters *GiveawayParameters `json:"parameters"` // Giveaway parameters
		Currency   string              `json:"currency"`   // ISO 4217 currency code of the payment currency
		Amount     int64               `json:"amount"`     // Paid amount, in the smallest units of the currency
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storePaymentPurposePremiumGiveaway.tdCommon = tempObj.tdCommon
	storePaymentPurposePremiumGiveaway.Parameters = tempObj.Parameters
	storePaymentPurposePremiumGiveaway.Currency = tempObj.Currency
	storePaymentPurposePremiumGiveaway.Amount = tempObj.Amount

	return nil
}

// GetStorePaymentPurposeEnum return the enum type of this object
func (storePaymentPurposePremiumGiveaway *StorePaymentPurposePremiumGiveaway) GetStorePaymentPurposeEnum() StorePaymentPurposeEnum {
	return StorePaymentPurposePremiumGiveawayType
}

// StorePaymentPurposeStarGiveaway The user creating a Telegram Star giveaway
type StorePaymentPurposeStarGiveaway struct {
	tdCommon
	Parameters  *GiveawayParameters `json:"parameters"`   // Giveaway parameters
	Currency    string              `json:"currency"`     // ISO 4217 currency code of the payment currency
	Amount      int64               `json:"amount"`       // Paid amount, in the smallest units of the currency
	WinnerCount int32               `json:"winner_count"` // The number of users to receive Telegram Stars
	StarCount   int64               `json:"star_count"`   // The number of Telegram Stars to be distributed through the giveaway
}

// MessageType return the string telegram-type of StorePaymentPurposeStarGiveaway
func (storePaymentPurposeStarGiveaway *StorePaymentPurposeStarGiveaway) MessageType() string {
	return "storePaymentPurposeStarGiveaway"
}

// NewStorePaymentPurposeStarGiveaway creates a new StorePaymentPurposeStarGiveaway
//
// @param parameters Giveaway parameters
// @param currency ISO 4217 currency code of the payment currency
// @param amount Paid amount, in the smallest units of the currency
// @param winnerCount The number of users to receive Telegram Stars
// @param starCount The number of Telegram Stars to be distributed through the giveaway
func NewStorePaymentPurposeStarGiveaway(parameters *GiveawayParameters, currency string, amount int64, winnerCount int32, starCount int64) *StorePaymentPurposeStarGiveaway {
	storePaymentPurposeStarGiveawayTemp := StorePaymentPurposeStarGiveaway{
		tdCommon:    tdCommon{Type: "storePaymentPurposeStarGiveaway"},
		Parameters:  parameters,
		Currency:    currency,
		Amount:      amount,
		WinnerCount: winnerCount,
		StarCount:   starCount,
	}

	return &storePaymentPurposeStarGiveawayTemp
}

// UnmarshalJSON unmarshal to json
func (storePaymentPurposeStarGiveaway *StorePaymentPurposeStarGiveaway) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Parameters  *GiveawayParameters `json:"parameters"`   // Giveaway parameters
		Currency    string              `json:"currency"`     // ISO 4217 currency code of the payment currency
		Amount      int64               `json:"amount"`       // Paid amount, in the smallest units of the currency
		WinnerCount int32               `json:"winner_count"` // The number of users to receive Telegram Stars
		StarCount   int64               `json:"star_count"`   // The number of Telegram Stars to be distributed through the giveaway
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storePaymentPurposeStarGiveaway.tdCommon = tempObj.tdCommon
	storePaymentPurposeStarGiveaway.Parameters = tempObj.Parameters
	storePaymentPurposeStarGiveaway.Currency = tempObj.Currency
	storePaymentPurposeStarGiveaway.Amount = tempObj.Amount
	storePaymentPurposeStarGiveaway.WinnerCount = tempObj.WinnerCount
	storePaymentPurposeStarGiveaway.StarCount = tempObj.StarCount

	return nil
}

// GetStorePaymentPurposeEnum return the enum type of this object
func (storePaymentPurposeStarGiveaway *StorePaymentPurposeStarGiveaway) GetStorePaymentPurposeEnum() StorePaymentPurposeEnum {
	return StorePaymentPurposeStarGiveawayType
}

// StorePaymentPurposeStars The user buying Telegram Stars
type StorePaymentPurposeStars struct {
	tdCommon
	Currency  string `json:"currency"`   // ISO 4217 currency code of the payment currency
	Amount    int64  `json:"amount"`     // Paid amount, in the smallest units of the currency
	StarCount int64  `json:"star_count"` // Number of bought Telegram Stars
}

// MessageType return the string telegram-type of StorePaymentPurposeStars
func (storePaymentPurposeStars *StorePaymentPurposeStars) MessageType() string {
	return "storePaymentPurposeStars"
}

// NewStorePaymentPurposeStars creates a new StorePaymentPurposeStars
//
// @param currency ISO 4217 currency code of the payment currency
// @param amount Paid amount, in the smallest units of the currency
// @param starCount Number of bought Telegram Stars
func NewStorePaymentPurposeStars(currency string, amount int64, starCount int64) *StorePaymentPurposeStars {
	storePaymentPurposeStarsTemp := StorePaymentPurposeStars{
		tdCommon:  tdCommon{Type: "storePaymentPurposeStars"},
		Currency:  currency,
		Amount:    amount,
		StarCount: starCount,
	}

	return &storePaymentPurposeStarsTemp
}

// UnmarshalJSON unmarshal to json
func (storePaymentPurposeStars *StorePaymentPurposeStars) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Currency  string `json:"currency"`   // ISO 4217 currency code of the payment currency
		Amount    int64  `json:"amount"`     // Paid amount, in the smallest units of the currency
		StarCount int64  `json:"star_count"` // Number of bought Telegram Stars
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storePaymentPurposeStars.tdCommon = tempObj.tdCommon
	storePaymentPurposeStars.Currency = tempObj.Currency
	storePaymentPurposeStars.Amount = tempObj.Amount
	storePaymentPurposeStars.StarCount = tempObj.StarCount

	return nil
}

// GetStorePaymentPurposeEnum return the enum type of this object
func (storePaymentPurposeStars *StorePaymentPurposeStars) GetStorePaymentPurposeEnum() StorePaymentPurposeEnum {
	return StorePaymentPurposeStarsType
}

// StorePaymentPurposeGiftedStars The user buying Telegram Stars for other users
type StorePaymentPurposeGiftedStars struct {
	tdCommon
	UserID    int64  `json:"user_id"`    // Identifier of the user to which Telegram Stars are gifted
	Currency  string `json:"currency"`   // ISO 4217 currency code of the payment currency
	Amount    int64  `json:"amount"`     // Paid amount, in the smallest units of the currency
	StarCount int64  `json:"star_count"` // Number of bought Telegram Stars
}

// MessageType return the string telegram-type of StorePaymentPurposeGiftedStars
func (storePaymentPurposeGiftedStars *StorePaymentPurposeGiftedStars) MessageType() string {
	return "storePaymentPurposeGiftedStars"
}

// NewStorePaymentPurposeGiftedStars creates a new StorePaymentPurposeGiftedStars
//
// @param userID Identifier of the user to which Telegram Stars are gifted
// @param currency ISO 4217 currency code of the payment currency
// @param amount Paid amount, in the smallest units of the currency
// @param starCount Number of bought Telegram Stars
func NewStorePaymentPurposeGiftedStars(userID int64, currency string, amount int64, starCount int64) *StorePaymentPurposeGiftedStars {
	storePaymentPurposeGiftedStarsTemp := StorePaymentPurposeGiftedStars{
		tdCommon:  tdCommon{Type: "storePaymentPurposeGiftedStars"},
		UserID:    userID,
		Currency:  currency,
		Amount:    amount,
		StarCount: starCount,
	}

	return &storePaymentPurposeGiftedStarsTemp
}

// UnmarshalJSON unmarshal to json
func (storePaymentPurposeGiftedStars *StorePaymentPurposeGiftedStars) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID    int64  `json:"user_id"`    // Identifier of the user to which Telegram Stars are gifted
		Currency  string `json:"currency"`   // ISO 4217 currency code of the payment currency
		Amount    int64  `json:"amount"`     // Paid amount, in the smallest units of the currency
		StarCount int64  `json:"star_count"` // Number of bought Telegram Stars
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storePaymentPurposeGiftedStars.tdCommon = tempObj.tdCommon
	storePaymentPurposeGiftedStars.UserID = tempObj.UserID
	storePaymentPurposeGiftedStars.Currency = tempObj.Currency
	storePaymentPurposeGiftedStars.Amount = tempObj.Amount
	storePaymentPurposeGiftedStars.StarCount = tempObj.StarCount

	return nil
}

// GetStorePaymentPurposeEnum return the enum type of this object
func (storePaymentPurposeGiftedStars *StorePaymentPurposeGiftedStars) GetStorePaymentPurposeEnum() StorePaymentPurposeEnum {
	return StorePaymentPurposeGiftedStarsType
}

// TelegramPaymentPurposePremiumGiftCodes The user creating Telegram Premium gift codes for other users
type TelegramPaymentPurposePremiumGiftCodes struct {
	tdCommon
	BoostedChatID int64   `json:"boosted_chat_id"` // Identifier of the supergroup or channel chat, which will be automatically boosted by the users for duration of the Premium subscription and which is administered by the user; 0 if none
	Currency      string  `json:"currency"`        // ISO 4217 currency code of the payment currency
	Amount        int64   `json:"amount"`          // Paid amount, in the smallest units of the currency
	UserIDs       []int64 `json:"user_ids"`        // Identifiers of the users which can activate the gift codes
	MonthCount    int32   `json:"month_count"`     // Number of months the Telegram Premium subscription will be active for the users
}

// MessageType return the string telegram-type of TelegramPaymentPurposePremiumGiftCodes
func (telegramPaymentPurposePremiumGiftCodes *TelegramPaymentPurposePremiumGiftCodes) MessageType() string {
	return "telegramPaymentPurposePremiumGiftCodes"
}

// NewTelegramPaymentPurposePremiumGiftCodes creates a new TelegramPaymentPurposePremiumGiftCodes
//
// @param boostedChatID Identifier of the supergroup or channel chat, which will be automatically boosted by the users for duration of the Premium subscription and which is administered by the user; 0 if none
// @param currency ISO 4217 currency code of the payment currency
// @param amount Paid amount, in the smallest units of the currency
// @param userIDs Identifiers of the users which can activate the gift codes
// @param monthCount Number of months the Telegram Premium subscription will be active for the users
func NewTelegramPaymentPurposePremiumGiftCodes(boostedChatID int64, currency string, amount int64, userIDs []int64, monthCount int32) *TelegramPaymentPurposePremiumGiftCodes {
	telegramPaymentPurposePremiumGiftCodesTemp := TelegramPaymentPurposePremiumGiftCodes{
		tdCommon:      tdCommon{Type: "telegramPaymentPurposePremiumGiftCodes"},
		BoostedChatID: boostedChatID,
		Currency:      currency,
		Amount:        amount,
		UserIDs:       userIDs,
		MonthCount:    monthCount,
	}

	return &telegramPaymentPurposePremiumGiftCodesTemp
}

// UnmarshalJSON unmarshal to json
func (telegramPaymentPurposePremiumGiftCodes *TelegramPaymentPurposePremiumGiftCodes) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BoostedChatID int64   `json:"boosted_chat_id"` // Identifier of the supergroup or channel chat, which will be automatically boosted by the users for duration of the Premium subscription and which is administered by the user; 0 if none
		Currency      string  `json:"currency"`        // ISO 4217 currency code of the payment currency
		Amount        int64   `json:"amount"`          // Paid amount, in the smallest units of the currency
		UserIDs       []int64 `json:"user_ids"`        // Identifiers of the users which can activate the gift codes
		MonthCount    int32   `json:"month_count"`     // Number of months the Telegram Premium subscription will be active for the users
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	telegramPaymentPurposePremiumGiftCodes.tdCommon = tempObj.tdCommon
	telegramPaymentPurposePremiumGiftCodes.BoostedChatID = tempObj.BoostedChatID
	telegramPaymentPurposePremiumGiftCodes.Currency = tempObj.Currency
	telegramPaymentPurposePremiumGiftCodes.Amount = tempObj.Amount
	telegramPaymentPurposePremiumGiftCodes.UserIDs = tempObj.UserIDs
	telegramPaymentPurposePremiumGiftCodes.MonthCount = tempObj.MonthCount

	return nil
}

// GetTelegramPaymentPurposeEnum return the enum type of this object
func (telegramPaymentPurposePremiumGiftCodes *TelegramPaymentPurposePremiumGiftCodes) GetTelegramPaymentPurposeEnum() TelegramPaymentPurposeEnum {
	return TelegramPaymentPurposePremiumGiftCodesType
}

// TelegramPaymentPurposePremiumGiveaway The user creating a Telegram Premium giveaway
type TelegramPaymentPurposePremiumGiveaway struct {
	tdCommon
	Parameters  *GiveawayParameters `json:"parameters"`   // Giveaway parameters
	Currency    string              `json:"currency"`     // ISO 4217 currency code of the payment currency
	Amount      int64               `json:"amount"`       // Paid amount, in the smallest units of the currency
	WinnerCount int32               `json:"winner_count"` // Number of users which will be able to activate the gift codes
	MonthCount  int32               `json:"month_count"`  // Number of months the Telegram Premium subscription will be active for the users
}

// MessageType return the string telegram-type of TelegramPaymentPurposePremiumGiveaway
func (telegramPaymentPurposePremiumGiveaway *TelegramPaymentPurposePremiumGiveaway) MessageType() string {
	return "telegramPaymentPurposePremiumGiveaway"
}

// NewTelegramPaymentPurposePremiumGiveaway creates a new TelegramPaymentPurposePremiumGiveaway
//
// @param parameters Giveaway parameters
// @param currency ISO 4217 currency code of the payment currency
// @param amount Paid amount, in the smallest units of the currency
// @param winnerCount Number of users which will be able to activate the gift codes
// @param monthCount Number of months the Telegram Premium subscription will be active for the users
func NewTelegramPaymentPurposePremiumGiveaway(parameters *GiveawayParameters, currency string, amount int64, winnerCount int32, monthCount int32) *TelegramPaymentPurposePremiumGiveaway {
	telegramPaymentPurposePremiumGiveawayTemp := TelegramPaymentPurposePremiumGiveaway{
		tdCommon:    tdCommon{Type: "telegramPaymentPurposePremiumGiveaway"},
		Parameters:  parameters,
		Currency:    currency,
		Amount:      amount,
		WinnerCount: winnerCount,
		MonthCount:  monthCount,
	}

	return &telegramPaymentPurposePremiumGiveawayTemp
}

// UnmarshalJSON unmarshal to json
func (telegramPaymentPurposePremiumGiveaway *TelegramPaymentPurposePremiumGiveaway) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Parameters  *GiveawayParameters `json:"parameters"`   // Giveaway parameters
		Currency    string              `json:"currency"`     // ISO 4217 currency code of the payment currency
		Amount      int64               `json:"amount"`       // Paid amount, in the smallest units of the currency
		WinnerCount int32               `json:"winner_count"` // Number of users which will be able to activate the gift codes
		MonthCount  int32               `json:"month_count"`  // Number of months the Telegram Premium subscription will be active for the users
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	telegramPaymentPurposePremiumGiveaway.tdCommon = tempObj.tdCommon
	telegramPaymentPurposePremiumGiveaway.Parameters = tempObj.Parameters
	telegramPaymentPurposePremiumGiveaway.Currency = tempObj.Currency
	telegramPaymentPurposePremiumGiveaway.Amount = tempObj.Amount
	telegramPaymentPurposePremiumGiveaway.WinnerCount = tempObj.WinnerCount
	telegramPaymentPurposePremiumGiveaway.MonthCount = tempObj.MonthCount

	return nil
}

// GetTelegramPaymentPurposeEnum return the enum type of this object
func (telegramPaymentPurposePremiumGiveaway *TelegramPaymentPurposePremiumGiveaway) GetTelegramPaymentPurposeEnum() TelegramPaymentPurposeEnum {
	return TelegramPaymentPurposePremiumGiveawayType
}

// TelegramPaymentPurposeStars The user buying Telegram Stars
type TelegramPaymentPurposeStars struct {
	tdCommon
	Currency  string `json:"currency"`   // ISO 4217 currency code of the payment currency
	Amount    int64  `json:"amount"`     // Paid amount, in the smallest units of the currency
	StarCount int64  `json:"star_count"` // Number of bought Telegram Stars
}

// MessageType return the string telegram-type of TelegramPaymentPurposeStars
func (telegramPaymentPurposeStars *TelegramPaymentPurposeStars) MessageType() string {
	return "telegramPaymentPurposeStars"
}

// NewTelegramPaymentPurposeStars creates a new TelegramPaymentPurposeStars
//
// @param currency ISO 4217 currency code of the payment currency
// @param amount Paid amount, in the smallest units of the currency
// @param starCount Number of bought Telegram Stars
func NewTelegramPaymentPurposeStars(currency string, amount int64, starCount int64) *TelegramPaymentPurposeStars {
	telegramPaymentPurposeStarsTemp := TelegramPaymentPurposeStars{
		tdCommon:  tdCommon{Type: "telegramPaymentPurposeStars"},
		Currency:  currency,
		Amount:    amount,
		StarCount: starCount,
	}

	return &telegramPaymentPurposeStarsTemp
}

// UnmarshalJSON unmarshal to json
func (telegramPaymentPurposeStars *TelegramPaymentPurposeStars) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Currency  string `json:"currency"`   // ISO 4217 currency code of the payment currency
		Amount    int64  `json:"amount"`     // Paid amount, in the smallest units of the currency
		StarCount int64  `json:"star_count"` // Number of bought Telegram Stars
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	telegramPaymentPurposeStars.tdCommon = tempObj.tdCommon
	telegramPaymentPurposeStars.Currency = tempObj.Currency
	telegramPaymentPurposeStars.Amount = tempObj.Amount
	telegramPaymentPurposeStars.StarCount = tempObj.StarCount

	return nil
}

// GetTelegramPaymentPurposeEnum return the enum type of this object
func (telegramPaymentPurposeStars *TelegramPaymentPurposeStars) GetTelegramPaymentPurposeEnum() TelegramPaymentPurposeEnum {
	return TelegramPaymentPurposeStarsType
}

// TelegramPaymentPurposeGiftedStars The user buying Telegram Stars for other users
type TelegramPaymentPurposeGiftedStars struct {
	tdCommon
	UserID    int64  `json:"user_id"`    // Identifier of the user to which Telegram Stars are gifted
	Currency  string `json:"currency"`   // ISO 4217 currency code of the payment currency
	Amount    int64  `json:"amount"`     // Paid amount, in the smallest units of the currency
	StarCount int64  `json:"star_count"` // Number of bought Telegram Stars
}

// MessageType return the string telegram-type of TelegramPaymentPurposeGiftedStars
func (telegramPaymentPurposeGiftedStars *TelegramPaymentPurposeGiftedStars) MessageType() string {
	return "telegramPaymentPurposeGiftedStars"
}

// NewTelegramPaymentPurposeGiftedStars creates a new TelegramPaymentPurposeGiftedStars
//
// @param userID Identifier of the user to which Telegram Stars are gifted
// @param currency ISO 4217 currency code of the payment currency
// @param amount Paid amount, in the smallest units of the currency
// @param starCount Number of bought Telegram Stars
func NewTelegramPaymentPurposeGiftedStars(userID int64, currency string, amount int64, starCount int64) *TelegramPaymentPurposeGiftedStars {
	telegramPaymentPurposeGiftedStarsTemp := TelegramPaymentPurposeGiftedStars{
		tdCommon:  tdCommon{Type: "telegramPaymentPurposeGiftedStars"},
		UserID:    userID,
		Currency:  currency,
		Amount:    amount,
		StarCount: starCount,
	}

	return &telegramPaymentPurposeGiftedStarsTemp
}

// UnmarshalJSON unmarshal to json
func (telegramPaymentPurposeGiftedStars *TelegramPaymentPurposeGiftedStars) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID    int64  `json:"user_id"`    // Identifier of the user to which Telegram Stars are gifted
		Currency  string `json:"currency"`   // ISO 4217 currency code of the payment currency
		Amount    int64  `json:"amount"`     // Paid amount, in the smallest units of the currency
		StarCount int64  `json:"star_count"` // Number of bought Telegram Stars
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	telegramPaymentPurposeGiftedStars.tdCommon = tempObj.tdCommon
	telegramPaymentPurposeGiftedStars.UserID = tempObj.UserID
	telegramPaymentPurposeGiftedStars.Currency = tempObj.Currency
	telegramPaymentPurposeGiftedStars.Amount = tempObj.Amount
	telegramPaymentPurposeGiftedStars.StarCount = tempObj.StarCount

	return nil
}

// GetTelegramPaymentPurposeEnum return the enum type of this object
func (telegramPaymentPurposeGiftedStars *TelegramPaymentPurposeGiftedStars) GetTelegramPaymentPurposeEnum() TelegramPaymentPurposeEnum {
	return TelegramPaymentPurposeGiftedStarsType
}

// TelegramPaymentPurposeStarGiveaway The user creating a Telegram Star giveaway
type TelegramPaymentPurposeStarGiveaway struct {
	tdCommon
	Parameters  *GiveawayParameters `json:"parameters"`   // Giveaway parameters
	Currency    string              `json:"currency"`     // ISO 4217 currency code of the payment currency
	Amount      int64               `json:"amount"`       // Paid amount, in the smallest units of the currency
	WinnerCount int32               `json:"winner_count"` // The number of users to receive Telegram Stars
	StarCount   int64               `json:"star_count"`   // The number of Telegram Stars to be distributed through the giveaway
}

// MessageType return the string telegram-type of TelegramPaymentPurposeStarGiveaway
func (telegramPaymentPurposeStarGiveaway *TelegramPaymentPurposeStarGiveaway) MessageType() string {
	return "telegramPaymentPurposeStarGiveaway"
}

// NewTelegramPaymentPurposeStarGiveaway creates a new TelegramPaymentPurposeStarGiveaway
//
// @param parameters Giveaway parameters
// @param currency ISO 4217 currency code of the payment currency
// @param amount Paid amount, in the smallest units of the currency
// @param winnerCount The number of users to receive Telegram Stars
// @param starCount The number of Telegram Stars to be distributed through the giveaway
func NewTelegramPaymentPurposeStarGiveaway(parameters *GiveawayParameters, currency string, amount int64, winnerCount int32, starCount int64) *TelegramPaymentPurposeStarGiveaway {
	telegramPaymentPurposeStarGiveawayTemp := TelegramPaymentPurposeStarGiveaway{
		tdCommon:    tdCommon{Type: "telegramPaymentPurposeStarGiveaway"},
		Parameters:  parameters,
		Currency:    currency,
		Amount:      amount,
		WinnerCount: winnerCount,
		StarCount:   starCount,
	}

	return &telegramPaymentPurposeStarGiveawayTemp
}

// UnmarshalJSON unmarshal to json
func (telegramPaymentPurposeStarGiveaway *TelegramPaymentPurposeStarGiveaway) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Parameters  *GiveawayParameters `json:"parameters"`   // Giveaway parameters
		Currency    string              `json:"currency"`     // ISO 4217 currency code of the payment currency
		Amount      int64               `json:"amount"`       // Paid amount, in the smallest units of the currency
		WinnerCount int32               `json:"winner_count"` // The number of users to receive Telegram Stars
		StarCount   int64               `json:"star_count"`   // The number of Telegram Stars to be distributed through the giveaway
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	telegramPaymentPurposeStarGiveaway.tdCommon = tempObj.tdCommon
	telegramPaymentPurposeStarGiveaway.Parameters = tempObj.Parameters
	telegramPaymentPurposeStarGiveaway.Currency = tempObj.Currency
	telegramPaymentPurposeStarGiveaway.Amount = tempObj.Amount
	telegramPaymentPurposeStarGiveaway.WinnerCount = tempObj.WinnerCount
	telegramPaymentPurposeStarGiveaway.StarCount = tempObj.StarCount

	return nil
}

// GetTelegramPaymentPurposeEnum return the enum type of this object
func (telegramPaymentPurposeStarGiveaway *TelegramPaymentPurposeStarGiveaway) GetTelegramPaymentPurposeEnum() TelegramPaymentPurposeEnum {
	return TelegramPaymentPurposeStarGiveawayType
}

// TelegramPaymentPurposeJoinChat The user joins a chat and subscribes to regular payments in Telegram Stars
type TelegramPaymentPurposeJoinChat struct {
	tdCommon
	InviteLink string `json:"invite_link"` // Invite link to use
}

// MessageType return the string telegram-type of TelegramPaymentPurposeJoinChat
func (telegramPaymentPurposeJoinChat *TelegramPaymentPurposeJoinChat) MessageType() string {
	return "telegramPaymentPurposeJoinChat"
}

// NewTelegramPaymentPurposeJoinChat creates a new TelegramPaymentPurposeJoinChat
//
// @param inviteLink Invite link to use
func NewTelegramPaymentPurposeJoinChat(inviteLink string) *TelegramPaymentPurposeJoinChat {
	telegramPaymentPurposeJoinChatTemp := TelegramPaymentPurposeJoinChat{
		tdCommon:   tdCommon{Type: "telegramPaymentPurposeJoinChat"},
		InviteLink: inviteLink,
	}

	return &telegramPaymentPurposeJoinChatTemp
}

// UnmarshalJSON unmarshal to json
func (telegramPaymentPurposeJoinChat *TelegramPaymentPurposeJoinChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		InviteLink string `json:"invite_link"` // Invite link to use
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	telegramPaymentPurposeJoinChat.tdCommon = tempObj.tdCommon
	telegramPaymentPurposeJoinChat.InviteLink = tempObj.InviteLink

	return nil
}

// GetTelegramPaymentPurposeEnum return the enum type of this object
func (telegramPaymentPurposeJoinChat *TelegramPaymentPurposeJoinChat) GetTelegramPaymentPurposeEnum() TelegramPaymentPurposeEnum {
	return TelegramPaymentPurposeJoinChatType
}

// DeviceTokenFirebaseCloudMessaging A token for Firebase Cloud Messaging
type DeviceTokenFirebaseCloudMessaging struct {
	tdCommon
	Token   string `json:"token"`   // Device registration token; may be empty to deregister a device
	Encrypt bool   `json:"encrypt"` // True, if push notifications must be additionally encrypted
}

// MessageType return the string telegram-type of DeviceTokenFirebaseCloudMessaging
func (deviceTokenFirebaseCloudMessaging *DeviceTokenFirebaseCloudMessaging) MessageType() string {
	return "deviceTokenFirebaseCloudMessaging"
}

// NewDeviceTokenFirebaseCloudMessaging creates a new DeviceTokenFirebaseCloudMessaging
//
// @param token Device registration token; may be empty to deregister a device
// @param encrypt True, if push notifications must be additionally encrypted
func NewDeviceTokenFirebaseCloudMessaging(token string, encrypt bool) *DeviceTokenFirebaseCloudMessaging {
	deviceTokenFirebaseCloudMessagingTemp := DeviceTokenFirebaseCloudMessaging{
		tdCommon: tdCommon{Type: "deviceTokenFirebaseCloudMessaging"},
		Token:    token,
		Encrypt:  encrypt,
	}

	return &deviceTokenFirebaseCloudMessagingTemp
}

// UnmarshalJSON unmarshal to json
func (deviceTokenFirebaseCloudMessaging *DeviceTokenFirebaseCloudMessaging) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Token   string `json:"token"`   // Device registration token; may be empty to deregister a device
		Encrypt bool   `json:"encrypt"` // True, if push notifications must be additionally encrypted
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	deviceTokenFirebaseCloudMessaging.tdCommon = tempObj.tdCommon
	deviceTokenFirebaseCloudMessaging.Token = tempObj.Token
	deviceTokenFirebaseCloudMessaging.Encrypt = tempObj.Encrypt

	return nil
}

// GetDeviceTokenEnum return the enum type of this object
func (deviceTokenFirebaseCloudMessaging *DeviceTokenFirebaseCloudMessaging) GetDeviceTokenEnum() DeviceTokenEnum {
	return DeviceTokenFirebaseCloudMessagingType
}

// DeviceTokenApplePush A token for Apple Push Notification service
type DeviceTokenApplePush struct {
	tdCommon
	DeviceToken  string `json:"device_token"`   // Device token; may be empty to deregister a device
	IsAppSandbox bool   `json:"is_app_sandbox"` // True, if App Sandbox is enabled
}

// MessageType return the string telegram-type of DeviceTokenApplePush
func (deviceTokenApplePush *DeviceTokenApplePush) MessageType() string {
	return "deviceTokenApplePush"
}

// NewDeviceTokenApplePush creates a new DeviceTokenApplePush
//
// @param deviceToken Device token; may be empty to deregister a device
// @param isAppSandbox True, if App Sandbox is enabled
func NewDeviceTokenApplePush(deviceToken string, isAppSandbox bool) *DeviceTokenApplePush {
	deviceTokenApplePushTemp := DeviceTokenApplePush{
		tdCommon:     tdCommon{Type: "deviceTokenApplePush"},
		DeviceToken:  deviceToken,
		IsAppSandbox: isAppSandbox,
	}

	return &deviceTokenApplePushTemp
}

// UnmarshalJSON unmarshal to json
func (deviceTokenApplePush *DeviceTokenApplePush) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		DeviceToken  string `json:"device_token"`   // Device token; may be empty to deregister a device
		IsAppSandbox bool   `json:"is_app_sandbox"` // True, if App Sandbox is enabled
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	deviceTokenApplePush.tdCommon = tempObj.tdCommon
	deviceTokenApplePush.DeviceToken = tempObj.DeviceToken
	deviceTokenApplePush.IsAppSandbox = tempObj.IsAppSandbox

	return nil
}

// GetDeviceTokenEnum return the enum type of this object
func (deviceTokenApplePush *DeviceTokenApplePush) GetDeviceTokenEnum() DeviceTokenEnum {
	return DeviceTokenApplePushType
}

// DeviceTokenApplePushVoIP A token for Apple Push Notification service VoIP notifications
type DeviceTokenApplePushVoIP struct {
	tdCommon
	DeviceToken  string `json:"device_token"`   // Device token; may be empty to deregister a device
	IsAppSandbox bool   `json:"is_app_sandbox"` // True, if App Sandbox is enabled
	Encrypt      bool   `json:"encrypt"`        // True, if push notifications must be additionally encrypted
}

// MessageType return the string telegram-type of DeviceTokenApplePushVoIP
func (deviceTokenApplePushVoIP *DeviceTokenApplePushVoIP) MessageType() string {
	return "deviceTokenApplePushVoIP"
}

// NewDeviceTokenApplePushVoIP creates a new DeviceTokenApplePushVoIP
//
// @param deviceToken Device token; may be empty to deregister a device
// @param isAppSandbox True, if App Sandbox is enabled
// @param encrypt True, if push notifications must be additionally encrypted
func NewDeviceTokenApplePushVoIP(deviceToken string, isAppSandbox bool, encrypt bool) *DeviceTokenApplePushVoIP {
	deviceTokenApplePushVoIPTemp := DeviceTokenApplePushVoIP{
		tdCommon:     tdCommon{Type: "deviceTokenApplePushVoIP"},
		DeviceToken:  deviceToken,
		IsAppSandbox: isAppSandbox,
		Encrypt:      encrypt,
	}

	return &deviceTokenApplePushVoIPTemp
}

// UnmarshalJSON unmarshal to json
func (deviceTokenApplePushVoIP *DeviceTokenApplePushVoIP) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		DeviceToken  string `json:"device_token"`   // Device token; may be empty to deregister a device
		IsAppSandbox bool   `json:"is_app_sandbox"` // True, if App Sandbox is enabled
		Encrypt      bool   `json:"encrypt"`        // True, if push notifications must be additionally encrypted
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	deviceTokenApplePushVoIP.tdCommon = tempObj.tdCommon
	deviceTokenApplePushVoIP.DeviceToken = tempObj.DeviceToken
	deviceTokenApplePushVoIP.IsAppSandbox = tempObj.IsAppSandbox
	deviceTokenApplePushVoIP.Encrypt = tempObj.Encrypt

	return nil
}

// GetDeviceTokenEnum return the enum type of this object
func (deviceTokenApplePushVoIP *DeviceTokenApplePushVoIP) GetDeviceTokenEnum() DeviceTokenEnum {
	return DeviceTokenApplePushVoIPType
}

// DeviceTokenWindowsPush A token for Windows Push Notification Services
type DeviceTokenWindowsPush struct {
	tdCommon
	AccessToken string `json:"access_token"` // The access token that will be used to send notifications; may be empty to deregister a device
}

// MessageType return the string telegram-type of DeviceTokenWindowsPush
func (deviceTokenWindowsPush *DeviceTokenWindowsPush) MessageType() string {
	return "deviceTokenWindowsPush"
}

// NewDeviceTokenWindowsPush creates a new DeviceTokenWindowsPush
//
// @param accessToken The access token that will be used to send notifications; may be empty to deregister a device
func NewDeviceTokenWindowsPush(accessToken string) *DeviceTokenWindowsPush {
	deviceTokenWindowsPushTemp := DeviceTokenWindowsPush{
		tdCommon:    tdCommon{Type: "deviceTokenWindowsPush"},
		AccessToken: accessToken,
	}

	return &deviceTokenWindowsPushTemp
}

// UnmarshalJSON unmarshal to json
func (deviceTokenWindowsPush *DeviceTokenWindowsPush) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		AccessToken string `json:"access_token"` // The access token that will be used to send notifications; may be empty to deregister a device
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	deviceTokenWindowsPush.tdCommon = tempObj.tdCommon
	deviceTokenWindowsPush.AccessToken = tempObj.AccessToken

	return nil
}

// GetDeviceTokenEnum return the enum type of this object
func (deviceTokenWindowsPush *DeviceTokenWindowsPush) GetDeviceTokenEnum() DeviceTokenEnum {
	return DeviceTokenWindowsPushType
}

// DeviceTokenMicrosoftPush A token for Microsoft Push Notification Service
type DeviceTokenMicrosoftPush struct {
	tdCommon
	ChannelURI string `json:"channel_uri"` // Push notification channel URI; may be empty to deregister a device
}

// MessageType return the string telegram-type of DeviceTokenMicrosoftPush
func (deviceTokenMicrosoftPush *DeviceTokenMicrosoftPush) MessageType() string {
	return "deviceTokenMicrosoftPush"
}

// NewDeviceTokenMicrosoftPush creates a new DeviceTokenMicrosoftPush
//
// @param channelURI Push notification channel URI; may be empty to deregister a device
func NewDeviceTokenMicrosoftPush(channelURI string) *DeviceTokenMicrosoftPush {
	deviceTokenMicrosoftPushTemp := DeviceTokenMicrosoftPush{
		tdCommon:   tdCommon{Type: "deviceTokenMicrosoftPush"},
		ChannelURI: channelURI,
	}

	return &deviceTokenMicrosoftPushTemp
}

// UnmarshalJSON unmarshal to json
func (deviceTokenMicrosoftPush *DeviceTokenMicrosoftPush) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChannelURI string `json:"channel_uri"` // Push notification channel URI; may be empty to deregister a device
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	deviceTokenMicrosoftPush.tdCommon = tempObj.tdCommon
	deviceTokenMicrosoftPush.ChannelURI = tempObj.ChannelURI

	return nil
}

// GetDeviceTokenEnum return the enum type of this object
func (deviceTokenMicrosoftPush *DeviceTokenMicrosoftPush) GetDeviceTokenEnum() DeviceTokenEnum {
	return DeviceTokenMicrosoftPushType
}

// DeviceTokenMicrosoftPushVoIP A token for Microsoft Push Notification Service VoIP channel
type DeviceTokenMicrosoftPushVoIP struct {
	tdCommon
	ChannelURI string `json:"channel_uri"` // Push notification channel URI; may be empty to deregister a device
}

// MessageType return the string telegram-type of DeviceTokenMicrosoftPushVoIP
func (deviceTokenMicrosoftPushVoIP *DeviceTokenMicrosoftPushVoIP) MessageType() string {
	return "deviceTokenMicrosoftPushVoIP"
}

// NewDeviceTokenMicrosoftPushVoIP creates a new DeviceTokenMicrosoftPushVoIP
//
// @param channelURI Push notification channel URI; may be empty to deregister a device
func NewDeviceTokenMicrosoftPushVoIP(channelURI string) *DeviceTokenMicrosoftPushVoIP {
	deviceTokenMicrosoftPushVoIPTemp := DeviceTokenMicrosoftPushVoIP{
		tdCommon:   tdCommon{Type: "deviceTokenMicrosoftPushVoIP"},
		ChannelURI: channelURI,
	}

	return &deviceTokenMicrosoftPushVoIPTemp
}

// UnmarshalJSON unmarshal to json
func (deviceTokenMicrosoftPushVoIP *DeviceTokenMicrosoftPushVoIP) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChannelURI string `json:"channel_uri"` // Push notification channel URI; may be empty to deregister a device
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	deviceTokenMicrosoftPushVoIP.tdCommon = tempObj.tdCommon
	deviceTokenMicrosoftPushVoIP.ChannelURI = tempObj.ChannelURI

	return nil
}

// GetDeviceTokenEnum return the enum type of this object
func (deviceTokenMicrosoftPushVoIP *DeviceTokenMicrosoftPushVoIP) GetDeviceTokenEnum() DeviceTokenEnum {
	return DeviceTokenMicrosoftPushVoIPType
}

// DeviceTokenWebPush A token for web Push API
type DeviceTokenWebPush struct {
	tdCommon
	Endpoint        string `json:"endpoint"`         // Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device
	P256dhBase64url string `json:"p256dh_base64url"` // Base64url-encoded P-256 elliptic curve Diffie-Hellman public key
	AuthBase64url   string `json:"auth_base64url"`   // Base64url-encoded authentication secret
}

// MessageType return the string telegram-type of DeviceTokenWebPush
func (deviceTokenWebPush *DeviceTokenWebPush) MessageType() string {
	return "deviceTokenWebPush"
}

// NewDeviceTokenWebPush creates a new DeviceTokenWebPush
//
// @param endpoint Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device
// @param p256dhBase64url Base64url-encoded P-256 elliptic curve Diffie-Hellman public key
// @param authBase64url Base64url-encoded authentication secret
func NewDeviceTokenWebPush(endpoint string, p256dhBase64url string, authBase64url string) *DeviceTokenWebPush {
	deviceTokenWebPushTemp := DeviceTokenWebPush{
		tdCommon:        tdCommon{Type: "deviceTokenWebPush"},
		Endpoint:        endpoint,
		P256dhBase64url: p256dhBase64url,
		AuthBase64url:   authBase64url,
	}

	return &deviceTokenWebPushTemp
}

// UnmarshalJSON unmarshal to json
func (deviceTokenWebPush *DeviceTokenWebPush) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Endpoint        string `json:"endpoint"`         // Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device
		P256dhBase64url string `json:"p256dh_base64url"` // Base64url-encoded P-256 elliptic curve Diffie-Hellman public key
		AuthBase64url   string `json:"auth_base64url"`   // Base64url-encoded authentication secret
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	deviceTokenWebPush.tdCommon = tempObj.tdCommon
	deviceTokenWebPush.Endpoint = tempObj.Endpoint
	deviceTokenWebPush.P256dhBase64url = tempObj.P256dhBase64url
	deviceTokenWebPush.AuthBase64url = tempObj.AuthBase64url

	return nil
}

// GetDeviceTokenEnum return the enum type of this object
func (deviceTokenWebPush *DeviceTokenWebPush) GetDeviceTokenEnum() DeviceTokenEnum {
	return DeviceTokenWebPushType
}

// DeviceTokenSimplePush A token for Simple Push API for Firefox OS
type DeviceTokenSimplePush struct {
	tdCommon
	Endpoint string `json:"endpoint"` // Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device
}

// MessageType return the string telegram-type of DeviceTokenSimplePush
func (deviceTokenSimplePush *DeviceTokenSimplePush) MessageType() string {
	return "deviceTokenSimplePush"
}

// NewDeviceTokenSimplePush creates a new DeviceTokenSimplePush
//
// @param endpoint Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device
func NewDeviceTokenSimplePush(endpoint string) *DeviceTokenSimplePush {
	deviceTokenSimplePushTemp := DeviceTokenSimplePush{
		tdCommon: tdCommon{Type: "deviceTokenSimplePush"},
		Endpoint: endpoint,
	}

	return &deviceTokenSimplePushTemp
}

// UnmarshalJSON unmarshal to json
func (deviceTokenSimplePush *DeviceTokenSimplePush) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Endpoint string `json:"endpoint"` // Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	deviceTokenSimplePush.tdCommon = tempObj.tdCommon
	deviceTokenSimplePush.Endpoint = tempObj.Endpoint

	return nil
}

// GetDeviceTokenEnum return the enum type of this object
func (deviceTokenSimplePush *DeviceTokenSimplePush) GetDeviceTokenEnum() DeviceTokenEnum {
	return DeviceTokenSimplePushType
}

// DeviceTokenUbuntuPush A token for Ubuntu Push Client service
type DeviceTokenUbuntuPush struct {
	tdCommon
	Token string `json:"token"` // Token; may be empty to deregister a device
}

// MessageType return the string telegram-type of DeviceTokenUbuntuPush
func (deviceTokenUbuntuPush *DeviceTokenUbuntuPush) MessageType() string {
	return "deviceTokenUbuntuPush"
}

// NewDeviceTokenUbuntuPush creates a new DeviceTokenUbuntuPush
//
// @param token Token; may be empty to deregister a device
func NewDeviceTokenUbuntuPush(token string) *DeviceTokenUbuntuPush {
	deviceTokenUbuntuPushTemp := DeviceTokenUbuntuPush{
		tdCommon: tdCommon{Type: "deviceTokenUbuntuPush"},
		Token:    token,
	}

	return &deviceTokenUbuntuPushTemp
}

// UnmarshalJSON unmarshal to json
func (deviceTokenUbuntuPush *DeviceTokenUbuntuPush) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Token string `json:"token"` // Token; may be empty to deregister a device
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	deviceTokenUbuntuPush.tdCommon = tempObj.tdCommon
	deviceTokenUbuntuPush.Token = tempObj.Token

	return nil
}

// GetDeviceTokenEnum return the enum type of this object
func (deviceTokenUbuntuPush *DeviceTokenUbuntuPush) GetDeviceTokenEnum() DeviceTokenEnum {
	return DeviceTokenUbuntuPushType
}

// DeviceTokenBlackBerryPush A token for BlackBerry Push Service
type DeviceTokenBlackBerryPush struct {
	tdCommon
	Token string `json:"token"` // Token; may be empty to deregister a device
}

// MessageType return the string telegram-type of DeviceTokenBlackBerryPush
func (deviceTokenBlackBerryPush *DeviceTokenBlackBerryPush) MessageType() string {
	return "deviceTokenBlackBerryPush"
}

// NewDeviceTokenBlackBerryPush creates a new DeviceTokenBlackBerryPush
//
// @param token Token; may be empty to deregister a device
func NewDeviceTokenBlackBerryPush(token string) *DeviceTokenBlackBerryPush {
	deviceTokenBlackBerryPushTemp := DeviceTokenBlackBerryPush{
		tdCommon: tdCommon{Type: "deviceTokenBlackBerryPush"},
		Token:    token,
	}

	return &deviceTokenBlackBerryPushTemp
}

// UnmarshalJSON unmarshal to json
func (deviceTokenBlackBerryPush *DeviceTokenBlackBerryPush) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Token string `json:"token"` // Token; may be empty to deregister a device
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	deviceTokenBlackBerryPush.tdCommon = tempObj.tdCommon
	deviceTokenBlackBerryPush.Token = tempObj.Token

	return nil
}

// GetDeviceTokenEnum return the enum type of this object
func (deviceTokenBlackBerryPush *DeviceTokenBlackBerryPush) GetDeviceTokenEnum() DeviceTokenEnum {
	return DeviceTokenBlackBerryPushType
}

// DeviceTokenTizenPush A token for Tizen Push Service
type DeviceTokenTizenPush struct {
	tdCommon
	RegID string `json:"reg_id"` // Push service registration identifier; may be empty to deregister a device
}

// MessageType return the string telegram-type of DeviceTokenTizenPush
func (deviceTokenTizenPush *DeviceTokenTizenPush) MessageType() string {
	return "deviceTokenTizenPush"
}

// NewDeviceTokenTizenPush creates a new DeviceTokenTizenPush
//
// @param regID Push service registration identifier; may be empty to deregister a device
func NewDeviceTokenTizenPush(regID string) *DeviceTokenTizenPush {
	deviceTokenTizenPushTemp := DeviceTokenTizenPush{
		tdCommon: tdCommon{Type: "deviceTokenTizenPush"},
		RegID:    regID,
	}

	return &deviceTokenTizenPushTemp
}

// UnmarshalJSON unmarshal to json
func (deviceTokenTizenPush *DeviceTokenTizenPush) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		RegID string `json:"reg_id"` // Push service registration identifier; may be empty to deregister a device
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	deviceTokenTizenPush.tdCommon = tempObj.tdCommon
	deviceTokenTizenPush.RegID = tempObj.RegID

	return nil
}

// GetDeviceTokenEnum return the enum type of this object
func (deviceTokenTizenPush *DeviceTokenTizenPush) GetDeviceTokenEnum() DeviceTokenEnum {
	return DeviceTokenTizenPushType
}

// DeviceTokenHuaweiPush A token for HUAWEI Push Service
type DeviceTokenHuaweiPush struct {
	tdCommon
	Token   string `json:"token"`   // Device registration token; may be empty to deregister a device
	Encrypt bool   `json:"encrypt"` // True, if push notifications must be additionally encrypted
}

// MessageType return the string telegram-type of DeviceTokenHuaweiPush
func (deviceTokenHuaweiPush *DeviceTokenHuaweiPush) MessageType() string {
	return "deviceTokenHuaweiPush"
}

// NewDeviceTokenHuaweiPush creates a new DeviceTokenHuaweiPush
//
// @param token Device registration token; may be empty to deregister a device
// @param encrypt True, if push notifications must be additionally encrypted
func NewDeviceTokenHuaweiPush(token string, encrypt bool) *DeviceTokenHuaweiPush {
	deviceTokenHuaweiPushTemp := DeviceTokenHuaweiPush{
		tdCommon: tdCommon{Type: "deviceTokenHuaweiPush"},
		Token:    token,
		Encrypt:  encrypt,
	}

	return &deviceTokenHuaweiPushTemp
}

// UnmarshalJSON unmarshal to json
func (deviceTokenHuaweiPush *DeviceTokenHuaweiPush) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Token   string `json:"token"`   // Device registration token; may be empty to deregister a device
		Encrypt bool   `json:"encrypt"` // True, if push notifications must be additionally encrypted
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	deviceTokenHuaweiPush.tdCommon = tempObj.tdCommon
	deviceTokenHuaweiPush.Token = tempObj.Token
	deviceTokenHuaweiPush.Encrypt = tempObj.Encrypt

	return nil
}

// GetDeviceTokenEnum return the enum type of this object
func (deviceTokenHuaweiPush *DeviceTokenHuaweiPush) GetDeviceTokenEnum() DeviceTokenEnum {
	return DeviceTokenHuaweiPushType
}

// PushReceiverID Contains a globally unique push receiver identifier, which can be used to identify which account has received a push notification
type PushReceiverID struct {
	tdCommon
	ID JSONInt64 `json:"id"` // The globally unique identifier of push notification subscription
}

// MessageType return the string telegram-type of PushReceiverID
func (pushReceiverID *PushReceiverID) MessageType() string {
	return "pushReceiverId"
}

// NewPushReceiverID creates a new PushReceiverID
//
// @param iD The globally unique identifier of push notification subscription
func NewPushReceiverID(iD JSONInt64) *PushReceiverID {
	pushReceiverIDTemp := PushReceiverID{
		tdCommon: tdCommon{Type: "pushReceiverId"},
		ID:       iD,
	}

	return &pushReceiverIDTemp
}

// UnmarshalJSON unmarshal to json
func (pushReceiverID *PushReceiverID) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID JSONInt64 `json:"id"` // The globally unique identifier of push notification subscription
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushReceiverID.tdCommon = tempObj.tdCommon
	pushReceiverID.ID = tempObj.ID

	return nil
}

// BackgroundFillSolid Describes a solid fill of a background
type BackgroundFillSolid struct {
	tdCommon
	Color int32 `json:"color"` // A color of the background in the RGB24 format
}

// MessageType return the string telegram-type of BackgroundFillSolid
func (backgroundFillSolid *BackgroundFillSolid) MessageType() string {
	return "backgroundFillSolid"
}

// NewBackgroundFillSolid creates a new BackgroundFillSolid
//
// @param color A color of the background in the RGB24 format
func NewBackgroundFillSolid(color int32) *BackgroundFillSolid {
	backgroundFillSolidTemp := BackgroundFillSolid{
		tdCommon: tdCommon{Type: "backgroundFillSolid"},
		Color:    color,
	}

	return &backgroundFillSolidTemp
}

// UnmarshalJSON unmarshal to json
func (backgroundFillSolid *BackgroundFillSolid) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Color int32 `json:"color"` // A color of the background in the RGB24 format
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	backgroundFillSolid.tdCommon = tempObj.tdCommon
	backgroundFillSolid.Color = tempObj.Color

	return nil
}

// GetBackgroundFillEnum return the enum type of this object
func (backgroundFillSolid *BackgroundFillSolid) GetBackgroundFillEnum() BackgroundFillEnum {
	return BackgroundFillSolidType
}

// BackgroundFillGradient Describes a gradient fill of a background
type BackgroundFillGradient struct {
	tdCommon
	TopColor      int32 `json:"top_color"`      // A top color of the background in the RGB24 format
	BottomColor   int32 `json:"bottom_color"`   // A bottom color of the background in the RGB24 format
	RotationAngle int32 `json:"rotation_angle"` // Clockwise rotation angle of the gradient, in degrees; 0-359. Must always be divisible by 45
}

// MessageType return the string telegram-type of BackgroundFillGradient
func (backgroundFillGradient *BackgroundFillGradient) MessageType() string {
	return "backgroundFillGradient"
}

// NewBackgroundFillGradient creates a new BackgroundFillGradient
//
// @param topColor A top color of the background in the RGB24 format
// @param bottomColor A bottom color of the background in the RGB24 format
// @param rotationAngle Clockwise rotation angle of the gradient, in degrees; 0-359. Must always be divisible by 45
func NewBackgroundFillGradient(topColor int32, bottomColor int32, rotationAngle int32) *BackgroundFillGradient {
	backgroundFillGradientTemp := BackgroundFillGradient{
		tdCommon:      tdCommon{Type: "backgroundFillGradient"},
		TopColor:      topColor,
		BottomColor:   bottomColor,
		RotationAngle: rotationAngle,
	}

	return &backgroundFillGradientTemp
}

// UnmarshalJSON unmarshal to json
func (backgroundFillGradient *BackgroundFillGradient) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TopColor      int32 `json:"top_color"`      // A top color of the background in the RGB24 format
		BottomColor   int32 `json:"bottom_color"`   // A bottom color of the background in the RGB24 format
		RotationAngle int32 `json:"rotation_angle"` // Clockwise rotation angle of the gradient, in degrees; 0-359. Must always be divisible by 45
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	backgroundFillGradient.tdCommon = tempObj.tdCommon
	backgroundFillGradient.TopColor = tempObj.TopColor
	backgroundFillGradient.BottomColor = tempObj.BottomColor
	backgroundFillGradient.RotationAngle = tempObj.RotationAngle

	return nil
}

// GetBackgroundFillEnum return the enum type of this object
func (backgroundFillGradient *BackgroundFillGradient) GetBackgroundFillEnum() BackgroundFillEnum {
	return BackgroundFillGradientType
}

// BackgroundFillFreeformGradient Describes a freeform gradient fill of a background
type BackgroundFillFreeformGradient struct {
	tdCommon
	Colors []int32 `json:"colors"` // A list of 3 or 4 colors of the freeform gradient in the RGB24 format
}

// MessageType return the string telegram-type of BackgroundFillFreeformGradient
func (backgroundFillFreeformGradient *BackgroundFillFreeformGradient) MessageType() string {
	return "backgroundFillFreeformGradient"
}

// NewBackgroundFillFreeformGradient creates a new BackgroundFillFreeformGradient
//
// @param colors A list of 3 or 4 colors of the freeform gradient in the RGB24 format
func NewBackgroundFillFreeformGradient(colors []int32) *BackgroundFillFreeformGradient {
	backgroundFillFreeformGradientTemp := BackgroundFillFreeformGradient{
		tdCommon: tdCommon{Type: "backgroundFillFreeformGradient"},
		Colors:   colors,
	}

	return &backgroundFillFreeformGradientTemp
}

// UnmarshalJSON unmarshal to json
func (backgroundFillFreeformGradient *BackgroundFillFreeformGradient) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Colors []int32 `json:"colors"` // A list of 3 or 4 colors of the freeform gradient in the RGB24 format
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	backgroundFillFreeformGradient.tdCommon = tempObj.tdCommon
	backgroundFillFreeformGradient.Colors = tempObj.Colors

	return nil
}

// GetBackgroundFillEnum return the enum type of this object
func (backgroundFillFreeformGradient *BackgroundFillFreeformGradient) GetBackgroundFillEnum() BackgroundFillEnum {
	return BackgroundFillFreeformGradientType
}

// BackgroundTypeWallpaper A wallpaper in JPEG format
type BackgroundTypeWallpaper struct {
	tdCommon
	IsBlurred bool `json:"is_blurred"` // True, if the wallpaper must be downscaled to fit in 450x450 square and then box-blurred with radius 12
	IsMoving  bool `json:"is_moving"`  // True, if the background needs to be slightly moved when device is tilted
}

// MessageType return the string telegram-type of BackgroundTypeWallpaper
func (backgroundTypeWallpaper *BackgroundTypeWallpaper) MessageType() string {
	return "backgroundTypeWallpaper"
}

// NewBackgroundTypeWallpaper creates a new BackgroundTypeWallpaper
//
// @param isBlurred True, if the wallpaper must be downscaled to fit in 450x450 square and then box-blurred with radius 12
// @param isMoving True, if the background needs to be slightly moved when device is tilted
func NewBackgroundTypeWallpaper(isBlurred bool, isMoving bool) *BackgroundTypeWallpaper {
	backgroundTypeWallpaperTemp := BackgroundTypeWallpaper{
		tdCommon:  tdCommon{Type: "backgroundTypeWallpaper"},
		IsBlurred: isBlurred,
		IsMoving:  isMoving,
	}

	return &backgroundTypeWallpaperTemp
}

// UnmarshalJSON unmarshal to json
func (backgroundTypeWallpaper *BackgroundTypeWallpaper) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsBlurred bool `json:"is_blurred"` // True, if the wallpaper must be downscaled to fit in 450x450 square and then box-blurred with radius 12
		IsMoving  bool `json:"is_moving"`  // True, if the background needs to be slightly moved when device is tilted
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	backgroundTypeWallpaper.tdCommon = tempObj.tdCommon
	backgroundTypeWallpaper.IsBlurred = tempObj.IsBlurred
	backgroundTypeWallpaper.IsMoving = tempObj.IsMoving

	return nil
}

// GetBackgroundTypeEnum return the enum type of this object
func (backgroundTypeWallpaper *BackgroundTypeWallpaper) GetBackgroundTypeEnum() BackgroundTypeEnum {
	return BackgroundTypeWallpaperType
}

// BackgroundTypePattern A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern") pattern to be combined with the background fill chosen by the user
type BackgroundTypePattern struct {
	tdCommon
	Fill       BackgroundFill `json:"fill"`        // Fill of the background
	Intensity  int32          `json:"intensity"`   // Intensity of the pattern when it is shown above the filled background; 0-100
	IsInverted bool           `json:"is_inverted"` // True, if the background fill must be applied only to the pattern itself. All other pixels are black in this case. For dark themes only
	IsMoving   bool           `json:"is_moving"`   // True, if the background needs to be slightly moved when device is tilted
}

// MessageType return the string telegram-type of BackgroundTypePattern
func (backgroundTypePattern *BackgroundTypePattern) MessageType() string {
	return "backgroundTypePattern"
}

// NewBackgroundTypePattern creates a new BackgroundTypePattern
//
// @param fill Fill of the background
// @param intensity Intensity of the pattern when it is shown above the filled background; 0-100
// @param isInverted True, if the background fill must be applied only to the pattern itself. All other pixels are black in this case. For dark themes only
// @param isMoving True, if the background needs to be slightly moved when device is tilted
func NewBackgroundTypePattern(fill BackgroundFill, intensity int32, isInverted bool, isMoving bool) *BackgroundTypePattern {
	backgroundTypePatternTemp := BackgroundTypePattern{
		tdCommon:   tdCommon{Type: "backgroundTypePattern"},
		Fill:       fill,
		Intensity:  intensity,
		IsInverted: isInverted,
		IsMoving:   isMoving,
	}

	return &backgroundTypePatternTemp
}

// UnmarshalJSON unmarshal to json
func (backgroundTypePattern *BackgroundTypePattern) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Intensity  int32 `json:"intensity"`   // Intensity of the pattern when it is shown above the filled background; 0-100
		IsInverted bool  `json:"is_inverted"` // True, if the background fill must be applied only to the pattern itself. All other pixels are black in this case. For dark themes only
		IsMoving   bool  `json:"is_moving"`   // True, if the background needs to be slightly moved when device is tilted
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	backgroundTypePattern.tdCommon = tempObj.tdCommon
	backgroundTypePattern.Intensity = tempObj.Intensity
	backgroundTypePattern.IsInverted = tempObj.IsInverted
	backgroundTypePattern.IsMoving = tempObj.IsMoving

	fieldFill, _ := unmarshalBackgroundFill(objMap["fill"])
	backgroundTypePattern.Fill = fieldFill

	return nil
}

// GetBackgroundTypeEnum return the enum type of this object
func (backgroundTypePattern *BackgroundTypePattern) GetBackgroundTypeEnum() BackgroundTypeEnum {
	return BackgroundTypePatternType
}

// BackgroundTypeFill A filled background
type BackgroundTypeFill struct {
	tdCommon
	Fill BackgroundFill `json:"fill"` // The background fill
}

// MessageType return the string telegram-type of BackgroundTypeFill
func (backgroundTypeFill *BackgroundTypeFill) MessageType() string {
	return "backgroundTypeFill"
}

// NewBackgroundTypeFill creates a new BackgroundTypeFill
//
// @param fill The background fill
func NewBackgroundTypeFill(fill BackgroundFill) *BackgroundTypeFill {
	backgroundTypeFillTemp := BackgroundTypeFill{
		tdCommon: tdCommon{Type: "backgroundTypeFill"},
		Fill:     fill,
	}

	return &backgroundTypeFillTemp
}

// UnmarshalJSON unmarshal to json
func (backgroundTypeFill *BackgroundTypeFill) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	backgroundTypeFill.tdCommon = tempObj.tdCommon

	fieldFill, _ := unmarshalBackgroundFill(objMap["fill"])
	backgroundTypeFill.Fill = fieldFill

	return nil
}

// GetBackgroundTypeEnum return the enum type of this object
func (backgroundTypeFill *BackgroundTypeFill) GetBackgroundTypeEnum() BackgroundTypeEnum {
	return BackgroundTypeFillType
}

// BackgroundTypeChatTheme A background from a chat theme; can be used only as a chat background in channels
type BackgroundTypeChatTheme struct {
	tdCommon
	ThemeName string `json:"theme_name"` // Name of the chat theme
}

// MessageType return the string telegram-type of BackgroundTypeChatTheme
func (backgroundTypeChatTheme *BackgroundTypeChatTheme) MessageType() string {
	return "backgroundTypeChatTheme"
}

// NewBackgroundTypeChatTheme creates a new BackgroundTypeChatTheme
//
// @param themeName Name of the chat theme
func NewBackgroundTypeChatTheme(themeName string) *BackgroundTypeChatTheme {
	backgroundTypeChatThemeTemp := BackgroundTypeChatTheme{
		tdCommon:  tdCommon{Type: "backgroundTypeChatTheme"},
		ThemeName: themeName,
	}

	return &backgroundTypeChatThemeTemp
}

// UnmarshalJSON unmarshal to json
func (backgroundTypeChatTheme *BackgroundTypeChatTheme) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ThemeName string `json:"theme_name"` // Name of the chat theme
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	backgroundTypeChatTheme.tdCommon = tempObj.tdCommon
	backgroundTypeChatTheme.ThemeName = tempObj.ThemeName

	return nil
}

// GetBackgroundTypeEnum return the enum type of this object
func (backgroundTypeChatTheme *BackgroundTypeChatTheme) GetBackgroundTypeEnum() BackgroundTypeEnum {
	return BackgroundTypeChatThemeType
}

// InputBackgroundLocal A background from a local file
type InputBackgroundLocal struct {
	tdCommon
	Background InputFile `json:"background"` // Background file to use. Only inputFileLocal and inputFileGenerated are supported. The file must be in JPEG format for wallpapers and in PNG format for patterns
}

// MessageType return the string telegram-type of InputBackgroundLocal
func (inputBackgroundLocal *InputBackgroundLocal) MessageType() string {
	return "inputBackgroundLocal"
}

// NewInputBackgroundLocal creates a new InputBackgroundLocal
//
// @param background Background file to use. Only inputFileLocal and inputFileGenerated are supported. The file must be in JPEG format for wallpapers and in PNG format for patterns
func NewInputBackgroundLocal(background InputFile) *InputBackgroundLocal {
	inputBackgroundLocalTemp := InputBackgroundLocal{
		tdCommon:   tdCommon{Type: "inputBackgroundLocal"},
		Background: background,
	}

	return &inputBackgroundLocalTemp
}

// UnmarshalJSON unmarshal to json
func (inputBackgroundLocal *InputBackgroundLocal) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputBackgroundLocal.tdCommon = tempObj.tdCommon

	fieldBackground, _ := unmarshalInputFile(objMap["background"])
	inputBackgroundLocal.Background = fieldBackground

	return nil
}

// GetInputBackgroundEnum return the enum type of this object
func (inputBackgroundLocal *InputBackgroundLocal) GetInputBackgroundEnum() InputBackgroundEnum {
	return InputBackgroundLocalType
}

// InputBackgroundRemote A background from the server
type InputBackgroundRemote struct {
	tdCommon
	BackgroundID JSONInt64 `json:"background_id"` // The background identifier
}

// MessageType return the string telegram-type of InputBackgroundRemote
func (inputBackgroundRemote *InputBackgroundRemote) MessageType() string {
	return "inputBackgroundRemote"
}

// NewInputBackgroundRemote creates a new InputBackgroundRemote
//
// @param backgroundID The background identifier
func NewInputBackgroundRemote(backgroundID JSONInt64) *InputBackgroundRemote {
	inputBackgroundRemoteTemp := InputBackgroundRemote{
		tdCommon:     tdCommon{Type: "inputBackgroundRemote"},
		BackgroundID: backgroundID,
	}

	return &inputBackgroundRemoteTemp
}

// UnmarshalJSON unmarshal to json
func (inputBackgroundRemote *InputBackgroundRemote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BackgroundID JSONInt64 `json:"background_id"` // The background identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputBackgroundRemote.tdCommon = tempObj.tdCommon
	inputBackgroundRemote.BackgroundID = tempObj.BackgroundID

	return nil
}

// GetInputBackgroundEnum return the enum type of this object
func (inputBackgroundRemote *InputBackgroundRemote) GetInputBackgroundEnum() InputBackgroundEnum {
	return InputBackgroundRemoteType
}

// InputBackgroundPrevious A background previously set in the chat; for chat backgrounds only
type InputBackgroundPrevious struct {
	tdCommon
	MessageID int64 `json:"message_id"` // Identifier of the message with the background
}

// MessageType return the string telegram-type of InputBackgroundPrevious
func (inputBackgroundPrevious *InputBackgroundPrevious) MessageType() string {
	return "inputBackgroundPrevious"
}

// NewInputBackgroundPrevious creates a new InputBackgroundPrevious
//
// @param messageID Identifier of the message with the background
func NewInputBackgroundPrevious(messageID int64) *InputBackgroundPrevious {
	inputBackgroundPreviousTemp := InputBackgroundPrevious{
		tdCommon:  tdCommon{Type: "inputBackgroundPrevious"},
		MessageID: messageID,
	}

	return &inputBackgroundPreviousTemp
}

// UnmarshalJSON unmarshal to json
func (inputBackgroundPrevious *InputBackgroundPrevious) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MessageID int64 `json:"message_id"` // Identifier of the message with the background
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputBackgroundPrevious.tdCommon = tempObj.tdCommon
	inputBackgroundPrevious.MessageID = tempObj.MessageID

	return nil
}

// GetInputBackgroundEnum return the enum type of this object
func (inputBackgroundPrevious *InputBackgroundPrevious) GetInputBackgroundEnum() InputBackgroundEnum {
	return InputBackgroundPreviousType
}

// ChatTheme Describes a chat theme
type ChatTheme struct {
	tdCommon
	Name          string         `json:"name"`           // Theme name
	LightSettings *ThemeSettings `json:"light_settings"` // Theme settings for a light chat theme
	DarkSettings  *ThemeSettings `json:"dark_settings"`  // Theme settings for a dark chat theme
}

// MessageType return the string telegram-type of ChatTheme
func (chatTheme *ChatTheme) MessageType() string {
	return "chatTheme"
}

// NewChatTheme creates a new ChatTheme
//
// @param name Theme name
// @param lightSettings Theme settings for a light chat theme
// @param darkSettings Theme settings for a dark chat theme
func NewChatTheme(name string, lightSettings *ThemeSettings, darkSettings *ThemeSettings) *ChatTheme {
	chatThemeTemp := ChatTheme{
		tdCommon:      tdCommon{Type: "chatTheme"},
		Name:          name,
		LightSettings: lightSettings,
		DarkSettings:  darkSettings,
	}

	return &chatThemeTemp
}

// UnmarshalJSON unmarshal to json
func (chatTheme *ChatTheme) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Name string `json:"name"` // Theme name

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatTheme.tdCommon = tempObj.tdCommon
	chatTheme.Name = tempObj.Name

	var lightSettings ThemeSettings
	if objMap["light_settings"] != nil {
		err = lightSettings.UnmarshalJSON(*objMap["light_settings"])
		if err != nil {
			return err
		}
	}

	chatTheme.LightSettings = &lightSettings

	var darkSettings ThemeSettings
	if objMap["dark_settings"] != nil {
		err = darkSettings.UnmarshalJSON(*objMap["dark_settings"])
		if err != nil {
			return err
		}
	}

	chatTheme.DarkSettings = &darkSettings

	return nil
}

// TimeZone Describes a time zone
type TimeZone struct {
	tdCommon
	ID            string `json:"id"`              // Unique time zone identifier
	Name          string `json:"name"`            // Time zone name
	UtcTimeOffset int32  `json:"utc_time_offset"` // Current UTC time offset for the time zone
}

// MessageType return the string telegram-type of TimeZone
func (timeZone *TimeZone) MessageType() string {
	return "timeZone"
}

// NewTimeZone creates a new TimeZone
//
// @param iD Unique time zone identifier
// @param name Time zone name
// @param utcTimeOffset Current UTC time offset for the time zone
func NewTimeZone(iD string, name string, utcTimeOffset int32) *TimeZone {
	timeZoneTemp := TimeZone{
		tdCommon:      tdCommon{Type: "timeZone"},
		ID:            iD,
		Name:          name,
		UtcTimeOffset: utcTimeOffset,
	}

	return &timeZoneTemp
}

// UnmarshalJSON unmarshal to json
func (timeZone *TimeZone) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID            string `json:"id"`              // Unique time zone identifier
		Name          string `json:"name"`            // Time zone name
		UtcTimeOffset int32  `json:"utc_time_offset"` // Current UTC time offset for the time zone
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	timeZone.tdCommon = tempObj.tdCommon
	timeZone.ID = tempObj.ID
	timeZone.Name = tempObj.Name
	timeZone.UtcTimeOffset = tempObj.UtcTimeOffset

	return nil
}

// TimeZones Contains a list of time zones
type TimeZones struct {
	tdCommon
	TimeZones []TimeZone `json:"time_zones"` // A list of time zones
}

// MessageType return the string telegram-type of TimeZones
func (timeZones *TimeZones) MessageType() string {
	return "timeZones"
}

// NewTimeZones creates a new TimeZones
//
// @param timeZones A list of time zones
func NewTimeZones(timeZones []TimeZone) *TimeZones {
	timeZonesTemp := TimeZones{
		tdCommon:  tdCommon{Type: "timeZones"},
		TimeZones: timeZones,
	}

	return &timeZonesTemp
}

// UnmarshalJSON unmarshal to json
func (timeZones *TimeZones) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TimeZones []TimeZone `json:"time_zones"` // A list of time zones
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	timeZones.tdCommon = tempObj.tdCommon
	timeZones.TimeZones = tempObj.TimeZones

	return nil
}

// Hashtags Contains a list of hashtags
type Hashtags struct {
	tdCommon
	Hashtags []string `json:"hashtags"` // A list of hashtags
}

// MessageType return the string telegram-type of Hashtags
func (hashtags *Hashtags) MessageType() string {
	return "hashtags"
}

// NewHashtags creates a new Hashtags
//
// @param hashtags A list of hashtags
func NewHashtags(hashtags []string) *Hashtags {
	hashtagsTemp := Hashtags{
		tdCommon: tdCommon{Type: "hashtags"},
		Hashtags: hashtags,
	}

	return &hashtagsTemp
}

// UnmarshalJSON unmarshal to json
func (hashtags *Hashtags) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Hashtags []string `json:"hashtags"` // A list of hashtags
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	hashtags.tdCommon = tempObj.tdCommon
	hashtags.Hashtags = tempObj.Hashtags

	return nil
}

// CanSendStoryResultOk A story can be sent
type CanSendStoryResultOk struct {
	tdCommon
}

// MessageType return the string telegram-type of CanSendStoryResultOk
func (canSendStoryResultOk *CanSendStoryResultOk) MessageType() string {
	return "canSendStoryResultOk"
}

// NewCanSendStoryResultOk creates a new CanSendStoryResultOk
//
func NewCanSendStoryResultOk() *CanSendStoryResultOk {
	canSendStoryResultOkTemp := CanSendStoryResultOk{
		tdCommon: tdCommon{Type: "canSendStoryResultOk"},
	}

	return &canSendStoryResultOkTemp
}

// UnmarshalJSON unmarshal to json
func (canSendStoryResultOk *CanSendStoryResultOk) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	canSendStoryResultOk.tdCommon = tempObj.tdCommon

	return nil
}

// GetCanSendStoryResultEnum return the enum type of this object
func (canSendStoryResultOk *CanSendStoryResultOk) GetCanSendStoryResultEnum() CanSendStoryResultEnum {
	return CanSendStoryResultOkType
}

// CanSendStoryResultPremiumNeeded The user must subscribe to Telegram Premium to be able to post stories
type CanSendStoryResultPremiumNeeded struct {
	tdCommon
}

// MessageType return the string telegram-type of CanSendStoryResultPremiumNeeded
func (canSendStoryResultPremiumNeeded *CanSendStoryResultPremiumNeeded) MessageType() string {
	return "canSendStoryResultPremiumNeeded"
}

// NewCanSendStoryResultPremiumNeeded creates a new CanSendStoryResultPremiumNeeded
//
func NewCanSendStoryResultPremiumNeeded() *CanSendStoryResultPremiumNeeded {
	canSendStoryResultPremiumNeededTemp := CanSendStoryResultPremiumNeeded{
		tdCommon: tdCommon{Type: "canSendStoryResultPremiumNeeded"},
	}

	return &canSendStoryResultPremiumNeededTemp
}

// UnmarshalJSON unmarshal to json
func (canSendStoryResultPremiumNeeded *CanSendStoryResultPremiumNeeded) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	canSendStoryResultPremiumNeeded.tdCommon = tempObj.tdCommon

	return nil
}

// GetCanSendStoryResultEnum return the enum type of this object
func (canSendStoryResultPremiumNeeded *CanSendStoryResultPremiumNeeded) GetCanSendStoryResultEnum() CanSendStoryResultEnum {
	return CanSendStoryResultPremiumNeededType
}

// CanSendStoryResultBoostNeeded The chat must be boosted first by Telegram Premium subscribers to post more stories. Call getChatBoostStatus to get current boost status of the chat
type CanSendStoryResultBoostNeeded struct {
	tdCommon
}

// MessageType return the string telegram-type of CanSendStoryResultBoostNeeded
func (canSendStoryResultBoostNeeded *CanSendStoryResultBoostNeeded) MessageType() string {
	return "canSendStoryResultBoostNeeded"
}

// NewCanSendStoryResultBoostNeeded creates a new CanSendStoryResultBoostNeeded
//
func NewCanSendStoryResultBoostNeeded() *CanSendStoryResultBoostNeeded {
	canSendStoryResultBoostNeededTemp := CanSendStoryResultBoostNeeded{
		tdCommon: tdCommon{Type: "canSendStoryResultBoostNeeded"},
	}

	return &canSendStoryResultBoostNeededTemp
}

// UnmarshalJSON unmarshal to json
func (canSendStoryResultBoostNeeded *CanSendStoryResultBoostNeeded) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	canSendStoryResultBoostNeeded.tdCommon = tempObj.tdCommon

	return nil
}

// GetCanSendStoryResultEnum return the enum type of this object
func (canSendStoryResultBoostNeeded *CanSendStoryResultBoostNeeded) GetCanSendStoryResultEnum() CanSendStoryResultEnum {
	return CanSendStoryResultBoostNeededType
}

// CanSendStoryResultActiveStoryLimitExceeded The limit for the number of active stories exceeded. The user can buy Telegram Premium, delete an active story, or wait for the oldest story to expire
type CanSendStoryResultActiveStoryLimitExceeded struct {
	tdCommon
}

// MessageType return the string telegram-type of CanSendStoryResultActiveStoryLimitExceeded
func (canSendStoryResultActiveStoryLimitExceeded *CanSendStoryResultActiveStoryLimitExceeded) MessageType() string {
	return "canSendStoryResultActiveStoryLimitExceeded"
}

// NewCanSendStoryResultActiveStoryLimitExceeded creates a new CanSendStoryResultActiveStoryLimitExceeded
//
func NewCanSendStoryResultActiveStoryLimitExceeded() *CanSendStoryResultActiveStoryLimitExceeded {
	canSendStoryResultActiveStoryLimitExceededTemp := CanSendStoryResultActiveStoryLimitExceeded{
		tdCommon: tdCommon{Type: "canSendStoryResultActiveStoryLimitExceeded"},
	}

	return &canSendStoryResultActiveStoryLimitExceededTemp
}

// UnmarshalJSON unmarshal to json
func (canSendStoryResultActiveStoryLimitExceeded *CanSendStoryResultActiveStoryLimitExceeded) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	canSendStoryResultActiveStoryLimitExceeded.tdCommon = tempObj.tdCommon

	return nil
}

// GetCanSendStoryResultEnum return the enum type of this object
func (canSendStoryResultActiveStoryLimitExceeded *CanSendStoryResultActiveStoryLimitExceeded) GetCanSendStoryResultEnum() CanSendStoryResultEnum {
	return CanSendStoryResultActiveStoryLimitExceededType
}

// CanSendStoryResultWeeklyLimitExceeded The weekly limit for the number of posted stories exceeded. The user needs to buy Telegram Premium or wait specified time
type CanSendStoryResultWeeklyLimitExceeded struct {
	tdCommon
	RetryAfter int32 `json:"retry_after"` // Time left before the user can send the next story
}

// MessageType return the string telegram-type of CanSendStoryResultWeeklyLimitExceeded
func (canSendStoryResultWeeklyLimitExceeded *CanSendStoryResultWeeklyLimitExceeded) MessageType() string {
	return "canSendStoryResultWeeklyLimitExceeded"
}

// NewCanSendStoryResultWeeklyLimitExceeded creates a new CanSendStoryResultWeeklyLimitExceeded
//
// @param retryAfter Time left before the user can send the next story
func NewCanSendStoryResultWeeklyLimitExceeded(retryAfter int32) *CanSendStoryResultWeeklyLimitExceeded {
	canSendStoryResultWeeklyLimitExceededTemp := CanSendStoryResultWeeklyLimitExceeded{
		tdCommon:   tdCommon{Type: "canSendStoryResultWeeklyLimitExceeded"},
		RetryAfter: retryAfter,
	}

	return &canSendStoryResultWeeklyLimitExceededTemp
}

// UnmarshalJSON unmarshal to json
func (canSendStoryResultWeeklyLimitExceeded *CanSendStoryResultWeeklyLimitExceeded) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		RetryAfter int32 `json:"retry_after"` // Time left before the user can send the next story
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	canSendStoryResultWeeklyLimitExceeded.tdCommon = tempObj.tdCommon
	canSendStoryResultWeeklyLimitExceeded.RetryAfter = tempObj.RetryAfter

	return nil
}

// GetCanSendStoryResultEnum return the enum type of this object
func (canSendStoryResultWeeklyLimitExceeded *CanSendStoryResultWeeklyLimitExceeded) GetCanSendStoryResultEnum() CanSendStoryResultEnum {
	return CanSendStoryResultWeeklyLimitExceededType
}

// CanSendStoryResultMonthlyLimitExceeded The monthly limit for the number of posted stories exceeded. The user needs to buy Telegram Premium or wait specified time
type CanSendStoryResultMonthlyLimitExceeded struct {
	tdCommon
	RetryAfter int32 `json:"retry_after"` // Time left before the user can send the next story
}

// MessageType return the string telegram-type of CanSendStoryResultMonthlyLimitExceeded
func (canSendStoryResultMonthlyLimitExceeded *CanSendStoryResultMonthlyLimitExceeded) MessageType() string {
	return "canSendStoryResultMonthlyLimitExceeded"
}

// NewCanSendStoryResultMonthlyLimitExceeded creates a new CanSendStoryResultMonthlyLimitExceeded
//
// @param retryAfter Time left before the user can send the next story
func NewCanSendStoryResultMonthlyLimitExceeded(retryAfter int32) *CanSendStoryResultMonthlyLimitExceeded {
	canSendStoryResultMonthlyLimitExceededTemp := CanSendStoryResultMonthlyLimitExceeded{
		tdCommon:   tdCommon{Type: "canSendStoryResultMonthlyLimitExceeded"},
		RetryAfter: retryAfter,
	}

	return &canSendStoryResultMonthlyLimitExceededTemp
}

// UnmarshalJSON unmarshal to json
func (canSendStoryResultMonthlyLimitExceeded *CanSendStoryResultMonthlyLimitExceeded) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		RetryAfter int32 `json:"retry_after"` // Time left before the user can send the next story
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	canSendStoryResultMonthlyLimitExceeded.tdCommon = tempObj.tdCommon
	canSendStoryResultMonthlyLimitExceeded.RetryAfter = tempObj.RetryAfter

	return nil
}

// GetCanSendStoryResultEnum return the enum type of this object
func (canSendStoryResultMonthlyLimitExceeded *CanSendStoryResultMonthlyLimitExceeded) GetCanSendStoryResultEnum() CanSendStoryResultEnum {
	return CanSendStoryResultMonthlyLimitExceededType
}

// CanTransferOwnershipResultOk The session can be used
type CanTransferOwnershipResultOk struct {
	tdCommon
}

// MessageType return the string telegram-type of CanTransferOwnershipResultOk
func (canTransferOwnershipResultOk *CanTransferOwnershipResultOk) MessageType() string {
	return "canTransferOwnershipResultOk"
}

// NewCanTransferOwnershipResultOk creates a new CanTransferOwnershipResultOk
//
func NewCanTransferOwnershipResultOk() *CanTransferOwnershipResultOk {
	canTransferOwnershipResultOkTemp := CanTransferOwnershipResultOk{
		tdCommon: tdCommon{Type: "canTransferOwnershipResultOk"},
	}

	return &canTransferOwnershipResultOkTemp
}

// UnmarshalJSON unmarshal to json
func (canTransferOwnershipResultOk *CanTransferOwnershipResultOk) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	canTransferOwnershipResultOk.tdCommon = tempObj.tdCommon

	return nil
}

// GetCanTransferOwnershipResultEnum return the enum type of this object
func (canTransferOwnershipResultOk *CanTransferOwnershipResultOk) GetCanTransferOwnershipResultEnum() CanTransferOwnershipResultEnum {
	return CanTransferOwnershipResultOkType
}

// CanTransferOwnershipResultPasswordNeeded The 2-step verification needs to be enabled first
type CanTransferOwnershipResultPasswordNeeded struct {
	tdCommon
}

// MessageType return the string telegram-type of CanTransferOwnershipResultPasswordNeeded
func (canTransferOwnershipResultPasswordNeeded *CanTransferOwnershipResultPasswordNeeded) MessageType() string {
	return "canTransferOwnershipResultPasswordNeeded"
}

// NewCanTransferOwnershipResultPasswordNeeded creates a new CanTransferOwnershipResultPasswordNeeded
//
func NewCanTransferOwnershipResultPasswordNeeded() *CanTransferOwnershipResultPasswordNeeded {
	canTransferOwnershipResultPasswordNeededTemp := CanTransferOwnershipResultPasswordNeeded{
		tdCommon: tdCommon{Type: "canTransferOwnershipResultPasswordNeeded"},
	}

	return &canTransferOwnershipResultPasswordNeededTemp
}

// UnmarshalJSON unmarshal to json
func (canTransferOwnershipResultPasswordNeeded *CanTransferOwnershipResultPasswordNeeded) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	canTransferOwnershipResultPasswordNeeded.tdCommon = tempObj.tdCommon

	return nil
}

// GetCanTransferOwnershipResultEnum return the enum type of this object
func (canTransferOwnershipResultPasswordNeeded *CanTransferOwnershipResultPasswordNeeded) GetCanTransferOwnershipResultEnum() CanTransferOwnershipResultEnum {
	return CanTransferOwnershipResultPasswordNeededType
}

// CanTransferOwnershipResultPasswordTooFresh The 2-step verification was enabled recently, user needs to wait
type CanTransferOwnershipResultPasswordTooFresh struct {
	tdCommon
	RetryAfter int32 `json:"retry_after"` // Time left before the session can be used to transfer ownership of a chat, in seconds
}

// MessageType return the string telegram-type of CanTransferOwnershipResultPasswordTooFresh
func (canTransferOwnershipResultPasswordTooFresh *CanTransferOwnershipResultPasswordTooFresh) MessageType() string {
	return "canTransferOwnershipResultPasswordTooFresh"
}

// NewCanTransferOwnershipResultPasswordTooFresh creates a new CanTransferOwnershipResultPasswordTooFresh
//
// @param retryAfter Time left before the session can be used to transfer ownership of a chat, in seconds
func NewCanTransferOwnershipResultPasswordTooFresh(retryAfter int32) *CanTransferOwnershipResultPasswordTooFresh {
	canTransferOwnershipResultPasswordTooFreshTemp := CanTransferOwnershipResultPasswordTooFresh{
		tdCommon:   tdCommon{Type: "canTransferOwnershipResultPasswordTooFresh"},
		RetryAfter: retryAfter,
	}

	return &canTransferOwnershipResultPasswordTooFreshTemp
}

// UnmarshalJSON unmarshal to json
func (canTransferOwnershipResultPasswordTooFresh *CanTransferOwnershipResultPasswordTooFresh) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		RetryAfter int32 `json:"retry_after"` // Time left before the session can be used to transfer ownership of a chat, in seconds
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	canTransferOwnershipResultPasswordTooFresh.tdCommon = tempObj.tdCommon
	canTransferOwnershipResultPasswordTooFresh.RetryAfter = tempObj.RetryAfter

	return nil
}

// GetCanTransferOwnershipResultEnum return the enum type of this object
func (canTransferOwnershipResultPasswordTooFresh *CanTransferOwnershipResultPasswordTooFresh) GetCanTransferOwnershipResultEnum() CanTransferOwnershipResultEnum {
	return CanTransferOwnershipResultPasswordTooFreshType
}

// CanTransferOwnershipResultSessionTooFresh The session was created recently, user needs to wait
type CanTransferOwnershipResultSessionTooFresh struct {
	tdCommon
	RetryAfter int32 `json:"retry_after"` // Time left before the session can be used to transfer ownership of a chat, in seconds
}

// MessageType return the string telegram-type of CanTransferOwnershipResultSessionTooFresh
func (canTransferOwnershipResultSessionTooFresh *CanTransferOwnershipResultSessionTooFresh) MessageType() string {
	return "canTransferOwnershipResultSessionTooFresh"
}

// NewCanTransferOwnershipResultSessionTooFresh creates a new CanTransferOwnershipResultSessionTooFresh
//
// @param retryAfter Time left before the session can be used to transfer ownership of a chat, in seconds
func NewCanTransferOwnershipResultSessionTooFresh(retryAfter int32) *CanTransferOwnershipResultSessionTooFresh {
	canTransferOwnershipResultSessionTooFreshTemp := CanTransferOwnershipResultSessionTooFresh{
		tdCommon:   tdCommon{Type: "canTransferOwnershipResultSessionTooFresh"},
		RetryAfter: retryAfter,
	}

	return &canTransferOwnershipResultSessionTooFreshTemp
}

// UnmarshalJSON unmarshal to json
func (canTransferOwnershipResultSessionTooFresh *CanTransferOwnershipResultSessionTooFresh) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		RetryAfter int32 `json:"retry_after"` // Time left before the session can be used to transfer ownership of a chat, in seconds
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	canTransferOwnershipResultSessionTooFresh.tdCommon = tempObj.tdCommon
	canTransferOwnershipResultSessionTooFresh.RetryAfter = tempObj.RetryAfter

	return nil
}

// GetCanTransferOwnershipResultEnum return the enum type of this object
func (canTransferOwnershipResultSessionTooFresh *CanTransferOwnershipResultSessionTooFresh) GetCanTransferOwnershipResultEnum() CanTransferOwnershipResultEnum {
	return CanTransferOwnershipResultSessionTooFreshType
}

// CheckChatUsernameResultOk The username can be set
type CheckChatUsernameResultOk struct {
	tdCommon
}

// MessageType return the string telegram-type of CheckChatUsernameResultOk
func (checkChatUsernameResultOk *CheckChatUsernameResultOk) MessageType() string {
	return "checkChatUsernameResultOk"
}

// NewCheckChatUsernameResultOk creates a new CheckChatUsernameResultOk
//
func NewCheckChatUsernameResultOk() *CheckChatUsernameResultOk {
	checkChatUsernameResultOkTemp := CheckChatUsernameResultOk{
		tdCommon: tdCommon{Type: "checkChatUsernameResultOk"},
	}

	return &checkChatUsernameResultOkTemp
}

// UnmarshalJSON unmarshal to json
func (checkChatUsernameResultOk *CheckChatUsernameResultOk) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	checkChatUsernameResultOk.tdCommon = tempObj.tdCommon

	return nil
}

// GetCheckChatUsernameResultEnum return the enum type of this object
func (checkChatUsernameResultOk *CheckChatUsernameResultOk) GetCheckChatUsernameResultEnum() CheckChatUsernameResultEnum {
	return CheckChatUsernameResultOkType
}

// CheckChatUsernameResultUsernameInvalid The username is invalid
type CheckChatUsernameResultUsernameInvalid struct {
	tdCommon
}

// MessageType return the string telegram-type of CheckChatUsernameResultUsernameInvalid
func (checkChatUsernameResultUsernameInvalid *CheckChatUsernameResultUsernameInvalid) MessageType() string {
	return "checkChatUsernameResultUsernameInvalid"
}

// NewCheckChatUsernameResultUsernameInvalid creates a new CheckChatUsernameResultUsernameInvalid
//
func NewCheckChatUsernameResultUsernameInvalid() *CheckChatUsernameResultUsernameInvalid {
	checkChatUsernameResultUsernameInvalidTemp := CheckChatUsernameResultUsernameInvalid{
		tdCommon: tdCommon{Type: "checkChatUsernameResultUsernameInvalid"},
	}

	return &checkChatUsernameResultUsernameInvalidTemp
}

// UnmarshalJSON unmarshal to json
func (checkChatUsernameResultUsernameInvalid *CheckChatUsernameResultUsernameInvalid) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	checkChatUsernameResultUsernameInvalid.tdCommon = tempObj.tdCommon

	return nil
}

// GetCheckChatUsernameResultEnum return the enum type of this object
func (checkChatUsernameResultUsernameInvalid *CheckChatUsernameResultUsernameInvalid) GetCheckChatUsernameResultEnum() CheckChatUsernameResultEnum {
	return CheckChatUsernameResultUsernameInvalidType
}

// CheckChatUsernameResultUsernameOccupied The username is occupied
type CheckChatUsernameResultUsernameOccupied struct {
	tdCommon
}

// MessageType return the string telegram-type of CheckChatUsernameResultUsernameOccupied
func (checkChatUsernameResultUsernameOccupied *CheckChatUsernameResultUsernameOccupied) MessageType() string {
	return "checkChatUsernameResultUsernameOccupied"
}

// NewCheckChatUsernameResultUsernameOccupied creates a new CheckChatUsernameResultUsernameOccupied
//
func NewCheckChatUsernameResultUsernameOccupied() *CheckChatUsernameResultUsernameOccupied {
	checkChatUsernameResultUsernameOccupiedTemp := CheckChatUsernameResultUsernameOccupied{
		tdCommon: tdCommon{Type: "checkChatUsernameResultUsernameOccupied"},
	}

	return &checkChatUsernameResultUsernameOccupiedTemp
}

// UnmarshalJSON unmarshal to json
func (checkChatUsernameResultUsernameOccupied *CheckChatUsernameResultUsernameOccupied) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	checkChatUsernameResultUsernameOccupied.tdCommon = tempObj.tdCommon

	return nil
}

// GetCheckChatUsernameResultEnum return the enum type of this object
func (checkChatUsernameResultUsernameOccupied *CheckChatUsernameResultUsernameOccupied) GetCheckChatUsernameResultEnum() CheckChatUsernameResultEnum {
	return CheckChatUsernameResultUsernameOccupiedType
}

// CheckChatUsernameResultUsernamePurchasable The username can be purchased at https://fragment.com. Information about the username can be received using getCollectibleItemInfo
type CheckChatUsernameResultUsernamePurchasable struct {
	tdCommon
}

// MessageType return the string telegram-type of CheckChatUsernameResultUsernamePurchasable
func (checkChatUsernameResultUsernamePurchasable *CheckChatUsernameResultUsernamePurchasable) MessageType() string {
	return "checkChatUsernameResultUsernamePurchasable"
}

// NewCheckChatUsernameResultUsernamePurchasable creates a new CheckChatUsernameResultUsernamePurchasable
//
func NewCheckChatUsernameResultUsernamePurchasable() *CheckChatUsernameResultUsernamePurchasable {
	checkChatUsernameResultUsernamePurchasableTemp := CheckChatUsernameResultUsernamePurchasable{
		tdCommon: tdCommon{Type: "checkChatUsernameResultUsernamePurchasable"},
	}

	return &checkChatUsernameResultUsernamePurchasableTemp
}

// UnmarshalJSON unmarshal to json
func (checkChatUsernameResultUsernamePurchasable *CheckChatUsernameResultUsernamePurchasable) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	checkChatUsernameResultUsernamePurchasable.tdCommon = tempObj.tdCommon

	return nil
}

// GetCheckChatUsernameResultEnum return the enum type of this object
func (checkChatUsernameResultUsernamePurchasable *CheckChatUsernameResultUsernamePurchasable) GetCheckChatUsernameResultEnum() CheckChatUsernameResultEnum {
	return CheckChatUsernameResultUsernamePurchasableType
}

// CheckChatUsernameResultPublicChatsTooMany The user has too many chats with username, one of them must be made private first
type CheckChatUsernameResultPublicChatsTooMany struct {
	tdCommon
}

// MessageType return the string telegram-type of CheckChatUsernameResultPublicChatsTooMany
func (checkChatUsernameResultPublicChatsTooMany *CheckChatUsernameResultPublicChatsTooMany) MessageType() string {
	return "checkChatUsernameResultPublicChatsTooMany"
}

// NewCheckChatUsernameResultPublicChatsTooMany creates a new CheckChatUsernameResultPublicChatsTooMany
//
func NewCheckChatUsernameResultPublicChatsTooMany() *CheckChatUsernameResultPublicChatsTooMany {
	checkChatUsernameResultPublicChatsTooManyTemp := CheckChatUsernameResultPublicChatsTooMany{
		tdCommon: tdCommon{Type: "checkChatUsernameResultPublicChatsTooMany"},
	}

	return &checkChatUsernameResultPublicChatsTooManyTemp
}

// UnmarshalJSON unmarshal to json
func (checkChatUsernameResultPublicChatsTooMany *CheckChatUsernameResultPublicChatsTooMany) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	checkChatUsernameResultPublicChatsTooMany.tdCommon = tempObj.tdCommon

	return nil
}

// GetCheckChatUsernameResultEnum return the enum type of this object
func (checkChatUsernameResultPublicChatsTooMany *CheckChatUsernameResultPublicChatsTooMany) GetCheckChatUsernameResultEnum() CheckChatUsernameResultEnum {
	return CheckChatUsernameResultPublicChatsTooManyType
}

// CheckChatUsernameResultPublicGroupsUnavailable The user can't be a member of a public supergroup
type CheckChatUsernameResultPublicGroupsUnavailable struct {
	tdCommon
}

// MessageType return the string telegram-type of CheckChatUsernameResultPublicGroupsUnavailable
func (checkChatUsernameResultPublicGroupsUnavailable *CheckChatUsernameResultPublicGroupsUnavailable) MessageType() string {
	return "checkChatUsernameResultPublicGroupsUnavailable"
}

// NewCheckChatUsernameResultPublicGroupsUnavailable creates a new CheckChatUsernameResultPublicGroupsUnavailable
//
func NewCheckChatUsernameResultPublicGroupsUnavailable() *CheckChatUsernameResultPublicGroupsUnavailable {
	checkChatUsernameResultPublicGroupsUnavailableTemp := CheckChatUsernameResultPublicGroupsUnavailable{
		tdCommon: tdCommon{Type: "checkChatUsernameResultPublicGroupsUnavailable"},
	}

	return &checkChatUsernameResultPublicGroupsUnavailableTemp
}

// UnmarshalJSON unmarshal to json
func (checkChatUsernameResultPublicGroupsUnavailable *CheckChatUsernameResultPublicGroupsUnavailable) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	checkChatUsernameResultPublicGroupsUnavailable.tdCommon = tempObj.tdCommon

	return nil
}

// GetCheckChatUsernameResultEnum return the enum type of this object
func (checkChatUsernameResultPublicGroupsUnavailable *CheckChatUsernameResultPublicGroupsUnavailable) GetCheckChatUsernameResultEnum() CheckChatUsernameResultEnum {
	return CheckChatUsernameResultPublicGroupsUnavailableType
}

// CheckStickerSetNameResultOk The name can be set
type CheckStickerSetNameResultOk struct {
	tdCommon
}

// MessageType return the string telegram-type of CheckStickerSetNameResultOk
func (checkStickerSetNameResultOk *CheckStickerSetNameResultOk) MessageType() string {
	return "checkStickerSetNameResultOk"
}

// NewCheckStickerSetNameResultOk creates a new CheckStickerSetNameResultOk
//
func NewCheckStickerSetNameResultOk() *CheckStickerSetNameResultOk {
	checkStickerSetNameResultOkTemp := CheckStickerSetNameResultOk{
		tdCommon: tdCommon{Type: "checkStickerSetNameResultOk"},
	}

	return &checkStickerSetNameResultOkTemp
}

// UnmarshalJSON unmarshal to json
func (checkStickerSetNameResultOk *CheckStickerSetNameResultOk) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	checkStickerSetNameResultOk.tdCommon = tempObj.tdCommon

	return nil
}

// GetCheckStickerSetNameResultEnum return the enum type of this object
func (checkStickerSetNameResultOk *CheckStickerSetNameResultOk) GetCheckStickerSetNameResultEnum() CheckStickerSetNameResultEnum {
	return CheckStickerSetNameResultOkType
}

// CheckStickerSetNameResultNameInvalid The name is invalid
type CheckStickerSetNameResultNameInvalid struct {
	tdCommon
}

// MessageType return the string telegram-type of CheckStickerSetNameResultNameInvalid
func (checkStickerSetNameResultNameInvalid *CheckStickerSetNameResultNameInvalid) MessageType() string {
	return "checkStickerSetNameResultNameInvalid"
}

// NewCheckStickerSetNameResultNameInvalid creates a new CheckStickerSetNameResultNameInvalid
//
func NewCheckStickerSetNameResultNameInvalid() *CheckStickerSetNameResultNameInvalid {
	checkStickerSetNameResultNameInvalidTemp := CheckStickerSetNameResultNameInvalid{
		tdCommon: tdCommon{Type: "checkStickerSetNameResultNameInvalid"},
	}

	return &checkStickerSetNameResultNameInvalidTemp
}

// UnmarshalJSON unmarshal to json
func (checkStickerSetNameResultNameInvalid *CheckStickerSetNameResultNameInvalid) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	checkStickerSetNameResultNameInvalid.tdCommon = tempObj.tdCommon

	return nil
}

// GetCheckStickerSetNameResultEnum return the enum type of this object
func (checkStickerSetNameResultNameInvalid *CheckStickerSetNameResultNameInvalid) GetCheckStickerSetNameResultEnum() CheckStickerSetNameResultEnum {
	return CheckStickerSetNameResultNameInvalidType
}

// CheckStickerSetNameResultNameOccupied The name is occupied
type CheckStickerSetNameResultNameOccupied struct {
	tdCommon
}

// MessageType return the string telegram-type of CheckStickerSetNameResultNameOccupied
func (checkStickerSetNameResultNameOccupied *CheckStickerSetNameResultNameOccupied) MessageType() string {
	return "checkStickerSetNameResultNameOccupied"
}

// NewCheckStickerSetNameResultNameOccupied creates a new CheckStickerSetNameResultNameOccupied
//
func NewCheckStickerSetNameResultNameOccupied() *CheckStickerSetNameResultNameOccupied {
	checkStickerSetNameResultNameOccupiedTemp := CheckStickerSetNameResultNameOccupied{
		tdCommon: tdCommon{Type: "checkStickerSetNameResultNameOccupied"},
	}

	return &checkStickerSetNameResultNameOccupiedTemp
}

// UnmarshalJSON unmarshal to json
func (checkStickerSetNameResultNameOccupied *CheckStickerSetNameResultNameOccupied) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	checkStickerSetNameResultNameOccupied.tdCommon = tempObj.tdCommon

	return nil
}

// GetCheckStickerSetNameResultEnum return the enum type of this object
func (checkStickerSetNameResultNameOccupied *CheckStickerSetNameResultNameOccupied) GetCheckStickerSetNameResultEnum() CheckStickerSetNameResultEnum {
	return CheckStickerSetNameResultNameOccupiedType
}

// ResetPasswordResultOk The password was reset
type ResetPasswordResultOk struct {
	tdCommon
}

// MessageType return the string telegram-type of ResetPasswordResultOk
func (resetPasswordResultOk *ResetPasswordResultOk) MessageType() string {
	return "resetPasswordResultOk"
}

// NewResetPasswordResultOk creates a new ResetPasswordResultOk
//
func NewResetPasswordResultOk() *ResetPasswordResultOk {
	resetPasswordResultOkTemp := ResetPasswordResultOk{
		tdCommon: tdCommon{Type: "resetPasswordResultOk"},
	}

	return &resetPasswordResultOkTemp
}

// UnmarshalJSON unmarshal to json
func (resetPasswordResultOk *ResetPasswordResultOk) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	resetPasswordResultOk.tdCommon = tempObj.tdCommon

	return nil
}

// GetResetPasswordResultEnum return the enum type of this object
func (resetPasswordResultOk *ResetPasswordResultOk) GetResetPasswordResultEnum() ResetPasswordResultEnum {
	return ResetPasswordResultOkType
}

// ResetPasswordResultPending The password reset request is pending
type ResetPasswordResultPending struct {
	tdCommon
	PendingResetDate int32 `json:"pending_reset_date"` // Point in time (Unix timestamp) after which the password can be reset immediately using resetPassword
}

// MessageType return the string telegram-type of ResetPasswordResultPending
func (resetPasswordResultPending *ResetPasswordResultPending) MessageType() string {
	return "resetPasswordResultPending"
}

// NewResetPasswordResultPending creates a new ResetPasswordResultPending
//
// @param pendingResetDate Point in time (Unix timestamp) after which the password can be reset immediately using resetPassword
func NewResetPasswordResultPending(pendingResetDate int32) *ResetPasswordResultPending {
	resetPasswordResultPendingTemp := ResetPasswordResultPending{
		tdCommon:         tdCommon{Type: "resetPasswordResultPending"},
		PendingResetDate: pendingResetDate,
	}

	return &resetPasswordResultPendingTemp
}

// UnmarshalJSON unmarshal to json
func (resetPasswordResultPending *ResetPasswordResultPending) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PendingResetDate int32 `json:"pending_reset_date"` // Point in time (Unix timestamp) after which the password can be reset immediately using resetPassword
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	resetPasswordResultPending.tdCommon = tempObj.tdCommon
	resetPasswordResultPending.PendingResetDate = tempObj.PendingResetDate

	return nil
}

// GetResetPasswordResultEnum return the enum type of this object
func (resetPasswordResultPending *ResetPasswordResultPending) GetResetPasswordResultEnum() ResetPasswordResultEnum {
	return ResetPasswordResultPendingType
}

// ResetPasswordResultDeclined The password reset request was declined
type ResetPasswordResultDeclined struct {
	tdCommon
	RetryDate int32 `json:"retry_date"` // Point in time (Unix timestamp) when the password reset can be retried
}

// MessageType return the string telegram-type of ResetPasswordResultDeclined
func (resetPasswordResultDeclined *ResetPasswordResultDeclined) MessageType() string {
	return "resetPasswordResultDeclined"
}

// NewResetPasswordResultDeclined creates a new ResetPasswordResultDeclined
//
// @param retryDate Point in time (Unix timestamp) when the password reset can be retried
func NewResetPasswordResultDeclined(retryDate int32) *ResetPasswordResultDeclined {
	resetPasswordResultDeclinedTemp := ResetPasswordResultDeclined{
		tdCommon:  tdCommon{Type: "resetPasswordResultDeclined"},
		RetryDate: retryDate,
	}

	return &resetPasswordResultDeclinedTemp
}

// UnmarshalJSON unmarshal to json
func (resetPasswordResultDeclined *ResetPasswordResultDeclined) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		RetryDate int32 `json:"retry_date"` // Point in time (Unix timestamp) when the password reset can be retried
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	resetPasswordResultDeclined.tdCommon = tempObj.tdCommon
	resetPasswordResultDeclined.RetryDate = tempObj.RetryDate

	return nil
}

// GetResetPasswordResultEnum return the enum type of this object
func (resetPasswordResultDeclined *ResetPasswordResultDeclined) GetResetPasswordResultEnum() ResetPasswordResultEnum {
	return ResetPasswordResultDeclinedType
}

// MessageFileTypePrivate The messages were exported from a private chat
type MessageFileTypePrivate struct {
	tdCommon
	Name string `json:"name"` // Name of the other party; may be empty if unrecognized
}

// MessageType return the string telegram-type of MessageFileTypePrivate
func (messageFileTypePrivate *MessageFileTypePrivate) MessageType() string {
	return "messageFileTypePrivate"
}

// NewMessageFileTypePrivate creates a new MessageFileTypePrivate
//
// @param name Name of the other party; may be empty if unrecognized
func NewMessageFileTypePrivate(name string) *MessageFileTypePrivate {
	messageFileTypePrivateTemp := MessageFileTypePrivate{
		tdCommon: tdCommon{Type: "messageFileTypePrivate"},
		Name:     name,
	}

	return &messageFileTypePrivateTemp
}

// UnmarshalJSON unmarshal to json
func (messageFileTypePrivate *MessageFileTypePrivate) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Name string `json:"name"` // Name of the other party; may be empty if unrecognized
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageFileTypePrivate.tdCommon = tempObj.tdCommon
	messageFileTypePrivate.Name = tempObj.Name

	return nil
}

// GetMessageFileTypeEnum return the enum type of this object
func (messageFileTypePrivate *MessageFileTypePrivate) GetMessageFileTypeEnum() MessageFileTypeEnum {
	return MessageFileTypePrivateType
}

// MessageFileTypeGroup The messages were exported from a group chat
type MessageFileTypeGroup struct {
	tdCommon
	Title string `json:"title"` // Title of the group chat; may be empty if unrecognized
}

// MessageType return the string telegram-type of MessageFileTypeGroup
func (messageFileTypeGroup *MessageFileTypeGroup) MessageType() string {
	return "messageFileTypeGroup"
}

// NewMessageFileTypeGroup creates a new MessageFileTypeGroup
//
// @param title Title of the group chat; may be empty if unrecognized
func NewMessageFileTypeGroup(title string) *MessageFileTypeGroup {
	messageFileTypeGroupTemp := MessageFileTypeGroup{
		tdCommon: tdCommon{Type: "messageFileTypeGroup"},
		Title:    title,
	}

	return &messageFileTypeGroupTemp
}

// UnmarshalJSON unmarshal to json
func (messageFileTypeGroup *MessageFileTypeGroup) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Title string `json:"title"` // Title of the group chat; may be empty if unrecognized
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageFileTypeGroup.tdCommon = tempObj.tdCommon
	messageFileTypeGroup.Title = tempObj.Title

	return nil
}

// GetMessageFileTypeEnum return the enum type of this object
func (messageFileTypeGroup *MessageFileTypeGroup) GetMessageFileTypeEnum() MessageFileTypeEnum {
	return MessageFileTypeGroupType
}

// MessageFileTypeUnknown The messages were exported from a chat of unknown type
type MessageFileTypeUnknown struct {
	tdCommon
}

// MessageType return the string telegram-type of MessageFileTypeUnknown
func (messageFileTypeUnknown *MessageFileTypeUnknown) MessageType() string {
	return "messageFileTypeUnknown"
}

// NewMessageFileTypeUnknown creates a new MessageFileTypeUnknown
//
func NewMessageFileTypeUnknown() *MessageFileTypeUnknown {
	messageFileTypeUnknownTemp := MessageFileTypeUnknown{
		tdCommon: tdCommon{Type: "messageFileTypeUnknown"},
	}

	return &messageFileTypeUnknownTemp
}

// UnmarshalJSON unmarshal to json
func (messageFileTypeUnknown *MessageFileTypeUnknown) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageFileTypeUnknown.tdCommon = tempObj.tdCommon

	return nil
}

// GetMessageFileTypeEnum return the enum type of this object
func (messageFileTypeUnknown *MessageFileTypeUnknown) GetMessageFileTypeEnum() MessageFileTypeEnum {
	return MessageFileTypeUnknownType
}

// PushMessageContentHidden A general message with hidden content
type PushMessageContentHidden struct {
	tdCommon
	IsPinned bool `json:"is_pinned"` // True, if the message is a pinned message with the specified content
}

// MessageType return the string telegram-type of PushMessageContentHidden
func (pushMessageContentHidden *PushMessageContentHidden) MessageType() string {
	return "pushMessageContentHidden"
}

// NewPushMessageContentHidden creates a new PushMessageContentHidden
//
// @param isPinned True, if the message is a pinned message with the specified content
func NewPushMessageContentHidden(isPinned bool) *PushMessageContentHidden {
	pushMessageContentHiddenTemp := PushMessageContentHidden{
		tdCommon: tdCommon{Type: "pushMessageContentHidden"},
		IsPinned: isPinned,
	}

	return &pushMessageContentHiddenTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentHidden *PushMessageContentHidden) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsPinned bool `json:"is_pinned"` // True, if the message is a pinned message with the specified content
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentHidden.tdCommon = tempObj.tdCommon
	pushMessageContentHidden.IsPinned = tempObj.IsPinned

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentHidden *PushMessageContentHidden) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentHiddenType
}

// PushMessageContentAnimation An animation message (GIF-style).
type PushMessageContentAnimation struct {
	tdCommon
	Animation *Animation `json:"animation"` // Message content; may be null
	Caption   string     `json:"caption"`   // Animation caption
	IsPinned  bool       `json:"is_pinned"` // True, if the message is a pinned message with the specified content
}

// MessageType return the string telegram-type of PushMessageContentAnimation
func (pushMessageContentAnimation *PushMessageContentAnimation) MessageType() string {
	return "pushMessageContentAnimation"
}

// NewPushMessageContentAnimation creates a new PushMessageContentAnimation
//
// @param animation Message content; may be null
// @param caption Animation caption
// @param isPinned True, if the message is a pinned message with the specified content
func NewPushMessageContentAnimation(animation *Animation, caption string, isPinned bool) *PushMessageContentAnimation {
	pushMessageContentAnimationTemp := PushMessageContentAnimation{
		tdCommon:  tdCommon{Type: "pushMessageContentAnimation"},
		Animation: animation,
		Caption:   caption,
		IsPinned:  isPinned,
	}

	return &pushMessageContentAnimationTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentAnimation *PushMessageContentAnimation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Animation *Animation `json:"animation"` // Message content; may be null
		Caption   string     `json:"caption"`   // Animation caption
		IsPinned  bool       `json:"is_pinned"` // True, if the message is a pinned message with the specified content
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentAnimation.tdCommon = tempObj.tdCommon
	pushMessageContentAnimation.Animation = tempObj.Animation
	pushMessageContentAnimation.Caption = tempObj.Caption
	pushMessageContentAnimation.IsPinned = tempObj.IsPinned

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentAnimation *PushMessageContentAnimation) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentAnimationType
}

// PushMessageContentAudio An audio message
type PushMessageContentAudio struct {
	tdCommon
	Audio    *Audio `json:"audio"`     // Message content; may be null
	IsPinned bool   `json:"is_pinned"` // True, if the message is a pinned message with the specified content
}

// MessageType return the string telegram-type of PushMessageContentAudio
func (pushMessageContentAudio *PushMessageContentAudio) MessageType() string {
	return "pushMessageContentAudio"
}

// NewPushMessageContentAudio creates a new PushMessageContentAudio
//
// @param audio Message content; may be null
// @param isPinned True, if the message is a pinned message with the specified content
func NewPushMessageContentAudio(audio *Audio, isPinned bool) *PushMessageContentAudio {
	pushMessageContentAudioTemp := PushMessageContentAudio{
		tdCommon: tdCommon{Type: "pushMessageContentAudio"},
		Audio:    audio,
		IsPinned: isPinned,
	}

	return &pushMessageContentAudioTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentAudio *PushMessageContentAudio) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Audio    *Audio `json:"audio"`     // Message content; may be null
		IsPinned bool   `json:"is_pinned"` // True, if the message is a pinned message with the specified content
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentAudio.tdCommon = tempObj.tdCommon
	pushMessageContentAudio.Audio = tempObj.Audio
	pushMessageContentAudio.IsPinned = tempObj.IsPinned

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentAudio *PushMessageContentAudio) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentAudioType
}

// PushMessageContentContact A message with a user contact
type PushMessageContentContact struct {
	tdCommon
	Name     string `json:"name"`      // Contact's name
	IsPinned bool   `json:"is_pinned"` // True, if the message is a pinned message with the specified content
}

// MessageType return the string telegram-type of PushMessageContentContact
func (pushMessageContentContact *PushMessageContentContact) MessageType() string {
	return "pushMessageContentContact"
}

// NewPushMessageContentContact creates a new PushMessageContentContact
//
// @param name Contact's name
// @param isPinned True, if the message is a pinned message with the specified content
func NewPushMessageContentContact(name string, isPinned bool) *PushMessageContentContact {
	pushMessageContentContactTemp := PushMessageContentContact{
		tdCommon: tdCommon{Type: "pushMessageContentContact"},
		Name:     name,
		IsPinned: isPinned,
	}

	return &pushMessageContentContactTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentContact *PushMessageContentContact) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Name     string `json:"name"`      // Contact's name
		IsPinned bool   `json:"is_pinned"` // True, if the message is a pinned message with the specified content
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentContact.tdCommon = tempObj.tdCommon
	pushMessageContentContact.Name = tempObj.Name
	pushMessageContentContact.IsPinned = tempObj.IsPinned

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentContact *PushMessageContentContact) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentContactType
}

// PushMessageContentContactRegistered A contact has registered with Telegram
type PushMessageContentContactRegistered struct {
	tdCommon
}

// MessageType return the string telegram-type of PushMessageContentContactRegistered
func (pushMessageContentContactRegistered *PushMessageContentContactRegistered) MessageType() string {
	return "pushMessageContentContactRegistered"
}

// NewPushMessageContentContactRegistered creates a new PushMessageContentContactRegistered
//
func NewPushMessageContentContactRegistered() *PushMessageContentContactRegistered {
	pushMessageContentContactRegisteredTemp := PushMessageContentContactRegistered{
		tdCommon: tdCommon{Type: "pushMessageContentContactRegistered"},
	}

	return &pushMessageContentContactRegisteredTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentContactRegistered *PushMessageContentContactRegistered) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentContactRegistered.tdCommon = tempObj.tdCommon

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentContactRegistered *PushMessageContentContactRegistered) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentContactRegisteredType
}

// PushMessageContentDocument A document message (a general file)
type PushMessageContentDocument struct {
	tdCommon
	Document *Document `json:"document"`  // Message content; may be null
	IsPinned bool      `json:"is_pinned"` // True, if the message is a pinned message with the specified content
}

// MessageType return the string telegram-type of PushMessageContentDocument
func (pushMessageContentDocument *PushMessageContentDocument) MessageType() string {
	return "pushMessageContentDocument"
}

// NewPushMessageContentDocument creates a new PushMessageContentDocument
//
// @param document Message content; may be null
// @param isPinned True, if the message is a pinned message with the specified content
func NewPushMessageContentDocument(document *Document, isPinned bool) *PushMessageContentDocument {
	pushMessageContentDocumentTemp := PushMessageContentDocument{
		tdCommon: tdCommon{Type: "pushMessageContentDocument"},
		Document: document,
		IsPinned: isPinned,
	}

	return &pushMessageContentDocumentTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentDocument *PushMessageContentDocument) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Document *Document `json:"document"`  // Message content; may be null
		IsPinned bool      `json:"is_pinned"` // True, if the message is a pinned message with the specified content
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentDocument.tdCommon = tempObj.tdCommon
	pushMessageContentDocument.Document = tempObj.Document
	pushMessageContentDocument.IsPinned = tempObj.IsPinned

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentDocument *PushMessageContentDocument) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentDocumentType
}

// PushMessageContentGame A message with a game
type PushMessageContentGame struct {
	tdCommon
	Title    string `json:"title"`     // Game title, empty for pinned game message
	IsPinned bool   `json:"is_pinned"` // True, if the message is a pinned message with the specified content
}

// MessageType return the string telegram-type of PushMessageContentGame
func (pushMessageContentGame *PushMessageContentGame) MessageType() string {
	return "pushMessageContentGame"
}

// NewPushMessageContentGame creates a new PushMessageContentGame
//
// @param title Game title, empty for pinned game message
// @param isPinned True, if the message is a pinned message with the specified content
func NewPushMessageContentGame(title string, isPinned bool) *PushMessageContentGame {
	pushMessageContentGameTemp := PushMessageContentGame{
		tdCommon: tdCommon{Type: "pushMessageContentGame"},
		Title:    title,
		IsPinned: isPinned,
	}

	return &pushMessageContentGameTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentGame *PushMessageContentGame) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Title    string `json:"title"`     // Game title, empty for pinned game message
		IsPinned bool   `json:"is_pinned"` // True, if the message is a pinned message with the specified content
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentGame.tdCommon = tempObj.tdCommon
	pushMessageContentGame.Title = tempObj.Title
	pushMessageContentGame.IsPinned = tempObj.IsPinned

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentGame *PushMessageContentGame) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentGameType
}

// PushMessageContentGameScore A new high score was achieved in a game
type PushMessageContentGameScore struct {
	tdCommon
	Title    string `json:"title"`     // Game title, empty for pinned message
	Score    int32  `json:"score"`     // New score, 0 for pinned message
	IsPinned bool   `json:"is_pinned"` // True, if the message is a pinned message with the specified content
}

// MessageType return the string telegram-type of PushMessageContentGameScore
func (pushMessageContentGameScore *PushMessageContentGameScore) MessageType() string {
	return "pushMessageContentGameScore"
}

// NewPushMessageContentGameScore creates a new PushMessageContentGameScore
//
// @param title Game title, empty for pinned message
// @param score New score, 0 for pinned message
// @param isPinned True, if the message is a pinned message with the specified content
func NewPushMessageContentGameScore(title string, score int32, isPinned bool) *PushMessageContentGameScore {
	pushMessageContentGameScoreTemp := PushMessageContentGameScore{
		tdCommon: tdCommon{Type: "pushMessageContentGameScore"},
		Title:    title,
		Score:    score,
		IsPinned: isPinned,
	}

	return &pushMessageContentGameScoreTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentGameScore *PushMessageContentGameScore) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Title    string `json:"title"`     // Game title, empty for pinned message
		Score    int32  `json:"score"`     // New score, 0 for pinned message
		IsPinned bool   `json:"is_pinned"` // True, if the message is a pinned message with the specified content
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentGameScore.tdCommon = tempObj.tdCommon
	pushMessageContentGameScore.Title = tempObj.Title
	pushMessageContentGameScore.Score = tempObj.Score
	pushMessageContentGameScore.IsPinned = tempObj.IsPinned

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentGameScore *PushMessageContentGameScore) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentGameScoreType
}

// PushMessageContentInvoice A message with an invoice from a bot
type PushMessageContentInvoice struct {
	tdCommon
	Price    string `json:"price"`     // Product price
	IsPinned bool   `json:"is_pinned"` // True, if the message is a pinned message with the specified content
}

// MessageType return the string telegram-type of PushMessageContentInvoice
func (pushMessageContentInvoice *PushMessageContentInvoice) MessageType() string {
	return "pushMessageContentInvoice"
}

// NewPushMessageContentInvoice creates a new PushMessageContentInvoice
//
// @param price Product price
// @param isPinned True, if the message is a pinned message with the specified content
func NewPushMessageContentInvoice(price string, isPinned bool) *PushMessageContentInvoice {
	pushMessageContentInvoiceTemp := PushMessageContentInvoice{
		tdCommon: tdCommon{Type: "pushMessageContentInvoice"},
		Price:    price,
		IsPinned: isPinned,
	}

	return &pushMessageContentInvoiceTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentInvoice *PushMessageContentInvoice) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Price    string `json:"price"`     // Product price
		IsPinned bool   `json:"is_pinned"` // True, if the message is a pinned message with the specified content
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentInvoice.tdCommon = tempObj.tdCommon
	pushMessageContentInvoice.Price = tempObj.Price
	pushMessageContentInvoice.IsPinned = tempObj.IsPinned

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentInvoice *PushMessageContentInvoice) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentInvoiceType
}

// PushMessageContentLocation A message with a location
type PushMessageContentLocation struct {
	tdCommon
	IsLive   bool `json:"is_live"`   // True, if the location is live
	IsPinned bool `json:"is_pinned"` // True, if the message is a pinned message with the specified content
}

// MessageType return the string telegram-type of PushMessageContentLocation
func (pushMessageContentLocation *PushMessageContentLocation) MessageType() string {
	return "pushMessageContentLocation"
}

// NewPushMessageContentLocation creates a new PushMessageContentLocation
//
// @param isLive True, if the location is live
// @param isPinned True, if the message is a pinned message with the specified content
func NewPushMessageContentLocation(isLive bool, isPinned bool) *PushMessageContentLocation {
	pushMessageContentLocationTemp := PushMessageContentLocation{
		tdCommon: tdCommon{Type: "pushMessageContentLocation"},
		IsLive:   isLive,
		IsPinned: isPinned,
	}

	return &pushMessageContentLocationTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentLocation *PushMessageContentLocation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsLive   bool `json:"is_live"`   // True, if the location is live
		IsPinned bool `json:"is_pinned"` // True, if the message is a pinned message with the specified content
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentLocation.tdCommon = tempObj.tdCommon
	pushMessageContentLocation.IsLive = tempObj.IsLive
	pushMessageContentLocation.IsPinned = tempObj.IsPinned

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentLocation *PushMessageContentLocation) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentLocationType
}

// PushMessageContentPaidMedia A message with paid media
type PushMessageContentPaidMedia struct {
	tdCommon
	StarCount int64 `json:"star_count"` // Number of Telegram Stars needed to buy access to the media in the message; 0 for pinned message
	IsPinned  bool  `json:"is_pinned"`  // True, if the message is a pinned message with the specified content
}

// MessageType return the string telegram-type of PushMessageContentPaidMedia
func (pushMessageContentPaidMedia *PushMessageContentPaidMedia) MessageType() string {
	return "pushMessageContentPaidMedia"
}

// NewPushMessageContentPaidMedia creates a new PushMessageContentPaidMedia
//
// @param starCount Number of Telegram Stars needed to buy access to the media in the message; 0 for pinned message
// @param isPinned True, if the message is a pinned message with the specified content
func NewPushMessageContentPaidMedia(starCount int64, isPinned bool) *PushMessageContentPaidMedia {
	pushMessageContentPaidMediaTemp := PushMessageContentPaidMedia{
		tdCommon:  tdCommon{Type: "pushMessageContentPaidMedia"},
		StarCount: starCount,
		IsPinned:  isPinned,
	}

	return &pushMessageContentPaidMediaTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentPaidMedia *PushMessageContentPaidMedia) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StarCount int64 `json:"star_count"` // Number of Telegram Stars needed to buy access to the media in the message; 0 for pinned message
		IsPinned  bool  `json:"is_pinned"`  // True, if the message is a pinned message with the specified content
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentPaidMedia.tdCommon = tempObj.tdCommon
	pushMessageContentPaidMedia.StarCount = tempObj.StarCount
	pushMessageContentPaidMedia.IsPinned = tempObj.IsPinned

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentPaidMedia *PushMessageContentPaidMedia) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentPaidMediaType
}

// PushMessageContentPhoto A photo message
type PushMessageContentPhoto struct {
	tdCommon
	Photo    *Photo `json:"photo"`     // Message content; may be null
	Caption  string `json:"caption"`   // Photo caption
	IsSecret bool   `json:"is_secret"` // True, if the photo is secret
	IsPinned bool   `json:"is_pinned"` // True, if the message is a pinned message with the specified content
}

// MessageType return the string telegram-type of PushMessageContentPhoto
func (pushMessageContentPhoto *PushMessageContentPhoto) MessageType() string {
	return "pushMessageContentPhoto"
}

// NewPushMessageContentPhoto creates a new PushMessageContentPhoto
//
// @param photo Message content; may be null
// @param caption Photo caption
// @param isSecret True, if the photo is secret
// @param isPinned True, if the message is a pinned message with the specified content
func NewPushMessageContentPhoto(photo *Photo, caption string, isSecret bool, isPinned bool) *PushMessageContentPhoto {
	pushMessageContentPhotoTemp := PushMessageContentPhoto{
		tdCommon: tdCommon{Type: "pushMessageContentPhoto"},
		Photo:    photo,
		Caption:  caption,
		IsSecret: isSecret,
		IsPinned: isPinned,
	}

	return &pushMessageContentPhotoTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentPhoto *PushMessageContentPhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Photo    *Photo `json:"photo"`     // Message content; may be null
		Caption  string `json:"caption"`   // Photo caption
		IsSecret bool   `json:"is_secret"` // True, if the photo is secret
		IsPinned bool   `json:"is_pinned"` // True, if the message is a pinned message with the specified content
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentPhoto.tdCommon = tempObj.tdCommon
	pushMessageContentPhoto.Photo = tempObj.Photo
	pushMessageContentPhoto.Caption = tempObj.Caption
	pushMessageContentPhoto.IsSecret = tempObj.IsSecret
	pushMessageContentPhoto.IsPinned = tempObj.IsPinned

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentPhoto *PushMessageContentPhoto) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentPhotoType
}

// PushMessageContentPoll A message with a poll
type PushMessageContentPoll struct {
	tdCommon
	Question  string `json:"question"`   // Poll question
	IsRegular bool   `json:"is_regular"` // True, if the poll is regular and not in quiz mode
	IsPinned  bool   `json:"is_pinned"`  // True, if the message is a pinned message with the specified content
}

// MessageType return the string telegram-type of PushMessageContentPoll
func (pushMessageContentPoll *PushMessageContentPoll) MessageType() string {
	return "pushMessageContentPoll"
}

// NewPushMessageContentPoll creates a new PushMessageContentPoll
//
// @param question Poll question
// @param isRegular True, if the poll is regular and not in quiz mode
// @param isPinned True, if the message is a pinned message with the specified content
func NewPushMessageContentPoll(question string, isRegular bool, isPinned bool) *PushMessageContentPoll {
	pushMessageContentPollTemp := PushMessageContentPoll{
		tdCommon:  tdCommon{Type: "pushMessageContentPoll"},
		Question:  question,
		IsRegular: isRegular,
		IsPinned:  isPinned,
	}

	return &pushMessageContentPollTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentPoll *PushMessageContentPoll) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Question  string `json:"question"`   // Poll question
		IsRegular bool   `json:"is_regular"` // True, if the poll is regular and not in quiz mode
		IsPinned  bool   `json:"is_pinned"`  // True, if the message is a pinned message with the specified content
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentPoll.tdCommon = tempObj.tdCommon
	pushMessageContentPoll.Question = tempObj.Question
	pushMessageContentPoll.IsRegular = tempObj.IsRegular
	pushMessageContentPoll.IsPinned = tempObj.IsPinned

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentPoll *PushMessageContentPoll) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentPollType
}

// PushMessageContentPremiumGiftCode A message with a Telegram Premium gift code created for the user
type PushMessageContentPremiumGiftCode struct {
	tdCommon
	MonthCount int32 `json:"month_count"` // Number of months the Telegram Premium subscription will be active after code activation
}

// MessageType return the string telegram-type of PushMessageContentPremiumGiftCode
func (pushMessageContentPremiumGiftCode *PushMessageContentPremiumGiftCode) MessageType() string {
	return "pushMessageContentPremiumGiftCode"
}

// NewPushMessageContentPremiumGiftCode creates a new PushMessageContentPremiumGiftCode
//
// @param monthCount Number of months the Telegram Premium subscription will be active after code activation
func NewPushMessageContentPremiumGiftCode(monthCount int32) *PushMessageContentPremiumGiftCode {
	pushMessageContentPremiumGiftCodeTemp := PushMessageContentPremiumGiftCode{
		tdCommon:   tdCommon{Type: "pushMessageContentPremiumGiftCode"},
		MonthCount: monthCount,
	}

	return &pushMessageContentPremiumGiftCodeTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentPremiumGiftCode *PushMessageContentPremiumGiftCode) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MonthCount int32 `json:"month_count"` // Number of months the Telegram Premium subscription will be active after code activation
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentPremiumGiftCode.tdCommon = tempObj.tdCommon
	pushMessageContentPremiumGiftCode.MonthCount = tempObj.MonthCount

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentPremiumGiftCode *PushMessageContentPremiumGiftCode) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentPremiumGiftCodeType
}

// PushMessageContentGiveaway A message with a giveaway
type PushMessageContentGiveaway struct {
	tdCommon
	WinnerCount int32          `json:"winner_count"` // Number of users which will receive giveaway prizes; 0 for pinned message
	Prize       *GiveawayPrize `json:"prize"`        // Prize of the giveaway; may be null for pinned message
	IsPinned    bool           `json:"is_pinned"`    // True, if the message is a pinned message with the specified content
}

// MessageType return the string telegram-type of PushMessageContentGiveaway
func (pushMessageContentGiveaway *PushMessageContentGiveaway) MessageType() string {
	return "pushMessageContentGiveaway"
}

// NewPushMessageContentGiveaway creates a new PushMessageContentGiveaway
//
// @param winnerCount Number of users which will receive giveaway prizes; 0 for pinned message
// @param prize Prize of the giveaway; may be null for pinned message
// @param isPinned True, if the message is a pinned message with the specified content
func NewPushMessageContentGiveaway(winnerCount int32, prize *GiveawayPrize, isPinned bool) *PushMessageContentGiveaway {
	pushMessageContentGiveawayTemp := PushMessageContentGiveaway{
		tdCommon:    tdCommon{Type: "pushMessageContentGiveaway"},
		WinnerCount: winnerCount,
		Prize:       prize,
		IsPinned:    isPinned,
	}

	return &pushMessageContentGiveawayTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentGiveaway *PushMessageContentGiveaway) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		WinnerCount int32 `json:"winner_count"` // Number of users which will receive giveaway prizes; 0 for pinned message
		IsPinned    bool  `json:"is_pinned"`    // True, if the message is a pinned message with the specified content
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentGiveaway.tdCommon = tempObj.tdCommon
	pushMessageContentGiveaway.WinnerCount = tempObj.WinnerCount
	pushMessageContentGiveaway.IsPinned = tempObj.IsPinned

	fieldPrize, _ := unmarshalGiveawayPrize(objMap["prize"])
	pushMessageContentGiveaway.Prize = &fieldPrize

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentGiveaway *PushMessageContentGiveaway) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentGiveawayType
}

// PushMessageContentScreenshotTaken A screenshot of a message in the chat has been taken
type PushMessageContentScreenshotTaken struct {
	tdCommon
}

// MessageType return the string telegram-type of PushMessageContentScreenshotTaken
func (pushMessageContentScreenshotTaken *PushMessageContentScreenshotTaken) MessageType() string {
	return "pushMessageContentScreenshotTaken"
}

// NewPushMessageContentScreenshotTaken creates a new PushMessageContentScreenshotTaken
//
func NewPushMessageContentScreenshotTaken() *PushMessageContentScreenshotTaken {
	pushMessageContentScreenshotTakenTemp := PushMessageContentScreenshotTaken{
		tdCommon: tdCommon{Type: "pushMessageContentScreenshotTaken"},
	}

	return &pushMessageContentScreenshotTakenTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentScreenshotTaken *PushMessageContentScreenshotTaken) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentScreenshotTaken.tdCommon = tempObj.tdCommon

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentScreenshotTaken *PushMessageContentScreenshotTaken) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentScreenshotTakenType
}

// PushMessageContentSticker A message with a sticker
type PushMessageContentSticker struct {
	tdCommon
	Sticker  *Sticker `json:"sticker"`   // Message content; may be null
	Emoji    string   `json:"emoji"`     // Emoji corresponding to the sticker; may be empty
	IsPinned bool     `json:"is_pinned"` // True, if the message is a pinned message with the specified content
}

// MessageType return the string telegram-type of PushMessageContentSticker
func (pushMessageContentSticker *PushMessageContentSticker) MessageType() string {
	return "pushMessageContentSticker"
}

// NewPushMessageContentSticker creates a new PushMessageContentSticker
//
// @param sticker Message content; may be null
// @param emoji Emoji corresponding to the sticker; may be empty
// @param isPinned True, if the message is a pinned message with the specified content
func NewPushMessageContentSticker(sticker *Sticker, emoji string, isPinned bool) *PushMessageContentSticker {
	pushMessageContentStickerTemp := PushMessageContentSticker{
		tdCommon: tdCommon{Type: "pushMessageContentSticker"},
		Sticker:  sticker,
		Emoji:    emoji,
		IsPinned: isPinned,
	}

	return &pushMessageContentStickerTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentSticker *PushMessageContentSticker) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Emoji    string `json:"emoji"`     // Emoji corresponding to the sticker; may be empty
		IsPinned bool   `json:"is_pinned"` // True, if the message is a pinned message with the specified content
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentSticker.tdCommon = tempObj.tdCommon
	pushMessageContentSticker.Emoji = tempObj.Emoji
	pushMessageContentSticker.IsPinned = tempObj.IsPinned

	var sticker Sticker
	if objMap["sticker"] != nil {
		err = sticker.UnmarshalJSON(*objMap["sticker"])
		if err != nil {
			return err
		}
	}

	pushMessageContentSticker.Sticker = &sticker

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentSticker *PushMessageContentSticker) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentStickerType
}

// PushMessageContentStory A message with a story
type PushMessageContentStory struct {
	tdCommon
	IsPinned bool `json:"is_pinned"` // True, if the message is a pinned message with the specified content
}

// MessageType return the string telegram-type of PushMessageContentStory
func (pushMessageContentStory *PushMessageContentStory) MessageType() string {
	return "pushMessageContentStory"
}

// NewPushMessageContentStory creates a new PushMessageContentStory
//
// @param isPinned True, if the message is a pinned message with the specified content
func NewPushMessageContentStory(isPinned bool) *PushMessageContentStory {
	pushMessageContentStoryTemp := PushMessageContentStory{
		tdCommon: tdCommon{Type: "pushMessageContentStory"},
		IsPinned: isPinned,
	}

	return &pushMessageContentStoryTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentStory *PushMessageContentStory) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsPinned bool `json:"is_pinned"` // True, if the message is a pinned message with the specified content
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentStory.tdCommon = tempObj.tdCommon
	pushMessageContentStory.IsPinned = tempObj.IsPinned

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentStory *PushMessageContentStory) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentStoryType
}

// PushMessageContentText A text message
type PushMessageContentText struct {
	tdCommon
	Text     string `json:"text"`      // Message text
	IsPinned bool   `json:"is_pinned"` // True, if the message is a pinned message with the specified content
}

// MessageType return the string telegram-type of PushMessageContentText
func (pushMessageContentText *PushMessageContentText) MessageType() string {
	return "pushMessageContentText"
}

// NewPushMessageContentText creates a new PushMessageContentText
//
// @param text Message text
// @param isPinned True, if the message is a pinned message with the specified content
func NewPushMessageContentText(text string, isPinned bool) *PushMessageContentText {
	pushMessageContentTextTemp := PushMessageContentText{
		tdCommon: tdCommon{Type: "pushMessageContentText"},
		Text:     text,
		IsPinned: isPinned,
	}

	return &pushMessageContentTextTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentText *PushMessageContentText) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Text     string `json:"text"`      // Message text
		IsPinned bool   `json:"is_pinned"` // True, if the message is a pinned message with the specified content
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentText.tdCommon = tempObj.tdCommon
	pushMessageContentText.Text = tempObj.Text
	pushMessageContentText.IsPinned = tempObj.IsPinned

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentText *PushMessageContentText) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentTextType
}

// PushMessageContentVideo A video message
type PushMessageContentVideo struct {
	tdCommon
	Video    *Video `json:"video"`     // Message content; may be null
	Caption  string `json:"caption"`   // Video caption
	IsSecret bool   `json:"is_secret"` // True, if the video is secret
	IsPinned bool   `json:"is_pinned"` // True, if the message is a pinned message with the specified content
}

// MessageType return the string telegram-type of PushMessageContentVideo
func (pushMessageContentVideo *PushMessageContentVideo) MessageType() string {
	return "pushMessageContentVideo"
}

// NewPushMessageContentVideo creates a new PushMessageContentVideo
//
// @param video Message content; may be null
// @param caption Video caption
// @param isSecret True, if the video is secret
// @param isPinned True, if the message is a pinned message with the specified content
func NewPushMessageContentVideo(video *Video, caption string, isSecret bool, isPinned bool) *PushMessageContentVideo {
	pushMessageContentVideoTemp := PushMessageContentVideo{
		tdCommon: tdCommon{Type: "pushMessageContentVideo"},
		Video:    video,
		Caption:  caption,
		IsSecret: isSecret,
		IsPinned: isPinned,
	}

	return &pushMessageContentVideoTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentVideo *PushMessageContentVideo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Video    *Video `json:"video"`     // Message content; may be null
		Caption  string `json:"caption"`   // Video caption
		IsSecret bool   `json:"is_secret"` // True, if the video is secret
		IsPinned bool   `json:"is_pinned"` // True, if the message is a pinned message with the specified content
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentVideo.tdCommon = tempObj.tdCommon
	pushMessageContentVideo.Video = tempObj.Video
	pushMessageContentVideo.Caption = tempObj.Caption
	pushMessageContentVideo.IsSecret = tempObj.IsSecret
	pushMessageContentVideo.IsPinned = tempObj.IsPinned

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentVideo *PushMessageContentVideo) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentVideoType
}

// PushMessageContentVideoNote A video note message
type PushMessageContentVideoNote struct {
	tdCommon
	VideoNote *VideoNote `json:"video_note"` // Message content; may be null
	IsPinned  bool       `json:"is_pinned"`  // True, if the message is a pinned message with the specified content
}

// MessageType return the string telegram-type of PushMessageContentVideoNote
func (pushMessageContentVideoNote *PushMessageContentVideoNote) MessageType() string {
	return "pushMessageContentVideoNote"
}

// NewPushMessageContentVideoNote creates a new PushMessageContentVideoNote
//
// @param videoNote Message content; may be null
// @param isPinned True, if the message is a pinned message with the specified content
func NewPushMessageContentVideoNote(videoNote *VideoNote, isPinned bool) *PushMessageContentVideoNote {
	pushMessageContentVideoNoteTemp := PushMessageContentVideoNote{
		tdCommon:  tdCommon{Type: "pushMessageContentVideoNote"},
		VideoNote: videoNote,
		IsPinned:  isPinned,
	}

	return &pushMessageContentVideoNoteTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentVideoNote *PushMessageContentVideoNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsPinned bool `json:"is_pinned"` // True, if the message is a pinned message with the specified content
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentVideoNote.tdCommon = tempObj.tdCommon
	pushMessageContentVideoNote.IsPinned = tempObj.IsPinned

	var videoNote VideoNote
	if objMap["video_note"] != nil {
		err = videoNote.UnmarshalJSON(*objMap["video_note"])
		if err != nil {
			return err
		}
	}

	pushMessageContentVideoNote.VideoNote = &videoNote

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentVideoNote *PushMessageContentVideoNote) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentVideoNoteType
}

// PushMessageContentVoiceNote A voice note message
type PushMessageContentVoiceNote struct {
	tdCommon
	VoiceNote *VoiceNote `json:"voice_note"` // Message content; may be null
	IsPinned  bool       `json:"is_pinned"`  // True, if the message is a pinned message with the specified content
}

// MessageType return the string telegram-type of PushMessageContentVoiceNote
func (pushMessageContentVoiceNote *PushMessageContentVoiceNote) MessageType() string {
	return "pushMessageContentVoiceNote"
}

// NewPushMessageContentVoiceNote creates a new PushMessageContentVoiceNote
//
// @param voiceNote Message content; may be null
// @param isPinned True, if the message is a pinned message with the specified content
func NewPushMessageContentVoiceNote(voiceNote *VoiceNote, isPinned bool) *PushMessageContentVoiceNote {
	pushMessageContentVoiceNoteTemp := PushMessageContentVoiceNote{
		tdCommon:  tdCommon{Type: "pushMessageContentVoiceNote"},
		VoiceNote: voiceNote,
		IsPinned:  isPinned,
	}

	return &pushMessageContentVoiceNoteTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentVoiceNote *PushMessageContentVoiceNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsPinned bool `json:"is_pinned"` // True, if the message is a pinned message with the specified content
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentVoiceNote.tdCommon = tempObj.tdCommon
	pushMessageContentVoiceNote.IsPinned = tempObj.IsPinned

	var voiceNote VoiceNote
	if objMap["voice_note"] != nil {
		err = voiceNote.UnmarshalJSON(*objMap["voice_note"])
		if err != nil {
			return err
		}
	}

	pushMessageContentVoiceNote.VoiceNote = &voiceNote

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentVoiceNote *PushMessageContentVoiceNote) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentVoiceNoteType
}

// PushMessageContentBasicGroupChatCreate A newly created basic group
type PushMessageContentBasicGroupChatCreate struct {
	tdCommon
}

// MessageType return the string telegram-type of PushMessageContentBasicGroupChatCreate
func (pushMessageContentBasicGroupChatCreate *PushMessageContentBasicGroupChatCreate) MessageType() string {
	return "pushMessageContentBasicGroupChatCreate"
}

// NewPushMessageContentBasicGroupChatCreate creates a new PushMessageContentBasicGroupChatCreate
//
func NewPushMessageContentBasicGroupChatCreate() *PushMessageContentBasicGroupChatCreate {
	pushMessageContentBasicGroupChatCreateTemp := PushMessageContentBasicGroupChatCreate{
		tdCommon: tdCommon{Type: "pushMessageContentBasicGroupChatCreate"},
	}

	return &pushMessageContentBasicGroupChatCreateTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentBasicGroupChatCreate *PushMessageContentBasicGroupChatCreate) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentBasicGroupChatCreate.tdCommon = tempObj.tdCommon

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentBasicGroupChatCreate *PushMessageContentBasicGroupChatCreate) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentBasicGroupChatCreateType
}

// PushMessageContentChatAddMembers New chat members were invited to a group
type PushMessageContentChatAddMembers struct {
	tdCommon
	MemberName    string `json:"member_name"`     // Name of the added member
	IsCurrentUser bool   `json:"is_current_user"` // True, if the current user was added to the group
	IsReturned    bool   `json:"is_returned"`     // True, if the user has returned to the group themselves
}

// MessageType return the string telegram-type of PushMessageContentChatAddMembers
func (pushMessageContentChatAddMembers *PushMessageContentChatAddMembers) MessageType() string {
	return "pushMessageContentChatAddMembers"
}

// NewPushMessageContentChatAddMembers creates a new PushMessageContentChatAddMembers
//
// @param memberName Name of the added member
// @param isCurrentUser True, if the current user was added to the group
// @param isReturned True, if the user has returned to the group themselves
func NewPushMessageContentChatAddMembers(memberName string, isCurrentUser bool, isReturned bool) *PushMessageContentChatAddMembers {
	pushMessageContentChatAddMembersTemp := PushMessageContentChatAddMembers{
		tdCommon:      tdCommon{Type: "pushMessageContentChatAddMembers"},
		MemberName:    memberName,
		IsCurrentUser: isCurrentUser,
		IsReturned:    isReturned,
	}

	return &pushMessageContentChatAddMembersTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentChatAddMembers *PushMessageContentChatAddMembers) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MemberName    string `json:"member_name"`     // Name of the added member
		IsCurrentUser bool   `json:"is_current_user"` // True, if the current user was added to the group
		IsReturned    bool   `json:"is_returned"`     // True, if the user has returned to the group themselves
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentChatAddMembers.tdCommon = tempObj.tdCommon
	pushMessageContentChatAddMembers.MemberName = tempObj.MemberName
	pushMessageContentChatAddMembers.IsCurrentUser = tempObj.IsCurrentUser
	pushMessageContentChatAddMembers.IsReturned = tempObj.IsReturned

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentChatAddMembers *PushMessageContentChatAddMembers) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentChatAddMembersType
}

// PushMessageContentChatChangePhoto A chat photo was edited
type PushMessageContentChatChangePhoto struct {
	tdCommon
}

// MessageType return the string telegram-type of PushMessageContentChatChangePhoto
func (pushMessageContentChatChangePhoto *PushMessageContentChatChangePhoto) MessageType() string {
	return "pushMessageContentChatChangePhoto"
}

// NewPushMessageContentChatChangePhoto creates a new PushMessageContentChatChangePhoto
//
func NewPushMessageContentChatChangePhoto() *PushMessageContentChatChangePhoto {
	pushMessageContentChatChangePhotoTemp := PushMessageContentChatChangePhoto{
		tdCommon: tdCommon{Type: "pushMessageContentChatChangePhoto"},
	}

	return &pushMessageContentChatChangePhotoTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentChatChangePhoto *PushMessageContentChatChangePhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentChatChangePhoto.tdCommon = tempObj.tdCommon

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentChatChangePhoto *PushMessageContentChatChangePhoto) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentChatChangePhotoType
}

// PushMessageContentChatChangeTitle A chat title was edited
type PushMessageContentChatChangeTitle struct {
	tdCommon
	Title string `json:"title"` // New chat title
}

// MessageType return the string telegram-type of PushMessageContentChatChangeTitle
func (pushMessageContentChatChangeTitle *PushMessageContentChatChangeTitle) MessageType() string {
	return "pushMessageContentChatChangeTitle"
}

// NewPushMessageContentChatChangeTitle creates a new PushMessageContentChatChangeTitle
//
// @param title New chat title
func NewPushMessageContentChatChangeTitle(title string) *PushMessageContentChatChangeTitle {
	pushMessageContentChatChangeTitleTemp := PushMessageContentChatChangeTitle{
		tdCommon: tdCommon{Type: "pushMessageContentChatChangeTitle"},
		Title:    title,
	}

	return &pushMessageContentChatChangeTitleTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentChatChangeTitle *PushMessageContentChatChangeTitle) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Title string `json:"title"` // New chat title
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentChatChangeTitle.tdCommon = tempObj.tdCommon
	pushMessageContentChatChangeTitle.Title = tempObj.Title

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentChatChangeTitle *PushMessageContentChatChangeTitle) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentChatChangeTitleType
}

// PushMessageContentChatSetBackground A chat background was edited
type PushMessageContentChatSetBackground struct {
	tdCommon
	IsSame bool `json:"is_same"` // True, if the set background is the same as the background of the current user
}

// MessageType return the string telegram-type of PushMessageContentChatSetBackground
func (pushMessageContentChatSetBackground *PushMessageContentChatSetBackground) MessageType() string {
	return "pushMessageContentChatSetBackground"
}

// NewPushMessageContentChatSetBackground creates a new PushMessageContentChatSetBackground
//
// @param isSame True, if the set background is the same as the background of the current user
func NewPushMessageContentChatSetBackground(isSame bool) *PushMessageContentChatSetBackground {
	pushMessageContentChatSetBackgroundTemp := PushMessageContentChatSetBackground{
		tdCommon: tdCommon{Type: "pushMessageContentChatSetBackground"},
		IsSame:   isSame,
	}

	return &pushMessageContentChatSetBackgroundTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentChatSetBackground *PushMessageContentChatSetBackground) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsSame bool `json:"is_same"` // True, if the set background is the same as the background of the current user
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentChatSetBackground.tdCommon = tempObj.tdCommon
	pushMessageContentChatSetBackground.IsSame = tempObj.IsSame

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentChatSetBackground *PushMessageContentChatSetBackground) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentChatSetBackgroundType
}

// PushMessageContentChatSetTheme A chat theme was edited
type PushMessageContentChatSetTheme struct {
	tdCommon
	ThemeName string `json:"theme_name"` // If non-empty, name of a new theme, set for the chat. Otherwise, the chat theme was reset to the default one
}

// MessageType return the string telegram-type of PushMessageContentChatSetTheme
func (pushMessageContentChatSetTheme *PushMessageContentChatSetTheme) MessageType() string {
	return "pushMessageContentChatSetTheme"
}

// NewPushMessageContentChatSetTheme creates a new PushMessageContentChatSetTheme
//
// @param themeName If non-empty, name of a new theme, set for the chat. Otherwise, the chat theme was reset to the default one
func NewPushMessageContentChatSetTheme(themeName string) *PushMessageContentChatSetTheme {
	pushMessageContentChatSetThemeTemp := PushMessageContentChatSetTheme{
		tdCommon:  tdCommon{Type: "pushMessageContentChatSetTheme"},
		ThemeName: themeName,
	}

	return &pushMessageContentChatSetThemeTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentChatSetTheme *PushMessageContentChatSetTheme) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ThemeName string `json:"theme_name"` // If non-empty, name of a new theme, set for the chat. Otherwise, the chat theme was reset to the default one
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentChatSetTheme.tdCommon = tempObj.tdCommon
	pushMessageContentChatSetTheme.ThemeName = tempObj.ThemeName

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentChatSetTheme *PushMessageContentChatSetTheme) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentChatSetThemeType
}

// PushMessageContentChatDeleteMember A chat member was deleted
type PushMessageContentChatDeleteMember struct {
	tdCommon
	MemberName    string `json:"member_name"`     // Name of the deleted member
	IsCurrentUser bool   `json:"is_current_user"` // True, if the current user was deleted from the group
	IsLeft        bool   `json:"is_left"`         // True, if the user has left the group themselves
}

// MessageType return the string telegram-type of PushMessageContentChatDeleteMember
func (pushMessageContentChatDeleteMember *PushMessageContentChatDeleteMember) MessageType() string {
	return "pushMessageContentChatDeleteMember"
}

// NewPushMessageContentChatDeleteMember creates a new PushMessageContentChatDeleteMember
//
// @param memberName Name of the deleted member
// @param isCurrentUser True, if the current user was deleted from the group
// @param isLeft True, if the user has left the group themselves
func NewPushMessageContentChatDeleteMember(memberName string, isCurrentUser bool, isLeft bool) *PushMessageContentChatDeleteMember {
	pushMessageContentChatDeleteMemberTemp := PushMessageContentChatDeleteMember{
		tdCommon:      tdCommon{Type: "pushMessageContentChatDeleteMember"},
		MemberName:    memberName,
		IsCurrentUser: isCurrentUser,
		IsLeft:        isLeft,
	}

	return &pushMessageContentChatDeleteMemberTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentChatDeleteMember *PushMessageContentChatDeleteMember) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MemberName    string `json:"member_name"`     // Name of the deleted member
		IsCurrentUser bool   `json:"is_current_user"` // True, if the current user was deleted from the group
		IsLeft        bool   `json:"is_left"`         // True, if the user has left the group themselves
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentChatDeleteMember.tdCommon = tempObj.tdCommon
	pushMessageContentChatDeleteMember.MemberName = tempObj.MemberName
	pushMessageContentChatDeleteMember.IsCurrentUser = tempObj.IsCurrentUser
	pushMessageContentChatDeleteMember.IsLeft = tempObj.IsLeft

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentChatDeleteMember *PushMessageContentChatDeleteMember) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentChatDeleteMemberType
}

// PushMessageContentChatJoinByLink A new member joined the chat via an invite link
type PushMessageContentChatJoinByLink struct {
	tdCommon
}

// MessageType return the string telegram-type of PushMessageContentChatJoinByLink
func (pushMessageContentChatJoinByLink *PushMessageContentChatJoinByLink) MessageType() string {
	return "pushMessageContentChatJoinByLink"
}

// NewPushMessageContentChatJoinByLink creates a new PushMessageContentChatJoinByLink
//
func NewPushMessageContentChatJoinByLink() *PushMessageContentChatJoinByLink {
	pushMessageContentChatJoinByLinkTemp := PushMessageContentChatJoinByLink{
		tdCommon: tdCommon{Type: "pushMessageContentChatJoinByLink"},
	}

	return &pushMessageContentChatJoinByLinkTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentChatJoinByLink *PushMessageContentChatJoinByLink) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentChatJoinByLink.tdCommon = tempObj.tdCommon

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentChatJoinByLink *PushMessageContentChatJoinByLink) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentChatJoinByLinkType
}

// PushMessageContentChatJoinByRequest A new member was accepted to the chat by an administrator
type PushMessageContentChatJoinByRequest struct {
	tdCommon
}

// MessageType return the string telegram-type of PushMessageContentChatJoinByRequest
func (pushMessageContentChatJoinByRequest *PushMessageContentChatJoinByRequest) MessageType() string {
	return "pushMessageContentChatJoinByRequest"
}

// NewPushMessageContentChatJoinByRequest creates a new PushMessageContentChatJoinByRequest
//
func NewPushMessageContentChatJoinByRequest() *PushMessageContentChatJoinByRequest {
	pushMessageContentChatJoinByRequestTemp := PushMessageContentChatJoinByRequest{
		tdCommon: tdCommon{Type: "pushMessageContentChatJoinByRequest"},
	}

	return &pushMessageContentChatJoinByRequestTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentChatJoinByRequest *PushMessageContentChatJoinByRequest) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentChatJoinByRequest.tdCommon = tempObj.tdCommon

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentChatJoinByRequest *PushMessageContentChatJoinByRequest) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentChatJoinByRequestType
}

// PushMessageContentRecurringPayment A new recurring payment was made by the current user
type PushMessageContentRecurringPayment struct {
	tdCommon
	Amount string `json:"amount"` // The paid amount
}

// MessageType return the string telegram-type of PushMessageContentRecurringPayment
func (pushMessageContentRecurringPayment *PushMessageContentRecurringPayment) MessageType() string {
	return "pushMessageContentRecurringPayment"
}

// NewPushMessageContentRecurringPayment creates a new PushMessageContentRecurringPayment
//
// @param amount The paid amount
func NewPushMessageContentRecurringPayment(amount string) *PushMessageContentRecurringPayment {
	pushMessageContentRecurringPaymentTemp := PushMessageContentRecurringPayment{
		tdCommon: tdCommon{Type: "pushMessageContentRecurringPayment"},
		Amount:   amount,
	}

	return &pushMessageContentRecurringPaymentTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentRecurringPayment *PushMessageContentRecurringPayment) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Amount string `json:"amount"` // The paid amount
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentRecurringPayment.tdCommon = tempObj.tdCommon
	pushMessageContentRecurringPayment.Amount = tempObj.Amount

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentRecurringPayment *PushMessageContentRecurringPayment) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentRecurringPaymentType
}

// PushMessageContentSuggestProfilePhoto A profile photo was suggested to the user
type PushMessageContentSuggestProfilePhoto struct {
	tdCommon
}

// MessageType return the string telegram-type of PushMessageContentSuggestProfilePhoto
func (pushMessageContentSuggestProfilePhoto *PushMessageContentSuggestProfilePhoto) MessageType() string {
	return "pushMessageContentSuggestProfilePhoto"
}

// NewPushMessageContentSuggestProfilePhoto creates a new PushMessageContentSuggestProfilePhoto
//
func NewPushMessageContentSuggestProfilePhoto() *PushMessageContentSuggestProfilePhoto {
	pushMessageContentSuggestProfilePhotoTemp := PushMessageContentSuggestProfilePhoto{
		tdCommon: tdCommon{Type: "pushMessageContentSuggestProfilePhoto"},
	}

	return &pushMessageContentSuggestProfilePhotoTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentSuggestProfilePhoto *PushMessageContentSuggestProfilePhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentSuggestProfilePhoto.tdCommon = tempObj.tdCommon

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentSuggestProfilePhoto *PushMessageContentSuggestProfilePhoto) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentSuggestProfilePhotoType
}

// PushMessageContentMessageForwards A forwarded messages
type PushMessageContentMessageForwards struct {
	tdCommon
	TotalCount int32 `json:"total_count"` // Number of forwarded messages
}

// MessageType return the string telegram-type of PushMessageContentMessageForwards
func (pushMessageContentMessageForwards *PushMessageContentMessageForwards) MessageType() string {
	return "pushMessageContentMessageForwards"
}

// NewPushMessageContentMessageForwards creates a new PushMessageContentMessageForwards
//
// @param totalCount Number of forwarded messages
func NewPushMessageContentMessageForwards(totalCount int32) *PushMessageContentMessageForwards {
	pushMessageContentMessageForwardsTemp := PushMessageContentMessageForwards{
		tdCommon:   tdCommon{Type: "pushMessageContentMessageForwards"},
		TotalCount: totalCount,
	}

	return &pushMessageContentMessageForwardsTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentMessageForwards *PushMessageContentMessageForwards) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32 `json:"total_count"` // Number of forwarded messages
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentMessageForwards.tdCommon = tempObj.tdCommon
	pushMessageContentMessageForwards.TotalCount = tempObj.TotalCount

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentMessageForwards *PushMessageContentMessageForwards) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentMessageForwardsType
}

// PushMessageContentMediaAlbum A media album
type PushMessageContentMediaAlbum struct {
	tdCommon
	TotalCount   int32 `json:"total_count"`   // Number of messages in the album
	HasPhotos    bool  `json:"has_photos"`    // True, if the album has at least one photo
	HasVideos    bool  `json:"has_videos"`    // True, if the album has at least one video file
	HasAudios    bool  `json:"has_audios"`    // True, if the album has at least one audio file
	HasDocuments bool  `json:"has_documents"` // True, if the album has at least one document
}

// MessageType return the string telegram-type of PushMessageContentMediaAlbum
func (pushMessageContentMediaAlbum *PushMessageContentMediaAlbum) MessageType() string {
	return "pushMessageContentMediaAlbum"
}

// NewPushMessageContentMediaAlbum creates a new PushMessageContentMediaAlbum
//
// @param totalCount Number of messages in the album
// @param hasPhotos True, if the album has at least one photo
// @param hasVideos True, if the album has at least one video file
// @param hasAudios True, if the album has at least one audio file
// @param hasDocuments True, if the album has at least one document
func NewPushMessageContentMediaAlbum(totalCount int32, hasPhotos bool, hasVideos bool, hasAudios bool, hasDocuments bool) *PushMessageContentMediaAlbum {
	pushMessageContentMediaAlbumTemp := PushMessageContentMediaAlbum{
		tdCommon:     tdCommon{Type: "pushMessageContentMediaAlbum"},
		TotalCount:   totalCount,
		HasPhotos:    hasPhotos,
		HasVideos:    hasVideos,
		HasAudios:    hasAudios,
		HasDocuments: hasDocuments,
	}

	return &pushMessageContentMediaAlbumTemp
}

// UnmarshalJSON unmarshal to json
func (pushMessageContentMediaAlbum *PushMessageContentMediaAlbum) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount   int32 `json:"total_count"`   // Number of messages in the album
		HasPhotos    bool  `json:"has_photos"`    // True, if the album has at least one photo
		HasVideos    bool  `json:"has_videos"`    // True, if the album has at least one video file
		HasAudios    bool  `json:"has_audios"`    // True, if the album has at least one audio file
		HasDocuments bool  `json:"has_documents"` // True, if the album has at least one document
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	pushMessageContentMediaAlbum.tdCommon = tempObj.tdCommon
	pushMessageContentMediaAlbum.TotalCount = tempObj.TotalCount
	pushMessageContentMediaAlbum.HasPhotos = tempObj.HasPhotos
	pushMessageContentMediaAlbum.HasVideos = tempObj.HasVideos
	pushMessageContentMediaAlbum.HasAudios = tempObj.HasAudios
	pushMessageContentMediaAlbum.HasDocuments = tempObj.HasDocuments

	return nil
}

// GetPushMessageContentEnum return the enum type of this object
func (pushMessageContentMediaAlbum *PushMessageContentMediaAlbum) GetPushMessageContentEnum() PushMessageContentEnum {
	return PushMessageContentMediaAlbumType
}

// NotificationTypeNewMessage New message was received
type NotificationTypeNewMessage struct {
	tdCommon
	Message     *Message `json:"message"`      // The message
	ShowPreview bool     `json:"show_preview"` // True, if message content must be displayed in notifications
}

// MessageType return the string telegram-type of NotificationTypeNewMessage
func (notificationTypeNewMessage *NotificationTypeNewMessage) MessageType() string {
	return "notificationTypeNewMessage"
}

// NewNotificationTypeNewMessage creates a new NotificationTypeNewMessage
//
// @param message The message
// @param showPreview True, if message content must be displayed in notifications
func NewNotificationTypeNewMessage(message *Message, showPreview bool) *NotificationTypeNewMessage {
	notificationTypeNewMessageTemp := NotificationTypeNewMessage{
		tdCommon:    tdCommon{Type: "notificationTypeNewMessage"},
		Message:     message,
		ShowPreview: showPreview,
	}

	return &notificationTypeNewMessageTemp
}

// UnmarshalJSON unmarshal to json
func (notificationTypeNewMessage *NotificationTypeNewMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ShowPreview bool `json:"show_preview"` // True, if message content must be displayed in notifications
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	notificationTypeNewMessage.tdCommon = tempObj.tdCommon
	notificationTypeNewMessage.ShowPreview = tempObj.ShowPreview

	var message Message
	if objMap["message"] != nil {
		err = message.UnmarshalJSON(*objMap["message"])
		if err != nil {
			return err
		}
	}

	notificationTypeNewMessage.Message = &message

	return nil
}

// GetNotificationTypeEnum return the enum type of this object
func (notificationTypeNewMessage *NotificationTypeNewMessage) GetNotificationTypeEnum() NotificationTypeEnum {
	return NotificationTypeNewMessageType
}

// NotificationTypeNewSecretChat New secret chat was created
type NotificationTypeNewSecretChat struct {
	tdCommon
}

// MessageType return the string telegram-type of NotificationTypeNewSecretChat
func (notificationTypeNewSecretChat *NotificationTypeNewSecretChat) MessageType() string {
	return "notificationTypeNewSecretChat"
}

// NewNotificationTypeNewSecretChat creates a new NotificationTypeNewSecretChat
//
func NewNotificationTypeNewSecretChat() *NotificationTypeNewSecretChat {
	notificationTypeNewSecretChatTemp := NotificationTypeNewSecretChat{
		tdCommon: tdCommon{Type: "notificationTypeNewSecretChat"},
	}

	return &notificationTypeNewSecretChatTemp
}

// UnmarshalJSON unmarshal to json
func (notificationTypeNewSecretChat *NotificationTypeNewSecretChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	notificationTypeNewSecretChat.tdCommon = tempObj.tdCommon

	return nil
}

// GetNotificationTypeEnum return the enum type of this object
func (notificationTypeNewSecretChat *NotificationTypeNewSecretChat) GetNotificationTypeEnum() NotificationTypeEnum {
	return NotificationTypeNewSecretChatType
}

// NotificationTypeNewCall New call was received
type NotificationTypeNewCall struct {
	tdCommon
	CallID int32 `json:"call_id"` // Call identifier
}

// MessageType return the string telegram-type of NotificationTypeNewCall
func (notificationTypeNewCall *NotificationTypeNewCall) MessageType() string {
	return "notificationTypeNewCall"
}

// NewNotificationTypeNewCall creates a new NotificationTypeNewCall
//
// @param callID Call identifier
func NewNotificationTypeNewCall(callID int32) *NotificationTypeNewCall {
	notificationTypeNewCallTemp := NotificationTypeNewCall{
		tdCommon: tdCommon{Type: "notificationTypeNewCall"},
		CallID:   callID,
	}

	return &notificationTypeNewCallTemp
}

// UnmarshalJSON unmarshal to json
func (notificationTypeNewCall *NotificationTypeNewCall) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CallID int32 `json:"call_id"` // Call identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	notificationTypeNewCall.tdCommon = tempObj.tdCommon
	notificationTypeNewCall.CallID = tempObj.CallID

	return nil
}

// GetNotificationTypeEnum return the enum type of this object
func (notificationTypeNewCall *NotificationTypeNewCall) GetNotificationTypeEnum() NotificationTypeEnum {
	return NotificationTypeNewCallType
}

// NotificationTypeNewPushMessage New message was received through a push notification
type NotificationTypeNewPushMessage struct {
	tdCommon
	MessageID  int64              `json:"message_id"`  // The message identifier. The message will not be available in the chat history, but the identifier can be used in viewMessages, or as a message to be replied in the same chat
	SenderID   MessageSender      `json:"sender_id"`   // Identifier of the sender of the message. Corresponding user or chat may be inaccessible
	SenderName string             `json:"sender_name"` // Name of the sender
	IsOutgoing bool               `json:"is_outgoing"` // True, if the message is outgoing
	Content    PushMessageContent `json:"content"`     // Push message content
}

// MessageType return the string telegram-type of NotificationTypeNewPushMessage
func (notificationTypeNewPushMessage *NotificationTypeNewPushMessage) MessageType() string {
	return "notificationTypeNewPushMessage"
}

// NewNotificationTypeNewPushMessage creates a new NotificationTypeNewPushMessage
//
// @param messageID The message identifier. The message will not be available in the chat history, but the identifier can be used in viewMessages, or as a message to be replied in the same chat
// @param senderID Identifier of the sender of the message. Corresponding user or chat may be inaccessible
// @param senderName Name of the sender
// @param isOutgoing True, if the message is outgoing
// @param content Push message content
func NewNotificationTypeNewPushMessage(messageID int64, senderID MessageSender, senderName string, isOutgoing bool, content PushMessageContent) *NotificationTypeNewPushMessage {
	notificationTypeNewPushMessageTemp := NotificationTypeNewPushMessage{
		tdCommon:   tdCommon{Type: "notificationTypeNewPushMessage"},
		MessageID:  messageID,
		SenderID:   senderID,
		SenderName: senderName,
		IsOutgoing: isOutgoing,
		Content:    content,
	}

	return &notificationTypeNewPushMessageTemp
}

// UnmarshalJSON unmarshal to json
func (notificationTypeNewPushMessage *NotificationTypeNewPushMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MessageID  int64  `json:"message_id"`  // The message identifier. The message will not be available in the chat history, but the identifier can be used in viewMessages, or as a message to be replied in the same chat
		SenderName string `json:"sender_name"` // Name of the sender
		IsOutgoing bool   `json:"is_outgoing"` // True, if the message is outgoing

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	notificationTypeNewPushMessage.tdCommon = tempObj.tdCommon
	notificationTypeNewPushMessage.MessageID = tempObj.MessageID
	notificationTypeNewPushMessage.SenderName = tempObj.SenderName
	notificationTypeNewPushMessage.IsOutgoing = tempObj.IsOutgoing

	fieldSenderID, _ := unmarshalMessageSender(objMap["sender_id"])
	notificationTypeNewPushMessage.SenderID = fieldSenderID

	fieldContent, _ := unmarshalPushMessageContent(objMap["content"])
	notificationTypeNewPushMessage.Content = fieldContent

	return nil
}

// GetNotificationTypeEnum return the enum type of this object
func (notificationTypeNewPushMessage *NotificationTypeNewPushMessage) GetNotificationTypeEnum() NotificationTypeEnum {
	return NotificationTypeNewPushMessageType
}

// NotificationGroupTypeMessages A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with ordinary unread messages
type NotificationGroupTypeMessages struct {
	tdCommon
}

// MessageType return the string telegram-type of NotificationGroupTypeMessages
func (notificationGroupTypeMessages *NotificationGroupTypeMessages) MessageType() string {
	return "notificationGroupTypeMessages"
}

// NewNotificationGroupTypeMessages creates a new NotificationGroupTypeMessages
//
func NewNotificationGroupTypeMessages() *NotificationGroupTypeMessages {
	notificationGroupTypeMessagesTemp := NotificationGroupTypeMessages{
		tdCommon: tdCommon{Type: "notificationGroupTypeMessages"},
	}

	return &notificationGroupTypeMessagesTemp
}

// UnmarshalJSON unmarshal to json
func (notificationGroupTypeMessages *NotificationGroupTypeMessages) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	notificationGroupTypeMessages.tdCommon = tempObj.tdCommon

	return nil
}

// GetNotificationGroupTypeEnum return the enum type of this object
func (notificationGroupTypeMessages *NotificationGroupTypeMessages) GetNotificationGroupTypeEnum() NotificationGroupTypeEnum {
	return NotificationGroupTypeMessagesType
}

// NotificationGroupTypeMentions A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with unread mentions of the current user, replies to their messages, or a pinned message
type NotificationGroupTypeMentions struct {
	tdCommon
}

// MessageType return the string telegram-type of NotificationGroupTypeMentions
func (notificationGroupTypeMentions *NotificationGroupTypeMentions) MessageType() string {
	return "notificationGroupTypeMentions"
}

// NewNotificationGroupTypeMentions creates a new NotificationGroupTypeMentions
//
func NewNotificationGroupTypeMentions() *NotificationGroupTypeMentions {
	notificationGroupTypeMentionsTemp := NotificationGroupTypeMentions{
		tdCommon: tdCommon{Type: "notificationGroupTypeMentions"},
	}

	return &notificationGroupTypeMentionsTemp
}

// UnmarshalJSON unmarshal to json
func (notificationGroupTypeMentions *NotificationGroupTypeMentions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	notificationGroupTypeMentions.tdCommon = tempObj.tdCommon

	return nil
}

// GetNotificationGroupTypeEnum return the enum type of this object
func (notificationGroupTypeMentions *NotificationGroupTypeMentions) GetNotificationGroupTypeEnum() NotificationGroupTypeEnum {
	return NotificationGroupTypeMentionsType
}

// NotificationGroupTypeSecretChat A group containing a notification of type notificationTypeNewSecretChat
type NotificationGroupTypeSecretChat struct {
	tdCommon
}

// MessageType return the string telegram-type of NotificationGroupTypeSecretChat
func (notificationGroupTypeSecretChat *NotificationGroupTypeSecretChat) MessageType() string {
	return "notificationGroupTypeSecretChat"
}

// NewNotificationGroupTypeSecretChat creates a new NotificationGroupTypeSecretChat
//
func NewNotificationGroupTypeSecretChat() *NotificationGroupTypeSecretChat {
	notificationGroupTypeSecretChatTemp := NotificationGroupTypeSecretChat{
		tdCommon: tdCommon{Type: "notificationGroupTypeSecretChat"},
	}

	return &notificationGroupTypeSecretChatTemp
}

// UnmarshalJSON unmarshal to json
func (notificationGroupTypeSecretChat *NotificationGroupTypeSecretChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	notificationGroupTypeSecretChat.tdCommon = tempObj.tdCommon

	return nil
}

// GetNotificationGroupTypeEnum return the enum type of this object
func (notificationGroupTypeSecretChat *NotificationGroupTypeSecretChat) GetNotificationGroupTypeEnum() NotificationGroupTypeEnum {
	return NotificationGroupTypeSecretChatType
}

// NotificationGroupTypeCalls A group containing notifications of type notificationTypeNewCall
type NotificationGroupTypeCalls struct {
	tdCommon
}

// MessageType return the string telegram-type of NotificationGroupTypeCalls
func (notificationGroupTypeCalls *NotificationGroupTypeCalls) MessageType() string {
	return "notificationGroupTypeCalls"
}

// NewNotificationGroupTypeCalls creates a new NotificationGroupTypeCalls
//
func NewNotificationGroupTypeCalls() *NotificationGroupTypeCalls {
	notificationGroupTypeCallsTemp := NotificationGroupTypeCalls{
		tdCommon: tdCommon{Type: "notificationGroupTypeCalls"},
	}

	return &notificationGroupTypeCallsTemp
}

// UnmarshalJSON unmarshal to json
func (notificationGroupTypeCalls *NotificationGroupTypeCalls) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	notificationGroupTypeCalls.tdCommon = tempObj.tdCommon

	return nil
}

// GetNotificationGroupTypeEnum return the enum type of this object
func (notificationGroupTypeCalls *NotificationGroupTypeCalls) GetNotificationGroupTypeEnum() NotificationGroupTypeEnum {
	return NotificationGroupTypeCallsType
}

// NotificationSound Describes a notification sound in MP3 format
type NotificationSound struct {
	tdCommon
	ID       JSONInt64 `json:"id"`       // Unique identifier of the notification sound
	Duration int32     `json:"duration"` // Duration of the sound, in seconds
	Date     int32     `json:"date"`     // Point in time (Unix timestamp) when the sound was created
	Title    string    `json:"title"`    // Title of the notification sound
	Data     string    `json:"data"`     // Arbitrary data, defined while the sound was uploaded
	Sound    *File     `json:"sound"`    // File containing the sound
}

// MessageType return the string telegram-type of NotificationSound
func (notificationSound *NotificationSound) MessageType() string {
	return "notificationSound"
}

// NewNotificationSound creates a new NotificationSound
//
// @param iD Unique identifier of the notification sound
// @param duration Duration of the sound, in seconds
// @param date Point in time (Unix timestamp) when the sound was created
// @param title Title of the notification sound
// @param data Arbitrary data, defined while the sound was uploaded
// @param sound File containing the sound
func NewNotificationSound(iD JSONInt64, duration int32, date int32, title string, data string, sound *File) *NotificationSound {
	notificationSoundTemp := NotificationSound{
		tdCommon: tdCommon{Type: "notificationSound"},
		ID:       iD,
		Duration: duration,
		Date:     date,
		Title:    title,
		Data:     data,
		Sound:    sound,
	}

	return &notificationSoundTemp
}

// UnmarshalJSON unmarshal to json
func (notificationSound *NotificationSound) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID       JSONInt64 `json:"id"`       // Unique identifier of the notification sound
		Duration int32     `json:"duration"` // Duration of the sound, in seconds
		Date     int32     `json:"date"`     // Point in time (Unix timestamp) when the sound was created
		Title    string    `json:"title"`    // Title of the notification sound
		Data     string    `json:"data"`     // Arbitrary data, defined while the sound was uploaded
		Sound    *File     `json:"sound"`    // File containing the sound
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	notificationSound.tdCommon = tempObj.tdCommon
	notificationSound.ID = tempObj.ID
	notificationSound.Duration = tempObj.Duration
	notificationSound.Date = tempObj.Date
	notificationSound.Title = tempObj.Title
	notificationSound.Data = tempObj.Data
	notificationSound.Sound = tempObj.Sound

	return nil
}

// NotificationSounds Contains a list of notification sounds
type NotificationSounds struct {
	tdCommon
	NotificationSounds []NotificationSound `json:"notification_sounds"` // A list of notification sounds
}

// MessageType return the string telegram-type of NotificationSounds
func (notificationSounds *NotificationSounds) MessageType() string {
	return "notificationSounds"
}

// NewNotificationSounds creates a new NotificationSounds
//
// @param notificationSounds A list of notification sounds
func NewNotificationSounds(notificationSounds []NotificationSound) *NotificationSounds {
	notificationSoundsTemp := NotificationSounds{
		tdCommon:           tdCommon{Type: "notificationSounds"},
		NotificationSounds: notificationSounds,
	}

	return &notificationSoundsTemp
}

// UnmarshalJSON unmarshal to json
func (notificationSounds *NotificationSounds) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		NotificationSounds []NotificationSound `json:"notification_sounds"` // A list of notification sounds
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	notificationSounds.tdCommon = tempObj.tdCommon
	notificationSounds.NotificationSounds = tempObj.NotificationSounds

	return nil
}

// Notification Contains information about a notification
type Notification struct {
	tdCommon
	ID       int32            `json:"id"`        // Unique persistent identifier of this notification
	Date     int32            `json:"date"`      // Notification date
	IsSilent bool             `json:"is_silent"` // True, if the notification was explicitly sent without sound
	Type     NotificationType `json:"type"`      // Notification type
}

// MessageType return the string telegram-type of Notification
func (notification *Notification) MessageType() string {
	return "notification"
}

// NewNotification creates a new Notification
//
// @param iD Unique persistent identifier of this notification
// @param date Notification date
// @param isSilent True, if the notification was explicitly sent without sound
// @param typeParam Notification type
func NewNotification(iD int32, date int32, isSilent bool, typeParam NotificationType) *Notification {
	notificationTemp := Notification{
		tdCommon: tdCommon{Type: "notification"},
		ID:       iD,
		Date:     date,
		IsSilent: isSilent,
		Type:     typeParam,
	}

	return &notificationTemp
}

// UnmarshalJSON unmarshal to json
func (notification *Notification) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID       int32 `json:"id"`        // Unique persistent identifier of this notification
		Date     int32 `json:"date"`      // Notification date
		IsSilent bool  `json:"is_silent"` // True, if the notification was explicitly sent without sound

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	notification.tdCommon = tempObj.tdCommon
	notification.ID = tempObj.ID
	notification.Date = tempObj.Date
	notification.IsSilent = tempObj.IsSilent

	fieldType, _ := unmarshalNotificationType(objMap["type"])
	notification.Type = fieldType

	return nil
}

// NotificationGroup Describes a group of notifications
type NotificationGroup struct {
	tdCommon
	ID            int32                 `json:"id"`            // Unique persistent auto-incremented from 1 identifier of the notification group
	Type          NotificationGroupType `json:"type"`          // Type of the group
	ChatID        int64                 `json:"chat_id"`       // Identifier of a chat to which all notifications in the group belong
	TotalCount    int32                 `json:"total_count"`   // Total number of active notifications in the group
	Notifications []Notification        `json:"notifications"` // The list of active notifications
}

// MessageType return the string telegram-type of NotificationGroup
func (notificationGroup *NotificationGroup) MessageType() string {
	return "notificationGroup"
}

// NewNotificationGroup creates a new NotificationGroup
//
// @param iD Unique persistent auto-incremented from 1 identifier of the notification group
// @param typeParam Type of the group
// @param chatID Identifier of a chat to which all notifications in the group belong
// @param totalCount Total number of active notifications in the group
// @param notifications The list of active notifications
func NewNotificationGroup(iD int32, typeParam NotificationGroupType, chatID int64, totalCount int32, notifications []Notification) *NotificationGroup {
	notificationGroupTemp := NotificationGroup{
		tdCommon:      tdCommon{Type: "notificationGroup"},
		ID:            iD,
		Type:          typeParam,
		ChatID:        chatID,
		TotalCount:    totalCount,
		Notifications: notifications,
	}

	return &notificationGroupTemp
}

// UnmarshalJSON unmarshal to json
func (notificationGroup *NotificationGroup) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID            int32          `json:"id"`            // Unique persistent auto-incremented from 1 identifier of the notification group
		ChatID        int64          `json:"chat_id"`       // Identifier of a chat to which all notifications in the group belong
		TotalCount    int32          `json:"total_count"`   // Total number of active notifications in the group
		Notifications []Notification `json:"notifications"` // The list of active notifications
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	notificationGroup.tdCommon = tempObj.tdCommon
	notificationGroup.ID = tempObj.ID
	notificationGroup.ChatID = tempObj.ChatID
	notificationGroup.TotalCount = tempObj.TotalCount
	notificationGroup.Notifications = tempObj.Notifications

	fieldType, _ := unmarshalNotificationGroupType(objMap["type"])
	notificationGroup.Type = fieldType

	return nil
}

// OptionValueBoolean Represents a boolean option
type OptionValueBoolean struct {
	tdCommon
	Value bool `json:"value"` // The value of the option
}

// MessageType return the string telegram-type of OptionValueBoolean
func (optionValueBoolean *OptionValueBoolean) MessageType() string {
	return "optionValueBoolean"
}

// NewOptionValueBoolean creates a new OptionValueBoolean
//
// @param value The value of the option
func NewOptionValueBoolean(value bool) *OptionValueBoolean {
	optionValueBooleanTemp := OptionValueBoolean{
		tdCommon: tdCommon{Type: "optionValueBoolean"},
		Value:    value,
	}

	return &optionValueBooleanTemp
}

// UnmarshalJSON unmarshal to json
func (optionValueBoolean *OptionValueBoolean) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Value bool `json:"value"` // The value of the option
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	optionValueBoolean.tdCommon = tempObj.tdCommon
	optionValueBoolean.Value = tempObj.Value

	return nil
}

// GetOptionValueEnum return the enum type of this object
func (optionValueBoolean *OptionValueBoolean) GetOptionValueEnum() OptionValueEnum {
	return OptionValueBooleanType
}

// OptionValueEmpty Represents an unknown option or an option which has a default value
type OptionValueEmpty struct {
	tdCommon
}

// MessageType return the string telegram-type of OptionValueEmpty
func (optionValueEmpty *OptionValueEmpty) MessageType() string {
	return "optionValueEmpty"
}

// NewOptionValueEmpty creates a new OptionValueEmpty
//
func NewOptionValueEmpty() *OptionValueEmpty {
	optionValueEmptyTemp := OptionValueEmpty{
		tdCommon: tdCommon{Type: "optionValueEmpty"},
	}

	return &optionValueEmptyTemp
}

// UnmarshalJSON unmarshal to json
func (optionValueEmpty *OptionValueEmpty) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	optionValueEmpty.tdCommon = tempObj.tdCommon

	return nil
}

// GetOptionValueEnum return the enum type of this object
func (optionValueEmpty *OptionValueEmpty) GetOptionValueEnum() OptionValueEnum {
	return OptionValueEmptyType
}

// OptionValueInteger Represents an integer option
type OptionValueInteger struct {
	tdCommon
	Value JSONInt64 `json:"value"` // The value of the option
}

// MessageType return the string telegram-type of OptionValueInteger
func (optionValueInteger *OptionValueInteger) MessageType() string {
	return "optionValueInteger"
}

// NewOptionValueInteger creates a new OptionValueInteger
//
// @param value The value of the option
func NewOptionValueInteger(value JSONInt64) *OptionValueInteger {
	optionValueIntegerTemp := OptionValueInteger{
		tdCommon: tdCommon{Type: "optionValueInteger"},
		Value:    value,
	}

	return &optionValueIntegerTemp
}

// UnmarshalJSON unmarshal to json
func (optionValueInteger *OptionValueInteger) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Value JSONInt64 `json:"value"` // The value of the option
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	optionValueInteger.tdCommon = tempObj.tdCommon
	optionValueInteger.Value = tempObj.Value

	return nil
}

// GetOptionValueEnum return the enum type of this object
func (optionValueInteger *OptionValueInteger) GetOptionValueEnum() OptionValueEnum {
	return OptionValueIntegerType
}

// OptionValueString Represents a string option
type OptionValueString struct {
	tdCommon
	Value string `json:"value"` // The value of the option
}

// MessageType return the string telegram-type of OptionValueString
func (optionValueString *OptionValueString) MessageType() string {
	return "optionValueString"
}

// NewOptionValueString creates a new OptionValueString
//
// @param value The value of the option
func NewOptionValueString(value string) *OptionValueString {
	optionValueStringTemp := OptionValueString{
		tdCommon: tdCommon{Type: "optionValueString"},
		Value:    value,
	}

	return &optionValueStringTemp
}

// UnmarshalJSON unmarshal to json
func (optionValueString *OptionValueString) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Value string `json:"value"` // The value of the option
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	optionValueString.tdCommon = tempObj.tdCommon
	optionValueString.Value = tempObj.Value

	return nil
}

// GetOptionValueEnum return the enum type of this object
func (optionValueString *OptionValueString) GetOptionValueEnum() OptionValueEnum {
	return OptionValueStringType
}

// JsonObjectMember Represents one member of a JSON object
type JsonObjectMember struct {
	tdCommon
	Key   string    `json:"key"`   // Member's key
	Value JsonValue `json:"value"` // Member's value
}

// MessageType return the string telegram-type of JsonObjectMember
func (jsonObjectMember *JsonObjectMember) MessageType() string {
	return "jsonObjectMember"
}

// NewJsonObjectMember creates a new JsonObjectMember
//
// @param key Member's key
// @param value Member's value
func NewJsonObjectMember(key string, value JsonValue) *JsonObjectMember {
	jsonObjectMemberTemp := JsonObjectMember{
		tdCommon: tdCommon{Type: "jsonObjectMember"},
		Key:      key,
		Value:    value,
	}

	return &jsonObjectMemberTemp
}

// UnmarshalJSON unmarshal to json
func (jsonObjectMember *JsonObjectMember) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Key string `json:"key"` // Member's key

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	jsonObjectMember.tdCommon = tempObj.tdCommon
	jsonObjectMember.Key = tempObj.Key

	fieldValue, _ := unmarshalJsonValue(objMap["value"])
	jsonObjectMember.Value = fieldValue

	return nil
}

// JsonValueNull Represents a null JSON value
type JsonValueNull struct {
	tdCommon
}

// MessageType return the string telegram-type of JsonValueNull
func (jsonValueNull *JsonValueNull) MessageType() string {
	return "jsonValueNull"
}

// NewJsonValueNull creates a new JsonValueNull
//
func NewJsonValueNull() *JsonValueNull {
	jsonValueNullTemp := JsonValueNull{
		tdCommon: tdCommon{Type: "jsonValueNull"},
	}

	return &jsonValueNullTemp
}

// UnmarshalJSON unmarshal to json
func (jsonValueNull *JsonValueNull) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	jsonValueNull.tdCommon = tempObj.tdCommon

	return nil
}

// GetJsonValueEnum return the enum type of this object
func (jsonValueNull *JsonValueNull) GetJsonValueEnum() JsonValueEnum {
	return JsonValueNullType
}

// JsonValueBoolean Represents a boolean JSON value
type JsonValueBoolean struct {
	tdCommon
	Value bool `json:"value"` // The value
}

// MessageType return the string telegram-type of JsonValueBoolean
func (jsonValueBoolean *JsonValueBoolean) MessageType() string {
	return "jsonValueBoolean"
}

// NewJsonValueBoolean creates a new JsonValueBoolean
//
// @param value The value
func NewJsonValueBoolean(value bool) *JsonValueBoolean {
	jsonValueBooleanTemp := JsonValueBoolean{
		tdCommon: tdCommon{Type: "jsonValueBoolean"},
		Value:    value,
	}

	return &jsonValueBooleanTemp
}

// UnmarshalJSON unmarshal to json
func (jsonValueBoolean *JsonValueBoolean) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Value bool `json:"value"` // The value
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	jsonValueBoolean.tdCommon = tempObj.tdCommon
	jsonValueBoolean.Value = tempObj.Value

	return nil
}

// GetJsonValueEnum return the enum type of this object
func (jsonValueBoolean *JsonValueBoolean) GetJsonValueEnum() JsonValueEnum {
	return JsonValueBooleanType
}

// JsonValueNumber Represents a numeric JSON value
type JsonValueNumber struct {
	tdCommon
	Value float64 `json:"value"` // The value
}

// MessageType return the string telegram-type of JsonValueNumber
func (jsonValueNumber *JsonValueNumber) MessageType() string {
	return "jsonValueNumber"
}

// NewJsonValueNumber creates a new JsonValueNumber
//
// @param value The value
func NewJsonValueNumber(value float64) *JsonValueNumber {
	jsonValueNumberTemp := JsonValueNumber{
		tdCommon: tdCommon{Type: "jsonValueNumber"},
		Value:    value,
	}

	return &jsonValueNumberTemp
}

// UnmarshalJSON unmarshal to json
func (jsonValueNumber *JsonValueNumber) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Value float64 `json:"value"` // The value
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	jsonValueNumber.tdCommon = tempObj.tdCommon
	jsonValueNumber.Value = tempObj.Value

	return nil
}

// GetJsonValueEnum return the enum type of this object
func (jsonValueNumber *JsonValueNumber) GetJsonValueEnum() JsonValueEnum {
	return JsonValueNumberType
}

// JsonValueString Represents a string JSON value
type JsonValueString struct {
	tdCommon
	Value string `json:"value"` // The value
}

// MessageType return the string telegram-type of JsonValueString
func (jsonValueString *JsonValueString) MessageType() string {
	return "jsonValueString"
}

// NewJsonValueString creates a new JsonValueString
//
// @param value The value
func NewJsonValueString(value string) *JsonValueString {
	jsonValueStringTemp := JsonValueString{
		tdCommon: tdCommon{Type: "jsonValueString"},
		Value:    value,
	}

	return &jsonValueStringTemp
}

// UnmarshalJSON unmarshal to json
func (jsonValueString *JsonValueString) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Value string `json:"value"` // The value
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	jsonValueString.tdCommon = tempObj.tdCommon
	jsonValueString.Value = tempObj.Value

	return nil
}

// GetJsonValueEnum return the enum type of this object
func (jsonValueString *JsonValueString) GetJsonValueEnum() JsonValueEnum {
	return JsonValueStringType
}

// JsonValueArray Represents a JSON array
type JsonValueArray struct {
	tdCommon
	Values []JsonValue `json:"values"` // The list of array elements
}

// MessageType return the string telegram-type of JsonValueArray
func (jsonValueArray *JsonValueArray) MessageType() string {
	return "jsonValueArray"
}

// NewJsonValueArray creates a new JsonValueArray
//
// @param values The list of array elements
func NewJsonValueArray(values []JsonValue) *JsonValueArray {
	jsonValueArrayTemp := JsonValueArray{
		tdCommon: tdCommon{Type: "jsonValueArray"},
		Values:   values,
	}

	return &jsonValueArrayTemp
}

// UnmarshalJSON unmarshal to json
func (jsonValueArray *JsonValueArray) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	jsonValueArray.tdCommon = tempObj.tdCommon

	fieldValues, _ := unmarshalJsonValueSlice(objMap["values"])
	jsonValueArray.Values = fieldValues

	return nil
}

// GetJsonValueEnum return the enum type of this object
func (jsonValueArray *JsonValueArray) GetJsonValueEnum() JsonValueEnum {
	return JsonValueArrayType
}

// JsonValueObject Represents a JSON object
type JsonValueObject struct {
	tdCommon
	Members []JsonObjectMember `json:"members"` // The list of object members
}

// MessageType return the string telegram-type of JsonValueObject
func (jsonValueObject *JsonValueObject) MessageType() string {
	return "jsonValueObject"
}

// NewJsonValueObject creates a new JsonValueObject
//
// @param members The list of object members
func NewJsonValueObject(members []JsonObjectMember) *JsonValueObject {
	jsonValueObjectTemp := JsonValueObject{
		tdCommon: tdCommon{Type: "jsonValueObject"},
		Members:  members,
	}

	return &jsonValueObjectTemp
}

// UnmarshalJSON unmarshal to json
func (jsonValueObject *JsonValueObject) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Members []JsonObjectMember `json:"members"` // The list of object members
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	jsonValueObject.tdCommon = tempObj.tdCommon
	jsonValueObject.Members = tempObj.Members

	return nil
}

// GetJsonValueEnum return the enum type of this object
func (jsonValueObject *JsonValueObject) GetJsonValueEnum() JsonValueEnum {
	return JsonValueObjectType
}

// StoryPrivacySettingsEveryone The story can be viewed by everyone
type StoryPrivacySettingsEveryone struct {
	tdCommon
	ExceptUserIDs []int64 `json:"except_user_ids"` // Identifiers of the users that can't see the story; always unknown and empty for non-owned stories
}

// MessageType return the string telegram-type of StoryPrivacySettingsEveryone
func (storyPrivacySettingsEveryone *StoryPrivacySettingsEveryone) MessageType() string {
	return "storyPrivacySettingsEveryone"
}

// NewStoryPrivacySettingsEveryone creates a new StoryPrivacySettingsEveryone
//
// @param exceptUserIDs Identifiers of the users that can't see the story; always unknown and empty for non-owned stories
func NewStoryPrivacySettingsEveryone(exceptUserIDs []int64) *StoryPrivacySettingsEveryone {
	storyPrivacySettingsEveryoneTemp := StoryPrivacySettingsEveryone{
		tdCommon:      tdCommon{Type: "storyPrivacySettingsEveryone"},
		ExceptUserIDs: exceptUserIDs,
	}

	return &storyPrivacySettingsEveryoneTemp
}

// UnmarshalJSON unmarshal to json
func (storyPrivacySettingsEveryone *StoryPrivacySettingsEveryone) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ExceptUserIDs []int64 `json:"except_user_ids"` // Identifiers of the users that can't see the story; always unknown and empty for non-owned stories
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyPrivacySettingsEveryone.tdCommon = tempObj.tdCommon
	storyPrivacySettingsEveryone.ExceptUserIDs = tempObj.ExceptUserIDs

	return nil
}

// GetStoryPrivacySettingsEnum return the enum type of this object
func (storyPrivacySettingsEveryone *StoryPrivacySettingsEveryone) GetStoryPrivacySettingsEnum() StoryPrivacySettingsEnum {
	return StoryPrivacySettingsEveryoneType
}

// StoryPrivacySettingsContacts The story can be viewed by all contacts except chosen users
type StoryPrivacySettingsContacts struct {
	tdCommon
	ExceptUserIDs []int64 `json:"except_user_ids"` // User identifiers of the contacts that can't see the story; always unknown and empty for non-owned stories
}

// MessageType return the string telegram-type of StoryPrivacySettingsContacts
func (storyPrivacySettingsContacts *StoryPrivacySettingsContacts) MessageType() string {
	return "storyPrivacySettingsContacts"
}

// NewStoryPrivacySettingsContacts creates a new StoryPrivacySettingsContacts
//
// @param exceptUserIDs User identifiers of the contacts that can't see the story; always unknown and empty for non-owned stories
func NewStoryPrivacySettingsContacts(exceptUserIDs []int64) *StoryPrivacySettingsContacts {
	storyPrivacySettingsContactsTemp := StoryPrivacySettingsContacts{
		tdCommon:      tdCommon{Type: "storyPrivacySettingsContacts"},
		ExceptUserIDs: exceptUserIDs,
	}

	return &storyPrivacySettingsContactsTemp
}

// UnmarshalJSON unmarshal to json
func (storyPrivacySettingsContacts *StoryPrivacySettingsContacts) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ExceptUserIDs []int64 `json:"except_user_ids"` // User identifiers of the contacts that can't see the story; always unknown and empty for non-owned stories
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyPrivacySettingsContacts.tdCommon = tempObj.tdCommon
	storyPrivacySettingsContacts.ExceptUserIDs = tempObj.ExceptUserIDs

	return nil
}

// GetStoryPrivacySettingsEnum return the enum type of this object
func (storyPrivacySettingsContacts *StoryPrivacySettingsContacts) GetStoryPrivacySettingsEnum() StoryPrivacySettingsEnum {
	return StoryPrivacySettingsContactsType
}

// StoryPrivacySettingsCloseFriends The story can be viewed by all close friends
type StoryPrivacySettingsCloseFriends struct {
	tdCommon
}

// MessageType return the string telegram-type of StoryPrivacySettingsCloseFriends
func (storyPrivacySettingsCloseFriends *StoryPrivacySettingsCloseFriends) MessageType() string {
	return "storyPrivacySettingsCloseFriends"
}

// NewStoryPrivacySettingsCloseFriends creates a new StoryPrivacySettingsCloseFriends
//
func NewStoryPrivacySettingsCloseFriends() *StoryPrivacySettingsCloseFriends {
	storyPrivacySettingsCloseFriendsTemp := StoryPrivacySettingsCloseFriends{
		tdCommon: tdCommon{Type: "storyPrivacySettingsCloseFriends"},
	}

	return &storyPrivacySettingsCloseFriendsTemp
}

// UnmarshalJSON unmarshal to json
func (storyPrivacySettingsCloseFriends *StoryPrivacySettingsCloseFriends) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyPrivacySettingsCloseFriends.tdCommon = tempObj.tdCommon

	return nil
}

// GetStoryPrivacySettingsEnum return the enum type of this object
func (storyPrivacySettingsCloseFriends *StoryPrivacySettingsCloseFriends) GetStoryPrivacySettingsEnum() StoryPrivacySettingsEnum {
	return StoryPrivacySettingsCloseFriendsType
}

// StoryPrivacySettingsSelectedUsers The story can be viewed by certain specified users
type StoryPrivacySettingsSelectedUsers struct {
	tdCommon
	UserIDs []int64 `json:"user_ids"` // Identifiers of the users; always unknown and empty for non-owned stories
}

// MessageType return the string telegram-type of StoryPrivacySettingsSelectedUsers
func (storyPrivacySettingsSelectedUsers *StoryPrivacySettingsSelectedUsers) MessageType() string {
	return "storyPrivacySettingsSelectedUsers"
}

// NewStoryPrivacySettingsSelectedUsers creates a new StoryPrivacySettingsSelectedUsers
//
// @param userIDs Identifiers of the users; always unknown and empty for non-owned stories
func NewStoryPrivacySettingsSelectedUsers(userIDs []int64) *StoryPrivacySettingsSelectedUsers {
	storyPrivacySettingsSelectedUsersTemp := StoryPrivacySettingsSelectedUsers{
		tdCommon: tdCommon{Type: "storyPrivacySettingsSelectedUsers"},
		UserIDs:  userIDs,
	}

	return &storyPrivacySettingsSelectedUsersTemp
}

// UnmarshalJSON unmarshal to json
func (storyPrivacySettingsSelectedUsers *StoryPrivacySettingsSelectedUsers) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserIDs []int64 `json:"user_ids"` // Identifiers of the users; always unknown and empty for non-owned stories
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyPrivacySettingsSelectedUsers.tdCommon = tempObj.tdCommon
	storyPrivacySettingsSelectedUsers.UserIDs = tempObj.UserIDs

	return nil
}

// GetStoryPrivacySettingsEnum return the enum type of this object
func (storyPrivacySettingsSelectedUsers *StoryPrivacySettingsSelectedUsers) GetStoryPrivacySettingsEnum() StoryPrivacySettingsEnum {
	return StoryPrivacySettingsSelectedUsersType
}

// UserPrivacySettingRuleAllowAll A rule to allow all users to do something
type UserPrivacySettingRuleAllowAll struct {
	tdCommon
}

// MessageType return the string telegram-type of UserPrivacySettingRuleAllowAll
func (userPrivacySettingRuleAllowAll *UserPrivacySettingRuleAllowAll) MessageType() string {
	return "userPrivacySettingRuleAllowAll"
}

// NewUserPrivacySettingRuleAllowAll creates a new UserPrivacySettingRuleAllowAll
//
func NewUserPrivacySettingRuleAllowAll() *UserPrivacySettingRuleAllowAll {
	userPrivacySettingRuleAllowAllTemp := UserPrivacySettingRuleAllowAll{
		tdCommon: tdCommon{Type: "userPrivacySettingRuleAllowAll"},
	}

	return &userPrivacySettingRuleAllowAllTemp
}

// UnmarshalJSON unmarshal to json
func (userPrivacySettingRuleAllowAll *UserPrivacySettingRuleAllowAll) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userPrivacySettingRuleAllowAll.tdCommon = tempObj.tdCommon

	return nil
}

// GetUserPrivacySettingRuleEnum return the enum type of this object
func (userPrivacySettingRuleAllowAll *UserPrivacySettingRuleAllowAll) GetUserPrivacySettingRuleEnum() UserPrivacySettingRuleEnum {
	return UserPrivacySettingRuleAllowAllType
}

// UserPrivacySettingRuleAllowContacts A rule to allow all contacts of the user to do something
type UserPrivacySettingRuleAllowContacts struct {
	tdCommon
}

// MessageType return the string telegram-type of UserPrivacySettingRuleAllowContacts
func (userPrivacySettingRuleAllowContacts *UserPrivacySettingRuleAllowContacts) MessageType() string {
	return "userPrivacySettingRuleAllowContacts"
}

// NewUserPrivacySettingRuleAllowContacts creates a new UserPrivacySettingRuleAllowContacts
//
func NewUserPrivacySettingRuleAllowContacts() *UserPrivacySettingRuleAllowContacts {
	userPrivacySettingRuleAllowContactsTemp := UserPrivacySettingRuleAllowContacts{
		tdCommon: tdCommon{Type: "userPrivacySettingRuleAllowContacts"},
	}

	return &userPrivacySettingRuleAllowContactsTemp
}

// UnmarshalJSON unmarshal to json
func (userPrivacySettingRuleAllowContacts *UserPrivacySettingRuleAllowContacts) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userPrivacySettingRuleAllowContacts.tdCommon = tempObj.tdCommon

	return nil
}

// GetUserPrivacySettingRuleEnum return the enum type of this object
func (userPrivacySettingRuleAllowContacts *UserPrivacySettingRuleAllowContacts) GetUserPrivacySettingRuleEnum() UserPrivacySettingRuleEnum {
	return UserPrivacySettingRuleAllowContactsType
}

// UserPrivacySettingRuleAllowPremiumUsers A rule to allow all Premium Users to do something; currently, allowed only for userPrivacySettingAllowChatInvites
type UserPrivacySettingRuleAllowPremiumUsers struct {
	tdCommon
}

// MessageType return the string telegram-type of UserPrivacySettingRuleAllowPremiumUsers
func (userPrivacySettingRuleAllowPremiumUsers *UserPrivacySettingRuleAllowPremiumUsers) MessageType() string {
	return "userPrivacySettingRuleAllowPremiumUsers"
}

// NewUserPrivacySettingRuleAllowPremiumUsers creates a new UserPrivacySettingRuleAllowPremiumUsers
//
func NewUserPrivacySettingRuleAllowPremiumUsers() *UserPrivacySettingRuleAllowPremiumUsers {
	userPrivacySettingRuleAllowPremiumUsersTemp := UserPrivacySettingRuleAllowPremiumUsers{
		tdCommon: tdCommon{Type: "userPrivacySettingRuleAllowPremiumUsers"},
	}

	return &userPrivacySettingRuleAllowPremiumUsersTemp
}

// UnmarshalJSON unmarshal to json
func (userPrivacySettingRuleAllowPremiumUsers *UserPrivacySettingRuleAllowPremiumUsers) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userPrivacySettingRuleAllowPremiumUsers.tdCommon = tempObj.tdCommon

	return nil
}

// GetUserPrivacySettingRuleEnum return the enum type of this object
func (userPrivacySettingRuleAllowPremiumUsers *UserPrivacySettingRuleAllowPremiumUsers) GetUserPrivacySettingRuleEnum() UserPrivacySettingRuleEnum {
	return UserPrivacySettingRuleAllowPremiumUsersType
}

// UserPrivacySettingRuleAllowUsers A rule to allow certain specified users to do something
type UserPrivacySettingRuleAllowUsers struct {
	tdCommon
	UserIDs []int64 `json:"user_ids"` // The user identifiers, total number of users in all rules must not exceed 1000
}

// MessageType return the string telegram-type of UserPrivacySettingRuleAllowUsers
func (userPrivacySettingRuleAllowUsers *UserPrivacySettingRuleAllowUsers) MessageType() string {
	return "userPrivacySettingRuleAllowUsers"
}

// NewUserPrivacySettingRuleAllowUsers creates a new UserPrivacySettingRuleAllowUsers
//
// @param userIDs The user identifiers, total number of users in all rules must not exceed 1000
func NewUserPrivacySettingRuleAllowUsers(userIDs []int64) *UserPrivacySettingRuleAllowUsers {
	userPrivacySettingRuleAllowUsersTemp := UserPrivacySettingRuleAllowUsers{
		tdCommon: tdCommon{Type: "userPrivacySettingRuleAllowUsers"},
		UserIDs:  userIDs,
	}

	return &userPrivacySettingRuleAllowUsersTemp
}

// UnmarshalJSON unmarshal to json
func (userPrivacySettingRuleAllowUsers *UserPrivacySettingRuleAllowUsers) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserIDs []int64 `json:"user_ids"` // The user identifiers, total number of users in all rules must not exceed 1000
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userPrivacySettingRuleAllowUsers.tdCommon = tempObj.tdCommon
	userPrivacySettingRuleAllowUsers.UserIDs = tempObj.UserIDs

	return nil
}

// GetUserPrivacySettingRuleEnum return the enum type of this object
func (userPrivacySettingRuleAllowUsers *UserPrivacySettingRuleAllowUsers) GetUserPrivacySettingRuleEnum() UserPrivacySettingRuleEnum {
	return UserPrivacySettingRuleAllowUsersType
}

// UserPrivacySettingRuleAllowChatMembers A rule to allow all members of certain specified basic groups and supergroups to doing something
type UserPrivacySettingRuleAllowChatMembers struct {
	tdCommon
	ChatIDs []int64 `json:"chat_ids"` // The chat identifiers, total number of chats in all rules must not exceed 20
}

// MessageType return the string telegram-type of UserPrivacySettingRuleAllowChatMembers
func (userPrivacySettingRuleAllowChatMembers *UserPrivacySettingRuleAllowChatMembers) MessageType() string {
	return "userPrivacySettingRuleAllowChatMembers"
}

// NewUserPrivacySettingRuleAllowChatMembers creates a new UserPrivacySettingRuleAllowChatMembers
//
// @param chatIDs The chat identifiers, total number of chats in all rules must not exceed 20
func NewUserPrivacySettingRuleAllowChatMembers(chatIDs []int64) *UserPrivacySettingRuleAllowChatMembers {
	userPrivacySettingRuleAllowChatMembersTemp := UserPrivacySettingRuleAllowChatMembers{
		tdCommon: tdCommon{Type: "userPrivacySettingRuleAllowChatMembers"},
		ChatIDs:  chatIDs,
	}

	return &userPrivacySettingRuleAllowChatMembersTemp
}

// UnmarshalJSON unmarshal to json
func (userPrivacySettingRuleAllowChatMembers *UserPrivacySettingRuleAllowChatMembers) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatIDs []int64 `json:"chat_ids"` // The chat identifiers, total number of chats in all rules must not exceed 20
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userPrivacySettingRuleAllowChatMembers.tdCommon = tempObj.tdCommon
	userPrivacySettingRuleAllowChatMembers.ChatIDs = tempObj.ChatIDs

	return nil
}

// GetUserPrivacySettingRuleEnum return the enum type of this object
func (userPrivacySettingRuleAllowChatMembers *UserPrivacySettingRuleAllowChatMembers) GetUserPrivacySettingRuleEnum() UserPrivacySettingRuleEnum {
	return UserPrivacySettingRuleAllowChatMembersType
}

// UserPrivacySettingRuleRestrictAll A rule to restrict all users from doing something
type UserPrivacySettingRuleRestrictAll struct {
	tdCommon
}

// MessageType return the string telegram-type of UserPrivacySettingRuleRestrictAll
func (userPrivacySettingRuleRestrictAll *UserPrivacySettingRuleRestrictAll) MessageType() string {
	return "userPrivacySettingRuleRestrictAll"
}

// NewUserPrivacySettingRuleRestrictAll creates a new UserPrivacySettingRuleRestrictAll
//
func NewUserPrivacySettingRuleRestrictAll() *UserPrivacySettingRuleRestrictAll {
	userPrivacySettingRuleRestrictAllTemp := UserPrivacySettingRuleRestrictAll{
		tdCommon: tdCommon{Type: "userPrivacySettingRuleRestrictAll"},
	}

	return &userPrivacySettingRuleRestrictAllTemp
}

// UnmarshalJSON unmarshal to json
func (userPrivacySettingRuleRestrictAll *UserPrivacySettingRuleRestrictAll) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userPrivacySettingRuleRestrictAll.tdCommon = tempObj.tdCommon

	return nil
}

// GetUserPrivacySettingRuleEnum return the enum type of this object
func (userPrivacySettingRuleRestrictAll *UserPrivacySettingRuleRestrictAll) GetUserPrivacySettingRuleEnum() UserPrivacySettingRuleEnum {
	return UserPrivacySettingRuleRestrictAllType
}

// UserPrivacySettingRuleRestrictContacts A rule to restrict all contacts of the user from doing something
type UserPrivacySettingRuleRestrictContacts struct {
	tdCommon
}

// MessageType return the string telegram-type of UserPrivacySettingRuleRestrictContacts
func (userPrivacySettingRuleRestrictContacts *UserPrivacySettingRuleRestrictContacts) MessageType() string {
	return "userPrivacySettingRuleRestrictContacts"
}

// NewUserPrivacySettingRuleRestrictContacts creates a new UserPrivacySettingRuleRestrictContacts
//
func NewUserPrivacySettingRuleRestrictContacts() *UserPrivacySettingRuleRestrictContacts {
	userPrivacySettingRuleRestrictContactsTemp := UserPrivacySettingRuleRestrictContacts{
		tdCommon: tdCommon{Type: "userPrivacySettingRuleRestrictContacts"},
	}

	return &userPrivacySettingRuleRestrictContactsTemp
}

// UnmarshalJSON unmarshal to json
func (userPrivacySettingRuleRestrictContacts *UserPrivacySettingRuleRestrictContacts) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userPrivacySettingRuleRestrictContacts.tdCommon = tempObj.tdCommon

	return nil
}

// GetUserPrivacySettingRuleEnum return the enum type of this object
func (userPrivacySettingRuleRestrictContacts *UserPrivacySettingRuleRestrictContacts) GetUserPrivacySettingRuleEnum() UserPrivacySettingRuleEnum {
	return UserPrivacySettingRuleRestrictContactsType
}

// UserPrivacySettingRuleRestrictUsers A rule to restrict all specified users from doing something
type UserPrivacySettingRuleRestrictUsers struct {
	tdCommon
	UserIDs []int64 `json:"user_ids"` // The user identifiers, total number of users in all rules must not exceed 1000
}

// MessageType return the string telegram-type of UserPrivacySettingRuleRestrictUsers
func (userPrivacySettingRuleRestrictUsers *UserPrivacySettingRuleRestrictUsers) MessageType() string {
	return "userPrivacySettingRuleRestrictUsers"
}

// NewUserPrivacySettingRuleRestrictUsers creates a new UserPrivacySettingRuleRestrictUsers
//
// @param userIDs The user identifiers, total number of users in all rules must not exceed 1000
func NewUserPrivacySettingRuleRestrictUsers(userIDs []int64) *UserPrivacySettingRuleRestrictUsers {
	userPrivacySettingRuleRestrictUsersTemp := UserPrivacySettingRuleRestrictUsers{
		tdCommon: tdCommon{Type: "userPrivacySettingRuleRestrictUsers"},
		UserIDs:  userIDs,
	}

	return &userPrivacySettingRuleRestrictUsersTemp
}

// UnmarshalJSON unmarshal to json
func (userPrivacySettingRuleRestrictUsers *UserPrivacySettingRuleRestrictUsers) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserIDs []int64 `json:"user_ids"` // The user identifiers, total number of users in all rules must not exceed 1000
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userPrivacySettingRuleRestrictUsers.tdCommon = tempObj.tdCommon
	userPrivacySettingRuleRestrictUsers.UserIDs = tempObj.UserIDs

	return nil
}

// GetUserPrivacySettingRuleEnum return the enum type of this object
func (userPrivacySettingRuleRestrictUsers *UserPrivacySettingRuleRestrictUsers) GetUserPrivacySettingRuleEnum() UserPrivacySettingRuleEnum {
	return UserPrivacySettingRuleRestrictUsersType
}

// UserPrivacySettingRuleRestrictChatMembers A rule to restrict all members of specified basic groups and supergroups from doing something
type UserPrivacySettingRuleRestrictChatMembers struct {
	tdCommon
	ChatIDs []int64 `json:"chat_ids"` // The chat identifiers, total number of chats in all rules must not exceed 20
}

// MessageType return the string telegram-type of UserPrivacySettingRuleRestrictChatMembers
func (userPrivacySettingRuleRestrictChatMembers *UserPrivacySettingRuleRestrictChatMembers) MessageType() string {
	return "userPrivacySettingRuleRestrictChatMembers"
}

// NewUserPrivacySettingRuleRestrictChatMembers creates a new UserPrivacySettingRuleRestrictChatMembers
//
// @param chatIDs The chat identifiers, total number of chats in all rules must not exceed 20
func NewUserPrivacySettingRuleRestrictChatMembers(chatIDs []int64) *UserPrivacySettingRuleRestrictChatMembers {
	userPrivacySettingRuleRestrictChatMembersTemp := UserPrivacySettingRuleRestrictChatMembers{
		tdCommon: tdCommon{Type: "userPrivacySettingRuleRestrictChatMembers"},
		ChatIDs:  chatIDs,
	}

	return &userPrivacySettingRuleRestrictChatMembersTemp
}

// UnmarshalJSON unmarshal to json
func (userPrivacySettingRuleRestrictChatMembers *UserPrivacySettingRuleRestrictChatMembers) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatIDs []int64 `json:"chat_ids"` // The chat identifiers, total number of chats in all rules must not exceed 20
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userPrivacySettingRuleRestrictChatMembers.tdCommon = tempObj.tdCommon
	userPrivacySettingRuleRestrictChatMembers.ChatIDs = tempObj.ChatIDs

	return nil
}

// GetUserPrivacySettingRuleEnum return the enum type of this object
func (userPrivacySettingRuleRestrictChatMembers *UserPrivacySettingRuleRestrictChatMembers) GetUserPrivacySettingRuleEnum() UserPrivacySettingRuleEnum {
	return UserPrivacySettingRuleRestrictChatMembersType
}

// UserPrivacySettingRules A list of privacy rules. Rules are matched in the specified order. The first matched rule defines the privacy setting for a given user. If no rule matches, the action is not allowed
type UserPrivacySettingRules struct {
	tdCommon
	Rules []UserPrivacySettingRule `json:"rules"` // A list of rules
}

// MessageType return the string telegram-type of UserPrivacySettingRules
func (userPrivacySettingRules *UserPrivacySettingRules) MessageType() string {
	return "userPrivacySettingRules"
}

// NewUserPrivacySettingRules creates a new UserPrivacySettingRules
//
// @param rules A list of rules
func NewUserPrivacySettingRules(rules []UserPrivacySettingRule) *UserPrivacySettingRules {
	userPrivacySettingRulesTemp := UserPrivacySettingRules{
		tdCommon: tdCommon{Type: "userPrivacySettingRules"},
		Rules:    rules,
	}

	return &userPrivacySettingRulesTemp
}

// UnmarshalJSON unmarshal to json
func (userPrivacySettingRules *UserPrivacySettingRules) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userPrivacySettingRules.tdCommon = tempObj.tdCommon

	fieldRules, _ := unmarshalUserPrivacySettingRuleSlice(objMap["rules"])
	userPrivacySettingRules.Rules = fieldRules

	return nil
}

// UserPrivacySettingShowStatus A privacy setting for managing whether the user's online status is visible
type UserPrivacySettingShowStatus struct {
	tdCommon
}

// MessageType return the string telegram-type of UserPrivacySettingShowStatus
func (userPrivacySettingShowStatus *UserPrivacySettingShowStatus) MessageType() string {
	return "userPrivacySettingShowStatus"
}

// NewUserPrivacySettingShowStatus creates a new UserPrivacySettingShowStatus
//
func NewUserPrivacySettingShowStatus() *UserPrivacySettingShowStatus {
	userPrivacySettingShowStatusTemp := UserPrivacySettingShowStatus{
		tdCommon: tdCommon{Type: "userPrivacySettingShowStatus"},
	}

	return &userPrivacySettingShowStatusTemp
}

// UnmarshalJSON unmarshal to json
func (userPrivacySettingShowStatus *UserPrivacySettingShowStatus) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userPrivacySettingShowStatus.tdCommon = tempObj.tdCommon

	return nil
}

// GetUserPrivacySettingEnum return the enum type of this object
func (userPrivacySettingShowStatus *UserPrivacySettingShowStatus) GetUserPrivacySettingEnum() UserPrivacySettingEnum {
	return UserPrivacySettingShowStatusType
}

// UserPrivacySettingShowProfilePhoto A privacy setting for managing whether the user's profile photo is visible
type UserPrivacySettingShowProfilePhoto struct {
	tdCommon
}

// MessageType return the string telegram-type of UserPrivacySettingShowProfilePhoto
func (userPrivacySettingShowProfilePhoto *UserPrivacySettingShowProfilePhoto) MessageType() string {
	return "userPrivacySettingShowProfilePhoto"
}

// NewUserPrivacySettingShowProfilePhoto creates a new UserPrivacySettingShowProfilePhoto
//
func NewUserPrivacySettingShowProfilePhoto() *UserPrivacySettingShowProfilePhoto {
	userPrivacySettingShowProfilePhotoTemp := UserPrivacySettingShowProfilePhoto{
		tdCommon: tdCommon{Type: "userPrivacySettingShowProfilePhoto"},
	}

	return &userPrivacySettingShowProfilePhotoTemp
}

// UnmarshalJSON unmarshal to json
func (userPrivacySettingShowProfilePhoto *UserPrivacySettingShowProfilePhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userPrivacySettingShowProfilePhoto.tdCommon = tempObj.tdCommon

	return nil
}

// GetUserPrivacySettingEnum return the enum type of this object
func (userPrivacySettingShowProfilePhoto *UserPrivacySettingShowProfilePhoto) GetUserPrivacySettingEnum() UserPrivacySettingEnum {
	return UserPrivacySettingShowProfilePhotoType
}

// UserPrivacySettingShowLinkInForwardedMessages A privacy setting for managing whether a link to the user's account is included in forwarded messages
type UserPrivacySettingShowLinkInForwardedMessages struct {
	tdCommon
}

// MessageType return the string telegram-type of UserPrivacySettingShowLinkInForwardedMessages
func (userPrivacySettingShowLinkInForwardedMessages *UserPrivacySettingShowLinkInForwardedMessages) MessageType() string {
	return "userPrivacySettingShowLinkInForwardedMessages"
}

// NewUserPrivacySettingShowLinkInForwardedMessages creates a new UserPrivacySettingShowLinkInForwardedMessages
//
func NewUserPrivacySettingShowLinkInForwardedMessages() *UserPrivacySettingShowLinkInForwardedMessages {
	userPrivacySettingShowLinkInForwardedMessagesTemp := UserPrivacySettingShowLinkInForwardedMessages{
		tdCommon: tdCommon{Type: "userPrivacySettingShowLinkInForwardedMessages"},
	}

	return &userPrivacySettingShowLinkInForwardedMessagesTemp
}

// UnmarshalJSON unmarshal to json
func (userPrivacySettingShowLinkInForwardedMessages *UserPrivacySettingShowLinkInForwardedMessages) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userPrivacySettingShowLinkInForwardedMessages.tdCommon = tempObj.tdCommon

	return nil
}

// GetUserPrivacySettingEnum return the enum type of this object
func (userPrivacySettingShowLinkInForwardedMessages *UserPrivacySettingShowLinkInForwardedMessages) GetUserPrivacySettingEnum() UserPrivacySettingEnum {
	return UserPrivacySettingShowLinkInForwardedMessagesType
}

// UserPrivacySettingShowPhoneNumber A privacy setting for managing whether the user's phone number is visible
type UserPrivacySettingShowPhoneNumber struct {
	tdCommon
}

// MessageType return the string telegram-type of UserPrivacySettingShowPhoneNumber
func (userPrivacySettingShowPhoneNumber *UserPrivacySettingShowPhoneNumber) MessageType() string {
	return "userPrivacySettingShowPhoneNumber"
}

// NewUserPrivacySettingShowPhoneNumber creates a new UserPrivacySettingShowPhoneNumber
//
func NewUserPrivacySettingShowPhoneNumber() *UserPrivacySettingShowPhoneNumber {
	userPrivacySettingShowPhoneNumberTemp := UserPrivacySettingShowPhoneNumber{
		tdCommon: tdCommon{Type: "userPrivacySettingShowPhoneNumber"},
	}

	return &userPrivacySettingShowPhoneNumberTemp
}

// UnmarshalJSON unmarshal to json
func (userPrivacySettingShowPhoneNumber *UserPrivacySettingShowPhoneNumber) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userPrivacySettingShowPhoneNumber.tdCommon = tempObj.tdCommon

	return nil
}

// GetUserPrivacySettingEnum return the enum type of this object
func (userPrivacySettingShowPhoneNumber *UserPrivacySettingShowPhoneNumber) GetUserPrivacySettingEnum() UserPrivacySettingEnum {
	return UserPrivacySettingShowPhoneNumberType
}

// UserPrivacySettingShowBio A privacy setting for managing whether the user's bio is visible
type UserPrivacySettingShowBio struct {
	tdCommon
}

// MessageType return the string telegram-type of UserPrivacySettingShowBio
func (userPrivacySettingShowBio *UserPrivacySettingShowBio) MessageType() string {
	return "userPrivacySettingShowBio"
}

// NewUserPrivacySettingShowBio creates a new UserPrivacySettingShowBio
//
func NewUserPrivacySettingShowBio() *UserPrivacySettingShowBio {
	userPrivacySettingShowBioTemp := UserPrivacySettingShowBio{
		tdCommon: tdCommon{Type: "userPrivacySettingShowBio"},
	}

	return &userPrivacySettingShowBioTemp
}

// UnmarshalJSON unmarshal to json
func (userPrivacySettingShowBio *UserPrivacySettingShowBio) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userPrivacySettingShowBio.tdCommon = tempObj.tdCommon

	return nil
}

// GetUserPrivacySettingEnum return the enum type of this object
func (userPrivacySettingShowBio *UserPrivacySettingShowBio) GetUserPrivacySettingEnum() UserPrivacySettingEnum {
	return UserPrivacySettingShowBioType
}

// UserPrivacySettingShowBirthdate A privacy setting for managing whether the user's birthdate is visible
type UserPrivacySettingShowBirthdate struct {
	tdCommon
}

// MessageType return the string telegram-type of UserPrivacySettingShowBirthdate
func (userPrivacySettingShowBirthdate *UserPrivacySettingShowBirthdate) MessageType() string {
	return "userPrivacySettingShowBirthdate"
}

// NewUserPrivacySettingShowBirthdate creates a new UserPrivacySettingShowBirthdate
//
func NewUserPrivacySettingShowBirthdate() *UserPrivacySettingShowBirthdate {
	userPrivacySettingShowBirthdateTemp := UserPrivacySettingShowBirthdate{
		tdCommon: tdCommon{Type: "userPrivacySettingShowBirthdate"},
	}

	return &userPrivacySettingShowBirthdateTemp
}

// UnmarshalJSON unmarshal to json
func (userPrivacySettingShowBirthdate *UserPrivacySettingShowBirthdate) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userPrivacySettingShowBirthdate.tdCommon = tempObj.tdCommon

	return nil
}

// GetUserPrivacySettingEnum return the enum type of this object
func (userPrivacySettingShowBirthdate *UserPrivacySettingShowBirthdate) GetUserPrivacySettingEnum() UserPrivacySettingEnum {
	return UserPrivacySettingShowBirthdateType
}

// UserPrivacySettingAllowChatInvites A privacy setting for managing whether the user can be invited to chats
type UserPrivacySettingAllowChatInvites struct {
	tdCommon
}

// MessageType return the string telegram-type of UserPrivacySettingAllowChatInvites
func (userPrivacySettingAllowChatInvites *UserPrivacySettingAllowChatInvites) MessageType() string {
	return "userPrivacySettingAllowChatInvites"
}

// NewUserPrivacySettingAllowChatInvites creates a new UserPrivacySettingAllowChatInvites
//
func NewUserPrivacySettingAllowChatInvites() *UserPrivacySettingAllowChatInvites {
	userPrivacySettingAllowChatInvitesTemp := UserPrivacySettingAllowChatInvites{
		tdCommon: tdCommon{Type: "userPrivacySettingAllowChatInvites"},
	}

	return &userPrivacySettingAllowChatInvitesTemp
}

// UnmarshalJSON unmarshal to json
func (userPrivacySettingAllowChatInvites *UserPrivacySettingAllowChatInvites) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userPrivacySettingAllowChatInvites.tdCommon = tempObj.tdCommon

	return nil
}

// GetUserPrivacySettingEnum return the enum type of this object
func (userPrivacySettingAllowChatInvites *UserPrivacySettingAllowChatInvites) GetUserPrivacySettingEnum() UserPrivacySettingEnum {
	return UserPrivacySettingAllowChatInvitesType
}

// UserPrivacySettingAllowCalls A privacy setting for managing whether the user can be called
type UserPrivacySettingAllowCalls struct {
	tdCommon
}

// MessageType return the string telegram-type of UserPrivacySettingAllowCalls
func (userPrivacySettingAllowCalls *UserPrivacySettingAllowCalls) MessageType() string {
	return "userPrivacySettingAllowCalls"
}

// NewUserPrivacySettingAllowCalls creates a new UserPrivacySettingAllowCalls
//
func NewUserPrivacySettingAllowCalls() *UserPrivacySettingAllowCalls {
	userPrivacySettingAllowCallsTemp := UserPrivacySettingAllowCalls{
		tdCommon: tdCommon{Type: "userPrivacySettingAllowCalls"},
	}

	return &userPrivacySettingAllowCallsTemp
}

// UnmarshalJSON unmarshal to json
func (userPrivacySettingAllowCalls *UserPrivacySettingAllowCalls) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userPrivacySettingAllowCalls.tdCommon = tempObj.tdCommon

	return nil
}

// GetUserPrivacySettingEnum return the enum type of this object
func (userPrivacySettingAllowCalls *UserPrivacySettingAllowCalls) GetUserPrivacySettingEnum() UserPrivacySettingEnum {
	return UserPrivacySettingAllowCallsType
}

// UserPrivacySettingAllowPeerToPeerCalls A privacy setting for managing whether peer-to-peer connections can be used for calls
type UserPrivacySettingAllowPeerToPeerCalls struct {
	tdCommon
}

// MessageType return the string telegram-type of UserPrivacySettingAllowPeerToPeerCalls
func (userPrivacySettingAllowPeerToPeerCalls *UserPrivacySettingAllowPeerToPeerCalls) MessageType() string {
	return "userPrivacySettingAllowPeerToPeerCalls"
}

// NewUserPrivacySettingAllowPeerToPeerCalls creates a new UserPrivacySettingAllowPeerToPeerCalls
//
func NewUserPrivacySettingAllowPeerToPeerCalls() *UserPrivacySettingAllowPeerToPeerCalls {
	userPrivacySettingAllowPeerToPeerCallsTemp := UserPrivacySettingAllowPeerToPeerCalls{
		tdCommon: tdCommon{Type: "userPrivacySettingAllowPeerToPeerCalls"},
	}

	return &userPrivacySettingAllowPeerToPeerCallsTemp
}

// UnmarshalJSON unmarshal to json
func (userPrivacySettingAllowPeerToPeerCalls *UserPrivacySettingAllowPeerToPeerCalls) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userPrivacySettingAllowPeerToPeerCalls.tdCommon = tempObj.tdCommon

	return nil
}

// GetUserPrivacySettingEnum return the enum type of this object
func (userPrivacySettingAllowPeerToPeerCalls *UserPrivacySettingAllowPeerToPeerCalls) GetUserPrivacySettingEnum() UserPrivacySettingEnum {
	return UserPrivacySettingAllowPeerToPeerCallsType
}

// UserPrivacySettingAllowFindingByPhoneNumber A privacy setting for managing whether the user can be found by their phone number. Checked only if the phone number is not known to the other user. Can be set only to "Allow contacts" or "Allow all"
type UserPrivacySettingAllowFindingByPhoneNumber struct {
	tdCommon
}

// MessageType return the string telegram-type of UserPrivacySettingAllowFindingByPhoneNumber
func (userPrivacySettingAllowFindingByPhoneNumber *UserPrivacySettingAllowFindingByPhoneNumber) MessageType() string {
	return "userPrivacySettingAllowFindingByPhoneNumber"
}

// NewUserPrivacySettingAllowFindingByPhoneNumber creates a new UserPrivacySettingAllowFindingByPhoneNumber
//
func NewUserPrivacySettingAllowFindingByPhoneNumber() *UserPrivacySettingAllowFindingByPhoneNumber {
	userPrivacySettingAllowFindingByPhoneNumberTemp := UserPrivacySettingAllowFindingByPhoneNumber{
		tdCommon: tdCommon{Type: "userPrivacySettingAllowFindingByPhoneNumber"},
	}

	return &userPrivacySettingAllowFindingByPhoneNumberTemp
}

// UnmarshalJSON unmarshal to json
func (userPrivacySettingAllowFindingByPhoneNumber *UserPrivacySettingAllowFindingByPhoneNumber) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userPrivacySettingAllowFindingByPhoneNumber.tdCommon = tempObj.tdCommon

	return nil
}

// GetUserPrivacySettingEnum return the enum type of this object
func (userPrivacySettingAllowFindingByPhoneNumber *UserPrivacySettingAllowFindingByPhoneNumber) GetUserPrivacySettingEnum() UserPrivacySettingEnum {
	return UserPrivacySettingAllowFindingByPhoneNumberType
}

// UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages A privacy setting for managing whether the user can receive voice and video messages in private chats; for Telegram Premium users only
type UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages struct {
	tdCommon
}

// MessageType return the string telegram-type of UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages
func (userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages *UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages) MessageType() string {
	return "userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages"
}

// NewUserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages creates a new UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages
//
func NewUserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages() *UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages {
	userPrivacySettingAllowPrivateVoiceAndVideoNoteMessagesTemp := UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages{
		tdCommon: tdCommon{Type: "userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages"},
	}

	return &userPrivacySettingAllowPrivateVoiceAndVideoNoteMessagesTemp
}

// UnmarshalJSON unmarshal to json
func (userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages *UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages.tdCommon = tempObj.tdCommon

	return nil
}

// GetUserPrivacySettingEnum return the enum type of this object
func (userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages *UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessages) GetUserPrivacySettingEnum() UserPrivacySettingEnum {
	return UserPrivacySettingAllowPrivateVoiceAndVideoNoteMessagesType
}

// ReadDatePrivacySettings Contains privacy settings for message read date in private chats. Read dates are always shown to the users that can see online status of the current user regardless of this setting
type ReadDatePrivacySettings struct {
	tdCommon
	ShowReadDate bool `json:"show_read_date"` // True, if message read date is shown to other users in private chats. If false and the current user isn't a Telegram Premium user, then they will not be able to see other's message read date
}

// MessageType return the string telegram-type of ReadDatePrivacySettings
func (readDatePrivacySettings *ReadDatePrivacySettings) MessageType() string {
	return "readDatePrivacySettings"
}

// NewReadDatePrivacySettings creates a new ReadDatePrivacySettings
//
// @param showReadDate True, if message read date is shown to other users in private chats. If false and the current user isn't a Telegram Premium user, then they will not be able to see other's message read date
func NewReadDatePrivacySettings(showReadDate bool) *ReadDatePrivacySettings {
	readDatePrivacySettingsTemp := ReadDatePrivacySettings{
		tdCommon:     tdCommon{Type: "readDatePrivacySettings"},
		ShowReadDate: showReadDate,
	}

	return &readDatePrivacySettingsTemp
}

// UnmarshalJSON unmarshal to json
func (readDatePrivacySettings *ReadDatePrivacySettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ShowReadDate bool `json:"show_read_date"` // True, if message read date is shown to other users in private chats. If false and the current user isn't a Telegram Premium user, then they will not be able to see other's message read date
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	readDatePrivacySettings.tdCommon = tempObj.tdCommon
	readDatePrivacySettings.ShowReadDate = tempObj.ShowReadDate

	return nil
}

// NewChatPrivacySettings Contains privacy settings for new chats with non-contacts
type NewChatPrivacySettings struct {
	tdCommon
	AllowNewChatsFromUnknownUsers bool `json:"allow_new_chats_from_unknown_users"` // True, if non-contacts users are able to write first to the current user. Telegram Premium subscribers are able to write first regardless of this setting
}

// MessageType return the string telegram-type of NewChatPrivacySettings
func (newChatPrivacySettings *NewChatPrivacySettings) MessageType() string {
	return "newChatPrivacySettings"
}

// NewNewChatPrivacySettings creates a new NewChatPrivacySettings
//
// @param allowNewChatsFromUnknownUsers True, if non-contacts users are able to write first to the current user. Telegram Premium subscribers are able to write first regardless of this setting
func NewNewChatPrivacySettings(allowNewChatsFromUnknownUsers bool) *NewChatPrivacySettings {
	newChatPrivacySettingsTemp := NewChatPrivacySettings{
		tdCommon:                      tdCommon{Type: "newChatPrivacySettings"},
		AllowNewChatsFromUnknownUsers: allowNewChatsFromUnknownUsers,
	}

	return &newChatPrivacySettingsTemp
}

// UnmarshalJSON unmarshal to json
func (newChatPrivacySettings *NewChatPrivacySettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		AllowNewChatsFromUnknownUsers bool `json:"allow_new_chats_from_unknown_users"` // True, if non-contacts users are able to write first to the current user. Telegram Premium subscribers are able to write first regardless of this setting
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	newChatPrivacySettings.tdCommon = tempObj.tdCommon
	newChatPrivacySettings.AllowNewChatsFromUnknownUsers = tempObj.AllowNewChatsFromUnknownUsers

	return nil
}

// CanSendMessageToUserResultOk The user can be messaged
type CanSendMessageToUserResultOk struct {
	tdCommon
}

// MessageType return the string telegram-type of CanSendMessageToUserResultOk
func (canSendMessageToUserResultOk *CanSendMessageToUserResultOk) MessageType() string {
	return "canSendMessageToUserResultOk"
}

// NewCanSendMessageToUserResultOk creates a new CanSendMessageToUserResultOk
//
func NewCanSendMessageToUserResultOk() *CanSendMessageToUserResultOk {
	canSendMessageToUserResultOkTemp := CanSendMessageToUserResultOk{
		tdCommon: tdCommon{Type: "canSendMessageToUserResultOk"},
	}

	return &canSendMessageToUserResultOkTemp
}

// UnmarshalJSON unmarshal to json
func (canSendMessageToUserResultOk *CanSendMessageToUserResultOk) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	canSendMessageToUserResultOk.tdCommon = tempObj.tdCommon

	return nil
}

// GetCanSendMessageToUserResultEnum return the enum type of this object
func (canSendMessageToUserResultOk *CanSendMessageToUserResultOk) GetCanSendMessageToUserResultEnum() CanSendMessageToUserResultEnum {
	return CanSendMessageToUserResultOkType
}

// CanSendMessageToUserResultUserIsDeleted The user can't be messaged, because they are deleted or unknown
type CanSendMessageToUserResultUserIsDeleted struct {
	tdCommon
}

// MessageType return the string telegram-type of CanSendMessageToUserResultUserIsDeleted
func (canSendMessageToUserResultUserIsDeleted *CanSendMessageToUserResultUserIsDeleted) MessageType() string {
	return "canSendMessageToUserResultUserIsDeleted"
}

// NewCanSendMessageToUserResultUserIsDeleted creates a new CanSendMessageToUserResultUserIsDeleted
//
func NewCanSendMessageToUserResultUserIsDeleted() *CanSendMessageToUserResultUserIsDeleted {
	canSendMessageToUserResultUserIsDeletedTemp := CanSendMessageToUserResultUserIsDeleted{
		tdCommon: tdCommon{Type: "canSendMessageToUserResultUserIsDeleted"},
	}

	return &canSendMessageToUserResultUserIsDeletedTemp
}

// UnmarshalJSON unmarshal to json
func (canSendMessageToUserResultUserIsDeleted *CanSendMessageToUserResultUserIsDeleted) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	canSendMessageToUserResultUserIsDeleted.tdCommon = tempObj.tdCommon

	return nil
}

// GetCanSendMessageToUserResultEnum return the enum type of this object
func (canSendMessageToUserResultUserIsDeleted *CanSendMessageToUserResultUserIsDeleted) GetCanSendMessageToUserResultEnum() CanSendMessageToUserResultEnum {
	return CanSendMessageToUserResultUserIsDeletedType
}

// CanSendMessageToUserResultUserRestrictsNewChats The user can't be messaged, because they restrict new chats with non-contacts
type CanSendMessageToUserResultUserRestrictsNewChats struct {
	tdCommon
}

// MessageType return the string telegram-type of CanSendMessageToUserResultUserRestrictsNewChats
func (canSendMessageToUserResultUserRestrictsNewChats *CanSendMessageToUserResultUserRestrictsNewChats) MessageType() string {
	return "canSendMessageToUserResultUserRestrictsNewChats"
}

// NewCanSendMessageToUserResultUserRestrictsNewChats creates a new CanSendMessageToUserResultUserRestrictsNewChats
//
func NewCanSendMessageToUserResultUserRestrictsNewChats() *CanSendMessageToUserResultUserRestrictsNewChats {
	canSendMessageToUserResultUserRestrictsNewChatsTemp := CanSendMessageToUserResultUserRestrictsNewChats{
		tdCommon: tdCommon{Type: "canSendMessageToUserResultUserRestrictsNewChats"},
	}

	return &canSendMessageToUserResultUserRestrictsNewChatsTemp
}

// UnmarshalJSON unmarshal to json
func (canSendMessageToUserResultUserRestrictsNewChats *CanSendMessageToUserResultUserRestrictsNewChats) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	canSendMessageToUserResultUserRestrictsNewChats.tdCommon = tempObj.tdCommon

	return nil
}

// GetCanSendMessageToUserResultEnum return the enum type of this object
func (canSendMessageToUserResultUserRestrictsNewChats *CanSendMessageToUserResultUserRestrictsNewChats) GetCanSendMessageToUserResultEnum() CanSendMessageToUserResultEnum {
	return CanSendMessageToUserResultUserRestrictsNewChatsType
}

// AccountTTL Contains information about the period of inactivity after which the current user's account will automatically be deleted
type AccountTTL struct {
	tdCommon
	Days int32 `json:"days"` // Number of days of inactivity before the account will be flagged for deletion; 30-730 days
}

// MessageType return the string telegram-type of AccountTTL
func (accountTTL *AccountTTL) MessageType() string {
	return "accountTtl"
}

// NewAccountTTL creates a new AccountTTL
//
// @param days Number of days of inactivity before the account will be flagged for deletion; 30-730 days
func NewAccountTTL(days int32) *AccountTTL {
	accountTTLTemp := AccountTTL{
		tdCommon: tdCommon{Type: "accountTtl"},
		Days:     days,
	}

	return &accountTTLTemp
}

// UnmarshalJSON unmarshal to json
func (accountTTL *AccountTTL) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Days int32 `json:"days"` // Number of days of inactivity before the account will be flagged for deletion; 30-730 days
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	accountTTL.tdCommon = tempObj.tdCommon
	accountTTL.Days = tempObj.Days

	return nil
}

// MessageAutoDeleteTime Contains default auto-delete timer setting for new chats
type MessageAutoDeleteTime struct {
	tdCommon
	Time int32 `json:"time"` // Message auto-delete time, in seconds. If 0, then messages aren't deleted automatically
}

// MessageType return the string telegram-type of MessageAutoDeleteTime
func (messageAutoDeleteTime *MessageAutoDeleteTime) MessageType() string {
	return "messageAutoDeleteTime"
}

// NewMessageAutoDeleteTime creates a new MessageAutoDeleteTime
//
// @param time Message auto-delete time, in seconds. If 0, then messages aren't deleted automatically
func NewMessageAutoDeleteTime(time int32) *MessageAutoDeleteTime {
	messageAutoDeleteTimeTemp := MessageAutoDeleteTime{
		tdCommon: tdCommon{Type: "messageAutoDeleteTime"},
		Time:     time,
	}

	return &messageAutoDeleteTimeTemp
}

// UnmarshalJSON unmarshal to json
func (messageAutoDeleteTime *MessageAutoDeleteTime) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Time int32 `json:"time"` // Message auto-delete time, in seconds. If 0, then messages aren't deleted automatically
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageAutoDeleteTime.tdCommon = tempObj.tdCommon
	messageAutoDeleteTime.Time = tempObj.Time

	return nil
}

// SessionTypeAndroid The session is running on an Android device
type SessionTypeAndroid struct {
	tdCommon
}

// MessageType return the string telegram-type of SessionTypeAndroid
func (sessionTypeAndroid *SessionTypeAndroid) MessageType() string {
	return "sessionTypeAndroid"
}

// NewSessionTypeAndroid creates a new SessionTypeAndroid
//
func NewSessionTypeAndroid() *SessionTypeAndroid {
	sessionTypeAndroidTemp := SessionTypeAndroid{
		tdCommon: tdCommon{Type: "sessionTypeAndroid"},
	}

	return &sessionTypeAndroidTemp
}

// UnmarshalJSON unmarshal to json
func (sessionTypeAndroid *SessionTypeAndroid) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sessionTypeAndroid.tdCommon = tempObj.tdCommon

	return nil
}

// GetSessionTypeEnum return the enum type of this object
func (sessionTypeAndroid *SessionTypeAndroid) GetSessionTypeEnum() SessionTypeEnum {
	return SessionTypeAndroidType
}

// SessionTypeApple The session is running on a generic Apple device
type SessionTypeApple struct {
	tdCommon
}

// MessageType return the string telegram-type of SessionTypeApple
func (sessionTypeApple *SessionTypeApple) MessageType() string {
	return "sessionTypeApple"
}

// NewSessionTypeApple creates a new SessionTypeApple
//
func NewSessionTypeApple() *SessionTypeApple {
	sessionTypeAppleTemp := SessionTypeApple{
		tdCommon: tdCommon{Type: "sessionTypeApple"},
	}

	return &sessionTypeAppleTemp
}

// UnmarshalJSON unmarshal to json
func (sessionTypeApple *SessionTypeApple) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sessionTypeApple.tdCommon = tempObj.tdCommon

	return nil
}

// GetSessionTypeEnum return the enum type of this object
func (sessionTypeApple *SessionTypeApple) GetSessionTypeEnum() SessionTypeEnum {
	return SessionTypeAppleType
}

// SessionTypeBrave The session is running on the Brave browser
type SessionTypeBrave struct {
	tdCommon
}

// MessageType return the string telegram-type of SessionTypeBrave
func (sessionTypeBrave *SessionTypeBrave) MessageType() string {
	return "sessionTypeBrave"
}

// NewSessionTypeBrave creates a new SessionTypeBrave
//
func NewSessionTypeBrave() *SessionTypeBrave {
	sessionTypeBraveTemp := SessionTypeBrave{
		tdCommon: tdCommon{Type: "sessionTypeBrave"},
	}

	return &sessionTypeBraveTemp
}

// UnmarshalJSON unmarshal to json
func (sessionTypeBrave *SessionTypeBrave) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sessionTypeBrave.tdCommon = tempObj.tdCommon

	return nil
}

// GetSessionTypeEnum return the enum type of this object
func (sessionTypeBrave *SessionTypeBrave) GetSessionTypeEnum() SessionTypeEnum {
	return SessionTypeBraveType
}

// SessionTypeChrome The session is running on the Chrome browser
type SessionTypeChrome struct {
	tdCommon
}

// MessageType return the string telegram-type of SessionTypeChrome
func (sessionTypeChrome *SessionTypeChrome) MessageType() string {
	return "sessionTypeChrome"
}

// NewSessionTypeChrome creates a new SessionTypeChrome
//
func NewSessionTypeChrome() *SessionTypeChrome {
	sessionTypeChromeTemp := SessionTypeChrome{
		tdCommon: tdCommon{Type: "sessionTypeChrome"},
	}

	return &sessionTypeChromeTemp
}

// UnmarshalJSON unmarshal to json
func (sessionTypeChrome *SessionTypeChrome) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sessionTypeChrome.tdCommon = tempObj.tdCommon

	return nil
}

// GetSessionTypeEnum return the enum type of this object
func (sessionTypeChrome *SessionTypeChrome) GetSessionTypeEnum() SessionTypeEnum {
	return SessionTypeChromeType
}

// SessionTypeEdge The session is running on the Edge browser
type SessionTypeEdge struct {
	tdCommon
}

// MessageType return the string telegram-type of SessionTypeEdge
func (sessionTypeEdge *SessionTypeEdge) MessageType() string {
	return "sessionTypeEdge"
}

// NewSessionTypeEdge creates a new SessionTypeEdge
//
func NewSessionTypeEdge() *SessionTypeEdge {
	sessionTypeEdgeTemp := SessionTypeEdge{
		tdCommon: tdCommon{Type: "sessionTypeEdge"},
	}

	return &sessionTypeEdgeTemp
}

// UnmarshalJSON unmarshal to json
func (sessionTypeEdge *SessionTypeEdge) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sessionTypeEdge.tdCommon = tempObj.tdCommon

	return nil
}

// GetSessionTypeEnum return the enum type of this object
func (sessionTypeEdge *SessionTypeEdge) GetSessionTypeEnum() SessionTypeEnum {
	return SessionTypeEdgeType
}

// SessionTypeFirefox The session is running on the Firefox browser
type SessionTypeFirefox struct {
	tdCommon
}

// MessageType return the string telegram-type of SessionTypeFirefox
func (sessionTypeFirefox *SessionTypeFirefox) MessageType() string {
	return "sessionTypeFirefox"
}

// NewSessionTypeFirefox creates a new SessionTypeFirefox
//
func NewSessionTypeFirefox() *SessionTypeFirefox {
	sessionTypeFirefoxTemp := SessionTypeFirefox{
		tdCommon: tdCommon{Type: "sessionTypeFirefox"},
	}

	return &sessionTypeFirefoxTemp
}

// UnmarshalJSON unmarshal to json
func (sessionTypeFirefox *SessionTypeFirefox) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sessionTypeFirefox.tdCommon = tempObj.tdCommon

	return nil
}

// GetSessionTypeEnum return the enum type of this object
func (sessionTypeFirefox *SessionTypeFirefox) GetSessionTypeEnum() SessionTypeEnum {
	return SessionTypeFirefoxType
}

// SessionTypeIPad The session is running on an iPad device
type SessionTypeIPad struct {
	tdCommon
}

// MessageType return the string telegram-type of SessionTypeIPad
func (sessionTypeIPad *SessionTypeIPad) MessageType() string {
	return "sessionTypeIpad"
}

// NewSessionTypeIPad creates a new SessionTypeIPad
//
func NewSessionTypeIPad() *SessionTypeIPad {
	sessionTypeIPadTemp := SessionTypeIPad{
		tdCommon: tdCommon{Type: "sessionTypeIpad"},
	}

	return &sessionTypeIPadTemp
}

// UnmarshalJSON unmarshal to json
func (sessionTypeIPad *SessionTypeIPad) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sessionTypeIPad.tdCommon = tempObj.tdCommon

	return nil
}

// GetSessionTypeEnum return the enum type of this object
func (sessionTypeIPad *SessionTypeIPad) GetSessionTypeEnum() SessionTypeEnum {
	return SessionTypeIPadType
}

// SessionTypeIPhone The session is running on an iPhone device
type SessionTypeIPhone struct {
	tdCommon
}

// MessageType return the string telegram-type of SessionTypeIPhone
func (sessionTypeIPhone *SessionTypeIPhone) MessageType() string {
	return "sessionTypeIphone"
}

// NewSessionTypeIPhone creates a new SessionTypeIPhone
//
func NewSessionTypeIPhone() *SessionTypeIPhone {
	sessionTypeIPhoneTemp := SessionTypeIPhone{
		tdCommon: tdCommon{Type: "sessionTypeIphone"},
	}

	return &sessionTypeIPhoneTemp
}

// UnmarshalJSON unmarshal to json
func (sessionTypeIPhone *SessionTypeIPhone) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sessionTypeIPhone.tdCommon = tempObj.tdCommon

	return nil
}

// GetSessionTypeEnum return the enum type of this object
func (sessionTypeIPhone *SessionTypeIPhone) GetSessionTypeEnum() SessionTypeEnum {
	return SessionTypeIPhoneType
}

// SessionTypeLinux The session is running on a Linux device
type SessionTypeLinux struct {
	tdCommon
}

// MessageType return the string telegram-type of SessionTypeLinux
func (sessionTypeLinux *SessionTypeLinux) MessageType() string {
	return "sessionTypeLinux"
}

// NewSessionTypeLinux creates a new SessionTypeLinux
//
func NewSessionTypeLinux() *SessionTypeLinux {
	sessionTypeLinuxTemp := SessionTypeLinux{
		tdCommon: tdCommon{Type: "sessionTypeLinux"},
	}

	return &sessionTypeLinuxTemp
}

// UnmarshalJSON unmarshal to json
func (sessionTypeLinux *SessionTypeLinux) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sessionTypeLinux.tdCommon = tempObj.tdCommon

	return nil
}

// GetSessionTypeEnum return the enum type of this object
func (sessionTypeLinux *SessionTypeLinux) GetSessionTypeEnum() SessionTypeEnum {
	return SessionTypeLinuxType
}

// SessionTypeMac The session is running on a Mac device
type SessionTypeMac struct {
	tdCommon
}

// MessageType return the string telegram-type of SessionTypeMac
func (sessionTypeMac *SessionTypeMac) MessageType() string {
	return "sessionTypeMac"
}

// NewSessionTypeMac creates a new SessionTypeMac
//
func NewSessionTypeMac() *SessionTypeMac {
	sessionTypeMacTemp := SessionTypeMac{
		tdCommon: tdCommon{Type: "sessionTypeMac"},
	}

	return &sessionTypeMacTemp
}

// UnmarshalJSON unmarshal to json
func (sessionTypeMac *SessionTypeMac) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sessionTypeMac.tdCommon = tempObj.tdCommon

	return nil
}

// GetSessionTypeEnum return the enum type of this object
func (sessionTypeMac *SessionTypeMac) GetSessionTypeEnum() SessionTypeEnum {
	return SessionTypeMacType
}

// SessionTypeOpera The session is running on the Opera browser
type SessionTypeOpera struct {
	tdCommon
}

// MessageType return the string telegram-type of SessionTypeOpera
func (sessionTypeOpera *SessionTypeOpera) MessageType() string {
	return "sessionTypeOpera"
}

// NewSessionTypeOpera creates a new SessionTypeOpera
//
func NewSessionTypeOpera() *SessionTypeOpera {
	sessionTypeOperaTemp := SessionTypeOpera{
		tdCommon: tdCommon{Type: "sessionTypeOpera"},
	}

	return &sessionTypeOperaTemp
}

// UnmarshalJSON unmarshal to json
func (sessionTypeOpera *SessionTypeOpera) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sessionTypeOpera.tdCommon = tempObj.tdCommon

	return nil
}

// GetSessionTypeEnum return the enum type of this object
func (sessionTypeOpera *SessionTypeOpera) GetSessionTypeEnum() SessionTypeEnum {
	return SessionTypeOperaType
}

// SessionTypeSafari The session is running on the Safari browser
type SessionTypeSafari struct {
	tdCommon
}

// MessageType return the string telegram-type of SessionTypeSafari
func (sessionTypeSafari *SessionTypeSafari) MessageType() string {
	return "sessionTypeSafari"
}

// NewSessionTypeSafari creates a new SessionTypeSafari
//
func NewSessionTypeSafari() *SessionTypeSafari {
	sessionTypeSafariTemp := SessionTypeSafari{
		tdCommon: tdCommon{Type: "sessionTypeSafari"},
	}

	return &sessionTypeSafariTemp
}

// UnmarshalJSON unmarshal to json
func (sessionTypeSafari *SessionTypeSafari) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sessionTypeSafari.tdCommon = tempObj.tdCommon

	return nil
}

// GetSessionTypeEnum return the enum type of this object
func (sessionTypeSafari *SessionTypeSafari) GetSessionTypeEnum() SessionTypeEnum {
	return SessionTypeSafariType
}

// SessionTypeUbuntu The session is running on an Ubuntu device
type SessionTypeUbuntu struct {
	tdCommon
}

// MessageType return the string telegram-type of SessionTypeUbuntu
func (sessionTypeUbuntu *SessionTypeUbuntu) MessageType() string {
	return "sessionTypeUbuntu"
}

// NewSessionTypeUbuntu creates a new SessionTypeUbuntu
//
func NewSessionTypeUbuntu() *SessionTypeUbuntu {
	sessionTypeUbuntuTemp := SessionTypeUbuntu{
		tdCommon: tdCommon{Type: "sessionTypeUbuntu"},
	}

	return &sessionTypeUbuntuTemp
}

// UnmarshalJSON unmarshal to json
func (sessionTypeUbuntu *SessionTypeUbuntu) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sessionTypeUbuntu.tdCommon = tempObj.tdCommon

	return nil
}

// GetSessionTypeEnum return the enum type of this object
func (sessionTypeUbuntu *SessionTypeUbuntu) GetSessionTypeEnum() SessionTypeEnum {
	return SessionTypeUbuntuType
}

// SessionTypeUnknown The session is running on an unknown type of device
type SessionTypeUnknown struct {
	tdCommon
}

// MessageType return the string telegram-type of SessionTypeUnknown
func (sessionTypeUnknown *SessionTypeUnknown) MessageType() string {
	return "sessionTypeUnknown"
}

// NewSessionTypeUnknown creates a new SessionTypeUnknown
//
func NewSessionTypeUnknown() *SessionTypeUnknown {
	sessionTypeUnknownTemp := SessionTypeUnknown{
		tdCommon: tdCommon{Type: "sessionTypeUnknown"},
	}

	return &sessionTypeUnknownTemp
}

// UnmarshalJSON unmarshal to json
func (sessionTypeUnknown *SessionTypeUnknown) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sessionTypeUnknown.tdCommon = tempObj.tdCommon

	return nil
}

// GetSessionTypeEnum return the enum type of this object
func (sessionTypeUnknown *SessionTypeUnknown) GetSessionTypeEnum() SessionTypeEnum {
	return SessionTypeUnknownType
}

// SessionTypeVivaldi The session is running on the Vivaldi browser
type SessionTypeVivaldi struct {
	tdCommon
}

// MessageType return the string telegram-type of SessionTypeVivaldi
func (sessionTypeVivaldi *SessionTypeVivaldi) MessageType() string {
	return "sessionTypeVivaldi"
}

// NewSessionTypeVivaldi creates a new SessionTypeVivaldi
//
func NewSessionTypeVivaldi() *SessionTypeVivaldi {
	sessionTypeVivaldiTemp := SessionTypeVivaldi{
		tdCommon: tdCommon{Type: "sessionTypeVivaldi"},
	}

	return &sessionTypeVivaldiTemp
}

// UnmarshalJSON unmarshal to json
func (sessionTypeVivaldi *SessionTypeVivaldi) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sessionTypeVivaldi.tdCommon = tempObj.tdCommon

	return nil
}

// GetSessionTypeEnum return the enum type of this object
func (sessionTypeVivaldi *SessionTypeVivaldi) GetSessionTypeEnum() SessionTypeEnum {
	return SessionTypeVivaldiType
}

// SessionTypeWindows The session is running on a Windows device
type SessionTypeWindows struct {
	tdCommon
}

// MessageType return the string telegram-type of SessionTypeWindows
func (sessionTypeWindows *SessionTypeWindows) MessageType() string {
	return "sessionTypeWindows"
}

// NewSessionTypeWindows creates a new SessionTypeWindows
//
func NewSessionTypeWindows() *SessionTypeWindows {
	sessionTypeWindowsTemp := SessionTypeWindows{
		tdCommon: tdCommon{Type: "sessionTypeWindows"},
	}

	return &sessionTypeWindowsTemp
}

// UnmarshalJSON unmarshal to json
func (sessionTypeWindows *SessionTypeWindows) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sessionTypeWindows.tdCommon = tempObj.tdCommon

	return nil
}

// GetSessionTypeEnum return the enum type of this object
func (sessionTypeWindows *SessionTypeWindows) GetSessionTypeEnum() SessionTypeEnum {
	return SessionTypeWindowsType
}

// SessionTypeXbox The session is running on an Xbox console
type SessionTypeXbox struct {
	tdCommon
}

// MessageType return the string telegram-type of SessionTypeXbox
func (sessionTypeXbox *SessionTypeXbox) MessageType() string {
	return "sessionTypeXbox"
}

// NewSessionTypeXbox creates a new SessionTypeXbox
//
func NewSessionTypeXbox() *SessionTypeXbox {
	sessionTypeXboxTemp := SessionTypeXbox{
		tdCommon: tdCommon{Type: "sessionTypeXbox"},
	}

	return &sessionTypeXboxTemp
}

// UnmarshalJSON unmarshal to json
func (sessionTypeXbox *SessionTypeXbox) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sessionTypeXbox.tdCommon = tempObj.tdCommon

	return nil
}

// GetSessionTypeEnum return the enum type of this object
func (sessionTypeXbox *SessionTypeXbox) GetSessionTypeEnum() SessionTypeEnum {
	return SessionTypeXboxType
}

// Session Contains information about one session in a Telegram application used by the current user. Sessions must be shown to the user in the returned order
type Session struct {
	tdCommon
	ID                    JSONInt64   `json:"id"`                      // Session identifier
	IsCurrent             bool        `json:"is_current"`              // True, if this session is the current session
	IsPasswordPending     bool        `json:"is_password_pending"`     // True, if a 2-step verification password is needed to complete authorization of the session
	IsUnconfirmed         bool        `json:"is_unconfirmed"`          // True, if the session wasn't confirmed from another session
	CanAcceptSecretChats  bool        `json:"can_accept_secret_chats"` // True, if incoming secret chats can be accepted by the session
	CanAcceptCalls        bool        `json:"can_accept_calls"`        // True, if incoming calls can be accepted by the session
	Type                  SessionType `json:"type"`                    // Session type based on the system and application version, which can be used to display a corresponding icon
	APIID                 int32       `json:"api_id"`                  // Telegram API identifier, as provided by the application
	ApplicationName       string      `json:"application_name"`        // Name of the application, as provided by the application
	ApplicationVersion    string      `json:"application_version"`     // The version of the application, as provided by the application
	IsOfficialApplication bool        `json:"is_official_application"` // True, if the application is an official application or uses the api_id of an official application
	DeviceModel           string      `json:"device_model"`            // Model of the device the application has been run or is running on, as provided by the application
	Platform              string      `json:"platform"`                // Operating system the application has been run or is running on, as provided by the application
	SystemVersion         string      `json:"system_version"`          // Version of the operating system the application has been run or is running on, as provided by the application
	LogInDate             int32       `json:"log_in_date"`             // Point in time (Unix timestamp) when the user has logged in
	LastActiveDate        int32       `json:"last_active_date"`        // Point in time (Unix timestamp) when the session was last used
	IPAddress             string      `json:"ip_address"`              // IP address from which the session was created, in human-readable format
	Location              string      `json:"location"`                // A human-readable description of the location from which the session was created, based on the IP address
}

// MessageType return the string telegram-type of Session
func (session *Session) MessageType() string {
	return "session"
}

// NewSession creates a new Session
//
// @param iD Session identifier
// @param isCurrent True, if this session is the current session
// @param isPasswordPending True, if a 2-step verification password is needed to complete authorization of the session
// @param isUnconfirmed True, if the session wasn't confirmed from another session
// @param canAcceptSecretChats True, if incoming secret chats can be accepted by the session
// @param canAcceptCalls True, if incoming calls can be accepted by the session
// @param typeParam Session type based on the system and application version, which can be used to display a corresponding icon
// @param aPIID Telegram API identifier, as provided by the application
// @param applicationName Name of the application, as provided by the application
// @param applicationVersion The version of the application, as provided by the application
// @param isOfficialApplication True, if the application is an official application or uses the api_id of an official application
// @param deviceModel Model of the device the application has been run or is running on, as provided by the application
// @param platform Operating system the application has been run or is running on, as provided by the application
// @param systemVersion Version of the operating system the application has been run or is running on, as provided by the application
// @param logInDate Point in time (Unix timestamp) when the user has logged in
// @param lastActiveDate Point in time (Unix timestamp) when the session was last used
// @param iPAddress IP address from which the session was created, in human-readable format
// @param location A human-readable description of the location from which the session was created, based on the IP address
func NewSession(iD JSONInt64, isCurrent bool, isPasswordPending bool, isUnconfirmed bool, canAcceptSecretChats bool, canAcceptCalls bool, typeParam SessionType, aPIID int32, applicationName string, applicationVersion string, isOfficialApplication bool, deviceModel string, platform string, systemVersion string, logInDate int32, lastActiveDate int32, iPAddress string, location string) *Session {
	sessionTemp := Session{
		tdCommon:              tdCommon{Type: "session"},
		ID:                    iD,
		IsCurrent:             isCurrent,
		IsPasswordPending:     isPasswordPending,
		IsUnconfirmed:         isUnconfirmed,
		CanAcceptSecretChats:  canAcceptSecretChats,
		CanAcceptCalls:        canAcceptCalls,
		Type:                  typeParam,
		APIID:                 aPIID,
		ApplicationName:       applicationName,
		ApplicationVersion:    applicationVersion,
		IsOfficialApplication: isOfficialApplication,
		DeviceModel:           deviceModel,
		Platform:              platform,
		SystemVersion:         systemVersion,
		LogInDate:             logInDate,
		LastActiveDate:        lastActiveDate,
		IPAddress:             iPAddress,
		Location:              location,
	}

	return &sessionTemp
}

// UnmarshalJSON unmarshal to json
func (session *Session) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID                    JSONInt64 `json:"id"`                      // Session identifier
		IsCurrent             bool      `json:"is_current"`              // True, if this session is the current session
		IsPasswordPending     bool      `json:"is_password_pending"`     // True, if a 2-step verification password is needed to complete authorization of the session
		IsUnconfirmed         bool      `json:"is_unconfirmed"`          // True, if the session wasn't confirmed from another session
		CanAcceptSecretChats  bool      `json:"can_accept_secret_chats"` // True, if incoming secret chats can be accepted by the session
		CanAcceptCalls        bool      `json:"can_accept_calls"`        // True, if incoming calls can be accepted by the session
		APIID                 int32     `json:"api_id"`                  // Telegram API identifier, as provided by the application
		ApplicationName       string    `json:"application_name"`        // Name of the application, as provided by the application
		ApplicationVersion    string    `json:"application_version"`     // The version of the application, as provided by the application
		IsOfficialApplication bool      `json:"is_official_application"` // True, if the application is an official application or uses the api_id of an official application
		DeviceModel           string    `json:"device_model"`            // Model of the device the application has been run or is running on, as provided by the application
		Platform              string    `json:"platform"`                // Operating system the application has been run or is running on, as provided by the application
		SystemVersion         string    `json:"system_version"`          // Version of the operating system the application has been run or is running on, as provided by the application
		LogInDate             int32     `json:"log_in_date"`             // Point in time (Unix timestamp) when the user has logged in
		LastActiveDate        int32     `json:"last_active_date"`        // Point in time (Unix timestamp) when the session was last used
		IPAddress             string    `json:"ip_address"`              // IP address from which the session was created, in human-readable format
		Location              string    `json:"location"`                // A human-readable description of the location from which the session was created, based on the IP address
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	session.tdCommon = tempObj.tdCommon
	session.ID = tempObj.ID
	session.IsCurrent = tempObj.IsCurrent
	session.IsPasswordPending = tempObj.IsPasswordPending
	session.IsUnconfirmed = tempObj.IsUnconfirmed
	session.CanAcceptSecretChats = tempObj.CanAcceptSecretChats
	session.CanAcceptCalls = tempObj.CanAcceptCalls
	session.APIID = tempObj.APIID
	session.ApplicationName = tempObj.ApplicationName
	session.ApplicationVersion = tempObj.ApplicationVersion
	session.IsOfficialApplication = tempObj.IsOfficialApplication
	session.DeviceModel = tempObj.DeviceModel
	session.Platform = tempObj.Platform
	session.SystemVersion = tempObj.SystemVersion
	session.LogInDate = tempObj.LogInDate
	session.LastActiveDate = tempObj.LastActiveDate
	session.IPAddress = tempObj.IPAddress
	session.Location = tempObj.Location

	fieldType, _ := unmarshalSessionType(objMap["type"])
	session.Type = fieldType

	return nil
}

// Sessions Contains a list of sessions
type Sessions struct {
	tdCommon
	Sessions               []Session `json:"sessions"`                  // List of sessions
	InactiveSessionTTLDays int32     `json:"inactive_session_ttl_days"` // Number of days of inactivity before sessions will automatically be terminated; 1-366 days
}

// MessageType return the string telegram-type of Sessions
func (sessions *Sessions) MessageType() string {
	return "sessions"
}

// NewSessions creates a new Sessions
//
// @param sessions List of sessions
// @param inactiveSessionTTLDays Number of days of inactivity before sessions will automatically be terminated; 1-366 days
func NewSessions(sessions []Session, inactiveSessionTTLDays int32) *Sessions {
	sessionsTemp := Sessions{
		tdCommon:               tdCommon{Type: "sessions"},
		Sessions:               sessions,
		InactiveSessionTTLDays: inactiveSessionTTLDays,
	}

	return &sessionsTemp
}

// UnmarshalJSON unmarshal to json
func (sessions *Sessions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Sessions               []Session `json:"sessions"`                  // List of sessions
		InactiveSessionTTLDays int32     `json:"inactive_session_ttl_days"` // Number of days of inactivity before sessions will automatically be terminated; 1-366 days
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	sessions.tdCommon = tempObj.tdCommon
	sessions.Sessions = tempObj.Sessions
	sessions.InactiveSessionTTLDays = tempObj.InactiveSessionTTLDays

	return nil
}

// UnconfirmedSession Contains information about an unconfirmed session
type UnconfirmedSession struct {
	tdCommon
	ID          JSONInt64 `json:"id"`           // Session identifier
	LogInDate   int32     `json:"log_in_date"`  // Point in time (Unix timestamp) when the user has logged in
	DeviceModel string    `json:"device_model"` // Model of the device that was used for the session creation, as provided by the application
	Location    string    `json:"location"`     // A human-readable description of the location from which the session was created, based on the IP address
}

// MessageType return the string telegram-type of UnconfirmedSession
func (unconfirmedSession *UnconfirmedSession) MessageType() string {
	return "unconfirmedSession"
}

// NewUnconfirmedSession creates a new UnconfirmedSession
//
// @param iD Session identifier
// @param logInDate Point in time (Unix timestamp) when the user has logged in
// @param deviceModel Model of the device that was used for the session creation, as provided by the application
// @param location A human-readable description of the location from which the session was created, based on the IP address
func NewUnconfirmedSession(iD JSONInt64, logInDate int32, deviceModel string, location string) *UnconfirmedSession {
	unconfirmedSessionTemp := UnconfirmedSession{
		tdCommon:    tdCommon{Type: "unconfirmedSession"},
		ID:          iD,
		LogInDate:   logInDate,
		DeviceModel: deviceModel,
		Location:    location,
	}

	return &unconfirmedSessionTemp
}

// UnmarshalJSON unmarshal to json
func (unconfirmedSession *UnconfirmedSession) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID          JSONInt64 `json:"id"`           // Session identifier
		LogInDate   int32     `json:"log_in_date"`  // Point in time (Unix timestamp) when the user has logged in
		DeviceModel string    `json:"device_model"` // Model of the device that was used for the session creation, as provided by the application
		Location    string    `json:"location"`     // A human-readable description of the location from which the session was created, based on the IP address
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	unconfirmedSession.tdCommon = tempObj.tdCommon
	unconfirmedSession.ID = tempObj.ID
	unconfirmedSession.LogInDate = tempObj.LogInDate
	unconfirmedSession.DeviceModel = tempObj.DeviceModel
	unconfirmedSession.Location = tempObj.Location

	return nil
}

// ConnectedWebsite Contains information about one website the current user is logged in with Telegram
type ConnectedWebsite struct {
	tdCommon
	ID             JSONInt64 `json:"id"`               // Website identifier
	DomainName     string    `json:"domain_name"`      // The domain name of the website
	BotUserID      int64     `json:"bot_user_id"`      // User identifier of a bot linked with the website
	Browser        string    `json:"browser"`          // The version of a browser used to log in
	Platform       string    `json:"platform"`         // Operating system the browser is running on
	LogInDate      int32     `json:"log_in_date"`      // Point in time (Unix timestamp) when the user was logged in
	LastActiveDate int32     `json:"last_active_date"` // Point in time (Unix timestamp) when obtained authorization was last used
	IPAddress      string    `json:"ip_address"`       // IP address from which the user was logged in, in human-readable format
	Location       string    `json:"location"`         // Human-readable description of a country and a region from which the user was logged in, based on the IP address
}

// MessageType return the string telegram-type of ConnectedWebsite
func (connectedWebsite *ConnectedWebsite) MessageType() string {
	return "connectedWebsite"
}

// NewConnectedWebsite creates a new ConnectedWebsite
//
// @param iD Website identifier
// @param domainName The domain name of the website
// @param botUserID User identifier of a bot linked with the website
// @param browser The version of a browser used to log in
// @param platform Operating system the browser is running on
// @param logInDate Point in time (Unix timestamp) when the user was logged in
// @param lastActiveDate Point in time (Unix timestamp) when obtained authorization was last used
// @param iPAddress IP address from which the user was logged in, in human-readable format
// @param location Human-readable description of a country and a region from which the user was logged in, based on the IP address
func NewConnectedWebsite(iD JSONInt64, domainName string, botUserID int64, browser string, platform string, logInDate int32, lastActiveDate int32, iPAddress string, location string) *ConnectedWebsite {
	connectedWebsiteTemp := ConnectedWebsite{
		tdCommon:       tdCommon{Type: "connectedWebsite"},
		ID:             iD,
		DomainName:     domainName,
		BotUserID:      botUserID,
		Browser:        browser,
		Platform:       platform,
		LogInDate:      logInDate,
		LastActiveDate: lastActiveDate,
		IPAddress:      iPAddress,
		Location:       location,
	}

	return &connectedWebsiteTemp
}

// UnmarshalJSON unmarshal to json
func (connectedWebsite *ConnectedWebsite) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID             JSONInt64 `json:"id"`               // Website identifier
		DomainName     string    `json:"domain_name"`      // The domain name of the website
		BotUserID      int64     `json:"bot_user_id"`      // User identifier of a bot linked with the website
		Browser        string    `json:"browser"`          // The version of a browser used to log in
		Platform       string    `json:"platform"`         // Operating system the browser is running on
		LogInDate      int32     `json:"log_in_date"`      // Point in time (Unix timestamp) when the user was logged in
		LastActiveDate int32     `json:"last_active_date"` // Point in time (Unix timestamp) when obtained authorization was last used
		IPAddress      string    `json:"ip_address"`       // IP address from which the user was logged in, in human-readable format
		Location       string    `json:"location"`         // Human-readable description of a country and a region from which the user was logged in, based on the IP address
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	connectedWebsite.tdCommon = tempObj.tdCommon
	connectedWebsite.ID = tempObj.ID
	connectedWebsite.DomainName = tempObj.DomainName
	connectedWebsite.BotUserID = tempObj.BotUserID
	connectedWebsite.Browser = tempObj.Browser
	connectedWebsite.Platform = tempObj.Platform
	connectedWebsite.LogInDate = tempObj.LogInDate
	connectedWebsite.LastActiveDate = tempObj.LastActiveDate
	connectedWebsite.IPAddress = tempObj.IPAddress
	connectedWebsite.Location = tempObj.Location

	return nil
}

// ConnectedWebsites Contains a list of websites the current user is logged in with Telegram
type ConnectedWebsites struct {
	tdCommon
	Websites []ConnectedWebsite `json:"websites"` // List of connected websites
}

// MessageType return the string telegram-type of ConnectedWebsites
func (connectedWebsites *ConnectedWebsites) MessageType() string {
	return "connectedWebsites"
}

// NewConnectedWebsites creates a new ConnectedWebsites
//
// @param websites List of connected websites
func NewConnectedWebsites(websites []ConnectedWebsite) *ConnectedWebsites {
	connectedWebsitesTemp := ConnectedWebsites{
		tdCommon: tdCommon{Type: "connectedWebsites"},
		Websites: websites,
	}

	return &connectedWebsitesTemp
}

// UnmarshalJSON unmarshal to json
func (connectedWebsites *ConnectedWebsites) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Websites []ConnectedWebsite `json:"websites"` // List of connected websites
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	connectedWebsites.tdCommon = tempObj.tdCommon
	connectedWebsites.Websites = tempObj.Websites

	return nil
}

// ReportReasonSpam The chat contains spam messages
type ReportReasonSpam struct {
	tdCommon
}

// MessageType return the string telegram-type of ReportReasonSpam
func (reportReasonSpam *ReportReasonSpam) MessageType() string {
	return "reportReasonSpam"
}

// NewReportReasonSpam creates a new ReportReasonSpam
//
func NewReportReasonSpam() *ReportReasonSpam {
	reportReasonSpamTemp := ReportReasonSpam{
		tdCommon: tdCommon{Type: "reportReasonSpam"},
	}

	return &reportReasonSpamTemp
}

// UnmarshalJSON unmarshal to json
func (reportReasonSpam *ReportReasonSpam) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reportReasonSpam.tdCommon = tempObj.tdCommon

	return nil
}

// GetReportReasonEnum return the enum type of this object
func (reportReasonSpam *ReportReasonSpam) GetReportReasonEnum() ReportReasonEnum {
	return ReportReasonSpamType
}

// ReportReasonViolence The chat promotes violence
type ReportReasonViolence struct {
	tdCommon
}

// MessageType return the string telegram-type of ReportReasonViolence
func (reportReasonViolence *ReportReasonViolence) MessageType() string {
	return "reportReasonViolence"
}

// NewReportReasonViolence creates a new ReportReasonViolence
//
func NewReportReasonViolence() *ReportReasonViolence {
	reportReasonViolenceTemp := ReportReasonViolence{
		tdCommon: tdCommon{Type: "reportReasonViolence"},
	}

	return &reportReasonViolenceTemp
}

// UnmarshalJSON unmarshal to json
func (reportReasonViolence *ReportReasonViolence) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reportReasonViolence.tdCommon = tempObj.tdCommon

	return nil
}

// GetReportReasonEnum return the enum type of this object
func (reportReasonViolence *ReportReasonViolence) GetReportReasonEnum() ReportReasonEnum {
	return ReportReasonViolenceType
}

// ReportReasonPornography The chat contains pornographic messages
type ReportReasonPornography struct {
	tdCommon
}

// MessageType return the string telegram-type of ReportReasonPornography
func (reportReasonPornography *ReportReasonPornography) MessageType() string {
	return "reportReasonPornography"
}

// NewReportReasonPornography creates a new ReportReasonPornography
//
func NewReportReasonPornography() *ReportReasonPornography {
	reportReasonPornographyTemp := ReportReasonPornography{
		tdCommon: tdCommon{Type: "reportReasonPornography"},
	}

	return &reportReasonPornographyTemp
}

// UnmarshalJSON unmarshal to json
func (reportReasonPornography *ReportReasonPornography) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reportReasonPornography.tdCommon = tempObj.tdCommon

	return nil
}

// GetReportReasonEnum return the enum type of this object
func (reportReasonPornography *ReportReasonPornography) GetReportReasonEnum() ReportReasonEnum {
	return ReportReasonPornographyType
}

// ReportReasonChildAbuse The chat has child abuse related content
type ReportReasonChildAbuse struct {
	tdCommon
}

// MessageType return the string telegram-type of ReportReasonChildAbuse
func (reportReasonChildAbuse *ReportReasonChildAbuse) MessageType() string {
	return "reportReasonChildAbuse"
}

// NewReportReasonChildAbuse creates a new ReportReasonChildAbuse
//
func NewReportReasonChildAbuse() *ReportReasonChildAbuse {
	reportReasonChildAbuseTemp := ReportReasonChildAbuse{
		tdCommon: tdCommon{Type: "reportReasonChildAbuse"},
	}

	return &reportReasonChildAbuseTemp
}

// UnmarshalJSON unmarshal to json
func (reportReasonChildAbuse *ReportReasonChildAbuse) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reportReasonChildAbuse.tdCommon = tempObj.tdCommon

	return nil
}

// GetReportReasonEnum return the enum type of this object
func (reportReasonChildAbuse *ReportReasonChildAbuse) GetReportReasonEnum() ReportReasonEnum {
	return ReportReasonChildAbuseType
}

// ReportReasonCopyright The chat contains copyrighted content
type ReportReasonCopyright struct {
	tdCommon
}

// MessageType return the string telegram-type of ReportReasonCopyright
func (reportReasonCopyright *ReportReasonCopyright) MessageType() string {
	return "reportReasonCopyright"
}

// NewReportReasonCopyright creates a new ReportReasonCopyright
//
func NewReportReasonCopyright() *ReportReasonCopyright {
	reportReasonCopyrightTemp := ReportReasonCopyright{
		tdCommon: tdCommon{Type: "reportReasonCopyright"},
	}

	return &reportReasonCopyrightTemp
}

// UnmarshalJSON unmarshal to json
func (reportReasonCopyright *ReportReasonCopyright) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reportReasonCopyright.tdCommon = tempObj.tdCommon

	return nil
}

// GetReportReasonEnum return the enum type of this object
func (reportReasonCopyright *ReportReasonCopyright) GetReportReasonEnum() ReportReasonEnum {
	return ReportReasonCopyrightType
}

// ReportReasonUnrelatedLocation The location-based chat is unrelated to its stated location
type ReportReasonUnrelatedLocation struct {
	tdCommon
}

// MessageType return the string telegram-type of ReportReasonUnrelatedLocation
func (reportReasonUnrelatedLocation *ReportReasonUnrelatedLocation) MessageType() string {
	return "reportReasonUnrelatedLocation"
}

// NewReportReasonUnrelatedLocation creates a new ReportReasonUnrelatedLocation
//
func NewReportReasonUnrelatedLocation() *ReportReasonUnrelatedLocation {
	reportReasonUnrelatedLocationTemp := ReportReasonUnrelatedLocation{
		tdCommon: tdCommon{Type: "reportReasonUnrelatedLocation"},
	}

	return &reportReasonUnrelatedLocationTemp
}

// UnmarshalJSON unmarshal to json
func (reportReasonUnrelatedLocation *ReportReasonUnrelatedLocation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reportReasonUnrelatedLocation.tdCommon = tempObj.tdCommon

	return nil
}

// GetReportReasonEnum return the enum type of this object
func (reportReasonUnrelatedLocation *ReportReasonUnrelatedLocation) GetReportReasonEnum() ReportReasonEnum {
	return ReportReasonUnrelatedLocationType
}

// ReportReasonFake The chat represents a fake account
type ReportReasonFake struct {
	tdCommon
}

// MessageType return the string telegram-type of ReportReasonFake
func (reportReasonFake *ReportReasonFake) MessageType() string {
	return "reportReasonFake"
}

// NewReportReasonFake creates a new ReportReasonFake
//
func NewReportReasonFake() *ReportReasonFake {
	reportReasonFakeTemp := ReportReasonFake{
		tdCommon: tdCommon{Type: "reportReasonFake"},
	}

	return &reportReasonFakeTemp
}

// UnmarshalJSON unmarshal to json
func (reportReasonFake *ReportReasonFake) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reportReasonFake.tdCommon = tempObj.tdCommon

	return nil
}

// GetReportReasonEnum return the enum type of this object
func (reportReasonFake *ReportReasonFake) GetReportReasonEnum() ReportReasonEnum {
	return ReportReasonFakeType
}

// ReportReasonIllegalDrugs The chat has illegal drugs related content
type ReportReasonIllegalDrugs struct {
	tdCommon
}

// MessageType return the string telegram-type of ReportReasonIllegalDrugs
func (reportReasonIllegalDrugs *ReportReasonIllegalDrugs) MessageType() string {
	return "reportReasonIllegalDrugs"
}

// NewReportReasonIllegalDrugs creates a new ReportReasonIllegalDrugs
//
func NewReportReasonIllegalDrugs() *ReportReasonIllegalDrugs {
	reportReasonIllegalDrugsTemp := ReportReasonIllegalDrugs{
		tdCommon: tdCommon{Type: "reportReasonIllegalDrugs"},
	}

	return &reportReasonIllegalDrugsTemp
}

// UnmarshalJSON unmarshal to json
func (reportReasonIllegalDrugs *ReportReasonIllegalDrugs) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reportReasonIllegalDrugs.tdCommon = tempObj.tdCommon

	return nil
}

// GetReportReasonEnum return the enum type of this object
func (reportReasonIllegalDrugs *ReportReasonIllegalDrugs) GetReportReasonEnum() ReportReasonEnum {
	return ReportReasonIllegalDrugsType
}

// ReportReasonPersonalDetails The chat contains messages with personal details
type ReportReasonPersonalDetails struct {
	tdCommon
}

// MessageType return the string telegram-type of ReportReasonPersonalDetails
func (reportReasonPersonalDetails *ReportReasonPersonalDetails) MessageType() string {
	return "reportReasonPersonalDetails"
}

// NewReportReasonPersonalDetails creates a new ReportReasonPersonalDetails
//
func NewReportReasonPersonalDetails() *ReportReasonPersonalDetails {
	reportReasonPersonalDetailsTemp := ReportReasonPersonalDetails{
		tdCommon: tdCommon{Type: "reportReasonPersonalDetails"},
	}

	return &reportReasonPersonalDetailsTemp
}

// UnmarshalJSON unmarshal to json
func (reportReasonPersonalDetails *ReportReasonPersonalDetails) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reportReasonPersonalDetails.tdCommon = tempObj.tdCommon

	return nil
}

// GetReportReasonEnum return the enum type of this object
func (reportReasonPersonalDetails *ReportReasonPersonalDetails) GetReportReasonEnum() ReportReasonEnum {
	return ReportReasonPersonalDetailsType
}

// ReportReasonCustom A custom reason provided by the user
type ReportReasonCustom struct {
	tdCommon
}

// MessageType return the string telegram-type of ReportReasonCustom
func (reportReasonCustom *ReportReasonCustom) MessageType() string {
	return "reportReasonCustom"
}

// NewReportReasonCustom creates a new ReportReasonCustom
//
func NewReportReasonCustom() *ReportReasonCustom {
	reportReasonCustomTemp := ReportReasonCustom{
		tdCommon: tdCommon{Type: "reportReasonCustom"},
	}

	return &reportReasonCustomTemp
}

// UnmarshalJSON unmarshal to json
func (reportReasonCustom *ReportReasonCustom) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	reportReasonCustom.tdCommon = tempObj.tdCommon

	return nil
}

// GetReportReasonEnum return the enum type of this object
func (reportReasonCustom *ReportReasonCustom) GetReportReasonEnum() ReportReasonEnum {
	return ReportReasonCustomType
}

// TargetChatCurrent The currently opened chat needs to be kept
type TargetChatCurrent struct {
	tdCommon
}

// MessageType return the string telegram-type of TargetChatCurrent
func (targetChatCurrent *TargetChatCurrent) MessageType() string {
	return "targetChatCurrent"
}

// NewTargetChatCurrent creates a new TargetChatCurrent
//
func NewTargetChatCurrent() *TargetChatCurrent {
	targetChatCurrentTemp := TargetChatCurrent{
		tdCommon: tdCommon{Type: "targetChatCurrent"},
	}

	return &targetChatCurrentTemp
}

// UnmarshalJSON unmarshal to json
func (targetChatCurrent *TargetChatCurrent) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	targetChatCurrent.tdCommon = tempObj.tdCommon

	return nil
}

// GetTargetChatEnum return the enum type of this object
func (targetChatCurrent *TargetChatCurrent) GetTargetChatEnum() TargetChatEnum {
	return TargetChatCurrentType
}

// TargetChatChosen The chat needs to be chosen by the user among chats of the specified types
type TargetChatChosen struct {
	tdCommon
	AllowUserChats    bool `json:"allow_user_chats"`    // True, if private chats with ordinary users are allowed
	AllowBotChats     bool `json:"allow_bot_chats"`     // True, if private chats with other bots are allowed
	AllowGroupChats   bool `json:"allow_group_chats"`   // True, if basic group and supergroup chats are allowed
	AllowChannelChats bool `json:"allow_channel_chats"` // True, if channel chats are allowed
}

// MessageType return the string telegram-type of TargetChatChosen
func (targetChatChosen *TargetChatChosen) MessageType() string {
	return "targetChatChosen"
}

// NewTargetChatChosen creates a new TargetChatChosen
//
// @param allowUserChats True, if private chats with ordinary users are allowed
// @param allowBotChats True, if private chats with other bots are allowed
// @param allowGroupChats True, if basic group and supergroup chats are allowed
// @param allowChannelChats True, if channel chats are allowed
func NewTargetChatChosen(allowUserChats bool, allowBotChats bool, allowGroupChats bool, allowChannelChats bool) *TargetChatChosen {
	targetChatChosenTemp := TargetChatChosen{
		tdCommon:          tdCommon{Type: "targetChatChosen"},
		AllowUserChats:    allowUserChats,
		AllowBotChats:     allowBotChats,
		AllowGroupChats:   allowGroupChats,
		AllowChannelChats: allowChannelChats,
	}

	return &targetChatChosenTemp
}

// UnmarshalJSON unmarshal to json
func (targetChatChosen *TargetChatChosen) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		AllowUserChats    bool `json:"allow_user_chats"`    // True, if private chats with ordinary users are allowed
		AllowBotChats     bool `json:"allow_bot_chats"`     // True, if private chats with other bots are allowed
		AllowGroupChats   bool `json:"allow_group_chats"`   // True, if basic group and supergroup chats are allowed
		AllowChannelChats bool `json:"allow_channel_chats"` // True, if channel chats are allowed
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	targetChatChosen.tdCommon = tempObj.tdCommon
	targetChatChosen.AllowUserChats = tempObj.AllowUserChats
	targetChatChosen.AllowBotChats = tempObj.AllowBotChats
	targetChatChosen.AllowGroupChats = tempObj.AllowGroupChats
	targetChatChosen.AllowChannelChats = tempObj.AllowChannelChats

	return nil
}

// GetTargetChatEnum return the enum type of this object
func (targetChatChosen *TargetChatChosen) GetTargetChatEnum() TargetChatEnum {
	return TargetChatChosenType
}

// TargetChatInternalLink The chat needs to be open with the provided internal link
type TargetChatInternalLink struct {
	tdCommon
	Link InternalLinkType `json:"link"` // An internal link pointing to the chat
}

// MessageType return the string telegram-type of TargetChatInternalLink
func (targetChatInternalLink *TargetChatInternalLink) MessageType() string {
	return "targetChatInternalLink"
}

// NewTargetChatInternalLink creates a new TargetChatInternalLink
//
// @param link An internal link pointing to the chat
func NewTargetChatInternalLink(link InternalLinkType) *TargetChatInternalLink {
	targetChatInternalLinkTemp := TargetChatInternalLink{
		tdCommon: tdCommon{Type: "targetChatInternalLink"},
		Link:     link,
	}

	return &targetChatInternalLinkTemp
}

// UnmarshalJSON unmarshal to json
func (targetChatInternalLink *TargetChatInternalLink) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	targetChatInternalLink.tdCommon = tempObj.tdCommon

	fieldLink, _ := unmarshalInternalLinkType(objMap["link"])
	targetChatInternalLink.Link = fieldLink

	return nil
}

// GetTargetChatEnum return the enum type of this object
func (targetChatInternalLink *TargetChatInternalLink) GetTargetChatEnum() TargetChatEnum {
	return TargetChatInternalLinkType
}

// InternalLinkTypeActiveSessions The link is a link to the Devices section of the application. Use getActiveSessions to get the list of active sessions and show them to the user
type InternalLinkTypeActiveSessions struct {
	tdCommon
}

// MessageType return the string telegram-type of InternalLinkTypeActiveSessions
func (internalLinkTypeActiveSessions *InternalLinkTypeActiveSessions) MessageType() string {
	return "internalLinkTypeActiveSessions"
}

// NewInternalLinkTypeActiveSessions creates a new InternalLinkTypeActiveSessions
//
func NewInternalLinkTypeActiveSessions() *InternalLinkTypeActiveSessions {
	internalLinkTypeActiveSessionsTemp := InternalLinkTypeActiveSessions{
		tdCommon: tdCommon{Type: "internalLinkTypeActiveSessions"},
	}

	return &internalLinkTypeActiveSessionsTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeActiveSessions *InternalLinkTypeActiveSessions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeActiveSessions.tdCommon = tempObj.tdCommon

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeActiveSessions *InternalLinkTypeActiveSessions) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeActiveSessionsType
}

// InternalLinkTypeAttachmentMenuBot The link is a link to an attachment menu bot to be opened in the specified or a chosen chat. Process given target_chat to open the chat. Then, call searchPublicChat with the given bot username, check that the user is a bot and can be added to attachment menu. Then, use getAttachmentMenuBot to receive information about the bot. If the bot isn't added to attachment menu, then show a disclaimer about Mini Apps being third-party applications, ask the user to accept their Terms of service and confirm adding the bot to side and attachment menu. If the user accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu to add the bot. If the attachment menu bot can't be used in the opened chat, show an error to the user. If the bot is added to attachment menu and can be used in the chat, then use openWebApp with the given URL
type InternalLinkTypeAttachmentMenuBot struct {
	tdCommon
	TargetChat  TargetChat `json:"target_chat"`  // Target chat to be opened
	BotUsername string     `json:"bot_username"` // Username of the bot
	URL         string     `json:"url"`          // URL to be passed to openWebApp
}

// MessageType return the string telegram-type of InternalLinkTypeAttachmentMenuBot
func (internalLinkTypeAttachmentMenuBot *InternalLinkTypeAttachmentMenuBot) MessageType() string {
	return "internalLinkTypeAttachmentMenuBot"
}

// NewInternalLinkTypeAttachmentMenuBot creates a new InternalLinkTypeAttachmentMenuBot
//
// @param targetChat Target chat to be opened
// @param botUsername Username of the bot
// @param uRL URL to be passed to openWebApp
func NewInternalLinkTypeAttachmentMenuBot(targetChat TargetChat, botUsername string, uRL string) *InternalLinkTypeAttachmentMenuBot {
	internalLinkTypeAttachmentMenuBotTemp := InternalLinkTypeAttachmentMenuBot{
		tdCommon:    tdCommon{Type: "internalLinkTypeAttachmentMenuBot"},
		TargetChat:  targetChat,
		BotUsername: botUsername,
		URL:         uRL,
	}

	return &internalLinkTypeAttachmentMenuBotTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeAttachmentMenuBot *InternalLinkTypeAttachmentMenuBot) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BotUsername string `json:"bot_username"` // Username of the bot
		URL         string `json:"url"`          // URL to be passed to openWebApp
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeAttachmentMenuBot.tdCommon = tempObj.tdCommon
	internalLinkTypeAttachmentMenuBot.BotUsername = tempObj.BotUsername
	internalLinkTypeAttachmentMenuBot.URL = tempObj.URL

	fieldTargetChat, _ := unmarshalTargetChat(objMap["target_chat"])
	internalLinkTypeAttachmentMenuBot.TargetChat = fieldTargetChat

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeAttachmentMenuBot *InternalLinkTypeAttachmentMenuBot) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeAttachmentMenuBotType
}

// InternalLinkTypeAuthenticationCode The link contains an authentication code. Call checkAuthenticationCode with the code if the current authorization state is authorizationStateWaitCode
type InternalLinkTypeAuthenticationCode struct {
	tdCommon
	Code string `json:"code"` // The authentication code
}

// MessageType return the string telegram-type of InternalLinkTypeAuthenticationCode
func (internalLinkTypeAuthenticationCode *InternalLinkTypeAuthenticationCode) MessageType() string {
	return "internalLinkTypeAuthenticationCode"
}

// NewInternalLinkTypeAuthenticationCode creates a new InternalLinkTypeAuthenticationCode
//
// @param code The authentication code
func NewInternalLinkTypeAuthenticationCode(code string) *InternalLinkTypeAuthenticationCode {
	internalLinkTypeAuthenticationCodeTemp := InternalLinkTypeAuthenticationCode{
		tdCommon: tdCommon{Type: "internalLinkTypeAuthenticationCode"},
		Code:     code,
	}

	return &internalLinkTypeAuthenticationCodeTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeAuthenticationCode *InternalLinkTypeAuthenticationCode) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Code string `json:"code"` // The authentication code
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeAuthenticationCode.tdCommon = tempObj.tdCommon
	internalLinkTypeAuthenticationCode.Code = tempObj.Code

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeAuthenticationCode *InternalLinkTypeAuthenticationCode) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeAuthenticationCodeType
}

// InternalLinkTypeBackground The link is a link to a background. Call searchBackground with the given background name to process the link If background is found and the user wants to apply it, then call setDefaultBackground
type InternalLinkTypeBackground struct {
	tdCommon
	BackgroundName string `json:"background_name"` // Name of the background
}

// MessageType return the string telegram-type of InternalLinkTypeBackground
func (internalLinkTypeBackground *InternalLinkTypeBackground) MessageType() string {
	return "internalLinkTypeBackground"
}

// NewInternalLinkTypeBackground creates a new InternalLinkTypeBackground
//
// @param backgroundName Name of the background
func NewInternalLinkTypeBackground(backgroundName string) *InternalLinkTypeBackground {
	internalLinkTypeBackgroundTemp := InternalLinkTypeBackground{
		tdCommon:       tdCommon{Type: "internalLinkTypeBackground"},
		BackgroundName: backgroundName,
	}

	return &internalLinkTypeBackgroundTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeBackground *InternalLinkTypeBackground) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BackgroundName string `json:"background_name"` // Name of the background
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeBackground.tdCommon = tempObj.tdCommon
	internalLinkTypeBackground.BackgroundName = tempObj.BackgroundName

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeBackground *InternalLinkTypeBackground) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeBackgroundType
}

// InternalLinkTypeBotAddToChannel The link is a link to a Telegram bot, which is supposed to be added to a channel chat as an administrator. Call searchPublicChat with the given bot username and check that the user is a bot, ask the current user to select a channel chat to add the bot to as an administrator. Then, call getChatMember to receive the current bot rights in the chat and if the bot already is an administrator, check that the current user can edit its administrator rights and combine received rights with the requested administrator rights. Then, show confirmation box to the user, and call setChatMemberStatus with the chosen chat and confirmed rights
type InternalLinkTypeBotAddToChannel struct {
	tdCommon
	BotUsername         string                   `json:"bot_username"`         // Username of the bot
	AdministratorRights *ChatAdministratorRights `json:"administrator_rights"` // Expected administrator rights for the bot
}

// MessageType return the string telegram-type of InternalLinkTypeBotAddToChannel
func (internalLinkTypeBotAddToChannel *InternalLinkTypeBotAddToChannel) MessageType() string {
	return "internalLinkTypeBotAddToChannel"
}

// NewInternalLinkTypeBotAddToChannel creates a new InternalLinkTypeBotAddToChannel
//
// @param botUsername Username of the bot
// @param administratorRights Expected administrator rights for the bot
func NewInternalLinkTypeBotAddToChannel(botUsername string, administratorRights *ChatAdministratorRights) *InternalLinkTypeBotAddToChannel {
	internalLinkTypeBotAddToChannelTemp := InternalLinkTypeBotAddToChannel{
		tdCommon:            tdCommon{Type: "internalLinkTypeBotAddToChannel"},
		BotUsername:         botUsername,
		AdministratorRights: administratorRights,
	}

	return &internalLinkTypeBotAddToChannelTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeBotAddToChannel *InternalLinkTypeBotAddToChannel) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BotUsername         string                   `json:"bot_username"`         // Username of the bot
		AdministratorRights *ChatAdministratorRights `json:"administrator_rights"` // Expected administrator rights for the bot
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeBotAddToChannel.tdCommon = tempObj.tdCommon
	internalLinkTypeBotAddToChannel.BotUsername = tempObj.BotUsername
	internalLinkTypeBotAddToChannel.AdministratorRights = tempObj.AdministratorRights

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeBotAddToChannel *InternalLinkTypeBotAddToChannel) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeBotAddToChannelType
}

// InternalLinkTypeBotStart The link is a link to a chat with a Telegram bot. Call searchPublicChat with the given bot username, check that the user is a bot, show START button in the chat with the bot, and then call sendBotStartMessage with the given start parameter after the button is pressed
type InternalLinkTypeBotStart struct {
	tdCommon
	BotUsername    string `json:"bot_username"`    // Username of the bot
	StartParameter string `json:"start_parameter"` // The parameter to be passed to sendBotStartMessage
	Autostart      bool   `json:"autostart"`       // True, if sendBotStartMessage must be called automatically without showing the START button
}

// MessageType return the string telegram-type of InternalLinkTypeBotStart
func (internalLinkTypeBotStart *InternalLinkTypeBotStart) MessageType() string {
	return "internalLinkTypeBotStart"
}

// NewInternalLinkTypeBotStart creates a new InternalLinkTypeBotStart
//
// @param botUsername Username of the bot
// @param startParameter The parameter to be passed to sendBotStartMessage
// @param autostart True, if sendBotStartMessage must be called automatically without showing the START button
func NewInternalLinkTypeBotStart(botUsername string, startParameter string, autostart bool) *InternalLinkTypeBotStart {
	internalLinkTypeBotStartTemp := InternalLinkTypeBotStart{
		tdCommon:       tdCommon{Type: "internalLinkTypeBotStart"},
		BotUsername:    botUsername,
		StartParameter: startParameter,
		Autostart:      autostart,
	}

	return &internalLinkTypeBotStartTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeBotStart *InternalLinkTypeBotStart) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BotUsername    string `json:"bot_username"`    // Username of the bot
		StartParameter string `json:"start_parameter"` // The parameter to be passed to sendBotStartMessage
		Autostart      bool   `json:"autostart"`       // True, if sendBotStartMessage must be called automatically without showing the START button
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeBotStart.tdCommon = tempObj.tdCommon
	internalLinkTypeBotStart.BotUsername = tempObj.BotUsername
	internalLinkTypeBotStart.StartParameter = tempObj.StartParameter
	internalLinkTypeBotStart.Autostart = tempObj.Autostart

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeBotStart *InternalLinkTypeBotStart) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeBotStartType
}

// InternalLinkTypeBotStartInGroup The link is a link to a Telegram bot, which is supposed to be added to a group chat. Call searchPublicChat with the given bot username, check that the user is a bot and can be added to groups, ask the current user to select a basic group or a supergroup chat to add the bot to, taking into account that bots can be added to a public supergroup only by administrators of the supergroup. If administrator rights are provided by the link, call getChatMember to receive the current bot rights in the chat and if the bot already is an administrator, check that the current user can edit its administrator rights, combine received rights with the requested administrator rights, show confirmation box to the user, and call setChatMemberStatus with the chosen chat and confirmed administrator rights. Before call to setChatMemberStatus it may be required to upgrade the chosen basic group chat to a supergroup chat. Then, if start_parameter isn't empty, call sendBotStartMessage with the given start parameter and the chosen chat; otherwise, just send /start message with bot's username added to the chat
type InternalLinkTypeBotStartInGroup struct {
	tdCommon
	BotUsername         string                   `json:"bot_username"`         // Username of the bot
	StartParameter      string                   `json:"start_parameter"`      // The parameter to be passed to sendBotStartMessage
	AdministratorRights *ChatAdministratorRights `json:"administrator_rights"` // Expected administrator rights for the bot; may be null
}

// MessageType return the string telegram-type of InternalLinkTypeBotStartInGroup
func (internalLinkTypeBotStartInGroup *InternalLinkTypeBotStartInGroup) MessageType() string {
	return "internalLinkTypeBotStartInGroup"
}

// NewInternalLinkTypeBotStartInGroup creates a new InternalLinkTypeBotStartInGroup
//
// @param botUsername Username of the bot
// @param startParameter The parameter to be passed to sendBotStartMessage
// @param administratorRights Expected administrator rights for the bot; may be null
func NewInternalLinkTypeBotStartInGroup(botUsername string, startParameter string, administratorRights *ChatAdministratorRights) *InternalLinkTypeBotStartInGroup {
	internalLinkTypeBotStartInGroupTemp := InternalLinkTypeBotStartInGroup{
		tdCommon:            tdCommon{Type: "internalLinkTypeBotStartInGroup"},
		BotUsername:         botUsername,
		StartParameter:      startParameter,
		AdministratorRights: administratorRights,
	}

	return &internalLinkTypeBotStartInGroupTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeBotStartInGroup *InternalLinkTypeBotStartInGroup) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BotUsername         string                   `json:"bot_username"`         // Username of the bot
		StartParameter      string                   `json:"start_parameter"`      // The parameter to be passed to sendBotStartMessage
		AdministratorRights *ChatAdministratorRights `json:"administrator_rights"` // Expected administrator rights for the bot; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeBotStartInGroup.tdCommon = tempObj.tdCommon
	internalLinkTypeBotStartInGroup.BotUsername = tempObj.BotUsername
	internalLinkTypeBotStartInGroup.StartParameter = tempObj.StartParameter
	internalLinkTypeBotStartInGroup.AdministratorRights = tempObj.AdministratorRights

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeBotStartInGroup *InternalLinkTypeBotStartInGroup) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeBotStartInGroupType
}

// InternalLinkTypeBusinessChat The link is a link to a business chat. Use getBusinessChatLinkInfo with the provided link name to get information about the link, then open received private chat and replace chat draft with the provided text
type InternalLinkTypeBusinessChat struct {
	tdCommon
	LinkName string `json:"link_name"` // Name of the link
}

// MessageType return the string telegram-type of InternalLinkTypeBusinessChat
func (internalLinkTypeBusinessChat *InternalLinkTypeBusinessChat) MessageType() string {
	return "internalLinkTypeBusinessChat"
}

// NewInternalLinkTypeBusinessChat creates a new InternalLinkTypeBusinessChat
//
// @param linkName Name of the link
func NewInternalLinkTypeBusinessChat(linkName string) *InternalLinkTypeBusinessChat {
	internalLinkTypeBusinessChatTemp := InternalLinkTypeBusinessChat{
		tdCommon: tdCommon{Type: "internalLinkTypeBusinessChat"},
		LinkName: linkName,
	}

	return &internalLinkTypeBusinessChatTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeBusinessChat *InternalLinkTypeBusinessChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		LinkName string `json:"link_name"` // Name of the link
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeBusinessChat.tdCommon = tempObj.tdCommon
	internalLinkTypeBusinessChat.LinkName = tempObj.LinkName

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeBusinessChat *InternalLinkTypeBusinessChat) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeBusinessChatType
}

// InternalLinkTypeBuyStars The link is a link to the Telegram Star purchase section of the application
type InternalLinkTypeBuyStars struct {
	tdCommon
	StarCount int64  `json:"star_count"` // The number of Telegram Stars that must be owned by the user
	Purpose   string `json:"purpose"`    // Purpose of Telegram Star purchase. Arbitrary string specified by the server, for example, "subs" if the Telegram Stars are required to extend channel subscriptions
}

// MessageType return the string telegram-type of InternalLinkTypeBuyStars
func (internalLinkTypeBuyStars *InternalLinkTypeBuyStars) MessageType() string {
	return "internalLinkTypeBuyStars"
}

// NewInternalLinkTypeBuyStars creates a new InternalLinkTypeBuyStars
//
// @param starCount The number of Telegram Stars that must be owned by the user
// @param purpose Purpose of Telegram Star purchase. Arbitrary string specified by the server, for example, "subs" if the Telegram Stars are required to extend channel subscriptions
func NewInternalLinkTypeBuyStars(starCount int64, purpose string) *InternalLinkTypeBuyStars {
	internalLinkTypeBuyStarsTemp := InternalLinkTypeBuyStars{
		tdCommon:  tdCommon{Type: "internalLinkTypeBuyStars"},
		StarCount: starCount,
		Purpose:   purpose,
	}

	return &internalLinkTypeBuyStarsTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeBuyStars *InternalLinkTypeBuyStars) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StarCount int64  `json:"star_count"` // The number of Telegram Stars that must be owned by the user
		Purpose   string `json:"purpose"`    // Purpose of Telegram Star purchase. Arbitrary string specified by the server, for example, "subs" if the Telegram Stars are required to extend channel subscriptions
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeBuyStars.tdCommon = tempObj.tdCommon
	internalLinkTypeBuyStars.StarCount = tempObj.StarCount
	internalLinkTypeBuyStars.Purpose = tempObj.Purpose

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeBuyStars *InternalLinkTypeBuyStars) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeBuyStarsType
}

// InternalLinkTypeChangePhoneNumber The link is a link to the change phone number section of the application
type InternalLinkTypeChangePhoneNumber struct {
	tdCommon
}

// MessageType return the string telegram-type of InternalLinkTypeChangePhoneNumber
func (internalLinkTypeChangePhoneNumber *InternalLinkTypeChangePhoneNumber) MessageType() string {
	return "internalLinkTypeChangePhoneNumber"
}

// NewInternalLinkTypeChangePhoneNumber creates a new InternalLinkTypeChangePhoneNumber
//
func NewInternalLinkTypeChangePhoneNumber() *InternalLinkTypeChangePhoneNumber {
	internalLinkTypeChangePhoneNumberTemp := InternalLinkTypeChangePhoneNumber{
		tdCommon: tdCommon{Type: "internalLinkTypeChangePhoneNumber"},
	}

	return &internalLinkTypeChangePhoneNumberTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeChangePhoneNumber *InternalLinkTypeChangePhoneNumber) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeChangePhoneNumber.tdCommon = tempObj.tdCommon

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeChangePhoneNumber *InternalLinkTypeChangePhoneNumber) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeChangePhoneNumberType
}

// InternalLinkTypeChatBoost The link is a link to boost a Telegram chat. Call getChatBoostLinkInfo with the given URL to process the link. If the chat is found, then call getChatBoostStatus and getAvailableChatBoostSlots to get the current boost status and check whether the chat can be boosted. If the user wants to boost the chat and the chat can be boosted, then call boostChat
type InternalLinkTypeChatBoost struct {
	tdCommon
	URL string `json:"url"` // URL to be passed to getChatBoostLinkInfo
}

// MessageType return the string telegram-type of InternalLinkTypeChatBoost
func (internalLinkTypeChatBoost *InternalLinkTypeChatBoost) MessageType() string {
	return "internalLinkTypeChatBoost"
}

// NewInternalLinkTypeChatBoost creates a new InternalLinkTypeChatBoost
//
// @param uRL URL to be passed to getChatBoostLinkInfo
func NewInternalLinkTypeChatBoost(uRL string) *InternalLinkTypeChatBoost {
	internalLinkTypeChatBoostTemp := InternalLinkTypeChatBoost{
		tdCommon: tdCommon{Type: "internalLinkTypeChatBoost"},
		URL:      uRL,
	}

	return &internalLinkTypeChatBoostTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeChatBoost *InternalLinkTypeChatBoost) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL string `json:"url"` // URL to be passed to getChatBoostLinkInfo
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeChatBoost.tdCommon = tempObj.tdCommon
	internalLinkTypeChatBoost.URL = tempObj.URL

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeChatBoost *InternalLinkTypeChatBoost) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeChatBoostType
}

// InternalLinkTypeChatFolderInvite The link is an invite link to a chat folder. Call checkChatFolderInviteLink with the given invite link to process the link. If the link is valid and the user wants to join the chat folder, then call addChatFolderByInviteLink
type InternalLinkTypeChatFolderInvite struct {
	tdCommon
	InviteLink string `json:"invite_link"` // Internal representation of the invite link
}

// MessageType return the string telegram-type of InternalLinkTypeChatFolderInvite
func (internalLinkTypeChatFolderInvite *InternalLinkTypeChatFolderInvite) MessageType() string {
	return "internalLinkTypeChatFolderInvite"
}

// NewInternalLinkTypeChatFolderInvite creates a new InternalLinkTypeChatFolderInvite
//
// @param inviteLink Internal representation of the invite link
func NewInternalLinkTypeChatFolderInvite(inviteLink string) *InternalLinkTypeChatFolderInvite {
	internalLinkTypeChatFolderInviteTemp := InternalLinkTypeChatFolderInvite{
		tdCommon:   tdCommon{Type: "internalLinkTypeChatFolderInvite"},
		InviteLink: inviteLink,
	}

	return &internalLinkTypeChatFolderInviteTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeChatFolderInvite *InternalLinkTypeChatFolderInvite) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		InviteLink string `json:"invite_link"` // Internal representation of the invite link
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeChatFolderInvite.tdCommon = tempObj.tdCommon
	internalLinkTypeChatFolderInvite.InviteLink = tempObj.InviteLink

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeChatFolderInvite *InternalLinkTypeChatFolderInvite) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeChatFolderInviteType
}

// InternalLinkTypeChatFolderSettings The link is a link to the folder section of the application settings
type InternalLinkTypeChatFolderSettings struct {
	tdCommon
}

// MessageType return the string telegram-type of InternalLinkTypeChatFolderSettings
func (internalLinkTypeChatFolderSettings *InternalLinkTypeChatFolderSettings) MessageType() string {
	return "internalLinkTypeChatFolderSettings"
}

// NewInternalLinkTypeChatFolderSettings creates a new InternalLinkTypeChatFolderSettings
//
func NewInternalLinkTypeChatFolderSettings() *InternalLinkTypeChatFolderSettings {
	internalLinkTypeChatFolderSettingsTemp := InternalLinkTypeChatFolderSettings{
		tdCommon: tdCommon{Type: "internalLinkTypeChatFolderSettings"},
	}

	return &internalLinkTypeChatFolderSettingsTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeChatFolderSettings *InternalLinkTypeChatFolderSettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeChatFolderSettings.tdCommon = tempObj.tdCommon

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeChatFolderSettings *InternalLinkTypeChatFolderSettings) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeChatFolderSettingsType
}

// InternalLinkTypeChatInvite The link is a chat invite link. Call checkChatInviteLink with the given invite link to process the link. If the link is valid and the user wants to join the chat, then call joinChatByInviteLink
type InternalLinkTypeChatInvite struct {
	tdCommon
	InviteLink string `json:"invite_link"` // Internal representation of the invite link
}

// MessageType return the string telegram-type of InternalLinkTypeChatInvite
func (internalLinkTypeChatInvite *InternalLinkTypeChatInvite) MessageType() string {
	return "internalLinkTypeChatInvite"
}

// NewInternalLinkTypeChatInvite creates a new InternalLinkTypeChatInvite
//
// @param inviteLink Internal representation of the invite link
func NewInternalLinkTypeChatInvite(inviteLink string) *InternalLinkTypeChatInvite {
	internalLinkTypeChatInviteTemp := InternalLinkTypeChatInvite{
		tdCommon:   tdCommon{Type: "internalLinkTypeChatInvite"},
		InviteLink: inviteLink,
	}

	return &internalLinkTypeChatInviteTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeChatInvite *InternalLinkTypeChatInvite) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		InviteLink string `json:"invite_link"` // Internal representation of the invite link
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeChatInvite.tdCommon = tempObj.tdCommon
	internalLinkTypeChatInvite.InviteLink = tempObj.InviteLink

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeChatInvite *InternalLinkTypeChatInvite) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeChatInviteType
}

// InternalLinkTypeDefaultMessageAutoDeleteTimerSettings The link is a link to the default message auto-delete timer settings section of the application settings
type InternalLinkTypeDefaultMessageAutoDeleteTimerSettings struct {
	tdCommon
}

// MessageType return the string telegram-type of InternalLinkTypeDefaultMessageAutoDeleteTimerSettings
func (internalLinkTypeDefaultMessageAutoDeleteTimerSettings *InternalLinkTypeDefaultMessageAutoDeleteTimerSettings) MessageType() string {
	return "internalLinkTypeDefaultMessageAutoDeleteTimerSettings"
}

// NewInternalLinkTypeDefaultMessageAutoDeleteTimerSettings creates a new InternalLinkTypeDefaultMessageAutoDeleteTimerSettings
//
func NewInternalLinkTypeDefaultMessageAutoDeleteTimerSettings() *InternalLinkTypeDefaultMessageAutoDeleteTimerSettings {
	internalLinkTypeDefaultMessageAutoDeleteTimerSettingsTemp := InternalLinkTypeDefaultMessageAutoDeleteTimerSettings{
		tdCommon: tdCommon{Type: "internalLinkTypeDefaultMessageAutoDeleteTimerSettings"},
	}

	return &internalLinkTypeDefaultMessageAutoDeleteTimerSettingsTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeDefaultMessageAutoDeleteTimerSettings *InternalLinkTypeDefaultMessageAutoDeleteTimerSettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeDefaultMessageAutoDeleteTimerSettings.tdCommon = tempObj.tdCommon

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeDefaultMessageAutoDeleteTimerSettings *InternalLinkTypeDefaultMessageAutoDeleteTimerSettings) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeDefaultMessageAutoDeleteTimerSettingsType
}

// InternalLinkTypeEditProfileSettings The link is a link to the edit profile section of the application settings
type InternalLinkTypeEditProfileSettings struct {
	tdCommon
}

// MessageType return the string telegram-type of InternalLinkTypeEditProfileSettings
func (internalLinkTypeEditProfileSettings *InternalLinkTypeEditProfileSettings) MessageType() string {
	return "internalLinkTypeEditProfileSettings"
}

// NewInternalLinkTypeEditProfileSettings creates a new InternalLinkTypeEditProfileSettings
//
func NewInternalLinkTypeEditProfileSettings() *InternalLinkTypeEditProfileSettings {
	internalLinkTypeEditProfileSettingsTemp := InternalLinkTypeEditProfileSettings{
		tdCommon: tdCommon{Type: "internalLinkTypeEditProfileSettings"},
	}

	return &internalLinkTypeEditProfileSettingsTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeEditProfileSettings *InternalLinkTypeEditProfileSettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeEditProfileSettings.tdCommon = tempObj.tdCommon

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeEditProfileSettings *InternalLinkTypeEditProfileSettings) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeEditProfileSettingsType
}

// InternalLinkTypeGame The link is a link to a game. Call searchPublicChat with the given bot username, check that the user is a bot, ask the current user to select a chat to send the game, and then call sendMessage with inputMessageGame
type InternalLinkTypeGame struct {
	tdCommon
	BotUsername   string `json:"bot_username"`    // Username of the bot that owns the game
	GameShortName string `json:"game_short_name"` // Short name of the game
}

// MessageType return the string telegram-type of InternalLinkTypeGame
func (internalLinkTypeGame *InternalLinkTypeGame) MessageType() string {
	return "internalLinkTypeGame"
}

// NewInternalLinkTypeGame creates a new InternalLinkTypeGame
//
// @param botUsername Username of the bot that owns the game
// @param gameShortName Short name of the game
func NewInternalLinkTypeGame(botUsername string, gameShortName string) *InternalLinkTypeGame {
	internalLinkTypeGameTemp := InternalLinkTypeGame{
		tdCommon:      tdCommon{Type: "internalLinkTypeGame"},
		BotUsername:   botUsername,
		GameShortName: gameShortName,
	}

	return &internalLinkTypeGameTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeGame *InternalLinkTypeGame) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BotUsername   string `json:"bot_username"`    // Username of the bot that owns the game
		GameShortName string `json:"game_short_name"` // Short name of the game
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeGame.tdCommon = tempObj.tdCommon
	internalLinkTypeGame.BotUsername = tempObj.BotUsername
	internalLinkTypeGame.GameShortName = tempObj.GameShortName

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeGame *InternalLinkTypeGame) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeGameType
}

// InternalLinkTypeInstantView The link must be opened in an Instant View. Call getWebPageInstantView with the given URL to process the link. If Instant View is found, then show it, otherwise, open the fallback URL in an external browser
type InternalLinkTypeInstantView struct {
	tdCommon
	URL         string `json:"url"`          // URL to be passed to getWebPageInstantView
	FallbackURL string `json:"fallback_url"` // An URL to open if getWebPageInstantView fails
}

// MessageType return the string telegram-type of InternalLinkTypeInstantView
func (internalLinkTypeInstantView *InternalLinkTypeInstantView) MessageType() string {
	return "internalLinkTypeInstantView"
}

// NewInternalLinkTypeInstantView creates a new InternalLinkTypeInstantView
//
// @param uRL URL to be passed to getWebPageInstantView
// @param fallbackURL An URL to open if getWebPageInstantView fails
func NewInternalLinkTypeInstantView(uRL string, fallbackURL string) *InternalLinkTypeInstantView {
	internalLinkTypeInstantViewTemp := InternalLinkTypeInstantView{
		tdCommon:    tdCommon{Type: "internalLinkTypeInstantView"},
		URL:         uRL,
		FallbackURL: fallbackURL,
	}

	return &internalLinkTypeInstantViewTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeInstantView *InternalLinkTypeInstantView) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL         string `json:"url"`          // URL to be passed to getWebPageInstantView
		FallbackURL string `json:"fallback_url"` // An URL to open if getWebPageInstantView fails
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeInstantView.tdCommon = tempObj.tdCommon
	internalLinkTypeInstantView.URL = tempObj.URL
	internalLinkTypeInstantView.FallbackURL = tempObj.FallbackURL

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeInstantView *InternalLinkTypeInstantView) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeInstantViewType
}

// InternalLinkTypeInvoice The link is a link to an invoice. Call getPaymentForm with the given invoice name to process the link
type InternalLinkTypeInvoice struct {
	tdCommon
	InvoiceName string `json:"invoice_name"` // Name of the invoice
}

// MessageType return the string telegram-type of InternalLinkTypeInvoice
func (internalLinkTypeInvoice *InternalLinkTypeInvoice) MessageType() string {
	return "internalLinkTypeInvoice"
}

// NewInternalLinkTypeInvoice creates a new InternalLinkTypeInvoice
//
// @param invoiceName Name of the invoice
func NewInternalLinkTypeInvoice(invoiceName string) *InternalLinkTypeInvoice {
	internalLinkTypeInvoiceTemp := InternalLinkTypeInvoice{
		tdCommon:    tdCommon{Type: "internalLinkTypeInvoice"},
		InvoiceName: invoiceName,
	}

	return &internalLinkTypeInvoiceTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeInvoice *InternalLinkTypeInvoice) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		InvoiceName string `json:"invoice_name"` // Name of the invoice
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeInvoice.tdCommon = tempObj.tdCommon
	internalLinkTypeInvoice.InvoiceName = tempObj.InvoiceName

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeInvoice *InternalLinkTypeInvoice) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeInvoiceType
}

// InternalLinkTypeLanguagePack The link is a link to a language pack. Call getLanguagePackInfo with the given language pack identifier to process the link. If the language pack is found and the user wants to apply it, then call setOption for the option "language_pack_id"
type InternalLinkTypeLanguagePack struct {
	tdCommon
	LanguagePackID string `json:"language_pack_id"` // Language pack identifier
}

// MessageType return the string telegram-type of InternalLinkTypeLanguagePack
func (internalLinkTypeLanguagePack *InternalLinkTypeLanguagePack) MessageType() string {
	return "internalLinkTypeLanguagePack"
}

// NewInternalLinkTypeLanguagePack creates a new InternalLinkTypeLanguagePack
//
// @param languagePackID Language pack identifier
func NewInternalLinkTypeLanguagePack(languagePackID string) *InternalLinkTypeLanguagePack {
	internalLinkTypeLanguagePackTemp := InternalLinkTypeLanguagePack{
		tdCommon:       tdCommon{Type: "internalLinkTypeLanguagePack"},
		LanguagePackID: languagePackID,
	}

	return &internalLinkTypeLanguagePackTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeLanguagePack *InternalLinkTypeLanguagePack) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		LanguagePackID string `json:"language_pack_id"` // Language pack identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeLanguagePack.tdCommon = tempObj.tdCommon
	internalLinkTypeLanguagePack.LanguagePackID = tempObj.LanguagePackID

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeLanguagePack *InternalLinkTypeLanguagePack) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeLanguagePackType
}

// InternalLinkTypeLanguageSettings The link is a link to the language section of the application settings
type InternalLinkTypeLanguageSettings struct {
	tdCommon
}

// MessageType return the string telegram-type of InternalLinkTypeLanguageSettings
func (internalLinkTypeLanguageSettings *InternalLinkTypeLanguageSettings) MessageType() string {
	return "internalLinkTypeLanguageSettings"
}

// NewInternalLinkTypeLanguageSettings creates a new InternalLinkTypeLanguageSettings
//
func NewInternalLinkTypeLanguageSettings() *InternalLinkTypeLanguageSettings {
	internalLinkTypeLanguageSettingsTemp := InternalLinkTypeLanguageSettings{
		tdCommon: tdCommon{Type: "internalLinkTypeLanguageSettings"},
	}

	return &internalLinkTypeLanguageSettingsTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeLanguageSettings *InternalLinkTypeLanguageSettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeLanguageSettings.tdCommon = tempObj.tdCommon

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeLanguageSettings *InternalLinkTypeLanguageSettings) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeLanguageSettingsType
}

// InternalLinkTypeMainWebApp The link is a link to the main Web App of a bot. Call searchPublicChat with the given bot username, check that the user is a bot and has the main Web App. If the bot can be added to attachment menu, then use getAttachmentMenuBot to receive information about the bot, then if the bot isn't added to side menu, show a disclaimer about Mini Apps being third-party applications, ask the user to accept their Terms of service and confirm adding the bot to side and attachment menu, then if the user accepts the terms and confirms adding, use toggleBotIsAddedToAttachmentMenu to add the bot. Then, use getMainWebApp with the given start parameter and open the returned URL as a Web App
type InternalLinkTypeMainWebApp struct {
	tdCommon
	BotUsername    string `json:"bot_username"`    // Username of the bot
	StartParameter string `json:"start_parameter"` // Start parameter to be passed to getMainWebApp
	IsCompact      bool   `json:"is_compact"`      // True, if the Web App must be opened in the compact mode instead of the full-size mode
}

// MessageType return the string telegram-type of InternalLinkTypeMainWebApp
func (internalLinkTypeMainWebApp *InternalLinkTypeMainWebApp) MessageType() string {
	return "internalLinkTypeMainWebApp"
}

// NewInternalLinkTypeMainWebApp creates a new InternalLinkTypeMainWebApp
//
// @param botUsername Username of the bot
// @param startParameter Start parameter to be passed to getMainWebApp
// @param isCompact True, if the Web App must be opened in the compact mode instead of the full-size mode
func NewInternalLinkTypeMainWebApp(botUsername string, startParameter string, isCompact bool) *InternalLinkTypeMainWebApp {
	internalLinkTypeMainWebAppTemp := InternalLinkTypeMainWebApp{
		tdCommon:       tdCommon{Type: "internalLinkTypeMainWebApp"},
		BotUsername:    botUsername,
		StartParameter: startParameter,
		IsCompact:      isCompact,
	}

	return &internalLinkTypeMainWebAppTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeMainWebApp *InternalLinkTypeMainWebApp) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BotUsername    string `json:"bot_username"`    // Username of the bot
		StartParameter string `json:"start_parameter"` // Start parameter to be passed to getMainWebApp
		IsCompact      bool   `json:"is_compact"`      // True, if the Web App must be opened in the compact mode instead of the full-size mode
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeMainWebApp.tdCommon = tempObj.tdCommon
	internalLinkTypeMainWebApp.BotUsername = tempObj.BotUsername
	internalLinkTypeMainWebApp.StartParameter = tempObj.StartParameter
	internalLinkTypeMainWebApp.IsCompact = tempObj.IsCompact

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeMainWebApp *InternalLinkTypeMainWebApp) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeMainWebAppType
}

// InternalLinkTypeMessage The link is a link to a Telegram message or a forum topic. Call getMessageLinkInfo with the given URL to process the link, and then open received forum topic or chat and show the message there
type InternalLinkTypeMessage struct {
	tdCommon
	URL string `json:"url"` // URL to be passed to getMessageLinkInfo
}

// MessageType return the string telegram-type of InternalLinkTypeMessage
func (internalLinkTypeMessage *InternalLinkTypeMessage) MessageType() string {
	return "internalLinkTypeMessage"
}

// NewInternalLinkTypeMessage creates a new InternalLinkTypeMessage
//
// @param uRL URL to be passed to getMessageLinkInfo
func NewInternalLinkTypeMessage(uRL string) *InternalLinkTypeMessage {
	internalLinkTypeMessageTemp := InternalLinkTypeMessage{
		tdCommon: tdCommon{Type: "internalLinkTypeMessage"},
		URL:      uRL,
	}

	return &internalLinkTypeMessageTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeMessage *InternalLinkTypeMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL string `json:"url"` // URL to be passed to getMessageLinkInfo
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeMessage.tdCommon = tempObj.tdCommon
	internalLinkTypeMessage.URL = tempObj.URL

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeMessage *InternalLinkTypeMessage) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeMessageType
}

// InternalLinkTypeMessageDraft The link contains a message draft text. A share screen needs to be shown to the user, then the chosen chat must be opened and the text is added to the input field
type InternalLinkTypeMessageDraft struct {
	tdCommon
	Text         *FormattedText `json:"text"`          // Message draft text
	ContainsLink bool           `json:"contains_link"` // True, if the first line of the text contains a link. If true, the input field needs to be focused and the text after the link must be selected
}

// MessageType return the string telegram-type of InternalLinkTypeMessageDraft
func (internalLinkTypeMessageDraft *InternalLinkTypeMessageDraft) MessageType() string {
	return "internalLinkTypeMessageDraft"
}

// NewInternalLinkTypeMessageDraft creates a new InternalLinkTypeMessageDraft
//
// @param text Message draft text
// @param containsLink True, if the first line of the text contains a link. If true, the input field needs to be focused and the text after the link must be selected
func NewInternalLinkTypeMessageDraft(text *FormattedText, containsLink bool) *InternalLinkTypeMessageDraft {
	internalLinkTypeMessageDraftTemp := InternalLinkTypeMessageDraft{
		tdCommon:     tdCommon{Type: "internalLinkTypeMessageDraft"},
		Text:         text,
		ContainsLink: containsLink,
	}

	return &internalLinkTypeMessageDraftTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeMessageDraft *InternalLinkTypeMessageDraft) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Text         *FormattedText `json:"text"`          // Message draft text
		ContainsLink bool           `json:"contains_link"` // True, if the first line of the text contains a link. If true, the input field needs to be focused and the text after the link must be selected
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeMessageDraft.tdCommon = tempObj.tdCommon
	internalLinkTypeMessageDraft.Text = tempObj.Text
	internalLinkTypeMessageDraft.ContainsLink = tempObj.ContainsLink

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeMessageDraft *InternalLinkTypeMessageDraft) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeMessageDraftType
}

// InternalLinkTypePassportDataRequest The link contains a request of Telegram passport data. Call getPassportAuthorizationForm with the given parameters to process the link if the link was received from outside of the application; otherwise, ignore it
type InternalLinkTypePassportDataRequest struct {
	tdCommon
	BotUserID   int64  `json:"bot_user_id"`  // User identifier of the service's bot; the corresponding user may be unknown yet
	Scope       string `json:"scope"`        // Telegram Passport element types requested by the service
	PublicKey   string `json:"public_key"`   // Service's public key
	Nonce       string `json:"nonce"`        // Unique request identifier provided by the service
	CallbackURL string `json:"callback_url"` // An HTTP URL to open once the request is finished, canceled, or failed with the parameters tg_passport=success, tg_passport=cancel, or tg_passport=error&error=... respectively. If empty, then onActivityResult method must be used to return response on Android, or the link tgbot{bot_user_id}://passport/success or tgbot{bot_user_id}://passport/cancel must be opened otherwise
}

// MessageType return the string telegram-type of InternalLinkTypePassportDataRequest
func (internalLinkTypePassportDataRequest *InternalLinkTypePassportDataRequest) MessageType() string {
	return "internalLinkTypePassportDataRequest"
}

// NewInternalLinkTypePassportDataRequest creates a new InternalLinkTypePassportDataRequest
//
// @param botUserID User identifier of the service's bot; the corresponding user may be unknown yet
// @param scope Telegram Passport element types requested by the service
// @param publicKey Service's public key
// @param nonce Unique request identifier provided by the service
// @param callbackURL An HTTP URL to open once the request is finished, canceled, or failed with the parameters tg_passport=success, tg_passport=cancel, or tg_passport=error&error=... respectively. If empty, then onActivityResult method must be used to return response on Android, or the link tgbot{bot_user_id}://passport/success or tgbot{bot_user_id}://passport/cancel must be opened otherwise
func NewInternalLinkTypePassportDataRequest(botUserID int64, scope string, publicKey string, nonce string, callbackURL string) *InternalLinkTypePassportDataRequest {
	internalLinkTypePassportDataRequestTemp := InternalLinkTypePassportDataRequest{
		tdCommon:    tdCommon{Type: "internalLinkTypePassportDataRequest"},
		BotUserID:   botUserID,
		Scope:       scope,
		PublicKey:   publicKey,
		Nonce:       nonce,
		CallbackURL: callbackURL,
	}

	return &internalLinkTypePassportDataRequestTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypePassportDataRequest *InternalLinkTypePassportDataRequest) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BotUserID   int64  `json:"bot_user_id"`  // User identifier of the service's bot; the corresponding user may be unknown yet
		Scope       string `json:"scope"`        // Telegram Passport element types requested by the service
		PublicKey   string `json:"public_key"`   // Service's public key
		Nonce       string `json:"nonce"`        // Unique request identifier provided by the service
		CallbackURL string `json:"callback_url"` // An HTTP URL to open once the request is finished, canceled, or failed with the parameters tg_passport=success, tg_passport=cancel, or tg_passport=error&error=... respectively. If empty, then onActivityResult method must be used to return response on Android, or the link tgbot{bot_user_id}://passport/success or tgbot{bot_user_id}://passport/cancel must be opened otherwise
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypePassportDataRequest.tdCommon = tempObj.tdCommon
	internalLinkTypePassportDataRequest.BotUserID = tempObj.BotUserID
	internalLinkTypePassportDataRequest.Scope = tempObj.Scope
	internalLinkTypePassportDataRequest.PublicKey = tempObj.PublicKey
	internalLinkTypePassportDataRequest.Nonce = tempObj.Nonce
	internalLinkTypePassportDataRequest.CallbackURL = tempObj.CallbackURL

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypePassportDataRequest *InternalLinkTypePassportDataRequest) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypePassportDataRequestType
}

// InternalLinkTypePhoneNumberConfirmation The link can be used to confirm ownership of a phone number to prevent account deletion. Call sendPhoneNumberCode with the given phone number and with phoneNumberCodeTypeConfirmOwnership with the given hash to process the link. If succeeded, call checkPhoneNumberCode to check entered by the user code, or resendPhoneNumberCode to resend it
type InternalLinkTypePhoneNumberConfirmation struct {
	tdCommon
	Hash        string `json:"hash"`         // Hash value from the link
	PhoneNumber string `json:"phone_number"` // Phone number value from the link
}

// MessageType return the string telegram-type of InternalLinkTypePhoneNumberConfirmation
func (internalLinkTypePhoneNumberConfirmation *InternalLinkTypePhoneNumberConfirmation) MessageType() string {
	return "internalLinkTypePhoneNumberConfirmation"
}

// NewInternalLinkTypePhoneNumberConfirmation creates a new InternalLinkTypePhoneNumberConfirmation
//
// @param hash Hash value from the link
// @param phoneNumber Phone number value from the link
func NewInternalLinkTypePhoneNumberConfirmation(hash string, phoneNumber string) *InternalLinkTypePhoneNumberConfirmation {
	internalLinkTypePhoneNumberConfirmationTemp := InternalLinkTypePhoneNumberConfirmation{
		tdCommon:    tdCommon{Type: "internalLinkTypePhoneNumberConfirmation"},
		Hash:        hash,
		PhoneNumber: phoneNumber,
	}

	return &internalLinkTypePhoneNumberConfirmationTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypePhoneNumberConfirmation *InternalLinkTypePhoneNumberConfirmation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Hash        string `json:"hash"`         // Hash value from the link
		PhoneNumber string `json:"phone_number"` // Phone number value from the link
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypePhoneNumberConfirmation.tdCommon = tempObj.tdCommon
	internalLinkTypePhoneNumberConfirmation.Hash = tempObj.Hash
	internalLinkTypePhoneNumberConfirmation.PhoneNumber = tempObj.PhoneNumber

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypePhoneNumberConfirmation *InternalLinkTypePhoneNumberConfirmation) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypePhoneNumberConfirmationType
}

// InternalLinkTypePremiumFeatures The link is a link to the Premium features screen of the application from which the user can subscribe to Telegram Premium. Call getPremiumFeatures with the given referrer to process the link
type InternalLinkTypePremiumFeatures struct {
	tdCommon
	Referrer string `json:"referrer"` // Referrer specified in the link
}

// MessageType return the string telegram-type of InternalLinkTypePremiumFeatures
func (internalLinkTypePremiumFeatures *InternalLinkTypePremiumFeatures) MessageType() string {
	return "internalLinkTypePremiumFeatures"
}

// NewInternalLinkTypePremiumFeatures creates a new InternalLinkTypePremiumFeatures
//
// @param referrer Referrer specified in the link
func NewInternalLinkTypePremiumFeatures(referrer string) *InternalLinkTypePremiumFeatures {
	internalLinkTypePremiumFeaturesTemp := InternalLinkTypePremiumFeatures{
		tdCommon: tdCommon{Type: "internalLinkTypePremiumFeatures"},
		Referrer: referrer,
	}

	return &internalLinkTypePremiumFeaturesTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypePremiumFeatures *InternalLinkTypePremiumFeatures) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Referrer string `json:"referrer"` // Referrer specified in the link
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypePremiumFeatures.tdCommon = tempObj.tdCommon
	internalLinkTypePremiumFeatures.Referrer = tempObj.Referrer

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypePremiumFeatures *InternalLinkTypePremiumFeatures) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypePremiumFeaturesType
}

// InternalLinkTypePremiumGift The link is a link to the screen for gifting Telegram Premium subscriptions to friends via inputInvoiceTelegram payments or in-store purchases
type InternalLinkTypePremiumGift struct {
	tdCommon
	Referrer string `json:"referrer"` // Referrer specified in the link
}

// MessageType return the string telegram-type of InternalLinkTypePremiumGift
func (internalLinkTypePremiumGift *InternalLinkTypePremiumGift) MessageType() string {
	return "internalLinkTypePremiumGift"
}

// NewInternalLinkTypePremiumGift creates a new InternalLinkTypePremiumGift
//
// @param referrer Referrer specified in the link
func NewInternalLinkTypePremiumGift(referrer string) *InternalLinkTypePremiumGift {
	internalLinkTypePremiumGiftTemp := InternalLinkTypePremiumGift{
		tdCommon: tdCommon{Type: "internalLinkTypePremiumGift"},
		Referrer: referrer,
	}

	return &internalLinkTypePremiumGiftTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypePremiumGift *InternalLinkTypePremiumGift) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Referrer string `json:"referrer"` // Referrer specified in the link
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypePremiumGift.tdCommon = tempObj.tdCommon
	internalLinkTypePremiumGift.Referrer = tempObj.Referrer

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypePremiumGift *InternalLinkTypePremiumGift) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypePremiumGiftType
}

// InternalLinkTypePremiumGiftCode The link is a link with a Telegram Premium gift code. Call checkPremiumGiftCode with the given code to process the link. If the code is valid and the user wants to apply it, then call applyPremiumGiftCode
type InternalLinkTypePremiumGiftCode struct {
	tdCommon
	Code string `json:"code"` // The Telegram Premium gift code
}

// MessageType return the string telegram-type of InternalLinkTypePremiumGiftCode
func (internalLinkTypePremiumGiftCode *InternalLinkTypePremiumGiftCode) MessageType() string {
	return "internalLinkTypePremiumGiftCode"
}

// NewInternalLinkTypePremiumGiftCode creates a new InternalLinkTypePremiumGiftCode
//
// @param code The Telegram Premium gift code
func NewInternalLinkTypePremiumGiftCode(code string) *InternalLinkTypePremiumGiftCode {
	internalLinkTypePremiumGiftCodeTemp := InternalLinkTypePremiumGiftCode{
		tdCommon: tdCommon{Type: "internalLinkTypePremiumGiftCode"},
		Code:     code,
	}

	return &internalLinkTypePremiumGiftCodeTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypePremiumGiftCode *InternalLinkTypePremiumGiftCode) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Code string `json:"code"` // The Telegram Premium gift code
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypePremiumGiftCode.tdCommon = tempObj.tdCommon
	internalLinkTypePremiumGiftCode.Code = tempObj.Code

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypePremiumGiftCode *InternalLinkTypePremiumGiftCode) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypePremiumGiftCodeType
}

// InternalLinkTypePrivacyAndSecuritySettings The link is a link to the privacy and security section of the application settings
type InternalLinkTypePrivacyAndSecuritySettings struct {
	tdCommon
}

// MessageType return the string telegram-type of InternalLinkTypePrivacyAndSecuritySettings
func (internalLinkTypePrivacyAndSecuritySettings *InternalLinkTypePrivacyAndSecuritySettings) MessageType() string {
	return "internalLinkTypePrivacyAndSecuritySettings"
}

// NewInternalLinkTypePrivacyAndSecuritySettings creates a new InternalLinkTypePrivacyAndSecuritySettings
//
func NewInternalLinkTypePrivacyAndSecuritySettings() *InternalLinkTypePrivacyAndSecuritySettings {
	internalLinkTypePrivacyAndSecuritySettingsTemp := InternalLinkTypePrivacyAndSecuritySettings{
		tdCommon: tdCommon{Type: "internalLinkTypePrivacyAndSecuritySettings"},
	}

	return &internalLinkTypePrivacyAndSecuritySettingsTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypePrivacyAndSecuritySettings *InternalLinkTypePrivacyAndSecuritySettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypePrivacyAndSecuritySettings.tdCommon = tempObj.tdCommon

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypePrivacyAndSecuritySettings *InternalLinkTypePrivacyAndSecuritySettings) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypePrivacyAndSecuritySettingsType
}

// InternalLinkTypeProxy The link is a link to a proxy. Call addProxy with the given parameters to process the link and add the proxy
type InternalLinkTypeProxy struct {
	tdCommon
	Server string    `json:"server"` // Proxy server domain or IP address
	Port   int32     `json:"port"`   // Proxy server port
	Type   ProxyType `json:"type"`   // Type of the proxy
}

// MessageType return the string telegram-type of InternalLinkTypeProxy
func (internalLinkTypeProxy *InternalLinkTypeProxy) MessageType() string {
	return "internalLinkTypeProxy"
}

// NewInternalLinkTypeProxy creates a new InternalLinkTypeProxy
//
// @param server Proxy server domain or IP address
// @param port Proxy server port
// @param typeParam Type of the proxy
func NewInternalLinkTypeProxy(server string, port int32, typeParam ProxyType) *InternalLinkTypeProxy {
	internalLinkTypeProxyTemp := InternalLinkTypeProxy{
		tdCommon: tdCommon{Type: "internalLinkTypeProxy"},
		Server:   server,
		Port:     port,
		Type:     typeParam,
	}

	return &internalLinkTypeProxyTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeProxy *InternalLinkTypeProxy) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Server string `json:"server"` // Proxy server domain or IP address
		Port   int32  `json:"port"`   // Proxy server port

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeProxy.tdCommon = tempObj.tdCommon
	internalLinkTypeProxy.Server = tempObj.Server
	internalLinkTypeProxy.Port = tempObj.Port

	fieldType, _ := unmarshalProxyType(objMap["type"])
	internalLinkTypeProxy.Type = fieldType

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeProxy *InternalLinkTypeProxy) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeProxyType
}

// InternalLinkTypePublicChat The link is a link to a chat by its username. Call searchPublicChat with the given chat username to process the link If the chat is found, open its profile information screen or the chat itself. If draft text isn't empty and the chat is a private chat with a regular user, then put the draft text in the input field
type InternalLinkTypePublicChat struct {
	tdCommon
	ChatUsername string `json:"chat_username"` // Username of the chat
	DraftText    string `json:"draft_text"`    // Draft text for message to send in the chat
	OpenProfile  bool   `json:"open_profile"`  // True, if chat profile information screen must be opened; otherwise, the chat itself must be opened
}

// MessageType return the string telegram-type of InternalLinkTypePublicChat
func (internalLinkTypePublicChat *InternalLinkTypePublicChat) MessageType() string {
	return "internalLinkTypePublicChat"
}

// NewInternalLinkTypePublicChat creates a new InternalLinkTypePublicChat
//
// @param chatUsername Username of the chat
// @param draftText Draft text for message to send in the chat
// @param openProfile True, if chat profile information screen must be opened; otherwise, the chat itself must be opened
func NewInternalLinkTypePublicChat(chatUsername string, draftText string, openProfile bool) *InternalLinkTypePublicChat {
	internalLinkTypePublicChatTemp := InternalLinkTypePublicChat{
		tdCommon:     tdCommon{Type: "internalLinkTypePublicChat"},
		ChatUsername: chatUsername,
		DraftText:    draftText,
		OpenProfile:  openProfile,
	}

	return &internalLinkTypePublicChatTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypePublicChat *InternalLinkTypePublicChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatUsername string `json:"chat_username"` // Username of the chat
		DraftText    string `json:"draft_text"`    // Draft text for message to send in the chat
		OpenProfile  bool   `json:"open_profile"`  // True, if chat profile information screen must be opened; otherwise, the chat itself must be opened
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypePublicChat.tdCommon = tempObj.tdCommon
	internalLinkTypePublicChat.ChatUsername = tempObj.ChatUsername
	internalLinkTypePublicChat.DraftText = tempObj.DraftText
	internalLinkTypePublicChat.OpenProfile = tempObj.OpenProfile

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypePublicChat *InternalLinkTypePublicChat) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypePublicChatType
}

// InternalLinkTypeQrCodeAuthentication The link can be used to login the current user on another device, but it must be scanned from QR-code using in-app camera. An alert similar to "This code can be used to allow someone to log in to your Telegram account. To confirm Telegram login, please go to Settings > Devices > Scan QR and scan the code" needs to be shown
type InternalLinkTypeQrCodeAuthentication struct {
	tdCommon
}

// MessageType return the string telegram-type of InternalLinkTypeQrCodeAuthentication
func (internalLinkTypeQrCodeAuthentication *InternalLinkTypeQrCodeAuthentication) MessageType() string {
	return "internalLinkTypeQrCodeAuthentication"
}

// NewInternalLinkTypeQrCodeAuthentication creates a new InternalLinkTypeQrCodeAuthentication
//
func NewInternalLinkTypeQrCodeAuthentication() *InternalLinkTypeQrCodeAuthentication {
	internalLinkTypeQrCodeAuthenticationTemp := InternalLinkTypeQrCodeAuthentication{
		tdCommon: tdCommon{Type: "internalLinkTypeQrCodeAuthentication"},
	}

	return &internalLinkTypeQrCodeAuthenticationTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeQrCodeAuthentication *InternalLinkTypeQrCodeAuthentication) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeQrCodeAuthentication.tdCommon = tempObj.tdCommon

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeQrCodeAuthentication *InternalLinkTypeQrCodeAuthentication) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeQrCodeAuthenticationType
}

// InternalLinkTypeRestorePurchases The link forces restore of App Store purchases when opened. For official iOS application only
type InternalLinkTypeRestorePurchases struct {
	tdCommon
}

// MessageType return the string telegram-type of InternalLinkTypeRestorePurchases
func (internalLinkTypeRestorePurchases *InternalLinkTypeRestorePurchases) MessageType() string {
	return "internalLinkTypeRestorePurchases"
}

// NewInternalLinkTypeRestorePurchases creates a new InternalLinkTypeRestorePurchases
//
func NewInternalLinkTypeRestorePurchases() *InternalLinkTypeRestorePurchases {
	internalLinkTypeRestorePurchasesTemp := InternalLinkTypeRestorePurchases{
		tdCommon: tdCommon{Type: "internalLinkTypeRestorePurchases"},
	}

	return &internalLinkTypeRestorePurchasesTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeRestorePurchases *InternalLinkTypeRestorePurchases) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeRestorePurchases.tdCommon = tempObj.tdCommon

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeRestorePurchases *InternalLinkTypeRestorePurchases) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeRestorePurchasesType
}

// InternalLinkTypeSettings The link is a link to application settings
type InternalLinkTypeSettings struct {
	tdCommon
}

// MessageType return the string telegram-type of InternalLinkTypeSettings
func (internalLinkTypeSettings *InternalLinkTypeSettings) MessageType() string {
	return "internalLinkTypeSettings"
}

// NewInternalLinkTypeSettings creates a new InternalLinkTypeSettings
//
func NewInternalLinkTypeSettings() *InternalLinkTypeSettings {
	internalLinkTypeSettingsTemp := InternalLinkTypeSettings{
		tdCommon: tdCommon{Type: "internalLinkTypeSettings"},
	}

	return &internalLinkTypeSettingsTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeSettings *InternalLinkTypeSettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeSettings.tdCommon = tempObj.tdCommon

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeSettings *InternalLinkTypeSettings) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeSettingsType
}

// InternalLinkTypeStickerSet The link is a link to a sticker set. Call searchStickerSet with the given sticker set name to process the link and show the sticker set. If the sticker set is found and the user wants to add it, then call changeStickerSet
type InternalLinkTypeStickerSet struct {
	tdCommon
	StickerSetName    string `json:"sticker_set_name"`    // Name of the sticker set
	ExpectCustomEmoji bool   `json:"expect_custom_emoji"` // True, if the sticker set is expected to contain custom emoji
}

// MessageType return the string telegram-type of InternalLinkTypeStickerSet
func (internalLinkTypeStickerSet *InternalLinkTypeStickerSet) MessageType() string {
	return "internalLinkTypeStickerSet"
}

// NewInternalLinkTypeStickerSet creates a new InternalLinkTypeStickerSet
//
// @param stickerSetName Name of the sticker set
// @param expectCustomEmoji True, if the sticker set is expected to contain custom emoji
func NewInternalLinkTypeStickerSet(stickerSetName string, expectCustomEmoji bool) *InternalLinkTypeStickerSet {
	internalLinkTypeStickerSetTemp := InternalLinkTypeStickerSet{
		tdCommon:          tdCommon{Type: "internalLinkTypeStickerSet"},
		StickerSetName:    stickerSetName,
		ExpectCustomEmoji: expectCustomEmoji,
	}

	return &internalLinkTypeStickerSetTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeStickerSet *InternalLinkTypeStickerSet) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StickerSetName    string `json:"sticker_set_name"`    // Name of the sticker set
		ExpectCustomEmoji bool   `json:"expect_custom_emoji"` // True, if the sticker set is expected to contain custom emoji
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeStickerSet.tdCommon = tempObj.tdCommon
	internalLinkTypeStickerSet.StickerSetName = tempObj.StickerSetName
	internalLinkTypeStickerSet.ExpectCustomEmoji = tempObj.ExpectCustomEmoji

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeStickerSet *InternalLinkTypeStickerSet) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeStickerSetType
}

// InternalLinkTypeStory The link is a link to a story. Call searchPublicChat with the given sender username, then call getStory with the received chat identifier and the given story identifier, then show the story if received
type InternalLinkTypeStory struct {
	tdCommon
	StorySenderUsername string `json:"story_sender_username"` // Username of the sender of the story
	StoryID             int32  `json:"story_id"`              // Story identifier
}

// MessageType return the string telegram-type of InternalLinkTypeStory
func (internalLinkTypeStory *InternalLinkTypeStory) MessageType() string {
	return "internalLinkTypeStory"
}

// NewInternalLinkTypeStory creates a new InternalLinkTypeStory
//
// @param storySenderUsername Username of the sender of the story
// @param storyID Story identifier
func NewInternalLinkTypeStory(storySenderUsername string, storyID int32) *InternalLinkTypeStory {
	internalLinkTypeStoryTemp := InternalLinkTypeStory{
		tdCommon:            tdCommon{Type: "internalLinkTypeStory"},
		StorySenderUsername: storySenderUsername,
		StoryID:             storyID,
	}

	return &internalLinkTypeStoryTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeStory *InternalLinkTypeStory) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StorySenderUsername string `json:"story_sender_username"` // Username of the sender of the story
		StoryID             int32  `json:"story_id"`              // Story identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeStory.tdCommon = tempObj.tdCommon
	internalLinkTypeStory.StorySenderUsername = tempObj.StorySenderUsername
	internalLinkTypeStory.StoryID = tempObj.StoryID

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeStory *InternalLinkTypeStory) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeStoryType
}

// InternalLinkTypeTheme The link is a link to a cloud theme. TDLib has no theme support yet
type InternalLinkTypeTheme struct {
	tdCommon
	ThemeName string `json:"theme_name"` // Name of the theme
}

// MessageType return the string telegram-type of InternalLinkTypeTheme
func (internalLinkTypeTheme *InternalLinkTypeTheme) MessageType() string {
	return "internalLinkTypeTheme"
}

// NewInternalLinkTypeTheme creates a new InternalLinkTypeTheme
//
// @param themeName Name of the theme
func NewInternalLinkTypeTheme(themeName string) *InternalLinkTypeTheme {
	internalLinkTypeThemeTemp := InternalLinkTypeTheme{
		tdCommon:  tdCommon{Type: "internalLinkTypeTheme"},
		ThemeName: themeName,
	}

	return &internalLinkTypeThemeTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeTheme *InternalLinkTypeTheme) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ThemeName string `json:"theme_name"` // Name of the theme
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeTheme.tdCommon = tempObj.tdCommon
	internalLinkTypeTheme.ThemeName = tempObj.ThemeName

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeTheme *InternalLinkTypeTheme) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeThemeType
}

// InternalLinkTypeThemeSettings The link is a link to the theme section of the application settings
type InternalLinkTypeThemeSettings struct {
	tdCommon
}

// MessageType return the string telegram-type of InternalLinkTypeThemeSettings
func (internalLinkTypeThemeSettings *InternalLinkTypeThemeSettings) MessageType() string {
	return "internalLinkTypeThemeSettings"
}

// NewInternalLinkTypeThemeSettings creates a new InternalLinkTypeThemeSettings
//
func NewInternalLinkTypeThemeSettings() *InternalLinkTypeThemeSettings {
	internalLinkTypeThemeSettingsTemp := InternalLinkTypeThemeSettings{
		tdCommon: tdCommon{Type: "internalLinkTypeThemeSettings"},
	}

	return &internalLinkTypeThemeSettingsTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeThemeSettings *InternalLinkTypeThemeSettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeThemeSettings.tdCommon = tempObj.tdCommon

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeThemeSettings *InternalLinkTypeThemeSettings) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeThemeSettingsType
}

// InternalLinkTypeUnknownDeepLink The link is an unknown tg: link. Call getDeepLinkInfo to process the link
type InternalLinkTypeUnknownDeepLink struct {
	tdCommon
	Link string `json:"link"` // Link to be passed to getDeepLinkInfo
}

// MessageType return the string telegram-type of InternalLinkTypeUnknownDeepLink
func (internalLinkTypeUnknownDeepLink *InternalLinkTypeUnknownDeepLink) MessageType() string {
	return "internalLinkTypeUnknownDeepLink"
}

// NewInternalLinkTypeUnknownDeepLink creates a new InternalLinkTypeUnknownDeepLink
//
// @param link Link to be passed to getDeepLinkInfo
func NewInternalLinkTypeUnknownDeepLink(link string) *InternalLinkTypeUnknownDeepLink {
	internalLinkTypeUnknownDeepLinkTemp := InternalLinkTypeUnknownDeepLink{
		tdCommon: tdCommon{Type: "internalLinkTypeUnknownDeepLink"},
		Link:     link,
	}

	return &internalLinkTypeUnknownDeepLinkTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeUnknownDeepLink *InternalLinkTypeUnknownDeepLink) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Link string `json:"link"` // Link to be passed to getDeepLinkInfo
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeUnknownDeepLink.tdCommon = tempObj.tdCommon
	internalLinkTypeUnknownDeepLink.Link = tempObj.Link

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeUnknownDeepLink *InternalLinkTypeUnknownDeepLink) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeUnknownDeepLinkType
}

// InternalLinkTypeUnsupportedProxy The link is a link to an unsupported proxy. An alert can be shown to the user
type InternalLinkTypeUnsupportedProxy struct {
	tdCommon
}

// MessageType return the string telegram-type of InternalLinkTypeUnsupportedProxy
func (internalLinkTypeUnsupportedProxy *InternalLinkTypeUnsupportedProxy) MessageType() string {
	return "internalLinkTypeUnsupportedProxy"
}

// NewInternalLinkTypeUnsupportedProxy creates a new InternalLinkTypeUnsupportedProxy
//
func NewInternalLinkTypeUnsupportedProxy() *InternalLinkTypeUnsupportedProxy {
	internalLinkTypeUnsupportedProxyTemp := InternalLinkTypeUnsupportedProxy{
		tdCommon: tdCommon{Type: "internalLinkTypeUnsupportedProxy"},
	}

	return &internalLinkTypeUnsupportedProxyTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeUnsupportedProxy *InternalLinkTypeUnsupportedProxy) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeUnsupportedProxy.tdCommon = tempObj.tdCommon

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeUnsupportedProxy *InternalLinkTypeUnsupportedProxy) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeUnsupportedProxyType
}

// InternalLinkTypeUserPhoneNumber The link is a link to a user by its phone number. Call searchUserByPhoneNumber with the given phone number to process the link. If the user is found, then call createPrivateChat and open user's profile information screen or the chat itself. If draft text isn't empty, then put the draft text in the input field
type InternalLinkTypeUserPhoneNumber struct {
	tdCommon
	PhoneNumber string `json:"phone_number"` // Phone number of the user
	DraftText   string `json:"draft_text"`   // Draft text for message to send in the chat
	OpenProfile bool   `json:"open_profile"` // True, if user's profile information screen must be opened; otherwise, the chat itself must be opened
}

// MessageType return the string telegram-type of InternalLinkTypeUserPhoneNumber
func (internalLinkTypeUserPhoneNumber *InternalLinkTypeUserPhoneNumber) MessageType() string {
	return "internalLinkTypeUserPhoneNumber"
}

// NewInternalLinkTypeUserPhoneNumber creates a new InternalLinkTypeUserPhoneNumber
//
// @param phoneNumber Phone number of the user
// @param draftText Draft text for message to send in the chat
// @param openProfile True, if user's profile information screen must be opened; otherwise, the chat itself must be opened
func NewInternalLinkTypeUserPhoneNumber(phoneNumber string, draftText string, openProfile bool) *InternalLinkTypeUserPhoneNumber {
	internalLinkTypeUserPhoneNumberTemp := InternalLinkTypeUserPhoneNumber{
		tdCommon:    tdCommon{Type: "internalLinkTypeUserPhoneNumber"},
		PhoneNumber: phoneNumber,
		DraftText:   draftText,
		OpenProfile: openProfile,
	}

	return &internalLinkTypeUserPhoneNumberTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeUserPhoneNumber *InternalLinkTypeUserPhoneNumber) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PhoneNumber string `json:"phone_number"` // Phone number of the user
		DraftText   string `json:"draft_text"`   // Draft text for message to send in the chat
		OpenProfile bool   `json:"open_profile"` // True, if user's profile information screen must be opened; otherwise, the chat itself must be opened
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeUserPhoneNumber.tdCommon = tempObj.tdCommon
	internalLinkTypeUserPhoneNumber.PhoneNumber = tempObj.PhoneNumber
	internalLinkTypeUserPhoneNumber.DraftText = tempObj.DraftText
	internalLinkTypeUserPhoneNumber.OpenProfile = tempObj.OpenProfile

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeUserPhoneNumber *InternalLinkTypeUserPhoneNumber) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeUserPhoneNumberType
}

// InternalLinkTypeUserToken The link is a link to a user by a temporary token. Call searchUserByToken with the given token to process the link. If the user is found, then call createPrivateChat and open the chat
type InternalLinkTypeUserToken struct {
	tdCommon
	Token string `json:"token"` // The token
}

// MessageType return the string telegram-type of InternalLinkTypeUserToken
func (internalLinkTypeUserToken *InternalLinkTypeUserToken) MessageType() string {
	return "internalLinkTypeUserToken"
}

// NewInternalLinkTypeUserToken creates a new InternalLinkTypeUserToken
//
// @param token The token
func NewInternalLinkTypeUserToken(token string) *InternalLinkTypeUserToken {
	internalLinkTypeUserTokenTemp := InternalLinkTypeUserToken{
		tdCommon: tdCommon{Type: "internalLinkTypeUserToken"},
		Token:    token,
	}

	return &internalLinkTypeUserTokenTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeUserToken *InternalLinkTypeUserToken) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Token string `json:"token"` // The token
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeUserToken.tdCommon = tempObj.tdCommon
	internalLinkTypeUserToken.Token = tempObj.Token

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeUserToken *InternalLinkTypeUserToken) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeUserTokenType
}

// InternalLinkTypeVideoChat The link is a link to a video chat. Call searchPublicChat with the given chat username, and then joinGroupCall with the given invite hash to process the link
type InternalLinkTypeVideoChat struct {
	tdCommon
	ChatUsername string `json:"chat_username"`  // Username of the chat with the video chat
	InviteHash   string `json:"invite_hash"`    // If non-empty, invite hash to be used to join the video chat without being muted by administrators
	IsLiveStream bool   `json:"is_live_stream"` // True, if the video chat is expected to be a live stream in a channel or a broadcast group
}

// MessageType return the string telegram-type of InternalLinkTypeVideoChat
func (internalLinkTypeVideoChat *InternalLinkTypeVideoChat) MessageType() string {
	return "internalLinkTypeVideoChat"
}

// NewInternalLinkTypeVideoChat creates a new InternalLinkTypeVideoChat
//
// @param chatUsername Username of the chat with the video chat
// @param inviteHash If non-empty, invite hash to be used to join the video chat without being muted by administrators
// @param isLiveStream True, if the video chat is expected to be a live stream in a channel or a broadcast group
func NewInternalLinkTypeVideoChat(chatUsername string, inviteHash string, isLiveStream bool) *InternalLinkTypeVideoChat {
	internalLinkTypeVideoChatTemp := InternalLinkTypeVideoChat{
		tdCommon:     tdCommon{Type: "internalLinkTypeVideoChat"},
		ChatUsername: chatUsername,
		InviteHash:   inviteHash,
		IsLiveStream: isLiveStream,
	}

	return &internalLinkTypeVideoChatTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeVideoChat *InternalLinkTypeVideoChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatUsername string `json:"chat_username"`  // Username of the chat with the video chat
		InviteHash   string `json:"invite_hash"`    // If non-empty, invite hash to be used to join the video chat without being muted by administrators
		IsLiveStream bool   `json:"is_live_stream"` // True, if the video chat is expected to be a live stream in a channel or a broadcast group
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeVideoChat.tdCommon = tempObj.tdCommon
	internalLinkTypeVideoChat.ChatUsername = tempObj.ChatUsername
	internalLinkTypeVideoChat.InviteHash = tempObj.InviteHash
	internalLinkTypeVideoChat.IsLiveStream = tempObj.IsLiveStream

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeVideoChat *InternalLinkTypeVideoChat) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeVideoChatType
}

// InternalLinkTypeWebApp The link is a link to a Web App. Call searchPublicChat with the given bot username, check that the user is a bot, then call searchWebApp with the received bot and the given web_app_short_name. Process received foundWebApp by showing a confirmation dialog if needed. If the bot can be added to attachment or side menu, but isn't added yet, then show a disclaimer about Mini Apps being third-party applications instead of the dialog and ask the user to accept their Terms of service. If the user accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu to add the bot. Then, call getWebAppLinkUrl and open the returned URL as a Web App
type InternalLinkTypeWebApp struct {
	tdCommon
	BotUsername     string `json:"bot_username"`       // Username of the bot that owns the Web App
	WebAppShortName string `json:"web_app_short_name"` // Short name of the Web App
	StartParameter  string `json:"start_parameter"`    // Start parameter to be passed to getWebAppLinkUrl
	IsCompact       bool   `json:"is_compact"`         // True, if the Web App must be opened in the compact mode instead of the full-size mode
}

// MessageType return the string telegram-type of InternalLinkTypeWebApp
func (internalLinkTypeWebApp *InternalLinkTypeWebApp) MessageType() string {
	return "internalLinkTypeWebApp"
}

// NewInternalLinkTypeWebApp creates a new InternalLinkTypeWebApp
//
// @param botUsername Username of the bot that owns the Web App
// @param webAppShortName Short name of the Web App
// @param startParameter Start parameter to be passed to getWebAppLinkUrl
// @param isCompact True, if the Web App must be opened in the compact mode instead of the full-size mode
func NewInternalLinkTypeWebApp(botUsername string, webAppShortName string, startParameter string, isCompact bool) *InternalLinkTypeWebApp {
	internalLinkTypeWebAppTemp := InternalLinkTypeWebApp{
		tdCommon:        tdCommon{Type: "internalLinkTypeWebApp"},
		BotUsername:     botUsername,
		WebAppShortName: webAppShortName,
		StartParameter:  startParameter,
		IsCompact:       isCompact,
	}

	return &internalLinkTypeWebAppTemp
}

// UnmarshalJSON unmarshal to json
func (internalLinkTypeWebApp *InternalLinkTypeWebApp) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BotUsername     string `json:"bot_username"`       // Username of the bot that owns the Web App
		WebAppShortName string `json:"web_app_short_name"` // Short name of the Web App
		StartParameter  string `json:"start_parameter"`    // Start parameter to be passed to getWebAppLinkUrl
		IsCompact       bool   `json:"is_compact"`         // True, if the Web App must be opened in the compact mode instead of the full-size mode
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	internalLinkTypeWebApp.tdCommon = tempObj.tdCommon
	internalLinkTypeWebApp.BotUsername = tempObj.BotUsername
	internalLinkTypeWebApp.WebAppShortName = tempObj.WebAppShortName
	internalLinkTypeWebApp.StartParameter = tempObj.StartParameter
	internalLinkTypeWebApp.IsCompact = tempObj.IsCompact

	return nil
}

// GetInternalLinkTypeEnum return the enum type of this object
func (internalLinkTypeWebApp *InternalLinkTypeWebApp) GetInternalLinkTypeEnum() InternalLinkTypeEnum {
	return InternalLinkTypeWebAppType
}

// MessageLink Contains an HTTPS link to a message in a supergroup or channel, or a forum topic
type MessageLink struct {
	tdCommon
	Link     string `json:"link"`      // The link
	IsPublic bool   `json:"is_public"` // True, if the link will work for non-members of the chat
}

// MessageType return the string telegram-type of MessageLink
func (messageLink *MessageLink) MessageType() string {
	return "messageLink"
}

// NewMessageLink creates a new MessageLink
//
// @param link The link
// @param isPublic True, if the link will work for non-members of the chat
func NewMessageLink(link string, isPublic bool) *MessageLink {
	messageLinkTemp := MessageLink{
		tdCommon: tdCommon{Type: "messageLink"},
		Link:     link,
		IsPublic: isPublic,
	}

	return &messageLinkTemp
}

// UnmarshalJSON unmarshal to json
func (messageLink *MessageLink) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Link     string `json:"link"`      // The link
		IsPublic bool   `json:"is_public"` // True, if the link will work for non-members of the chat
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageLink.tdCommon = tempObj.tdCommon
	messageLink.Link = tempObj.Link
	messageLink.IsPublic = tempObj.IsPublic

	return nil
}

// MessageLinkInfo Contains information about a link to a message or a forum topic in a chat
type MessageLinkInfo struct {
	tdCommon
	IsPublic        bool     `json:"is_public"`         // True, if the link is a public link for a message or a forum topic in a chat
	ChatID          int64    `json:"chat_id"`           // If found, identifier of the chat to which the link points, 0 otherwise
	MessageThreadID int64    `json:"message_thread_id"` // If found, identifier of the message thread in which to open the message, or a forum topic to open if the message is missing
	Message         *Message `json:"message"`           // If found, the linked message; may be null
	MediaTimestamp  int32    `json:"media_timestamp"`   // Timestamp from which the video/audio/video note/voice note/story playing must start, in seconds; 0 if not specified. The media can be in the message content or in its link preview
	ForAlbum        bool     `json:"for_album"`         // True, if the whole media album to which the message belongs is linked
}

// MessageType return the string telegram-type of MessageLinkInfo
func (messageLinkInfo *MessageLinkInfo) MessageType() string {
	return "messageLinkInfo"
}

// NewMessageLinkInfo creates a new MessageLinkInfo
//
// @param isPublic True, if the link is a public link for a message or a forum topic in a chat
// @param chatID If found, identifier of the chat to which the link points, 0 otherwise
// @param messageThreadID If found, identifier of the message thread in which to open the message, or a forum topic to open if the message is missing
// @param message If found, the linked message; may be null
// @param mediaTimestamp Timestamp from which the video/audio/video note/voice note/story playing must start, in seconds; 0 if not specified. The media can be in the message content or in its link preview
// @param forAlbum True, if the whole media album to which the message belongs is linked
func NewMessageLinkInfo(isPublic bool, chatID int64, messageThreadID int64, message *Message, mediaTimestamp int32, forAlbum bool) *MessageLinkInfo {
	messageLinkInfoTemp := MessageLinkInfo{
		tdCommon:        tdCommon{Type: "messageLinkInfo"},
		IsPublic:        isPublic,
		ChatID:          chatID,
		MessageThreadID: messageThreadID,
		Message:         message,
		MediaTimestamp:  mediaTimestamp,
		ForAlbum:        forAlbum,
	}

	return &messageLinkInfoTemp
}

// UnmarshalJSON unmarshal to json
func (messageLinkInfo *MessageLinkInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsPublic        bool  `json:"is_public"`         // True, if the link is a public link for a message or a forum topic in a chat
		ChatID          int64 `json:"chat_id"`           // If found, identifier of the chat to which the link points, 0 otherwise
		MessageThreadID int64 `json:"message_thread_id"` // If found, identifier of the message thread in which to open the message, or a forum topic to open if the message is missing
		MediaTimestamp  int32 `json:"media_timestamp"`   // Timestamp from which the video/audio/video note/voice note/story playing must start, in seconds; 0 if not specified. The media can be in the message content or in its link preview
		ForAlbum        bool  `json:"for_album"`         // True, if the whole media album to which the message belongs is linked
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageLinkInfo.tdCommon = tempObj.tdCommon
	messageLinkInfo.IsPublic = tempObj.IsPublic
	messageLinkInfo.ChatID = tempObj.ChatID
	messageLinkInfo.MessageThreadID = tempObj.MessageThreadID
	messageLinkInfo.MediaTimestamp = tempObj.MediaTimestamp
	messageLinkInfo.ForAlbum = tempObj.ForAlbum

	var message Message
	if objMap["message"] != nil {
		err = message.UnmarshalJSON(*objMap["message"])
		if err != nil {
			return err
		}
	}

	messageLinkInfo.Message = &message

	return nil
}

// ChatBoostLink Contains an HTTPS link to boost a chat
type ChatBoostLink struct {
	tdCommon
	Link     string `json:"link"`      // The link
	IsPublic bool   `json:"is_public"` // True, if the link will work for non-members of the chat
}

// MessageType return the string telegram-type of ChatBoostLink
func (chatBoostLink *ChatBoostLink) MessageType() string {
	return "chatBoostLink"
}

// NewChatBoostLink creates a new ChatBoostLink
//
// @param link The link
// @param isPublic True, if the link will work for non-members of the chat
func NewChatBoostLink(link string, isPublic bool) *ChatBoostLink {
	chatBoostLinkTemp := ChatBoostLink{
		tdCommon: tdCommon{Type: "chatBoostLink"},
		Link:     link,
		IsPublic: isPublic,
	}

	return &chatBoostLinkTemp
}

// UnmarshalJSON unmarshal to json
func (chatBoostLink *ChatBoostLink) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Link     string `json:"link"`      // The link
		IsPublic bool   `json:"is_public"` // True, if the link will work for non-members of the chat
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatBoostLink.tdCommon = tempObj.tdCommon
	chatBoostLink.Link = tempObj.Link
	chatBoostLink.IsPublic = tempObj.IsPublic

	return nil
}

// ChatBoostLinkInfo Contains information about a link to boost a chat
type ChatBoostLinkInfo struct {
	tdCommon
	IsPublic bool  `json:"is_public"` // True, if the link will work for non-members of the chat
	ChatID   int64 `json:"chat_id"`   // Identifier of the chat to which the link points; 0 if the chat isn't found
}

// MessageType return the string telegram-type of ChatBoostLinkInfo
func (chatBoostLinkInfo *ChatBoostLinkInfo) MessageType() string {
	return "chatBoostLinkInfo"
}

// NewChatBoostLinkInfo creates a new ChatBoostLinkInfo
//
// @param isPublic True, if the link will work for non-members of the chat
// @param chatID Identifier of the chat to which the link points; 0 if the chat isn't found
func NewChatBoostLinkInfo(isPublic bool, chatID int64) *ChatBoostLinkInfo {
	chatBoostLinkInfoTemp := ChatBoostLinkInfo{
		tdCommon: tdCommon{Type: "chatBoostLinkInfo"},
		IsPublic: isPublic,
		ChatID:   chatID,
	}

	return &chatBoostLinkInfoTemp
}

// UnmarshalJSON unmarshal to json
func (chatBoostLinkInfo *ChatBoostLinkInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsPublic bool  `json:"is_public"` // True, if the link will work for non-members of the chat
		ChatID   int64 `json:"chat_id"`   // Identifier of the chat to which the link points; 0 if the chat isn't found
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatBoostLinkInfo.tdCommon = tempObj.tdCommon
	chatBoostLinkInfo.IsPublic = tempObj.IsPublic
	chatBoostLinkInfo.ChatID = tempObj.ChatID

	return nil
}

// BlockListMain The main block list that disallows writing messages to the current user, receiving their status and photo, viewing of stories, and some other actions
type BlockListMain struct {
	tdCommon
}

// MessageType return the string telegram-type of BlockListMain
func (blockListMain *BlockListMain) MessageType() string {
	return "blockListMain"
}

// NewBlockListMain creates a new BlockListMain
//
func NewBlockListMain() *BlockListMain {
	blockListMainTemp := BlockListMain{
		tdCommon: tdCommon{Type: "blockListMain"},
	}

	return &blockListMainTemp
}

// UnmarshalJSON unmarshal to json
func (blockListMain *BlockListMain) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	blockListMain.tdCommon = tempObj.tdCommon

	return nil
}

// GetBlockListEnum return the enum type of this object
func (blockListMain *BlockListMain) GetBlockListEnum() BlockListEnum {
	return BlockListMainType
}

// BlockListStories The block list that disallows viewing of stories of the current user
type BlockListStories struct {
	tdCommon
}

// MessageType return the string telegram-type of BlockListStories
func (blockListStories *BlockListStories) MessageType() string {
	return "blockListStories"
}

// NewBlockListStories creates a new BlockListStories
//
func NewBlockListStories() *BlockListStories {
	blockListStoriesTemp := BlockListStories{
		tdCommon: tdCommon{Type: "blockListStories"},
	}

	return &blockListStoriesTemp
}

// UnmarshalJSON unmarshal to json
func (blockListStories *BlockListStories) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	blockListStories.tdCommon = tempObj.tdCommon

	return nil
}

// GetBlockListEnum return the enum type of this object
func (blockListStories *BlockListStories) GetBlockListEnum() BlockListEnum {
	return BlockListStoriesType
}

// FilePart Contains a part of a file
type FilePart struct {
	tdCommon
	Data []byte `json:"data"` // File bytes
}

// MessageType return the string telegram-type of FilePart
func (filePart *FilePart) MessageType() string {
	return "filePart"
}

// NewFilePart creates a new FilePart
//
// @param data File bytes
func NewFilePart(data []byte) *FilePart {
	filePartTemp := FilePart{
		tdCommon: tdCommon{Type: "filePart"},
		Data:     data,
	}

	return &filePartTemp
}

// UnmarshalJSON unmarshal to json
func (filePart *FilePart) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Data []byte `json:"data"` // File bytes
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	filePart.tdCommon = tempObj.tdCommon
	filePart.Data = tempObj.Data

	return nil
}

// FileTypeNone The data is not a file
type FileTypeNone struct {
	tdCommon
}

// MessageType return the string telegram-type of FileTypeNone
func (fileTypeNone *FileTypeNone) MessageType() string {
	return "fileTypeNone"
}

// NewFileTypeNone creates a new FileTypeNone
//
func NewFileTypeNone() *FileTypeNone {
	fileTypeNoneTemp := FileTypeNone{
		tdCommon: tdCommon{Type: "fileTypeNone"},
	}

	return &fileTypeNoneTemp
}

// UnmarshalJSON unmarshal to json
func (fileTypeNone *FileTypeNone) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	fileTypeNone.tdCommon = tempObj.tdCommon

	return nil
}

// GetFileTypeEnum return the enum type of this object
func (fileTypeNone *FileTypeNone) GetFileTypeEnum() FileTypeEnum {
	return FileTypeNoneType
}

// FileTypeAnimation The file is an animation
type FileTypeAnimation struct {
	tdCommon
}

// MessageType return the string telegram-type of FileTypeAnimation
func (fileTypeAnimation *FileTypeAnimation) MessageType() string {
	return "fileTypeAnimation"
}

// NewFileTypeAnimation creates a new FileTypeAnimation
//
func NewFileTypeAnimation() *FileTypeAnimation {
	fileTypeAnimationTemp := FileTypeAnimation{
		tdCommon: tdCommon{Type: "fileTypeAnimation"},
	}

	return &fileTypeAnimationTemp
}

// UnmarshalJSON unmarshal to json
func (fileTypeAnimation *FileTypeAnimation) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	fileTypeAnimation.tdCommon = tempObj.tdCommon

	return nil
}

// GetFileTypeEnum return the enum type of this object
func (fileTypeAnimation *FileTypeAnimation) GetFileTypeEnum() FileTypeEnum {
	return FileTypeAnimationType
}

// FileTypeAudio The file is an audio file
type FileTypeAudio struct {
	tdCommon
}

// MessageType return the string telegram-type of FileTypeAudio
func (fileTypeAudio *FileTypeAudio) MessageType() string {
	return "fileTypeAudio"
}

// NewFileTypeAudio creates a new FileTypeAudio
//
func NewFileTypeAudio() *FileTypeAudio {
	fileTypeAudioTemp := FileTypeAudio{
		tdCommon: tdCommon{Type: "fileTypeAudio"},
	}

	return &fileTypeAudioTemp
}

// UnmarshalJSON unmarshal to json
func (fileTypeAudio *FileTypeAudio) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	fileTypeAudio.tdCommon = tempObj.tdCommon

	return nil
}

// GetFileTypeEnum return the enum type of this object
func (fileTypeAudio *FileTypeAudio) GetFileTypeEnum() FileTypeEnum {
	return FileTypeAudioType
}

// FileTypeDocument The file is a document
type FileTypeDocument struct {
	tdCommon
}

// MessageType return the string telegram-type of FileTypeDocument
func (fileTypeDocument *FileTypeDocument) MessageType() string {
	return "fileTypeDocument"
}

// NewFileTypeDocument creates a new FileTypeDocument
//
func NewFileTypeDocument() *FileTypeDocument {
	fileTypeDocumentTemp := FileTypeDocument{
		tdCommon: tdCommon{Type: "fileTypeDocument"},
	}

	return &fileTypeDocumentTemp
}

// UnmarshalJSON unmarshal to json
func (fileTypeDocument *FileTypeDocument) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	fileTypeDocument.tdCommon = tempObj.tdCommon

	return nil
}

// GetFileTypeEnum return the enum type of this object
func (fileTypeDocument *FileTypeDocument) GetFileTypeEnum() FileTypeEnum {
	return FileTypeDocumentType
}

// FileTypeNotificationSound The file is a notification sound
type FileTypeNotificationSound struct {
	tdCommon
}

// MessageType return the string telegram-type of FileTypeNotificationSound
func (fileTypeNotificationSound *FileTypeNotificationSound) MessageType() string {
	return "fileTypeNotificationSound"
}

// NewFileTypeNotificationSound creates a new FileTypeNotificationSound
//
func NewFileTypeNotificationSound() *FileTypeNotificationSound {
	fileTypeNotificationSoundTemp := FileTypeNotificationSound{
		tdCommon: tdCommon{Type: "fileTypeNotificationSound"},
	}

	return &fileTypeNotificationSoundTemp
}

// UnmarshalJSON unmarshal to json
func (fileTypeNotificationSound *FileTypeNotificationSound) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	fileTypeNotificationSound.tdCommon = tempObj.tdCommon

	return nil
}

// GetFileTypeEnum return the enum type of this object
func (fileTypeNotificationSound *FileTypeNotificationSound) GetFileTypeEnum() FileTypeEnum {
	return FileTypeNotificationSoundType
}

// FileTypePhoto The file is a photo
type FileTypePhoto struct {
	tdCommon
}

// MessageType return the string telegram-type of FileTypePhoto
func (fileTypePhoto *FileTypePhoto) MessageType() string {
	return "fileTypePhoto"
}

// NewFileTypePhoto creates a new FileTypePhoto
//
func NewFileTypePhoto() *FileTypePhoto {
	fileTypePhotoTemp := FileTypePhoto{
		tdCommon: tdCommon{Type: "fileTypePhoto"},
	}

	return &fileTypePhotoTemp
}

// UnmarshalJSON unmarshal to json
func (fileTypePhoto *FileTypePhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	fileTypePhoto.tdCommon = tempObj.tdCommon

	return nil
}

// GetFileTypeEnum return the enum type of this object
func (fileTypePhoto *FileTypePhoto) GetFileTypeEnum() FileTypeEnum {
	return FileTypePhotoType
}

// FileTypePhotoStory The file is a photo published as a story
type FileTypePhotoStory struct {
	tdCommon
}

// MessageType return the string telegram-type of FileTypePhotoStory
func (fileTypePhotoStory *FileTypePhotoStory) MessageType() string {
	return "fileTypePhotoStory"
}

// NewFileTypePhotoStory creates a new FileTypePhotoStory
//
func NewFileTypePhotoStory() *FileTypePhotoStory {
	fileTypePhotoStoryTemp := FileTypePhotoStory{
		tdCommon: tdCommon{Type: "fileTypePhotoStory"},
	}

	return &fileTypePhotoStoryTemp
}

// UnmarshalJSON unmarshal to json
func (fileTypePhotoStory *FileTypePhotoStory) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	fileTypePhotoStory.tdCommon = tempObj.tdCommon

	return nil
}

// GetFileTypeEnum return the enum type of this object
func (fileTypePhotoStory *FileTypePhotoStory) GetFileTypeEnum() FileTypeEnum {
	return FileTypePhotoStoryType
}

// FileTypeProfilePhoto The file is a profile photo
type FileTypeProfilePhoto struct {
	tdCommon
}

// MessageType return the string telegram-type of FileTypeProfilePhoto
func (fileTypeProfilePhoto *FileTypeProfilePhoto) MessageType() string {
	return "fileTypeProfilePhoto"
}

// NewFileTypeProfilePhoto creates a new FileTypeProfilePhoto
//
func NewFileTypeProfilePhoto() *FileTypeProfilePhoto {
	fileTypeProfilePhotoTemp := FileTypeProfilePhoto{
		tdCommon: tdCommon{Type: "fileTypeProfilePhoto"},
	}

	return &fileTypeProfilePhotoTemp
}

// UnmarshalJSON unmarshal to json
func (fileTypeProfilePhoto *FileTypeProfilePhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	fileTypeProfilePhoto.tdCommon = tempObj.tdCommon

	return nil
}

// GetFileTypeEnum return the enum type of this object
func (fileTypeProfilePhoto *FileTypeProfilePhoto) GetFileTypeEnum() FileTypeEnum {
	return FileTypeProfilePhotoType
}

// FileTypeSecret The file was sent to a secret chat (the file type is not known to the server)
type FileTypeSecret struct {
	tdCommon
}

// MessageType return the string telegram-type of FileTypeSecret
func (fileTypeSecret *FileTypeSecret) MessageType() string {
	return "fileTypeSecret"
}

// NewFileTypeSecret creates a new FileTypeSecret
//
func NewFileTypeSecret() *FileTypeSecret {
	fileTypeSecretTemp := FileTypeSecret{
		tdCommon: tdCommon{Type: "fileTypeSecret"},
	}

	return &fileTypeSecretTemp
}

// UnmarshalJSON unmarshal to json
func (fileTypeSecret *FileTypeSecret) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	fileTypeSecret.tdCommon = tempObj.tdCommon

	return nil
}

// GetFileTypeEnum return the enum type of this object
func (fileTypeSecret *FileTypeSecret) GetFileTypeEnum() FileTypeEnum {
	return FileTypeSecretType
}

// FileTypeSecretThumbnail The file is a thumbnail of a file from a secret chat
type FileTypeSecretThumbnail struct {
	tdCommon
}

// MessageType return the string telegram-type of FileTypeSecretThumbnail
func (fileTypeSecretThumbnail *FileTypeSecretThumbnail) MessageType() string {
	return "fileTypeSecretThumbnail"
}

// NewFileTypeSecretThumbnail creates a new FileTypeSecretThumbnail
//
func NewFileTypeSecretThumbnail() *FileTypeSecretThumbnail {
	fileTypeSecretThumbnailTemp := FileTypeSecretThumbnail{
		tdCommon: tdCommon{Type: "fileTypeSecretThumbnail"},
	}

	return &fileTypeSecretThumbnailTemp
}

// UnmarshalJSON unmarshal to json
func (fileTypeSecretThumbnail *FileTypeSecretThumbnail) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	fileTypeSecretThumbnail.tdCommon = tempObj.tdCommon

	return nil
}

// GetFileTypeEnum return the enum type of this object
func (fileTypeSecretThumbnail *FileTypeSecretThumbnail) GetFileTypeEnum() FileTypeEnum {
	return FileTypeSecretThumbnailType
}

// FileTypeSecure The file is a file from Secure storage used for storing Telegram Passport files
type FileTypeSecure struct {
	tdCommon
}

// MessageType return the string telegram-type of FileTypeSecure
func (fileTypeSecure *FileTypeSecure) MessageType() string {
	return "fileTypeSecure"
}

// NewFileTypeSecure creates a new FileTypeSecure
//
func NewFileTypeSecure() *FileTypeSecure {
	fileTypeSecureTemp := FileTypeSecure{
		tdCommon: tdCommon{Type: "fileTypeSecure"},
	}

	return &fileTypeSecureTemp
}

// UnmarshalJSON unmarshal to json
func (fileTypeSecure *FileTypeSecure) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	fileTypeSecure.tdCommon = tempObj.tdCommon

	return nil
}

// GetFileTypeEnum return the enum type of this object
func (fileTypeSecure *FileTypeSecure) GetFileTypeEnum() FileTypeEnum {
	return FileTypeSecureType
}

// FileTypeSticker The file is a sticker
type FileTypeSticker struct {
	tdCommon
}

// MessageType return the string telegram-type of FileTypeSticker
func (fileTypeSticker *FileTypeSticker) MessageType() string {
	return "fileTypeSticker"
}

// NewFileTypeSticker creates a new FileTypeSticker
//
func NewFileTypeSticker() *FileTypeSticker {
	fileTypeStickerTemp := FileTypeSticker{
		tdCommon: tdCommon{Type: "fileTypeSticker"},
	}

	return &fileTypeStickerTemp
}

// UnmarshalJSON unmarshal to json
func (fileTypeSticker *FileTypeSticker) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	fileTypeSticker.tdCommon = tempObj.tdCommon

	return nil
}

// GetFileTypeEnum return the enum type of this object
func (fileTypeSticker *FileTypeSticker) GetFileTypeEnum() FileTypeEnum {
	return FileTypeStickerType
}

// FileTypeThumbnail The file is a thumbnail of another file
type FileTypeThumbnail struct {
	tdCommon
}

// MessageType return the string telegram-type of FileTypeThumbnail
func (fileTypeThumbnail *FileTypeThumbnail) MessageType() string {
	return "fileTypeThumbnail"
}

// NewFileTypeThumbnail creates a new FileTypeThumbnail
//
func NewFileTypeThumbnail() *FileTypeThumbnail {
	fileTypeThumbnailTemp := FileTypeThumbnail{
		tdCommon: tdCommon{Type: "fileTypeThumbnail"},
	}

	return &fileTypeThumbnailTemp
}

// UnmarshalJSON unmarshal to json
func (fileTypeThumbnail *FileTypeThumbnail) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	fileTypeThumbnail.tdCommon = tempObj.tdCommon

	return nil
}

// GetFileTypeEnum return the enum type of this object
func (fileTypeThumbnail *FileTypeThumbnail) GetFileTypeEnum() FileTypeEnum {
	return FileTypeThumbnailType
}

// FileTypeUnknown The file type is not yet known
type FileTypeUnknown struct {
	tdCommon
}

// MessageType return the string telegram-type of FileTypeUnknown
func (fileTypeUnknown *FileTypeUnknown) MessageType() string {
	return "fileTypeUnknown"
}

// NewFileTypeUnknown creates a new FileTypeUnknown
//
func NewFileTypeUnknown() *FileTypeUnknown {
	fileTypeUnknownTemp := FileTypeUnknown{
		tdCommon: tdCommon{Type: "fileTypeUnknown"},
	}

	return &fileTypeUnknownTemp
}

// UnmarshalJSON unmarshal to json
func (fileTypeUnknown *FileTypeUnknown) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	fileTypeUnknown.tdCommon = tempObj.tdCommon

	return nil
}

// GetFileTypeEnum return the enum type of this object
func (fileTypeUnknown *FileTypeUnknown) GetFileTypeEnum() FileTypeEnum {
	return FileTypeUnknownType
}

// FileTypeVideo The file is a video
type FileTypeVideo struct {
	tdCommon
}

// MessageType return the string telegram-type of FileTypeVideo
func (fileTypeVideo *FileTypeVideo) MessageType() string {
	return "fileTypeVideo"
}

// NewFileTypeVideo creates a new FileTypeVideo
//
func NewFileTypeVideo() *FileTypeVideo {
	fileTypeVideoTemp := FileTypeVideo{
		tdCommon: tdCommon{Type: "fileTypeVideo"},
	}

	return &fileTypeVideoTemp
}

// UnmarshalJSON unmarshal to json
func (fileTypeVideo *FileTypeVideo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	fileTypeVideo.tdCommon = tempObj.tdCommon

	return nil
}

// GetFileTypeEnum return the enum type of this object
func (fileTypeVideo *FileTypeVideo) GetFileTypeEnum() FileTypeEnum {
	return FileTypeVideoType
}

// FileTypeVideoNote The file is a video note
type FileTypeVideoNote struct {
	tdCommon
}

// MessageType return the string telegram-type of FileTypeVideoNote
func (fileTypeVideoNote *FileTypeVideoNote) MessageType() string {
	return "fileTypeVideoNote"
}

// NewFileTypeVideoNote creates a new FileTypeVideoNote
//
func NewFileTypeVideoNote() *FileTypeVideoNote {
	fileTypeVideoNoteTemp := FileTypeVideoNote{
		tdCommon: tdCommon{Type: "fileTypeVideoNote"},
	}

	return &fileTypeVideoNoteTemp
}

// UnmarshalJSON unmarshal to json
func (fileTypeVideoNote *FileTypeVideoNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	fileTypeVideoNote.tdCommon = tempObj.tdCommon

	return nil
}

// GetFileTypeEnum return the enum type of this object
func (fileTypeVideoNote *FileTypeVideoNote) GetFileTypeEnum() FileTypeEnum {
	return FileTypeVideoNoteType
}

// FileTypeVideoStory The file is a video published as a story
type FileTypeVideoStory struct {
	tdCommon
}

// MessageType return the string telegram-type of FileTypeVideoStory
func (fileTypeVideoStory *FileTypeVideoStory) MessageType() string {
	return "fileTypeVideoStory"
}

// NewFileTypeVideoStory creates a new FileTypeVideoStory
//
func NewFileTypeVideoStory() *FileTypeVideoStory {
	fileTypeVideoStoryTemp := FileTypeVideoStory{
		tdCommon: tdCommon{Type: "fileTypeVideoStory"},
	}

	return &fileTypeVideoStoryTemp
}

// UnmarshalJSON unmarshal to json
func (fileTypeVideoStory *FileTypeVideoStory) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	fileTypeVideoStory.tdCommon = tempObj.tdCommon

	return nil
}

// GetFileTypeEnum return the enum type of this object
func (fileTypeVideoStory *FileTypeVideoStory) GetFileTypeEnum() FileTypeEnum {
	return FileTypeVideoStoryType
}

// FileTypeVoiceNote The file is a voice note
type FileTypeVoiceNote struct {
	tdCommon
}

// MessageType return the string telegram-type of FileTypeVoiceNote
func (fileTypeVoiceNote *FileTypeVoiceNote) MessageType() string {
	return "fileTypeVoiceNote"
}

// NewFileTypeVoiceNote creates a new FileTypeVoiceNote
//
func NewFileTypeVoiceNote() *FileTypeVoiceNote {
	fileTypeVoiceNoteTemp := FileTypeVoiceNote{
		tdCommon: tdCommon{Type: "fileTypeVoiceNote"},
	}

	return &fileTypeVoiceNoteTemp
}

// UnmarshalJSON unmarshal to json
func (fileTypeVoiceNote *FileTypeVoiceNote) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	fileTypeVoiceNote.tdCommon = tempObj.tdCommon

	return nil
}

// GetFileTypeEnum return the enum type of this object
func (fileTypeVoiceNote *FileTypeVoiceNote) GetFileTypeEnum() FileTypeEnum {
	return FileTypeVoiceNoteType
}

// FileTypeWallpaper The file is a wallpaper or a background pattern
type FileTypeWallpaper struct {
	tdCommon
}

// MessageType return the string telegram-type of FileTypeWallpaper
func (fileTypeWallpaper *FileTypeWallpaper) MessageType() string {
	return "fileTypeWallpaper"
}

// NewFileTypeWallpaper creates a new FileTypeWallpaper
//
func NewFileTypeWallpaper() *FileTypeWallpaper {
	fileTypeWallpaperTemp := FileTypeWallpaper{
		tdCommon: tdCommon{Type: "fileTypeWallpaper"},
	}

	return &fileTypeWallpaperTemp
}

// UnmarshalJSON unmarshal to json
func (fileTypeWallpaper *FileTypeWallpaper) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	fileTypeWallpaper.tdCommon = tempObj.tdCommon

	return nil
}

// GetFileTypeEnum return the enum type of this object
func (fileTypeWallpaper *FileTypeWallpaper) GetFileTypeEnum() FileTypeEnum {
	return FileTypeWallpaperType
}

// StorageStatisticsByFileType Contains the storage usage statistics for a specific file type
type StorageStatisticsByFileType struct {
	tdCommon
	FileType FileType `json:"file_type"` // File type
	Size     int64    `json:"size"`      // Total size of the files, in bytes
	Count    int32    `json:"count"`     // Total number of files
}

// MessageType return the string telegram-type of StorageStatisticsByFileType
func (storageStatisticsByFileType *StorageStatisticsByFileType) MessageType() string {
	return "storageStatisticsByFileType"
}

// NewStorageStatisticsByFileType creates a new StorageStatisticsByFileType
//
// @param fileType File type
// @param size Total size of the files, in bytes
// @param count Total number of files
func NewStorageStatisticsByFileType(fileType FileType, size int64, count int32) *StorageStatisticsByFileType {
	storageStatisticsByFileTypeTemp := StorageStatisticsByFileType{
		tdCommon: tdCommon{Type: "storageStatisticsByFileType"},
		FileType: fileType,
		Size:     size,
		Count:    count,
	}

	return &storageStatisticsByFileTypeTemp
}

// UnmarshalJSON unmarshal to json
func (storageStatisticsByFileType *StorageStatisticsByFileType) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Size  int64 `json:"size"`  // Total size of the files, in bytes
		Count int32 `json:"count"` // Total number of files
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storageStatisticsByFileType.tdCommon = tempObj.tdCommon
	storageStatisticsByFileType.Size = tempObj.Size
	storageStatisticsByFileType.Count = tempObj.Count

	fieldFileType, _ := unmarshalFileType(objMap["file_type"])
	storageStatisticsByFileType.FileType = fieldFileType

	return nil
}

// StorageStatisticsByChat Contains the storage usage statistics for a specific chat
type StorageStatisticsByChat struct {
	tdCommon
	ChatID     int64                         `json:"chat_id"`      // Chat identifier; 0 if none
	Size       int64                         `json:"size"`         // Total size of the files in the chat, in bytes
	Count      int32                         `json:"count"`        // Total number of files in the chat
	ByFileType []StorageStatisticsByFileType `json:"by_file_type"` // Statistics split by file types
}

// MessageType return the string telegram-type of StorageStatisticsByChat
func (storageStatisticsByChat *StorageStatisticsByChat) MessageType() string {
	return "storageStatisticsByChat"
}

// NewStorageStatisticsByChat creates a new StorageStatisticsByChat
//
// @param chatID Chat identifier; 0 if none
// @param size Total size of the files in the chat, in bytes
// @param count Total number of files in the chat
// @param byFileType Statistics split by file types
func NewStorageStatisticsByChat(chatID int64, size int64, count int32, byFileType []StorageStatisticsByFileType) *StorageStatisticsByChat {
	storageStatisticsByChatTemp := StorageStatisticsByChat{
		tdCommon:   tdCommon{Type: "storageStatisticsByChat"},
		ChatID:     chatID,
		Size:       size,
		Count:      count,
		ByFileType: byFileType,
	}

	return &storageStatisticsByChatTemp
}

// UnmarshalJSON unmarshal to json
func (storageStatisticsByChat *StorageStatisticsByChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID     int64                         `json:"chat_id"`      // Chat identifier; 0 if none
		Size       int64                         `json:"size"`         // Total size of the files in the chat, in bytes
		Count      int32                         `json:"count"`        // Total number of files in the chat
		ByFileType []StorageStatisticsByFileType `json:"by_file_type"` // Statistics split by file types
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storageStatisticsByChat.tdCommon = tempObj.tdCommon
	storageStatisticsByChat.ChatID = tempObj.ChatID
	storageStatisticsByChat.Size = tempObj.Size
	storageStatisticsByChat.Count = tempObj.Count
	storageStatisticsByChat.ByFileType = tempObj.ByFileType

	return nil
}

// StorageStatistics Contains the exact storage usage statistics split by chats and file type
type StorageStatistics struct {
	tdCommon
	Size   int64                     `json:"size"`    // Total size of files, in bytes
	Count  int32                     `json:"count"`   // Total number of files
	ByChat []StorageStatisticsByChat `json:"by_chat"` // Statistics split by chats
}

// MessageType return the string telegram-type of StorageStatistics
func (storageStatistics *StorageStatistics) MessageType() string {
	return "storageStatistics"
}

// NewStorageStatistics creates a new StorageStatistics
//
// @param size Total size of files, in bytes
// @param count Total number of files
// @param byChat Statistics split by chats
func NewStorageStatistics(size int64, count int32, byChat []StorageStatisticsByChat) *StorageStatistics {
	storageStatisticsTemp := StorageStatistics{
		tdCommon: tdCommon{Type: "storageStatistics"},
		Size:     size,
		Count:    count,
		ByChat:   byChat,
	}

	return &storageStatisticsTemp
}

// UnmarshalJSON unmarshal to json
func (storageStatistics *StorageStatistics) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Size   int64                     `json:"size"`    // Total size of files, in bytes
		Count  int32                     `json:"count"`   // Total number of files
		ByChat []StorageStatisticsByChat `json:"by_chat"` // Statistics split by chats
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storageStatistics.tdCommon = tempObj.tdCommon
	storageStatistics.Size = tempObj.Size
	storageStatistics.Count = tempObj.Count
	storageStatistics.ByChat = tempObj.ByChat

	return nil
}

// StorageStatisticsFast Contains approximate storage usage statistics, excluding files of unknown file type
type StorageStatisticsFast struct {
	tdCommon
	FilesSize                int64 `json:"files_size"`                  // Approximate total size of files, in bytes
	FileCount                int32 `json:"file_count"`                  // Approximate number of files
	DatabaseSize             int64 `json:"database_size"`               // Size of the database
	LanguagePackDatabaseSize int64 `json:"language_pack_database_size"` // Size of the language pack database
	LogSize                  int64 `json:"log_size"`                    // Size of the TDLib internal log
}

// MessageType return the string telegram-type of StorageStatisticsFast
func (storageStatisticsFast *StorageStatisticsFast) MessageType() string {
	return "storageStatisticsFast"
}

// NewStorageStatisticsFast creates a new StorageStatisticsFast
//
// @param filesSize Approximate total size of files, in bytes
// @param fileCount Approximate number of files
// @param databaseSize Size of the database
// @param languagePackDatabaseSize Size of the language pack database
// @param logSize Size of the TDLib internal log
func NewStorageStatisticsFast(filesSize int64, fileCount int32, databaseSize int64, languagePackDatabaseSize int64, logSize int64) *StorageStatisticsFast {
	storageStatisticsFastTemp := StorageStatisticsFast{
		tdCommon:                 tdCommon{Type: "storageStatisticsFast"},
		FilesSize:                filesSize,
		FileCount:                fileCount,
		DatabaseSize:             databaseSize,
		LanguagePackDatabaseSize: languagePackDatabaseSize,
		LogSize:                  logSize,
	}

	return &storageStatisticsFastTemp
}

// UnmarshalJSON unmarshal to json
func (storageStatisticsFast *StorageStatisticsFast) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		FilesSize                int64 `json:"files_size"`                  // Approximate total size of files, in bytes
		FileCount                int32 `json:"file_count"`                  // Approximate number of files
		DatabaseSize             int64 `json:"database_size"`               // Size of the database
		LanguagePackDatabaseSize int64 `json:"language_pack_database_size"` // Size of the language pack database
		LogSize                  int64 `json:"log_size"`                    // Size of the TDLib internal log
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storageStatisticsFast.tdCommon = tempObj.tdCommon
	storageStatisticsFast.FilesSize = tempObj.FilesSize
	storageStatisticsFast.FileCount = tempObj.FileCount
	storageStatisticsFast.DatabaseSize = tempObj.DatabaseSize
	storageStatisticsFast.LanguagePackDatabaseSize = tempObj.LanguagePackDatabaseSize
	storageStatisticsFast.LogSize = tempObj.LogSize

	return nil
}

// DatabaseStatistics Contains database statistics
type DatabaseStatistics struct {
	tdCommon
	Statistics string `json:"statistics"` // Database statistics in an unspecified human-readable format
}

// MessageType return the string telegram-type of DatabaseStatistics
func (databaseStatistics *DatabaseStatistics) MessageType() string {
	return "databaseStatistics"
}

// NewDatabaseStatistics creates a new DatabaseStatistics
//
// @param statistics Database statistics in an unspecified human-readable format
func NewDatabaseStatistics(statistics string) *DatabaseStatistics {
	databaseStatisticsTemp := DatabaseStatistics{
		tdCommon:   tdCommon{Type: "databaseStatistics"},
		Statistics: statistics,
	}

	return &databaseStatisticsTemp
}

// UnmarshalJSON unmarshal to json
func (databaseStatistics *DatabaseStatistics) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Statistics string `json:"statistics"` // Database statistics in an unspecified human-readable format
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	databaseStatistics.tdCommon = tempObj.tdCommon
	databaseStatistics.Statistics = tempObj.Statistics

	return nil
}

// NetworkTypeNone The network is not available
type NetworkTypeNone struct {
	tdCommon
}

// MessageType return the string telegram-type of NetworkTypeNone
func (networkTypeNone *NetworkTypeNone) MessageType() string {
	return "networkTypeNone"
}

// NewNetworkTypeNone creates a new NetworkTypeNone
//
func NewNetworkTypeNone() *NetworkTypeNone {
	networkTypeNoneTemp := NetworkTypeNone{
		tdCommon: tdCommon{Type: "networkTypeNone"},
	}

	return &networkTypeNoneTemp
}

// UnmarshalJSON unmarshal to json
func (networkTypeNone *NetworkTypeNone) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	networkTypeNone.tdCommon = tempObj.tdCommon

	return nil
}

// GetNetworkTypeEnum return the enum type of this object
func (networkTypeNone *NetworkTypeNone) GetNetworkTypeEnum() NetworkTypeEnum {
	return NetworkTypeNoneType
}

// NetworkTypeMobile A mobile network
type NetworkTypeMobile struct {
	tdCommon
}

// MessageType return the string telegram-type of NetworkTypeMobile
func (networkTypeMobile *NetworkTypeMobile) MessageType() string {
	return "networkTypeMobile"
}

// NewNetworkTypeMobile creates a new NetworkTypeMobile
//
func NewNetworkTypeMobile() *NetworkTypeMobile {
	networkTypeMobileTemp := NetworkTypeMobile{
		tdCommon: tdCommon{Type: "networkTypeMobile"},
	}

	return &networkTypeMobileTemp
}

// UnmarshalJSON unmarshal to json
func (networkTypeMobile *NetworkTypeMobile) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	networkTypeMobile.tdCommon = tempObj.tdCommon

	return nil
}

// GetNetworkTypeEnum return the enum type of this object
func (networkTypeMobile *NetworkTypeMobile) GetNetworkTypeEnum() NetworkTypeEnum {
	return NetworkTypeMobileType
}

// NetworkTypeMobileRoaming A mobile roaming network
type NetworkTypeMobileRoaming struct {
	tdCommon
}

// MessageType return the string telegram-type of NetworkTypeMobileRoaming
func (networkTypeMobileRoaming *NetworkTypeMobileRoaming) MessageType() string {
	return "networkTypeMobileRoaming"
}

// NewNetworkTypeMobileRoaming creates a new NetworkTypeMobileRoaming
//
func NewNetworkTypeMobileRoaming() *NetworkTypeMobileRoaming {
	networkTypeMobileRoamingTemp := NetworkTypeMobileRoaming{
		tdCommon: tdCommon{Type: "networkTypeMobileRoaming"},
	}

	return &networkTypeMobileRoamingTemp
}

// UnmarshalJSON unmarshal to json
func (networkTypeMobileRoaming *NetworkTypeMobileRoaming) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	networkTypeMobileRoaming.tdCommon = tempObj.tdCommon

	return nil
}

// GetNetworkTypeEnum return the enum type of this object
func (networkTypeMobileRoaming *NetworkTypeMobileRoaming) GetNetworkTypeEnum() NetworkTypeEnum {
	return NetworkTypeMobileRoamingType
}

// NetworkTypeWiFi A Wi-Fi network
type NetworkTypeWiFi struct {
	tdCommon
}

// MessageType return the string telegram-type of NetworkTypeWiFi
func (networkTypeWiFi *NetworkTypeWiFi) MessageType() string {
	return "networkTypeWiFi"
}

// NewNetworkTypeWiFi creates a new NetworkTypeWiFi
//
func NewNetworkTypeWiFi() *NetworkTypeWiFi {
	networkTypeWiFiTemp := NetworkTypeWiFi{
		tdCommon: tdCommon{Type: "networkTypeWiFi"},
	}

	return &networkTypeWiFiTemp
}

// UnmarshalJSON unmarshal to json
func (networkTypeWiFi *NetworkTypeWiFi) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	networkTypeWiFi.tdCommon = tempObj.tdCommon

	return nil
}

// GetNetworkTypeEnum return the enum type of this object
func (networkTypeWiFi *NetworkTypeWiFi) GetNetworkTypeEnum() NetworkTypeEnum {
	return NetworkTypeWiFiType
}

// NetworkTypeOther A different network type (e.g., Ethernet network)
type NetworkTypeOther struct {
	tdCommon
}

// MessageType return the string telegram-type of NetworkTypeOther
func (networkTypeOther *NetworkTypeOther) MessageType() string {
	return "networkTypeOther"
}

// NewNetworkTypeOther creates a new NetworkTypeOther
//
func NewNetworkTypeOther() *NetworkTypeOther {
	networkTypeOtherTemp := NetworkTypeOther{
		tdCommon: tdCommon{Type: "networkTypeOther"},
	}

	return &networkTypeOtherTemp
}

// UnmarshalJSON unmarshal to json
func (networkTypeOther *NetworkTypeOther) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	networkTypeOther.tdCommon = tempObj.tdCommon

	return nil
}

// GetNetworkTypeEnum return the enum type of this object
func (networkTypeOther *NetworkTypeOther) GetNetworkTypeEnum() NetworkTypeEnum {
	return NetworkTypeOtherType
}

// NetworkStatisticsEntryFile Contains information about the total amount of data that was used to send and receive files
type NetworkStatisticsEntryFile struct {
	tdCommon
	FileType      FileType    `json:"file_type"`      // Type of the file the data is part of; pass null if the data isn't related to files
	NetworkType   NetworkType `json:"network_type"`   // Type of the network the data was sent through. Call setNetworkType to maintain the actual network type
	SentBytes     int64       `json:"sent_bytes"`     // Total number of bytes sent
	ReceivedBytes int64       `json:"received_bytes"` // Total number of bytes received
}

// MessageType return the string telegram-type of NetworkStatisticsEntryFile
func (networkStatisticsEntryFile *NetworkStatisticsEntryFile) MessageType() string {
	return "networkStatisticsEntryFile"
}

// NewNetworkStatisticsEntryFile creates a new NetworkStatisticsEntryFile
//
// @param fileType Type of the file the data is part of; pass null if the data isn't related to files
// @param networkType Type of the network the data was sent through. Call setNetworkType to maintain the actual network type
// @param sentBytes Total number of bytes sent
// @param receivedBytes Total number of bytes received
func NewNetworkStatisticsEntryFile(fileType FileType, networkType NetworkType, sentBytes int64, receivedBytes int64) *NetworkStatisticsEntryFile {
	networkStatisticsEntryFileTemp := NetworkStatisticsEntryFile{
		tdCommon:      tdCommon{Type: "networkStatisticsEntryFile"},
		FileType:      fileType,
		NetworkType:   networkType,
		SentBytes:     sentBytes,
		ReceivedBytes: receivedBytes,
	}

	return &networkStatisticsEntryFileTemp
}

// UnmarshalJSON unmarshal to json
func (networkStatisticsEntryFile *NetworkStatisticsEntryFile) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SentBytes     int64 `json:"sent_bytes"`     // Total number of bytes sent
		ReceivedBytes int64 `json:"received_bytes"` // Total number of bytes received
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	networkStatisticsEntryFile.tdCommon = tempObj.tdCommon
	networkStatisticsEntryFile.SentBytes = tempObj.SentBytes
	networkStatisticsEntryFile.ReceivedBytes = tempObj.ReceivedBytes

	fieldFileType, _ := unmarshalFileType(objMap["file_type"])
	networkStatisticsEntryFile.FileType = fieldFileType

	fieldNetworkType, _ := unmarshalNetworkType(objMap["network_type"])
	networkStatisticsEntryFile.NetworkType = fieldNetworkType

	return nil
}

// GetNetworkStatisticsEntryEnum return the enum type of this object
func (networkStatisticsEntryFile *NetworkStatisticsEntryFile) GetNetworkStatisticsEntryEnum() NetworkStatisticsEntryEnum {
	return NetworkStatisticsEntryFileType
}

// NetworkStatisticsEntryCall Contains information about the total amount of data that was used for calls
type NetworkStatisticsEntryCall struct {
	tdCommon
	NetworkType   NetworkType `json:"network_type"`   // Type of the network the data was sent through. Call setNetworkType to maintain the actual network type
	SentBytes     int64       `json:"sent_bytes"`     // Total number of bytes sent
	ReceivedBytes int64       `json:"received_bytes"` // Total number of bytes received
	Duration      float64     `json:"duration"`       // Total call duration, in seconds
}

// MessageType return the string telegram-type of NetworkStatisticsEntryCall
func (networkStatisticsEntryCall *NetworkStatisticsEntryCall) MessageType() string {
	return "networkStatisticsEntryCall"
}

// NewNetworkStatisticsEntryCall creates a new NetworkStatisticsEntryCall
//
// @param networkType Type of the network the data was sent through. Call setNetworkType to maintain the actual network type
// @param sentBytes Total number of bytes sent
// @param receivedBytes Total number of bytes received
// @param duration Total call duration, in seconds
func NewNetworkStatisticsEntryCall(networkType NetworkType, sentBytes int64, receivedBytes int64, duration float64) *NetworkStatisticsEntryCall {
	networkStatisticsEntryCallTemp := NetworkStatisticsEntryCall{
		tdCommon:      tdCommon{Type: "networkStatisticsEntryCall"},
		NetworkType:   networkType,
		SentBytes:     sentBytes,
		ReceivedBytes: receivedBytes,
		Duration:      duration,
	}

	return &networkStatisticsEntryCallTemp
}

// UnmarshalJSON unmarshal to json
func (networkStatisticsEntryCall *NetworkStatisticsEntryCall) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SentBytes     int64   `json:"sent_bytes"`     // Total number of bytes sent
		ReceivedBytes int64   `json:"received_bytes"` // Total number of bytes received
		Duration      float64 `json:"duration"`       // Total call duration, in seconds
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	networkStatisticsEntryCall.tdCommon = tempObj.tdCommon
	networkStatisticsEntryCall.SentBytes = tempObj.SentBytes
	networkStatisticsEntryCall.ReceivedBytes = tempObj.ReceivedBytes
	networkStatisticsEntryCall.Duration = tempObj.Duration

	fieldNetworkType, _ := unmarshalNetworkType(objMap["network_type"])
	networkStatisticsEntryCall.NetworkType = fieldNetworkType

	return nil
}

// GetNetworkStatisticsEntryEnum return the enum type of this object
func (networkStatisticsEntryCall *NetworkStatisticsEntryCall) GetNetworkStatisticsEntryEnum() NetworkStatisticsEntryEnum {
	return NetworkStatisticsEntryCallType
}

// NetworkStatistics A full list of available network statistic entries
type NetworkStatistics struct {
	tdCommon
	SinceDate int32                    `json:"since_date"` // Point in time (Unix timestamp) from which the statistics are collected
	Entries   []NetworkStatisticsEntry `json:"entries"`    // Network statistics entries
}

// MessageType return the string telegram-type of NetworkStatistics
func (networkStatistics *NetworkStatistics) MessageType() string {
	return "networkStatistics"
}

// NewNetworkStatistics creates a new NetworkStatistics
//
// @param sinceDate Point in time (Unix timestamp) from which the statistics are collected
// @param entries Network statistics entries
func NewNetworkStatistics(sinceDate int32, entries []NetworkStatisticsEntry) *NetworkStatistics {
	networkStatisticsTemp := NetworkStatistics{
		tdCommon:  tdCommon{Type: "networkStatistics"},
		SinceDate: sinceDate,
		Entries:   entries,
	}

	return &networkStatisticsTemp
}

// UnmarshalJSON unmarshal to json
func (networkStatistics *NetworkStatistics) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SinceDate int32 `json:"since_date"` // Point in time (Unix timestamp) from which the statistics are collected

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	networkStatistics.tdCommon = tempObj.tdCommon
	networkStatistics.SinceDate = tempObj.SinceDate

	fieldEntries, _ := unmarshalNetworkStatisticsEntrySlice(objMap["entries"])
	networkStatistics.Entries = fieldEntries

	return nil
}

// AutoDownloadSettings Contains auto-download settings
type AutoDownloadSettings struct {
	tdCommon
	IsAutoDownloadEnabled bool  `json:"is_auto_download_enabled"` // True, if the auto-download is enabled
	MaxPhotoFileSize      int32 `json:"max_photo_file_size"`      // The maximum size of a photo file to be auto-downloaded, in bytes
	MaxVideoFileSize      int64 `json:"max_video_file_size"`      // The maximum size of a video file to be auto-downloaded, in bytes
	MaxOtherFileSize      int64 `json:"max_other_file_size"`      // The maximum size of other file types to be auto-downloaded, in bytes
	VideoUploadBitrate    int32 `json:"video_upload_bitrate"`     // The maximum suggested bitrate for uploaded videos, in kbit/s
	PreloadLargeVideos    bool  `json:"preload_large_videos"`     // True, if the beginning of video files needs to be preloaded for instant playback
	PreloadNextAudio      bool  `json:"preload_next_audio"`       // True, if the next audio track needs to be preloaded while the user is listening to an audio file
	PreloadStories        bool  `json:"preload_stories"`          // True, if stories needs to be preloaded
	UseLessDataForCalls   bool  `json:"use_less_data_for_calls"`  // True, if "use less data for calls" option needs to be enabled
}

// MessageType return the string telegram-type of AutoDownloadSettings
func (autoDownloadSettings *AutoDownloadSettings) MessageType() string {
	return "autoDownloadSettings"
}

// NewAutoDownloadSettings creates a new AutoDownloadSettings
//
// @param isAutoDownloadEnabled True, if the auto-download is enabled
// @param maxPhotoFileSize The maximum size of a photo file to be auto-downloaded, in bytes
// @param maxVideoFileSize The maximum size of a video file to be auto-downloaded, in bytes
// @param maxOtherFileSize The maximum size of other file types to be auto-downloaded, in bytes
// @param videoUploadBitrate The maximum suggested bitrate for uploaded videos, in kbit/s
// @param preloadLargeVideos True, if the beginning of video files needs to be preloaded for instant playback
// @param preloadNextAudio True, if the next audio track needs to be preloaded while the user is listening to an audio file
// @param preloadStories True, if stories needs to be preloaded
// @param useLessDataForCalls True, if "use less data for calls" option needs to be enabled
func NewAutoDownloadSettings(isAutoDownloadEnabled bool, maxPhotoFileSize int32, maxVideoFileSize int64, maxOtherFileSize int64, videoUploadBitrate int32, preloadLargeVideos bool, preloadNextAudio bool, preloadStories bool, useLessDataForCalls bool) *AutoDownloadSettings {
	autoDownloadSettingsTemp := AutoDownloadSettings{
		tdCommon:              tdCommon{Type: "autoDownloadSettings"},
		IsAutoDownloadEnabled: isAutoDownloadEnabled,
		MaxPhotoFileSize:      maxPhotoFileSize,
		MaxVideoFileSize:      maxVideoFileSize,
		MaxOtherFileSize:      maxOtherFileSize,
		VideoUploadBitrate:    videoUploadBitrate,
		PreloadLargeVideos:    preloadLargeVideos,
		PreloadNextAudio:      preloadNextAudio,
		PreloadStories:        preloadStories,
		UseLessDataForCalls:   useLessDataForCalls,
	}

	return &autoDownloadSettingsTemp
}

// UnmarshalJSON unmarshal to json
func (autoDownloadSettings *AutoDownloadSettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsAutoDownloadEnabled bool  `json:"is_auto_download_enabled"` // True, if the auto-download is enabled
		MaxPhotoFileSize      int32 `json:"max_photo_file_size"`      // The maximum size of a photo file to be auto-downloaded, in bytes
		MaxVideoFileSize      int64 `json:"max_video_file_size"`      // The maximum size of a video file to be auto-downloaded, in bytes
		MaxOtherFileSize      int64 `json:"max_other_file_size"`      // The maximum size of other file types to be auto-downloaded, in bytes
		VideoUploadBitrate    int32 `json:"video_upload_bitrate"`     // The maximum suggested bitrate for uploaded videos, in kbit/s
		PreloadLargeVideos    bool  `json:"preload_large_videos"`     // True, if the beginning of video files needs to be preloaded for instant playback
		PreloadNextAudio      bool  `json:"preload_next_audio"`       // True, if the next audio track needs to be preloaded while the user is listening to an audio file
		PreloadStories        bool  `json:"preload_stories"`          // True, if stories needs to be preloaded
		UseLessDataForCalls   bool  `json:"use_less_data_for_calls"`  // True, if "use less data for calls" option needs to be enabled
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	autoDownloadSettings.tdCommon = tempObj.tdCommon
	autoDownloadSettings.IsAutoDownloadEnabled = tempObj.IsAutoDownloadEnabled
	autoDownloadSettings.MaxPhotoFileSize = tempObj.MaxPhotoFileSize
	autoDownloadSettings.MaxVideoFileSize = tempObj.MaxVideoFileSize
	autoDownloadSettings.MaxOtherFileSize = tempObj.MaxOtherFileSize
	autoDownloadSettings.VideoUploadBitrate = tempObj.VideoUploadBitrate
	autoDownloadSettings.PreloadLargeVideos = tempObj.PreloadLargeVideos
	autoDownloadSettings.PreloadNextAudio = tempObj.PreloadNextAudio
	autoDownloadSettings.PreloadStories = tempObj.PreloadStories
	autoDownloadSettings.UseLessDataForCalls = tempObj.UseLessDataForCalls

	return nil
}

// AutoDownloadSettingsPresets Contains auto-download settings presets for the current user
type AutoDownloadSettingsPresets struct {
	tdCommon
	Low    *AutoDownloadSettings `json:"low"`    // Preset with lowest settings; supposed to be used by default when roaming
	Medium *AutoDownloadSettings `json:"medium"` // Preset with medium settings; supposed to be used by default when using mobile data
	High   *AutoDownloadSettings `json:"high"`   // Preset with highest settings; supposed to be used by default when connected on Wi-Fi
}

// MessageType return the string telegram-type of AutoDownloadSettingsPresets
func (autoDownloadSettingsPresets *AutoDownloadSettingsPresets) MessageType() string {
	return "autoDownloadSettingsPresets"
}

// NewAutoDownloadSettingsPresets creates a new AutoDownloadSettingsPresets
//
// @param low Preset with lowest settings; supposed to be used by default when roaming
// @param medium Preset with medium settings; supposed to be used by default when using mobile data
// @param high Preset with highest settings; supposed to be used by default when connected on Wi-Fi
func NewAutoDownloadSettingsPresets(low *AutoDownloadSettings, medium *AutoDownloadSettings, high *AutoDownloadSettings) *AutoDownloadSettingsPresets {
	autoDownloadSettingsPresetsTemp := AutoDownloadSettingsPresets{
		tdCommon: tdCommon{Type: "autoDownloadSettingsPresets"},
		Low:      low,
		Medium:   medium,
		High:     high,
	}

	return &autoDownloadSettingsPresetsTemp
}

// UnmarshalJSON unmarshal to json
func (autoDownloadSettingsPresets *AutoDownloadSettingsPresets) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Low    *AutoDownloadSettings `json:"low"`    // Preset with lowest settings; supposed to be used by default when roaming
		Medium *AutoDownloadSettings `json:"medium"` // Preset with medium settings; supposed to be used by default when using mobile data
		High   *AutoDownloadSettings `json:"high"`   // Preset with highest settings; supposed to be used by default when connected on Wi-Fi
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	autoDownloadSettingsPresets.tdCommon = tempObj.tdCommon
	autoDownloadSettingsPresets.Low = tempObj.Low
	autoDownloadSettingsPresets.Medium = tempObj.Medium
	autoDownloadSettingsPresets.High = tempObj.High

	return nil
}

// AutosaveSettingsScopePrivateChats Autosave settings applied to all private chats without chat-specific settings
type AutosaveSettingsScopePrivateChats struct {
	tdCommon
}

// MessageType return the string telegram-type of AutosaveSettingsScopePrivateChats
func (autosaveSettingsScopePrivateChats *AutosaveSettingsScopePrivateChats) MessageType() string {
	return "autosaveSettingsScopePrivateChats"
}

// NewAutosaveSettingsScopePrivateChats creates a new AutosaveSettingsScopePrivateChats
//
func NewAutosaveSettingsScopePrivateChats() *AutosaveSettingsScopePrivateChats {
	autosaveSettingsScopePrivateChatsTemp := AutosaveSettingsScopePrivateChats{
		tdCommon: tdCommon{Type: "autosaveSettingsScopePrivateChats"},
	}

	return &autosaveSettingsScopePrivateChatsTemp
}

// UnmarshalJSON unmarshal to json
func (autosaveSettingsScopePrivateChats *AutosaveSettingsScopePrivateChats) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	autosaveSettingsScopePrivateChats.tdCommon = tempObj.tdCommon

	return nil
}

// GetAutosaveSettingsScopeEnum return the enum type of this object
func (autosaveSettingsScopePrivateChats *AutosaveSettingsScopePrivateChats) GetAutosaveSettingsScopeEnum() AutosaveSettingsScopeEnum {
	return AutosaveSettingsScopePrivateChatsType
}

// AutosaveSettingsScopeGroupChats Autosave settings applied to all basic group and supergroup chats without chat-specific settings
type AutosaveSettingsScopeGroupChats struct {
	tdCommon
}

// MessageType return the string telegram-type of AutosaveSettingsScopeGroupChats
func (autosaveSettingsScopeGroupChats *AutosaveSettingsScopeGroupChats) MessageType() string {
	return "autosaveSettingsScopeGroupChats"
}

// NewAutosaveSettingsScopeGroupChats creates a new AutosaveSettingsScopeGroupChats
//
func NewAutosaveSettingsScopeGroupChats() *AutosaveSettingsScopeGroupChats {
	autosaveSettingsScopeGroupChatsTemp := AutosaveSettingsScopeGroupChats{
		tdCommon: tdCommon{Type: "autosaveSettingsScopeGroupChats"},
	}

	return &autosaveSettingsScopeGroupChatsTemp
}

// UnmarshalJSON unmarshal to json
func (autosaveSettingsScopeGroupChats *AutosaveSettingsScopeGroupChats) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	autosaveSettingsScopeGroupChats.tdCommon = tempObj.tdCommon

	return nil
}

// GetAutosaveSettingsScopeEnum return the enum type of this object
func (autosaveSettingsScopeGroupChats *AutosaveSettingsScopeGroupChats) GetAutosaveSettingsScopeEnum() AutosaveSettingsScopeEnum {
	return AutosaveSettingsScopeGroupChatsType
}

// AutosaveSettingsScopeChannelChats Autosave settings applied to all channel chats without chat-specific settings
type AutosaveSettingsScopeChannelChats struct {
	tdCommon
}

// MessageType return the string telegram-type of AutosaveSettingsScopeChannelChats
func (autosaveSettingsScopeChannelChats *AutosaveSettingsScopeChannelChats) MessageType() string {
	return "autosaveSettingsScopeChannelChats"
}

// NewAutosaveSettingsScopeChannelChats creates a new AutosaveSettingsScopeChannelChats
//
func NewAutosaveSettingsScopeChannelChats() *AutosaveSettingsScopeChannelChats {
	autosaveSettingsScopeChannelChatsTemp := AutosaveSettingsScopeChannelChats{
		tdCommon: tdCommon{Type: "autosaveSettingsScopeChannelChats"},
	}

	return &autosaveSettingsScopeChannelChatsTemp
}

// UnmarshalJSON unmarshal to json
func (autosaveSettingsScopeChannelChats *AutosaveSettingsScopeChannelChats) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	autosaveSettingsScopeChannelChats.tdCommon = tempObj.tdCommon

	return nil
}

// GetAutosaveSettingsScopeEnum return the enum type of this object
func (autosaveSettingsScopeChannelChats *AutosaveSettingsScopeChannelChats) GetAutosaveSettingsScopeEnum() AutosaveSettingsScopeEnum {
	return AutosaveSettingsScopeChannelChatsType
}

// AutosaveSettingsScopeChat Autosave settings applied to a chat
type AutosaveSettingsScopeChat struct {
	tdCommon
	ChatID int64 `json:"chat_id"` // Chat identifier
}

// MessageType return the string telegram-type of AutosaveSettingsScopeChat
func (autosaveSettingsScopeChat *AutosaveSettingsScopeChat) MessageType() string {
	return "autosaveSettingsScopeChat"
}

// NewAutosaveSettingsScopeChat creates a new AutosaveSettingsScopeChat
//
// @param chatID Chat identifier
func NewAutosaveSettingsScopeChat(chatID int64) *AutosaveSettingsScopeChat {
	autosaveSettingsScopeChatTemp := AutosaveSettingsScopeChat{
		tdCommon: tdCommon{Type: "autosaveSettingsScopeChat"},
		ChatID:   chatID,
	}

	return &autosaveSettingsScopeChatTemp
}

// UnmarshalJSON unmarshal to json
func (autosaveSettingsScopeChat *AutosaveSettingsScopeChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID int64 `json:"chat_id"` // Chat identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	autosaveSettingsScopeChat.tdCommon = tempObj.tdCommon
	autosaveSettingsScopeChat.ChatID = tempObj.ChatID

	return nil
}

// GetAutosaveSettingsScopeEnum return the enum type of this object
func (autosaveSettingsScopeChat *AutosaveSettingsScopeChat) GetAutosaveSettingsScopeEnum() AutosaveSettingsScopeEnum {
	return AutosaveSettingsScopeChatType
}

// ScopeAutosaveSettings Contains autosave settings for an autosave settings scope
type ScopeAutosaveSettings struct {
	tdCommon
	AutosavePhotos   bool  `json:"autosave_photos"`     // True, if photo autosave is enabled
	AutosaveVideos   bool  `json:"autosave_videos"`     // True, if video autosave is enabled
	MaxVideoFileSize int64 `json:"max_video_file_size"` // The maximum size of a video file to be autosaved, in bytes; 512 KB - 4000 MB
}

// MessageType return the string telegram-type of ScopeAutosaveSettings
func (scopeAutosaveSettings *ScopeAutosaveSettings) MessageType() string {
	return "scopeAutosaveSettings"
}

// NewScopeAutosaveSettings creates a new ScopeAutosaveSettings
//
// @param autosavePhotos True, if photo autosave is enabled
// @param autosaveVideos True, if video autosave is enabled
// @param maxVideoFileSize The maximum size of a video file to be autosaved, in bytes; 512 KB - 4000 MB
func NewScopeAutosaveSettings(autosavePhotos bool, autosaveVideos bool, maxVideoFileSize int64) *ScopeAutosaveSettings {
	scopeAutosaveSettingsTemp := ScopeAutosaveSettings{
		tdCommon:         tdCommon{Type: "scopeAutosaveSettings"},
		AutosavePhotos:   autosavePhotos,
		AutosaveVideos:   autosaveVideos,
		MaxVideoFileSize: maxVideoFileSize,
	}

	return &scopeAutosaveSettingsTemp
}

// UnmarshalJSON unmarshal to json
func (scopeAutosaveSettings *ScopeAutosaveSettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		AutosavePhotos   bool  `json:"autosave_photos"`     // True, if photo autosave is enabled
		AutosaveVideos   bool  `json:"autosave_videos"`     // True, if video autosave is enabled
		MaxVideoFileSize int64 `json:"max_video_file_size"` // The maximum size of a video file to be autosaved, in bytes; 512 KB - 4000 MB
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	scopeAutosaveSettings.tdCommon = tempObj.tdCommon
	scopeAutosaveSettings.AutosavePhotos = tempObj.AutosavePhotos
	scopeAutosaveSettings.AutosaveVideos = tempObj.AutosaveVideos
	scopeAutosaveSettings.MaxVideoFileSize = tempObj.MaxVideoFileSize

	return nil
}

// AutosaveSettingsException Contains autosave settings for a chat, which overrides default settings for the corresponding scope
type AutosaveSettingsException struct {
	tdCommon
	ChatID   int64                  `json:"chat_id"`  // Chat identifier
	Settings *ScopeAutosaveSettings `json:"settings"` // Autosave settings for the chat
}

// MessageType return the string telegram-type of AutosaveSettingsException
func (autosaveSettingsException *AutosaveSettingsException) MessageType() string {
	return "autosaveSettingsException"
}

// NewAutosaveSettingsException creates a new AutosaveSettingsException
//
// @param chatID Chat identifier
// @param settings Autosave settings for the chat
func NewAutosaveSettingsException(chatID int64, settings *ScopeAutosaveSettings) *AutosaveSettingsException {
	autosaveSettingsExceptionTemp := AutosaveSettingsException{
		tdCommon: tdCommon{Type: "autosaveSettingsException"},
		ChatID:   chatID,
		Settings: settings,
	}

	return &autosaveSettingsExceptionTemp
}

// UnmarshalJSON unmarshal to json
func (autosaveSettingsException *AutosaveSettingsException) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID   int64                  `json:"chat_id"`  // Chat identifier
		Settings *ScopeAutosaveSettings `json:"settings"` // Autosave settings for the chat
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	autosaveSettingsException.tdCommon = tempObj.tdCommon
	autosaveSettingsException.ChatID = tempObj.ChatID
	autosaveSettingsException.Settings = tempObj.Settings

	return nil
}

// AutosaveSettings Describes autosave settings
type AutosaveSettings struct {
	tdCommon
	PrivateChatSettings *ScopeAutosaveSettings      `json:"private_chat_settings"` // Default autosave settings for private chats
	GroupSettings       *ScopeAutosaveSettings      `json:"group_settings"`        // Default autosave settings for basic group and supergroup chats
	ChannelSettings     *ScopeAutosaveSettings      `json:"channel_settings"`      // Default autosave settings for channel chats
	Exceptions          []AutosaveSettingsException `json:"exceptions"`            // Autosave settings for specific chats
}

// MessageType return the string telegram-type of AutosaveSettings
func (autosaveSettings *AutosaveSettings) MessageType() string {
	return "autosaveSettings"
}

// NewAutosaveSettings creates a new AutosaveSettings
//
// @param privateChatSettings Default autosave settings for private chats
// @param groupSettings Default autosave settings for basic group and supergroup chats
// @param channelSettings Default autosave settings for channel chats
// @param exceptions Autosave settings for specific chats
func NewAutosaveSettings(privateChatSettings *ScopeAutosaveSettings, groupSettings *ScopeAutosaveSettings, channelSettings *ScopeAutosaveSettings, exceptions []AutosaveSettingsException) *AutosaveSettings {
	autosaveSettingsTemp := AutosaveSettings{
		tdCommon:            tdCommon{Type: "autosaveSettings"},
		PrivateChatSettings: privateChatSettings,
		GroupSettings:       groupSettings,
		ChannelSettings:     channelSettings,
		Exceptions:          exceptions,
	}

	return &autosaveSettingsTemp
}

// UnmarshalJSON unmarshal to json
func (autosaveSettings *AutosaveSettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PrivateChatSettings *ScopeAutosaveSettings      `json:"private_chat_settings"` // Default autosave settings for private chats
		GroupSettings       *ScopeAutosaveSettings      `json:"group_settings"`        // Default autosave settings for basic group and supergroup chats
		ChannelSettings     *ScopeAutosaveSettings      `json:"channel_settings"`      // Default autosave settings for channel chats
		Exceptions          []AutosaveSettingsException `json:"exceptions"`            // Autosave settings for specific chats
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	autosaveSettings.tdCommon = tempObj.tdCommon
	autosaveSettings.PrivateChatSettings = tempObj.PrivateChatSettings
	autosaveSettings.GroupSettings = tempObj.GroupSettings
	autosaveSettings.ChannelSettings = tempObj.ChannelSettings
	autosaveSettings.Exceptions = tempObj.Exceptions

	return nil
}

// ConnectionStateWaitingForNetwork Waiting for the network to become available. Use setNetworkType to change the available network type
type ConnectionStateWaitingForNetwork struct {
	tdCommon
}

// MessageType return the string telegram-type of ConnectionStateWaitingForNetwork
func (connectionStateWaitingForNetwork *ConnectionStateWaitingForNetwork) MessageType() string {
	return "connectionStateWaitingForNetwork"
}

// NewConnectionStateWaitingForNetwork creates a new ConnectionStateWaitingForNetwork
//
func NewConnectionStateWaitingForNetwork() *ConnectionStateWaitingForNetwork {
	connectionStateWaitingForNetworkTemp := ConnectionStateWaitingForNetwork{
		tdCommon: tdCommon{Type: "connectionStateWaitingForNetwork"},
	}

	return &connectionStateWaitingForNetworkTemp
}

// UnmarshalJSON unmarshal to json
func (connectionStateWaitingForNetwork *ConnectionStateWaitingForNetwork) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	connectionStateWaitingForNetwork.tdCommon = tempObj.tdCommon

	return nil
}

// GetConnectionStateEnum return the enum type of this object
func (connectionStateWaitingForNetwork *ConnectionStateWaitingForNetwork) GetConnectionStateEnum() ConnectionStateEnum {
	return ConnectionStateWaitingForNetworkType
}

// ConnectionStateConnectingToProxy Establishing a connection with a proxy server
type ConnectionStateConnectingToProxy struct {
	tdCommon
}

// MessageType return the string telegram-type of ConnectionStateConnectingToProxy
func (connectionStateConnectingToProxy *ConnectionStateConnectingToProxy) MessageType() string {
	return "connectionStateConnectingToProxy"
}

// NewConnectionStateConnectingToProxy creates a new ConnectionStateConnectingToProxy
//
func NewConnectionStateConnectingToProxy() *ConnectionStateConnectingToProxy {
	connectionStateConnectingToProxyTemp := ConnectionStateConnectingToProxy{
		tdCommon: tdCommon{Type: "connectionStateConnectingToProxy"},
	}

	return &connectionStateConnectingToProxyTemp
}

// UnmarshalJSON unmarshal to json
func (connectionStateConnectingToProxy *ConnectionStateConnectingToProxy) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	connectionStateConnectingToProxy.tdCommon = tempObj.tdCommon

	return nil
}

// GetConnectionStateEnum return the enum type of this object
func (connectionStateConnectingToProxy *ConnectionStateConnectingToProxy) GetConnectionStateEnum() ConnectionStateEnum {
	return ConnectionStateConnectingToProxyType
}

// ConnectionStateConnecting Establishing a connection to the Telegram servers
type ConnectionStateConnecting struct {
	tdCommon
}

// MessageType return the string telegram-type of ConnectionStateConnecting
func (connectionStateConnecting *ConnectionStateConnecting) MessageType() string {
	return "connectionStateConnecting"
}

// NewConnectionStateConnecting creates a new ConnectionStateConnecting
//
func NewConnectionStateConnecting() *ConnectionStateConnecting {
	connectionStateConnectingTemp := ConnectionStateConnecting{
		tdCommon: tdCommon{Type: "connectionStateConnecting"},
	}

	return &connectionStateConnectingTemp
}

// UnmarshalJSON unmarshal to json
func (connectionStateConnecting *ConnectionStateConnecting) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	connectionStateConnecting.tdCommon = tempObj.tdCommon

	return nil
}

// GetConnectionStateEnum return the enum type of this object
func (connectionStateConnecting *ConnectionStateConnecting) GetConnectionStateEnum() ConnectionStateEnum {
	return ConnectionStateConnectingType
}

// ConnectionStateUpdating Downloading data supposed to be received while the application was offline
type ConnectionStateUpdating struct {
	tdCommon
}

// MessageType return the string telegram-type of ConnectionStateUpdating
func (connectionStateUpdating *ConnectionStateUpdating) MessageType() string {
	return "connectionStateUpdating"
}

// NewConnectionStateUpdating creates a new ConnectionStateUpdating
//
func NewConnectionStateUpdating() *ConnectionStateUpdating {
	connectionStateUpdatingTemp := ConnectionStateUpdating{
		tdCommon: tdCommon{Type: "connectionStateUpdating"},
	}

	return &connectionStateUpdatingTemp
}

// UnmarshalJSON unmarshal to json
func (connectionStateUpdating *ConnectionStateUpdating) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	connectionStateUpdating.tdCommon = tempObj.tdCommon

	return nil
}

// GetConnectionStateEnum return the enum type of this object
func (connectionStateUpdating *ConnectionStateUpdating) GetConnectionStateEnum() ConnectionStateEnum {
	return ConnectionStateUpdatingType
}

// ConnectionStateReady There is a working connection to the Telegram servers
type ConnectionStateReady struct {
	tdCommon
}

// MessageType return the string telegram-type of ConnectionStateReady
func (connectionStateReady *ConnectionStateReady) MessageType() string {
	return "connectionStateReady"
}

// NewConnectionStateReady creates a new ConnectionStateReady
//
func NewConnectionStateReady() *ConnectionStateReady {
	connectionStateReadyTemp := ConnectionStateReady{
		tdCommon: tdCommon{Type: "connectionStateReady"},
	}

	return &connectionStateReadyTemp
}

// UnmarshalJSON unmarshal to json
func (connectionStateReady *ConnectionStateReady) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	connectionStateReady.tdCommon = tempObj.tdCommon

	return nil
}

// GetConnectionStateEnum return the enum type of this object
func (connectionStateReady *ConnectionStateReady) GetConnectionStateEnum() ConnectionStateEnum {
	return ConnectionStateReadyType
}

// TopChatCategoryUsers A category containing frequently used private chats with non-bot users
type TopChatCategoryUsers struct {
	tdCommon
}

// MessageType return the string telegram-type of TopChatCategoryUsers
func (topChatCategoryUsers *TopChatCategoryUsers) MessageType() string {
	return "topChatCategoryUsers"
}

// NewTopChatCategoryUsers creates a new TopChatCategoryUsers
//
func NewTopChatCategoryUsers() *TopChatCategoryUsers {
	topChatCategoryUsersTemp := TopChatCategoryUsers{
		tdCommon: tdCommon{Type: "topChatCategoryUsers"},
	}

	return &topChatCategoryUsersTemp
}

// UnmarshalJSON unmarshal to json
func (topChatCategoryUsers *TopChatCategoryUsers) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	topChatCategoryUsers.tdCommon = tempObj.tdCommon

	return nil
}

// GetTopChatCategoryEnum return the enum type of this object
func (topChatCategoryUsers *TopChatCategoryUsers) GetTopChatCategoryEnum() TopChatCategoryEnum {
	return TopChatCategoryUsersType
}

// TopChatCategoryBots A category containing frequently used private chats with bot users
type TopChatCategoryBots struct {
	tdCommon
}

// MessageType return the string telegram-type of TopChatCategoryBots
func (topChatCategoryBots *TopChatCategoryBots) MessageType() string {
	return "topChatCategoryBots"
}

// NewTopChatCategoryBots creates a new TopChatCategoryBots
//
func NewTopChatCategoryBots() *TopChatCategoryBots {
	topChatCategoryBotsTemp := TopChatCategoryBots{
		tdCommon: tdCommon{Type: "topChatCategoryBots"},
	}

	return &topChatCategoryBotsTemp
}

// UnmarshalJSON unmarshal to json
func (topChatCategoryBots *TopChatCategoryBots) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	topChatCategoryBots.tdCommon = tempObj.tdCommon

	return nil
}

// GetTopChatCategoryEnum return the enum type of this object
func (topChatCategoryBots *TopChatCategoryBots) GetTopChatCategoryEnum() TopChatCategoryEnum {
	return TopChatCategoryBotsType
}

// TopChatCategoryGroups A category containing frequently used basic groups and supergroups
type TopChatCategoryGroups struct {
	tdCommon
}

// MessageType return the string telegram-type of TopChatCategoryGroups
func (topChatCategoryGroups *TopChatCategoryGroups) MessageType() string {
	return "topChatCategoryGroups"
}

// NewTopChatCategoryGroups creates a new TopChatCategoryGroups
//
func NewTopChatCategoryGroups() *TopChatCategoryGroups {
	topChatCategoryGroupsTemp := TopChatCategoryGroups{
		tdCommon: tdCommon{Type: "topChatCategoryGroups"},
	}

	return &topChatCategoryGroupsTemp
}

// UnmarshalJSON unmarshal to json
func (topChatCategoryGroups *TopChatCategoryGroups) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	topChatCategoryGroups.tdCommon = tempObj.tdCommon

	return nil
}

// GetTopChatCategoryEnum return the enum type of this object
func (topChatCategoryGroups *TopChatCategoryGroups) GetTopChatCategoryEnum() TopChatCategoryEnum {
	return TopChatCategoryGroupsType
}

// TopChatCategoryChannels A category containing frequently used channels
type TopChatCategoryChannels struct {
	tdCommon
}

// MessageType return the string telegram-type of TopChatCategoryChannels
func (topChatCategoryChannels *TopChatCategoryChannels) MessageType() string {
	return "topChatCategoryChannels"
}

// NewTopChatCategoryChannels creates a new TopChatCategoryChannels
//
func NewTopChatCategoryChannels() *TopChatCategoryChannels {
	topChatCategoryChannelsTemp := TopChatCategoryChannels{
		tdCommon: tdCommon{Type: "topChatCategoryChannels"},
	}

	return &topChatCategoryChannelsTemp
}

// UnmarshalJSON unmarshal to json
func (topChatCategoryChannels *TopChatCategoryChannels) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	topChatCategoryChannels.tdCommon = tempObj.tdCommon

	return nil
}

// GetTopChatCategoryEnum return the enum type of this object
func (topChatCategoryChannels *TopChatCategoryChannels) GetTopChatCategoryEnum() TopChatCategoryEnum {
	return TopChatCategoryChannelsType
}

// TopChatCategoryInlineBots A category containing frequently used chats with inline bots sorted by their usage in inline mode
type TopChatCategoryInlineBots struct {
	tdCommon
}

// MessageType return the string telegram-type of TopChatCategoryInlineBots
func (topChatCategoryInlineBots *TopChatCategoryInlineBots) MessageType() string {
	return "topChatCategoryInlineBots"
}

// NewTopChatCategoryInlineBots creates a new TopChatCategoryInlineBots
//
func NewTopChatCategoryInlineBots() *TopChatCategoryInlineBots {
	topChatCategoryInlineBotsTemp := TopChatCategoryInlineBots{
		tdCommon: tdCommon{Type: "topChatCategoryInlineBots"},
	}

	return &topChatCategoryInlineBotsTemp
}

// UnmarshalJSON unmarshal to json
func (topChatCategoryInlineBots *TopChatCategoryInlineBots) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	topChatCategoryInlineBots.tdCommon = tempObj.tdCommon

	return nil
}

// GetTopChatCategoryEnum return the enum type of this object
func (topChatCategoryInlineBots *TopChatCategoryInlineBots) GetTopChatCategoryEnum() TopChatCategoryEnum {
	return TopChatCategoryInlineBotsType
}

// TopChatCategoryWebAppBots A category containing frequently used chats with bots, which Web Apps were opened
type TopChatCategoryWebAppBots struct {
	tdCommon
}

// MessageType return the string telegram-type of TopChatCategoryWebAppBots
func (topChatCategoryWebAppBots *TopChatCategoryWebAppBots) MessageType() string {
	return "topChatCategoryWebAppBots"
}

// NewTopChatCategoryWebAppBots creates a new TopChatCategoryWebAppBots
//
func NewTopChatCategoryWebAppBots() *TopChatCategoryWebAppBots {
	topChatCategoryWebAppBotsTemp := TopChatCategoryWebAppBots{
		tdCommon: tdCommon{Type: "topChatCategoryWebAppBots"},
	}

	return &topChatCategoryWebAppBotsTemp
}

// UnmarshalJSON unmarshal to json
func (topChatCategoryWebAppBots *TopChatCategoryWebAppBots) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	topChatCategoryWebAppBots.tdCommon = tempObj.tdCommon

	return nil
}

// GetTopChatCategoryEnum return the enum type of this object
func (topChatCategoryWebAppBots *TopChatCategoryWebAppBots) GetTopChatCategoryEnum() TopChatCategoryEnum {
	return TopChatCategoryWebAppBotsType
}

// TopChatCategoryCalls A category containing frequently used chats used for calls
type TopChatCategoryCalls struct {
	tdCommon
}

// MessageType return the string telegram-type of TopChatCategoryCalls
func (topChatCategoryCalls *TopChatCategoryCalls) MessageType() string {
	return "topChatCategoryCalls"
}

// NewTopChatCategoryCalls creates a new TopChatCategoryCalls
//
func NewTopChatCategoryCalls() *TopChatCategoryCalls {
	topChatCategoryCallsTemp := TopChatCategoryCalls{
		tdCommon: tdCommon{Type: "topChatCategoryCalls"},
	}

	return &topChatCategoryCallsTemp
}

// UnmarshalJSON unmarshal to json
func (topChatCategoryCalls *TopChatCategoryCalls) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	topChatCategoryCalls.tdCommon = tempObj.tdCommon

	return nil
}

// GetTopChatCategoryEnum return the enum type of this object
func (topChatCategoryCalls *TopChatCategoryCalls) GetTopChatCategoryEnum() TopChatCategoryEnum {
	return TopChatCategoryCallsType
}

// TopChatCategoryForwardChats A category containing frequently used chats used to forward messages
type TopChatCategoryForwardChats struct {
	tdCommon
}

// MessageType return the string telegram-type of TopChatCategoryForwardChats
func (topChatCategoryForwardChats *TopChatCategoryForwardChats) MessageType() string {
	return "topChatCategoryForwardChats"
}

// NewTopChatCategoryForwardChats creates a new TopChatCategoryForwardChats
//
func NewTopChatCategoryForwardChats() *TopChatCategoryForwardChats {
	topChatCategoryForwardChatsTemp := TopChatCategoryForwardChats{
		tdCommon: tdCommon{Type: "topChatCategoryForwardChats"},
	}

	return &topChatCategoryForwardChatsTemp
}

// UnmarshalJSON unmarshal to json
func (topChatCategoryForwardChats *TopChatCategoryForwardChats) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	topChatCategoryForwardChats.tdCommon = tempObj.tdCommon

	return nil
}

// GetTopChatCategoryEnum return the enum type of this object
func (topChatCategoryForwardChats *TopChatCategoryForwardChats) GetTopChatCategoryEnum() TopChatCategoryEnum {
	return TopChatCategoryForwardChatsType
}

// FoundPosition Contains 0-based match position
type FoundPosition struct {
	tdCommon
	Position int32 `json:"position"` // The position of the match
}

// MessageType return the string telegram-type of FoundPosition
func (foundPosition *FoundPosition) MessageType() string {
	return "foundPosition"
}

// NewFoundPosition creates a new FoundPosition
//
// @param position The position of the match
func NewFoundPosition(position int32) *FoundPosition {
	foundPositionTemp := FoundPosition{
		tdCommon: tdCommon{Type: "foundPosition"},
		Position: position,
	}

	return &foundPositionTemp
}

// UnmarshalJSON unmarshal to json
func (foundPosition *FoundPosition) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Position int32 `json:"position"` // The position of the match
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	foundPosition.tdCommon = tempObj.tdCommon
	foundPosition.Position = tempObj.Position

	return nil
}

// FoundPositions Contains 0-based positions of matched objects
type FoundPositions struct {
	tdCommon
	TotalCount int32   `json:"total_count"` // Total number of matched objects
	Positions  []int32 `json:"positions"`   // The positions of the matched objects
}

// MessageType return the string telegram-type of FoundPositions
func (foundPositions *FoundPositions) MessageType() string {
	return "foundPositions"
}

// NewFoundPositions creates a new FoundPositions
//
// @param totalCount Total number of matched objects
// @param positions The positions of the matched objects
func NewFoundPositions(totalCount int32, positions []int32) *FoundPositions {
	foundPositionsTemp := FoundPositions{
		tdCommon:   tdCommon{Type: "foundPositions"},
		TotalCount: totalCount,
		Positions:  positions,
	}

	return &foundPositionsTemp
}

// UnmarshalJSON unmarshal to json
func (foundPositions *FoundPositions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount int32   `json:"total_count"` // Total number of matched objects
		Positions  []int32 `json:"positions"`   // The positions of the matched objects
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	foundPositions.tdCommon = tempObj.tdCommon
	foundPositions.TotalCount = tempObj.TotalCount
	foundPositions.Positions = tempObj.Positions

	return nil
}

// TMeURLTypeUser A URL linking to a user
type TMeURLTypeUser struct {
	tdCommon
	UserID int64 `json:"user_id"` // Identifier of the user
}

// MessageType return the string telegram-type of TMeURLTypeUser
func (tMeURLTypeUser *TMeURLTypeUser) MessageType() string {
	return "tMeUrlTypeUser"
}

// NewTMeURLTypeUser creates a new TMeURLTypeUser
//
// @param userID Identifier of the user
func NewTMeURLTypeUser(userID int64) *TMeURLTypeUser {
	tMeURLTypeUserTemp := TMeURLTypeUser{
		tdCommon: tdCommon{Type: "tMeUrlTypeUser"},
		UserID:   userID,
	}

	return &tMeURLTypeUserTemp
}

// UnmarshalJSON unmarshal to json
func (tMeURLTypeUser *TMeURLTypeUser) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID int64 `json:"user_id"` // Identifier of the user
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	tMeURLTypeUser.tdCommon = tempObj.tdCommon
	tMeURLTypeUser.UserID = tempObj.UserID

	return nil
}

// TMeURLTypeSupergroup A URL linking to a public supergroup or channel
type TMeURLTypeSupergroup struct {
	tdCommon
	SupergroupID int64 `json:"supergroup_id"` // Identifier of the supergroup or channel
}

// MessageType return the string telegram-type of TMeURLTypeSupergroup
func (tMeURLTypeSupergroup *TMeURLTypeSupergroup) MessageType() string {
	return "tMeUrlTypeSupergroup"
}

// NewTMeURLTypeSupergroup creates a new TMeURLTypeSupergroup
//
// @param supergroupID Identifier of the supergroup or channel
func NewTMeURLTypeSupergroup(supergroupID int64) *TMeURLTypeSupergroup {
	tMeURLTypeSupergroupTemp := TMeURLTypeSupergroup{
		tdCommon:     tdCommon{Type: "tMeUrlTypeSupergroup"},
		SupergroupID: supergroupID,
	}

	return &tMeURLTypeSupergroupTemp
}

// UnmarshalJSON unmarshal to json
func (tMeURLTypeSupergroup *TMeURLTypeSupergroup) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SupergroupID int64 `json:"supergroup_id"` // Identifier of the supergroup or channel
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	tMeURLTypeSupergroup.tdCommon = tempObj.tdCommon
	tMeURLTypeSupergroup.SupergroupID = tempObj.SupergroupID

	return nil
}

// TMeURLTypeChatInvite A chat invite link
type TMeURLTypeChatInvite struct {
	tdCommon
	Info *ChatInviteLinkInfo `json:"info"` // Information about the chat invite link
}

// MessageType return the string telegram-type of TMeURLTypeChatInvite
func (tMeURLTypeChatInvite *TMeURLTypeChatInvite) MessageType() string {
	return "tMeUrlTypeChatInvite"
}

// NewTMeURLTypeChatInvite creates a new TMeURLTypeChatInvite
//
// @param info Information about the chat invite link
func NewTMeURLTypeChatInvite(info *ChatInviteLinkInfo) *TMeURLTypeChatInvite {
	tMeURLTypeChatInviteTemp := TMeURLTypeChatInvite{
		tdCommon: tdCommon{Type: "tMeUrlTypeChatInvite"},
		Info:     info,
	}

	return &tMeURLTypeChatInviteTemp
}

// UnmarshalJSON unmarshal to json
func (tMeURLTypeChatInvite *TMeURLTypeChatInvite) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	tMeURLTypeChatInvite.tdCommon = tempObj.tdCommon

	var info ChatInviteLinkInfo
	if objMap["info"] != nil {
		err = info.UnmarshalJSON(*objMap["info"])
		if err != nil {
			return err
		}
	}

	tMeURLTypeChatInvite.Info = &info

	return nil
}

// TMeURLTypeStickerSet A URL linking to a sticker set
type TMeURLTypeStickerSet struct {
	tdCommon
	StickerSetID JSONInt64 `json:"sticker_set_id"` // Identifier of the sticker set
}

// MessageType return the string telegram-type of TMeURLTypeStickerSet
func (tMeURLTypeStickerSet *TMeURLTypeStickerSet) MessageType() string {
	return "tMeUrlTypeStickerSet"
}

// NewTMeURLTypeStickerSet creates a new TMeURLTypeStickerSet
//
// @param stickerSetID Identifier of the sticker set
func NewTMeURLTypeStickerSet(stickerSetID JSONInt64) *TMeURLTypeStickerSet {
	tMeURLTypeStickerSetTemp := TMeURLTypeStickerSet{
		tdCommon:     tdCommon{Type: "tMeUrlTypeStickerSet"},
		StickerSetID: stickerSetID,
	}

	return &tMeURLTypeStickerSetTemp
}

// UnmarshalJSON unmarshal to json
func (tMeURLTypeStickerSet *TMeURLTypeStickerSet) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StickerSetID JSONInt64 `json:"sticker_set_id"` // Identifier of the sticker set
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	tMeURLTypeStickerSet.tdCommon = tempObj.tdCommon
	tMeURLTypeStickerSet.StickerSetID = tempObj.StickerSetID

	return nil
}

// TMeURL Represents a URL linking to an internal Telegram entity
type TMeURL struct {
	tdCommon
	URL  string     `json:"url"`  // URL
	Type TMeURLType `json:"type"` // Type of the URL
}

// MessageType return the string telegram-type of TMeURL
func (tMeURL *TMeURL) MessageType() string {
	return "tMeUrl"
}

// NewTMeURL creates a new TMeURL
//
// @param uRL URL
// @param typeParam Type of the URL
func NewTMeURL(uRL string, typeParam TMeURLType) *TMeURL {
	tMeURLTemp := TMeURL{
		tdCommon: tdCommon{Type: "tMeUrl"},
		URL:      uRL,
		Type:     typeParam,
	}

	return &tMeURLTemp
}

// UnmarshalJSON unmarshal to json
func (tMeURL *TMeURL) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URL string `json:"url"` // URL

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	tMeURL.tdCommon = tempObj.tdCommon
	tMeURL.URL = tempObj.URL

	fieldType, _ := unmarshalTMeURLType(objMap["type"])
	tMeURL.Type = fieldType

	return nil
}

// TMeURLs Contains a list of t.me URLs
type TMeURLs struct {
	tdCommon
	URLs []TMeURL `json:"urls"` // List of URLs
}

// MessageType return the string telegram-type of TMeURLs
func (tMeURLs *TMeURLs) MessageType() string {
	return "tMeUrls"
}

// NewTMeURLs creates a new TMeURLs
//
// @param uRLs List of URLs
func NewTMeURLs(uRLs []TMeURL) *TMeURLs {
	tMeURLsTemp := TMeURLs{
		tdCommon: tdCommon{Type: "tMeUrls"},
		URLs:     uRLs,
	}

	return &tMeURLsTemp
}

// UnmarshalJSON unmarshal to json
func (tMeURLs *TMeURLs) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		URLs []TMeURL `json:"urls"` // List of URLs
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	tMeURLs.tdCommon = tempObj.tdCommon
	tMeURLs.URLs = tempObj.URLs

	return nil
}

// SuggestedActionEnableArchiveAndMuteNewChats Suggests the user to enable archive_and_mute_new_chats_from_unknown_users setting in archiveChatListSettings
type SuggestedActionEnableArchiveAndMuteNewChats struct {
	tdCommon
}

// MessageType return the string telegram-type of SuggestedActionEnableArchiveAndMuteNewChats
func (suggestedActionEnableArchiveAndMuteNewChats *SuggestedActionEnableArchiveAndMuteNewChats) MessageType() string {
	return "suggestedActionEnableArchiveAndMuteNewChats"
}

// NewSuggestedActionEnableArchiveAndMuteNewChats creates a new SuggestedActionEnableArchiveAndMuteNewChats
//
func NewSuggestedActionEnableArchiveAndMuteNewChats() *SuggestedActionEnableArchiveAndMuteNewChats {
	suggestedActionEnableArchiveAndMuteNewChatsTemp := SuggestedActionEnableArchiveAndMuteNewChats{
		tdCommon: tdCommon{Type: "suggestedActionEnableArchiveAndMuteNewChats"},
	}

	return &suggestedActionEnableArchiveAndMuteNewChatsTemp
}

// UnmarshalJSON unmarshal to json
func (suggestedActionEnableArchiveAndMuteNewChats *SuggestedActionEnableArchiveAndMuteNewChats) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	suggestedActionEnableArchiveAndMuteNewChats.tdCommon = tempObj.tdCommon

	return nil
}

// GetSuggestedActionEnum return the enum type of this object
func (suggestedActionEnableArchiveAndMuteNewChats *SuggestedActionEnableArchiveAndMuteNewChats) GetSuggestedActionEnum() SuggestedActionEnum {
	return SuggestedActionEnableArchiveAndMuteNewChatsType
}

// SuggestedActionCheckPassword Suggests the user to check whether they still remember their 2-step verification password
type SuggestedActionCheckPassword struct {
	tdCommon
}

// MessageType return the string telegram-type of SuggestedActionCheckPassword
func (suggestedActionCheckPassword *SuggestedActionCheckPassword) MessageType() string {
	return "suggestedActionCheckPassword"
}

// NewSuggestedActionCheckPassword creates a new SuggestedActionCheckPassword
//
func NewSuggestedActionCheckPassword() *SuggestedActionCheckPassword {
	suggestedActionCheckPasswordTemp := SuggestedActionCheckPassword{
		tdCommon: tdCommon{Type: "suggestedActionCheckPassword"},
	}

	return &suggestedActionCheckPasswordTemp
}

// UnmarshalJSON unmarshal to json
func (suggestedActionCheckPassword *SuggestedActionCheckPassword) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	suggestedActionCheckPassword.tdCommon = tempObj.tdCommon

	return nil
}

// GetSuggestedActionEnum return the enum type of this object
func (suggestedActionCheckPassword *SuggestedActionCheckPassword) GetSuggestedActionEnum() SuggestedActionEnum {
	return SuggestedActionCheckPasswordType
}

// SuggestedActionCheckPhoneNumber Suggests the user to check whether authorization phone number is correct and change the phone number if it is inaccessible
type SuggestedActionCheckPhoneNumber struct {
	tdCommon
}

// MessageType return the string telegram-type of SuggestedActionCheckPhoneNumber
func (suggestedActionCheckPhoneNumber *SuggestedActionCheckPhoneNumber) MessageType() string {
	return "suggestedActionCheckPhoneNumber"
}

// NewSuggestedActionCheckPhoneNumber creates a new SuggestedActionCheckPhoneNumber
//
func NewSuggestedActionCheckPhoneNumber() *SuggestedActionCheckPhoneNumber {
	suggestedActionCheckPhoneNumberTemp := SuggestedActionCheckPhoneNumber{
		tdCommon: tdCommon{Type: "suggestedActionCheckPhoneNumber"},
	}

	return &suggestedActionCheckPhoneNumberTemp
}

// UnmarshalJSON unmarshal to json
func (suggestedActionCheckPhoneNumber *SuggestedActionCheckPhoneNumber) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	suggestedActionCheckPhoneNumber.tdCommon = tempObj.tdCommon

	return nil
}

// GetSuggestedActionEnum return the enum type of this object
func (suggestedActionCheckPhoneNumber *SuggestedActionCheckPhoneNumber) GetSuggestedActionEnum() SuggestedActionEnum {
	return SuggestedActionCheckPhoneNumberType
}

// SuggestedActionViewChecksHint Suggests the user to view a hint about the meaning of one and two check marks on sent messages
type SuggestedActionViewChecksHint struct {
	tdCommon
}

// MessageType return the string telegram-type of SuggestedActionViewChecksHint
func (suggestedActionViewChecksHint *SuggestedActionViewChecksHint) MessageType() string {
	return "suggestedActionViewChecksHint"
}

// NewSuggestedActionViewChecksHint creates a new SuggestedActionViewChecksHint
//
func NewSuggestedActionViewChecksHint() *SuggestedActionViewChecksHint {
	suggestedActionViewChecksHintTemp := SuggestedActionViewChecksHint{
		tdCommon: tdCommon{Type: "suggestedActionViewChecksHint"},
	}

	return &suggestedActionViewChecksHintTemp
}

// UnmarshalJSON unmarshal to json
func (suggestedActionViewChecksHint *SuggestedActionViewChecksHint) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	suggestedActionViewChecksHint.tdCommon = tempObj.tdCommon

	return nil
}

// GetSuggestedActionEnum return the enum type of this object
func (suggestedActionViewChecksHint *SuggestedActionViewChecksHint) GetSuggestedActionEnum() SuggestedActionEnum {
	return SuggestedActionViewChecksHintType
}

// SuggestedActionConvertToBroadcastGroup Suggests the user to convert specified supergroup to a broadcast group
type SuggestedActionConvertToBroadcastGroup struct {
	tdCommon
	SupergroupID int64 `json:"supergroup_id"` // Supergroup identifier
}

// MessageType return the string telegram-type of SuggestedActionConvertToBroadcastGroup
func (suggestedActionConvertToBroadcastGroup *SuggestedActionConvertToBroadcastGroup) MessageType() string {
	return "suggestedActionConvertToBroadcastGroup"
}

// NewSuggestedActionConvertToBroadcastGroup creates a new SuggestedActionConvertToBroadcastGroup
//
// @param supergroupID Supergroup identifier
func NewSuggestedActionConvertToBroadcastGroup(supergroupID int64) *SuggestedActionConvertToBroadcastGroup {
	suggestedActionConvertToBroadcastGroupTemp := SuggestedActionConvertToBroadcastGroup{
		tdCommon:     tdCommon{Type: "suggestedActionConvertToBroadcastGroup"},
		SupergroupID: supergroupID,
	}

	return &suggestedActionConvertToBroadcastGroupTemp
}

// UnmarshalJSON unmarshal to json
func (suggestedActionConvertToBroadcastGroup *SuggestedActionConvertToBroadcastGroup) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SupergroupID int64 `json:"supergroup_id"` // Supergroup identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	suggestedActionConvertToBroadcastGroup.tdCommon = tempObj.tdCommon
	suggestedActionConvertToBroadcastGroup.SupergroupID = tempObj.SupergroupID

	return nil
}

// GetSuggestedActionEnum return the enum type of this object
func (suggestedActionConvertToBroadcastGroup *SuggestedActionConvertToBroadcastGroup) GetSuggestedActionEnum() SuggestedActionEnum {
	return SuggestedActionConvertToBroadcastGroupType
}

// SuggestedActionSetPassword Suggests the user to set a 2-step verification password to be able to log in again
type SuggestedActionSetPassword struct {
	tdCommon
	AuthorizationDelay int32 `json:"authorization_delay"` // The number of days to pass between consecutive authorizations if the user declines to set password; if 0, then the user is advised to set the password for security reasons
}

// MessageType return the string telegram-type of SuggestedActionSetPassword
func (suggestedActionSetPassword *SuggestedActionSetPassword) MessageType() string {
	return "suggestedActionSetPassword"
}

// NewSuggestedActionSetPassword creates a new SuggestedActionSetPassword
//
// @param authorizationDelay The number of days to pass between consecutive authorizations if the user declines to set password; if 0, then the user is advised to set the password for security reasons
func NewSuggestedActionSetPassword(authorizationDelay int32) *SuggestedActionSetPassword {
	suggestedActionSetPasswordTemp := SuggestedActionSetPassword{
		tdCommon:           tdCommon{Type: "suggestedActionSetPassword"},
		AuthorizationDelay: authorizationDelay,
	}

	return &suggestedActionSetPasswordTemp
}

// UnmarshalJSON unmarshal to json
func (suggestedActionSetPassword *SuggestedActionSetPassword) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		AuthorizationDelay int32 `json:"authorization_delay"` // The number of days to pass between consecutive authorizations if the user declines to set password; if 0, then the user is advised to set the password for security reasons
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	suggestedActionSetPassword.tdCommon = tempObj.tdCommon
	suggestedActionSetPassword.AuthorizationDelay = tempObj.AuthorizationDelay

	return nil
}

// GetSuggestedActionEnum return the enum type of this object
func (suggestedActionSetPassword *SuggestedActionSetPassword) GetSuggestedActionEnum() SuggestedActionEnum {
	return SuggestedActionSetPasswordType
}

// SuggestedActionUpgradePremium Suggests the user to upgrade the Premium subscription from monthly payments to annual payments
type SuggestedActionUpgradePremium struct {
	tdCommon
}

// MessageType return the string telegram-type of SuggestedActionUpgradePremium
func (suggestedActionUpgradePremium *SuggestedActionUpgradePremium) MessageType() string {
	return "suggestedActionUpgradePremium"
}

// NewSuggestedActionUpgradePremium creates a new SuggestedActionUpgradePremium
//
func NewSuggestedActionUpgradePremium() *SuggestedActionUpgradePremium {
	suggestedActionUpgradePremiumTemp := SuggestedActionUpgradePremium{
		tdCommon: tdCommon{Type: "suggestedActionUpgradePremium"},
	}

	return &suggestedActionUpgradePremiumTemp
}

// UnmarshalJSON unmarshal to json
func (suggestedActionUpgradePremium *SuggestedActionUpgradePremium) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	suggestedActionUpgradePremium.tdCommon = tempObj.tdCommon

	return nil
}

// GetSuggestedActionEnum return the enum type of this object
func (suggestedActionUpgradePremium *SuggestedActionUpgradePremium) GetSuggestedActionEnum() SuggestedActionEnum {
	return SuggestedActionUpgradePremiumType
}

// SuggestedActionRestorePremium Suggests the user to restore a recently expired Premium subscription
type SuggestedActionRestorePremium struct {
	tdCommon
}

// MessageType return the string telegram-type of SuggestedActionRestorePremium
func (suggestedActionRestorePremium *SuggestedActionRestorePremium) MessageType() string {
	return "suggestedActionRestorePremium"
}

// NewSuggestedActionRestorePremium creates a new SuggestedActionRestorePremium
//
func NewSuggestedActionRestorePremium() *SuggestedActionRestorePremium {
	suggestedActionRestorePremiumTemp := SuggestedActionRestorePremium{
		tdCommon: tdCommon{Type: "suggestedActionRestorePremium"},
	}

	return &suggestedActionRestorePremiumTemp
}

// UnmarshalJSON unmarshal to json
func (suggestedActionRestorePremium *SuggestedActionRestorePremium) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	suggestedActionRestorePremium.tdCommon = tempObj.tdCommon

	return nil
}

// GetSuggestedActionEnum return the enum type of this object
func (suggestedActionRestorePremium *SuggestedActionRestorePremium) GetSuggestedActionEnum() SuggestedActionEnum {
	return SuggestedActionRestorePremiumType
}

// SuggestedActionSubscribeToAnnualPremium Suggests the user to subscribe to the Premium subscription with annual payments
type SuggestedActionSubscribeToAnnualPremium struct {
	tdCommon
}

// MessageType return the string telegram-type of SuggestedActionSubscribeToAnnualPremium
func (suggestedActionSubscribeToAnnualPremium *SuggestedActionSubscribeToAnnualPremium) MessageType() string {
	return "suggestedActionSubscribeToAnnualPremium"
}

// NewSuggestedActionSubscribeToAnnualPremium creates a new SuggestedActionSubscribeToAnnualPremium
//
func NewSuggestedActionSubscribeToAnnualPremium() *SuggestedActionSubscribeToAnnualPremium {
	suggestedActionSubscribeToAnnualPremiumTemp := SuggestedActionSubscribeToAnnualPremium{
		tdCommon: tdCommon{Type: "suggestedActionSubscribeToAnnualPremium"},
	}

	return &suggestedActionSubscribeToAnnualPremiumTemp
}

// UnmarshalJSON unmarshal to json
func (suggestedActionSubscribeToAnnualPremium *SuggestedActionSubscribeToAnnualPremium) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	suggestedActionSubscribeToAnnualPremium.tdCommon = tempObj.tdCommon

	return nil
}

// GetSuggestedActionEnum return the enum type of this object
func (suggestedActionSubscribeToAnnualPremium *SuggestedActionSubscribeToAnnualPremium) GetSuggestedActionEnum() SuggestedActionEnum {
	return SuggestedActionSubscribeToAnnualPremiumType
}

// SuggestedActionGiftPremiumForChristmas Suggests the user to gift Telegram Premium to friends for Christmas
type SuggestedActionGiftPremiumForChristmas struct {
	tdCommon
}

// MessageType return the string telegram-type of SuggestedActionGiftPremiumForChristmas
func (suggestedActionGiftPremiumForChristmas *SuggestedActionGiftPremiumForChristmas) MessageType() string {
	return "suggestedActionGiftPremiumForChristmas"
}

// NewSuggestedActionGiftPremiumForChristmas creates a new SuggestedActionGiftPremiumForChristmas
//
func NewSuggestedActionGiftPremiumForChristmas() *SuggestedActionGiftPremiumForChristmas {
	suggestedActionGiftPremiumForChristmasTemp := SuggestedActionGiftPremiumForChristmas{
		tdCommon: tdCommon{Type: "suggestedActionGiftPremiumForChristmas"},
	}

	return &suggestedActionGiftPremiumForChristmasTemp
}

// UnmarshalJSON unmarshal to json
func (suggestedActionGiftPremiumForChristmas *SuggestedActionGiftPremiumForChristmas) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	suggestedActionGiftPremiumForChristmas.tdCommon = tempObj.tdCommon

	return nil
}

// GetSuggestedActionEnum return the enum type of this object
func (suggestedActionGiftPremiumForChristmas *SuggestedActionGiftPremiumForChristmas) GetSuggestedActionEnum() SuggestedActionEnum {
	return SuggestedActionGiftPremiumForChristmasType
}

// SuggestedActionSetBirthdate Suggests the user to set birthdate
type SuggestedActionSetBirthdate struct {
	tdCommon
}

// MessageType return the string telegram-type of SuggestedActionSetBirthdate
func (suggestedActionSetBirthdate *SuggestedActionSetBirthdate) MessageType() string {
	return "suggestedActionSetBirthdate"
}

// NewSuggestedActionSetBirthdate creates a new SuggestedActionSetBirthdate
//
func NewSuggestedActionSetBirthdate() *SuggestedActionSetBirthdate {
	suggestedActionSetBirthdateTemp := SuggestedActionSetBirthdate{
		tdCommon: tdCommon{Type: "suggestedActionSetBirthdate"},
	}

	return &suggestedActionSetBirthdateTemp
}

// UnmarshalJSON unmarshal to json
func (suggestedActionSetBirthdate *SuggestedActionSetBirthdate) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	suggestedActionSetBirthdate.tdCommon = tempObj.tdCommon

	return nil
}

// GetSuggestedActionEnum return the enum type of this object
func (suggestedActionSetBirthdate *SuggestedActionSetBirthdate) GetSuggestedActionEnum() SuggestedActionEnum {
	return SuggestedActionSetBirthdateType
}

// SuggestedActionExtendPremium Suggests the user to extend their expiring Telegram Premium subscription
type SuggestedActionExtendPremium struct {
	tdCommon
	ManagePremiumSubscriptionURL string `json:"manage_premium_subscription_url"` // A URL for managing Telegram Premium subscription
}

// MessageType return the string telegram-type of SuggestedActionExtendPremium
func (suggestedActionExtendPremium *SuggestedActionExtendPremium) MessageType() string {
	return "suggestedActionExtendPremium"
}

// NewSuggestedActionExtendPremium creates a new SuggestedActionExtendPremium
//
// @param managePremiumSubscriptionURL A URL for managing Telegram Premium subscription
func NewSuggestedActionExtendPremium(managePremiumSubscriptionURL string) *SuggestedActionExtendPremium {
	suggestedActionExtendPremiumTemp := SuggestedActionExtendPremium{
		tdCommon:                     tdCommon{Type: "suggestedActionExtendPremium"},
		ManagePremiumSubscriptionURL: managePremiumSubscriptionURL,
	}

	return &suggestedActionExtendPremiumTemp
}

// UnmarshalJSON unmarshal to json
func (suggestedActionExtendPremium *SuggestedActionExtendPremium) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ManagePremiumSubscriptionURL string `json:"manage_premium_subscription_url"` // A URL for managing Telegram Premium subscription
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	suggestedActionExtendPremium.tdCommon = tempObj.tdCommon
	suggestedActionExtendPremium.ManagePremiumSubscriptionURL = tempObj.ManagePremiumSubscriptionURL

	return nil
}

// GetSuggestedActionEnum return the enum type of this object
func (suggestedActionExtendPremium *SuggestedActionExtendPremium) GetSuggestedActionEnum() SuggestedActionEnum {
	return SuggestedActionExtendPremiumType
}

// SuggestedActionExtendStarSubscriptions Suggests the user to extend their expiring Telegram Star subscriptions. Call getStarSubscriptions with only_expiring == true to get the number of expiring subscriptions and the number of required to buy Telegram Stars
type SuggestedActionExtendStarSubscriptions struct {
	tdCommon
}

// MessageType return the string telegram-type of SuggestedActionExtendStarSubscriptions
func (suggestedActionExtendStarSubscriptions *SuggestedActionExtendStarSubscriptions) MessageType() string {
	return "suggestedActionExtendStarSubscriptions"
}

// NewSuggestedActionExtendStarSubscriptions creates a new SuggestedActionExtendStarSubscriptions
//
func NewSuggestedActionExtendStarSubscriptions() *SuggestedActionExtendStarSubscriptions {
	suggestedActionExtendStarSubscriptionsTemp := SuggestedActionExtendStarSubscriptions{
		tdCommon: tdCommon{Type: "suggestedActionExtendStarSubscriptions"},
	}

	return &suggestedActionExtendStarSubscriptionsTemp
}

// UnmarshalJSON unmarshal to json
func (suggestedActionExtendStarSubscriptions *SuggestedActionExtendStarSubscriptions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	suggestedActionExtendStarSubscriptions.tdCommon = tempObj.tdCommon

	return nil
}

// GetSuggestedActionEnum return the enum type of this object
func (suggestedActionExtendStarSubscriptions *SuggestedActionExtendStarSubscriptions) GetSuggestedActionEnum() SuggestedActionEnum {
	return SuggestedActionExtendStarSubscriptionsType
}

// Count Contains a counter
type Count struct {
	tdCommon
	Count int32 `json:"count"` // Count
}

// MessageType return the string telegram-type of Count
func (count *Count) MessageType() string {
	return "count"
}

// NewCount creates a new Count
//
// @param count Count
func NewCount(count int32) *Count {
	countTemp := Count{
		tdCommon: tdCommon{Type: "count"},
		Count:    count,
	}

	return &countTemp
}

// UnmarshalJSON unmarshal to json
func (count *Count) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Count int32 `json:"count"` // Count
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	count.tdCommon = tempObj.tdCommon
	count.Count = tempObj.Count

	return nil
}

// Text Contains some text
type Text struct {
	tdCommon
	Text string `json:"text"` // Text
}

// MessageType return the string telegram-type of Text
func (text *Text) MessageType() string {
	return "text"
}

// NewText creates a new Text
//
// @param text Text
func NewText(text string) *Text {
	textTemp := Text{
		tdCommon: tdCommon{Type: "text"},
		Text:     text,
	}

	return &textTemp
}

// UnmarshalJSON unmarshal to json
func (text *Text) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Text string `json:"text"` // Text
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	text.tdCommon = tempObj.tdCommon
	text.Text = tempObj.Text

	return nil
}

// Seconds Contains a value representing a number of seconds
type Seconds struct {
	tdCommon
	Seconds float64 `json:"seconds"` // Number of seconds
}

// MessageType return the string telegram-type of Seconds
func (seconds *Seconds) MessageType() string {
	return "seconds"
}

// NewSeconds creates a new Seconds
//
// @param seconds Number of seconds
func NewSeconds(seconds float64) *Seconds {
	secondsTemp := Seconds{
		tdCommon: tdCommon{Type: "seconds"},
		Seconds:  seconds,
	}

	return &secondsTemp
}

// UnmarshalJSON unmarshal to json
func (seconds *Seconds) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Seconds float64 `json:"seconds"` // Number of seconds
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	seconds.tdCommon = tempObj.tdCommon
	seconds.Seconds = tempObj.Seconds

	return nil
}

// FileDownloadedPrefixSize Contains size of downloaded prefix of a file
type FileDownloadedPrefixSize struct {
	tdCommon
	Size int64 `json:"size"` // The prefix size, in bytes
}

// MessageType return the string telegram-type of FileDownloadedPrefixSize
func (fileDownloadedPrefixSize *FileDownloadedPrefixSize) MessageType() string {
	return "fileDownloadedPrefixSize"
}

// NewFileDownloadedPrefixSize creates a new FileDownloadedPrefixSize
//
// @param size The prefix size, in bytes
func NewFileDownloadedPrefixSize(size int64) *FileDownloadedPrefixSize {
	fileDownloadedPrefixSizeTemp := FileDownloadedPrefixSize{
		tdCommon: tdCommon{Type: "fileDownloadedPrefixSize"},
		Size:     size,
	}

	return &fileDownloadedPrefixSizeTemp
}

// UnmarshalJSON unmarshal to json
func (fileDownloadedPrefixSize *FileDownloadedPrefixSize) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Size int64 `json:"size"` // The prefix size, in bytes
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	fileDownloadedPrefixSize.tdCommon = tempObj.tdCommon
	fileDownloadedPrefixSize.Size = tempObj.Size

	return nil
}

// DeepLinkInfo Contains information about a tg: deep link
type DeepLinkInfo struct {
	tdCommon
	Text                  *FormattedText `json:"text"`                    // Text to be shown to the user
	NeedUpdateApplication bool           `json:"need_update_application"` // True, if the user must be asked to update the application
}

// MessageType return the string telegram-type of DeepLinkInfo
func (deepLinkInfo *DeepLinkInfo) MessageType() string {
	return "deepLinkInfo"
}

// NewDeepLinkInfo creates a new DeepLinkInfo
//
// @param text Text to be shown to the user
// @param needUpdateApplication True, if the user must be asked to update the application
func NewDeepLinkInfo(text *FormattedText, needUpdateApplication bool) *DeepLinkInfo {
	deepLinkInfoTemp := DeepLinkInfo{
		tdCommon:              tdCommon{Type: "deepLinkInfo"},
		Text:                  text,
		NeedUpdateApplication: needUpdateApplication,
	}

	return &deepLinkInfoTemp
}

// UnmarshalJSON unmarshal to json
func (deepLinkInfo *DeepLinkInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Text                  *FormattedText `json:"text"`                    // Text to be shown to the user
		NeedUpdateApplication bool           `json:"need_update_application"` // True, if the user must be asked to update the application
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	deepLinkInfo.tdCommon = tempObj.tdCommon
	deepLinkInfo.Text = tempObj.Text
	deepLinkInfo.NeedUpdateApplication = tempObj.NeedUpdateApplication

	return nil
}

// TextParseModeMarkdown The text uses Markdown-style formatting
type TextParseModeMarkdown struct {
	tdCommon
	Version int32 `json:"version"` // Version of the parser: 0 or 1 - Telegram Bot API "Markdown" parse mode, 2 - Telegram Bot API "MarkdownV2" parse mode
}

// MessageType return the string telegram-type of TextParseModeMarkdown
func (textParseModeMarkdown *TextParseModeMarkdown) MessageType() string {
	return "textParseModeMarkdown"
}

// NewTextParseModeMarkdown creates a new TextParseModeMarkdown
//
// @param version Version of the parser: 0 or 1 - Telegram Bot API "Markdown" parse mode, 2 - Telegram Bot API "MarkdownV2" parse mode
func NewTextParseModeMarkdown(version int32) *TextParseModeMarkdown {
	textParseModeMarkdownTemp := TextParseModeMarkdown{
		tdCommon: tdCommon{Type: "textParseModeMarkdown"},
		Version:  version,
	}

	return &textParseModeMarkdownTemp
}

// UnmarshalJSON unmarshal to json
func (textParseModeMarkdown *TextParseModeMarkdown) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Version int32 `json:"version"` // Version of the parser: 0 or 1 - Telegram Bot API "Markdown" parse mode, 2 - Telegram Bot API "MarkdownV2" parse mode
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textParseModeMarkdown.tdCommon = tempObj.tdCommon
	textParseModeMarkdown.Version = tempObj.Version

	return nil
}

// GetTextParseModeEnum return the enum type of this object
func (textParseModeMarkdown *TextParseModeMarkdown) GetTextParseModeEnum() TextParseModeEnum {
	return TextParseModeMarkdownType
}

// TextParseModeHTML The text uses HTML-style formatting. The same as Telegram Bot API "HTML" parse mode
type TextParseModeHTML struct {
	tdCommon
}

// MessageType return the string telegram-type of TextParseModeHTML
func (textParseModeHTML *TextParseModeHTML) MessageType() string {
	return "textParseModeHTML"
}

// NewTextParseModeHTML creates a new TextParseModeHTML
//
func NewTextParseModeHTML() *TextParseModeHTML {
	textParseModeHTMLTemp := TextParseModeHTML{
		tdCommon: tdCommon{Type: "textParseModeHTML"},
	}

	return &textParseModeHTMLTemp
}

// UnmarshalJSON unmarshal to json
func (textParseModeHTML *TextParseModeHTML) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	textParseModeHTML.tdCommon = tempObj.tdCommon

	return nil
}

// GetTextParseModeEnum return the enum type of this object
func (textParseModeHTML *TextParseModeHTML) GetTextParseModeEnum() TextParseModeEnum {
	return TextParseModeHTMLType
}

// ProxyTypeSocks5 A SOCKS5 proxy server
type ProxyTypeSocks5 struct {
	tdCommon
	Username string `json:"username"` // Username for logging in; may be empty
	Password string `json:"password"` // Password for logging in; may be empty
}

// MessageType return the string telegram-type of ProxyTypeSocks5
func (proxyTypeSocks5 *ProxyTypeSocks5) MessageType() string {
	return "proxyTypeSocks5"
}

// NewProxyTypeSocks5 creates a new ProxyTypeSocks5
//
// @param username Username for logging in; may be empty
// @param password Password for logging in; may be empty
func NewProxyTypeSocks5(username string, password string) *ProxyTypeSocks5 {
	proxyTypeSocks5Temp := ProxyTypeSocks5{
		tdCommon: tdCommon{Type: "proxyTypeSocks5"},
		Username: username,
		Password: password,
	}

	return &proxyTypeSocks5Temp
}

// UnmarshalJSON unmarshal to json
func (proxyTypeSocks5 *ProxyTypeSocks5) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Username string `json:"username"` // Username for logging in; may be empty
		Password string `json:"password"` // Password for logging in; may be empty
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	proxyTypeSocks5.tdCommon = tempObj.tdCommon
	proxyTypeSocks5.Username = tempObj.Username
	proxyTypeSocks5.Password = tempObj.Password

	return nil
}

// GetProxyTypeEnum return the enum type of this object
func (proxyTypeSocks5 *ProxyTypeSocks5) GetProxyTypeEnum() ProxyTypeEnum {
	return ProxyTypeSocks5Type
}

// ProxyTypeHttp A HTTP transparent proxy server
type ProxyTypeHttp struct {
	tdCommon
	Username string `json:"username"`  // Username for logging in; may be empty
	Password string `json:"password"`  // Password for logging in; may be empty
	HttpOnly bool   `json:"http_only"` // Pass true if the proxy supports only HTTP requests and doesn't support transparent TCP connections via HTTP CONNECT method
}

// MessageType return the string telegram-type of ProxyTypeHttp
func (proxyTypeHttp *ProxyTypeHttp) MessageType() string {
	return "proxyTypeHttp"
}

// NewProxyTypeHttp creates a new ProxyTypeHttp
//
// @param username Username for logging in; may be empty
// @param password Password for logging in; may be empty
// @param httpOnly Pass true if the proxy supports only HTTP requests and doesn't support transparent TCP connections via HTTP CONNECT method
func NewProxyTypeHttp(username string, password string, httpOnly bool) *ProxyTypeHttp {
	proxyTypeHttpTemp := ProxyTypeHttp{
		tdCommon: tdCommon{Type: "proxyTypeHttp"},
		Username: username,
		Password: password,
		HttpOnly: httpOnly,
	}

	return &proxyTypeHttpTemp
}

// UnmarshalJSON unmarshal to json
func (proxyTypeHttp *ProxyTypeHttp) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Username string `json:"username"`  // Username for logging in; may be empty
		Password string `json:"password"`  // Password for logging in; may be empty
		HttpOnly bool   `json:"http_only"` // Pass true if the proxy supports only HTTP requests and doesn't support transparent TCP connections via HTTP CONNECT method
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	proxyTypeHttp.tdCommon = tempObj.tdCommon
	proxyTypeHttp.Username = tempObj.Username
	proxyTypeHttp.Password = tempObj.Password
	proxyTypeHttp.HttpOnly = tempObj.HttpOnly

	return nil
}

// GetProxyTypeEnum return the enum type of this object
func (proxyTypeHttp *ProxyTypeHttp) GetProxyTypeEnum() ProxyTypeEnum {
	return ProxyTypeHttpType
}

// ProxyTypeMtproto An MTProto proxy server
type ProxyTypeMtproto struct {
	tdCommon
	Secret string `json:"secret"` // The proxy's secret in hexadecimal encoding
}

// MessageType return the string telegram-type of ProxyTypeMtproto
func (proxyTypeMtproto *ProxyTypeMtproto) MessageType() string {
	return "proxyTypeMtproto"
}

// NewProxyTypeMtproto creates a new ProxyTypeMtproto
//
// @param secret The proxy's secret in hexadecimal encoding
func NewProxyTypeMtproto(secret string) *ProxyTypeMtproto {
	proxyTypeMtprotoTemp := ProxyTypeMtproto{
		tdCommon: tdCommon{Type: "proxyTypeMtproto"},
		Secret:   secret,
	}

	return &proxyTypeMtprotoTemp
}

// UnmarshalJSON unmarshal to json
func (proxyTypeMtproto *ProxyTypeMtproto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Secret string `json:"secret"` // The proxy's secret in hexadecimal encoding
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	proxyTypeMtproto.tdCommon = tempObj.tdCommon
	proxyTypeMtproto.Secret = tempObj.Secret

	return nil
}

// GetProxyTypeEnum return the enum type of this object
func (proxyTypeMtproto *ProxyTypeMtproto) GetProxyTypeEnum() ProxyTypeEnum {
	return ProxyTypeMtprotoType
}

// Proxy Contains information about a proxy server
type Proxy struct {
	tdCommon
	ID           int32     `json:"id"`             // Unique identifier of the proxy
	Server       string    `json:"server"`         // Proxy server domain or IP address
	Port         int32     `json:"port"`           // Proxy server port
	LastUsedDate int32     `json:"last_used_date"` // Point in time (Unix timestamp) when the proxy was last used; 0 if never
	IsEnabled    bool      `json:"is_enabled"`     // True, if the proxy is enabled now
	Type         ProxyType `json:"type"`           // Type of the proxy
}

// MessageType return the string telegram-type of Proxy
func (proxy *Proxy) MessageType() string {
	return "proxy"
}

// NewProxy creates a new Proxy
//
// @param iD Unique identifier of the proxy
// @param server Proxy server domain or IP address
// @param port Proxy server port
// @param lastUsedDate Point in time (Unix timestamp) when the proxy was last used; 0 if never
// @param isEnabled True, if the proxy is enabled now
// @param typeParam Type of the proxy
func NewProxy(iD int32, server string, port int32, lastUsedDate int32, isEnabled bool, typeParam ProxyType) *Proxy {
	proxyTemp := Proxy{
		tdCommon:     tdCommon{Type: "proxy"},
		ID:           iD,
		Server:       server,
		Port:         port,
		LastUsedDate: lastUsedDate,
		IsEnabled:    isEnabled,
		Type:         typeParam,
	}

	return &proxyTemp
}

// UnmarshalJSON unmarshal to json
func (proxy *Proxy) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID           int32  `json:"id"`             // Unique identifier of the proxy
		Server       string `json:"server"`         // Proxy server domain or IP address
		Port         int32  `json:"port"`           // Proxy server port
		LastUsedDate int32  `json:"last_used_date"` // Point in time (Unix timestamp) when the proxy was last used; 0 if never
		IsEnabled    bool   `json:"is_enabled"`     // True, if the proxy is enabled now

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	proxy.tdCommon = tempObj.tdCommon
	proxy.ID = tempObj.ID
	proxy.Server = tempObj.Server
	proxy.Port = tempObj.Port
	proxy.LastUsedDate = tempObj.LastUsedDate
	proxy.IsEnabled = tempObj.IsEnabled

	fieldType, _ := unmarshalProxyType(objMap["type"])
	proxy.Type = fieldType

	return nil
}

// Proxies Represents a list of proxy servers
type Proxies struct {
	tdCommon
	Proxies []Proxy `json:"proxies"` // List of proxy servers
}

// MessageType return the string telegram-type of Proxies
func (proxies *Proxies) MessageType() string {
	return "proxies"
}

// NewProxies creates a new Proxies
//
// @param proxies List of proxy servers
func NewProxies(proxies []Proxy) *Proxies {
	proxiesTemp := Proxies{
		tdCommon: tdCommon{Type: "proxies"},
		Proxies:  proxies,
	}

	return &proxiesTemp
}

// UnmarshalJSON unmarshal to json
func (proxies *Proxies) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Proxies []Proxy `json:"proxies"` // List of proxy servers
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	proxies.tdCommon = tempObj.tdCommon
	proxies.Proxies = tempObj.Proxies

	return nil
}

// InputSticker A sticker to be added to a sticker set
type InputSticker struct {
	tdCommon
	Sticker      InputFile     `json:"sticker"`       // File with the sticker; must fit in a 512x512 square. For WEBP stickers the file must be in WEBP or PNG format, which will be converted to WEBP server-side. See https://core.telegram.org/animated_stickers#technical-requirements for technical requirements
	Format       StickerFormat `json:"format"`        // Format of the sticker
	Emojis       string        `json:"emojis"`        // String with 1-20 emoji corresponding to the sticker
	MaskPosition *MaskPosition `json:"mask_position"` // Position where the mask is placed; pass null if not specified
	Keywords     []string      `json:"keywords"`      // List of up to 20 keywords with total length up to 64 characters, which can be used to find the sticker
}

// MessageType return the string telegram-type of InputSticker
func (inputSticker *InputSticker) MessageType() string {
	return "inputSticker"
}

// NewInputSticker creates a new InputSticker
//
// @param sticker File with the sticker; must fit in a 512x512 square. For WEBP stickers the file must be in WEBP or PNG format, which will be converted to WEBP server-side. See https://core.telegram.org/animated_stickers#technical-requirements for technical requirements
// @param format Format of the sticker
// @param emojis String with 1-20 emoji corresponding to the sticker
// @param maskPosition Position where the mask is placed; pass null if not specified
// @param keywords List of up to 20 keywords with total length up to 64 characters, which can be used to find the sticker
func NewInputSticker(sticker InputFile, format StickerFormat, emojis string, maskPosition *MaskPosition, keywords []string) *InputSticker {
	inputStickerTemp := InputSticker{
		tdCommon:     tdCommon{Type: "inputSticker"},
		Sticker:      sticker,
		Format:       format,
		Emojis:       emojis,
		MaskPosition: maskPosition,
		Keywords:     keywords,
	}

	return &inputStickerTemp
}

// UnmarshalJSON unmarshal to json
func (inputSticker *InputSticker) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Emojis   string   `json:"emojis"`   // String with 1-20 emoji corresponding to the sticker
		Keywords []string `json:"keywords"` // List of up to 20 keywords with total length up to 64 characters, which can be used to find the sticker
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	inputSticker.tdCommon = tempObj.tdCommon
	inputSticker.Emojis = tempObj.Emojis
	inputSticker.Keywords = tempObj.Keywords

	fieldSticker, _ := unmarshalInputFile(objMap["sticker"])
	inputSticker.Sticker = fieldSticker

	fieldFormat, _ := unmarshalStickerFormat(objMap["format"])
	inputSticker.Format = fieldFormat

	var maskPosition MaskPosition
	if objMap["mask_position"] != nil {
		err = maskPosition.UnmarshalJSON(*objMap["mask_position"])
		if err != nil {
			return err
		}
	}

	inputSticker.MaskPosition = &maskPosition

	return nil
}

// DateRange Represents a date range
type DateRange struct {
	tdCommon
	StartDate int32 `json:"start_date"` // Point in time (Unix timestamp) at which the date range begins
	EndDate   int32 `json:"end_date"`   // Point in time (Unix timestamp) at which the date range ends
}

// MessageType return the string telegram-type of DateRange
func (dateRange *DateRange) MessageType() string {
	return "dateRange"
}

// NewDateRange creates a new DateRange
//
// @param startDate Point in time (Unix timestamp) at which the date range begins
// @param endDate Point in time (Unix timestamp) at which the date range ends
func NewDateRange(startDate int32, endDate int32) *DateRange {
	dateRangeTemp := DateRange{
		tdCommon:  tdCommon{Type: "dateRange"},
		StartDate: startDate,
		EndDate:   endDate,
	}

	return &dateRangeTemp
}

// UnmarshalJSON unmarshal to json
func (dateRange *DateRange) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StartDate int32 `json:"start_date"` // Point in time (Unix timestamp) at which the date range begins
		EndDate   int32 `json:"end_date"`   // Point in time (Unix timestamp) at which the date range ends
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	dateRange.tdCommon = tempObj.tdCommon
	dateRange.StartDate = tempObj.StartDate
	dateRange.EndDate = tempObj.EndDate

	return nil
}

// StatisticalValue A value with information about its recent changes
type StatisticalValue struct {
	tdCommon
	Value                float64 `json:"value"`                  // The current value
	PreviousValue        float64 `json:"previous_value"`         // The value for the previous day
	GrowthRatePercentage float64 `json:"growth_rate_percentage"` // The growth rate of the value, as a percentage
}

// MessageType return the string telegram-type of StatisticalValue
func (statisticalValue *StatisticalValue) MessageType() string {
	return "statisticalValue"
}

// NewStatisticalValue creates a new StatisticalValue
//
// @param value The current value
// @param previousValue The value for the previous day
// @param growthRatePercentage The growth rate of the value, as a percentage
func NewStatisticalValue(value float64, previousValue float64, growthRatePercentage float64) *StatisticalValue {
	statisticalValueTemp := StatisticalValue{
		tdCommon:             tdCommon{Type: "statisticalValue"},
		Value:                value,
		PreviousValue:        previousValue,
		GrowthRatePercentage: growthRatePercentage,
	}

	return &statisticalValueTemp
}

// UnmarshalJSON unmarshal to json
func (statisticalValue *StatisticalValue) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Value                float64 `json:"value"`                  // The current value
		PreviousValue        float64 `json:"previous_value"`         // The value for the previous day
		GrowthRatePercentage float64 `json:"growth_rate_percentage"` // The growth rate of the value, as a percentage
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	statisticalValue.tdCommon = tempObj.tdCommon
	statisticalValue.Value = tempObj.Value
	statisticalValue.PreviousValue = tempObj.PreviousValue
	statisticalValue.GrowthRatePercentage = tempObj.GrowthRatePercentage

	return nil
}

// StatisticalGraphData A graph data
type StatisticalGraphData struct {
	tdCommon
	JsonData  string `json:"json_data"`  // Graph data in JSON format
	ZoomToken string `json:"zoom_token"` // If non-empty, a token which can be used to receive a zoomed in graph
}

// MessageType return the string telegram-type of StatisticalGraphData
func (statisticalGraphData *StatisticalGraphData) MessageType() string {
	return "statisticalGraphData"
}

// NewStatisticalGraphData creates a new StatisticalGraphData
//
// @param jsonStringData Graph data in JSON format
// @param zoomToken If non-empty, a token which can be used to receive a zoomed in graph
func NewStatisticalGraphData(jsonStringData string, zoomToken string) *StatisticalGraphData {
	statisticalGraphDataTemp := StatisticalGraphData{
		tdCommon:  tdCommon{Type: "statisticalGraphData"},
		JsonData:  jsonStringData,
		ZoomToken: zoomToken,
	}

	return &statisticalGraphDataTemp
}

// UnmarshalJSON unmarshal to json
func (statisticalGraphData *StatisticalGraphData) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		JsonData  string `json:"json_data"`  // Graph data in JSON format
		ZoomToken string `json:"zoom_token"` // If non-empty, a token which can be used to receive a zoomed in graph
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	statisticalGraphData.tdCommon = tempObj.tdCommon
	statisticalGraphData.JsonData = tempObj.JsonData
	statisticalGraphData.ZoomToken = tempObj.ZoomToken

	return nil
}

// GetStatisticalGraphEnum return the enum type of this object
func (statisticalGraphData *StatisticalGraphData) GetStatisticalGraphEnum() StatisticalGraphEnum {
	return StatisticalGraphDataType
}

// StatisticalGraphAsync The graph data to be asynchronously loaded through getStatisticalGraph
type StatisticalGraphAsync struct {
	tdCommon
	Token string `json:"token"` // The token to use for data loading
}

// MessageType return the string telegram-type of StatisticalGraphAsync
func (statisticalGraphAsync *StatisticalGraphAsync) MessageType() string {
	return "statisticalGraphAsync"
}

// NewStatisticalGraphAsync creates a new StatisticalGraphAsync
//
// @param token The token to use for data loading
func NewStatisticalGraphAsync(token string) *StatisticalGraphAsync {
	statisticalGraphAsyncTemp := StatisticalGraphAsync{
		tdCommon: tdCommon{Type: "statisticalGraphAsync"},
		Token:    token,
	}

	return &statisticalGraphAsyncTemp
}

// UnmarshalJSON unmarshal to json
func (statisticalGraphAsync *StatisticalGraphAsync) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Token string `json:"token"` // The token to use for data loading
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	statisticalGraphAsync.tdCommon = tempObj.tdCommon
	statisticalGraphAsync.Token = tempObj.Token

	return nil
}

// GetStatisticalGraphEnum return the enum type of this object
func (statisticalGraphAsync *StatisticalGraphAsync) GetStatisticalGraphEnum() StatisticalGraphEnum {
	return StatisticalGraphAsyncType
}

// StatisticalGraphError An error message to be shown to the user instead of the graph
type StatisticalGraphError struct {
	tdCommon
	ErrorMessage string `json:"error_message"` // The error message
}

// MessageType return the string telegram-type of StatisticalGraphError
func (statisticalGraphError *StatisticalGraphError) MessageType() string {
	return "statisticalGraphError"
}

// NewStatisticalGraphError creates a new StatisticalGraphError
//
// @param errParamMessage The error message
func NewStatisticalGraphError(errParamMessage string) *StatisticalGraphError {
	statisticalGraphErrorTemp := StatisticalGraphError{
		tdCommon:     tdCommon{Type: "statisticalGraphError"},
		ErrorMessage: errParamMessage,
	}

	return &statisticalGraphErrorTemp
}

// UnmarshalJSON unmarshal to json
func (statisticalGraphError *StatisticalGraphError) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ErrorMessage string `json:"error_message"` // The error message
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	statisticalGraphError.tdCommon = tempObj.tdCommon
	statisticalGraphError.ErrorMessage = tempObj.ErrorMessage

	return nil
}

// GetStatisticalGraphEnum return the enum type of this object
func (statisticalGraphError *StatisticalGraphError) GetStatisticalGraphEnum() StatisticalGraphEnum {
	return StatisticalGraphErrorType
}

// ChatStatisticsObjectTypeMessage Describes a message sent in the chat
type ChatStatisticsObjectTypeMessage struct {
	tdCommon
	MessageID int64 `json:"message_id"` // Message identifier
}

// MessageType return the string telegram-type of ChatStatisticsObjectTypeMessage
func (chatStatisticsObjectTypeMessage *ChatStatisticsObjectTypeMessage) MessageType() string {
	return "chatStatisticsObjectTypeMessage"
}

// NewChatStatisticsObjectTypeMessage creates a new ChatStatisticsObjectTypeMessage
//
// @param messageID Message identifier
func NewChatStatisticsObjectTypeMessage(messageID int64) *ChatStatisticsObjectTypeMessage {
	chatStatisticsObjectTypeMessageTemp := ChatStatisticsObjectTypeMessage{
		tdCommon:  tdCommon{Type: "chatStatisticsObjectTypeMessage"},
		MessageID: messageID,
	}

	return &chatStatisticsObjectTypeMessageTemp
}

// UnmarshalJSON unmarshal to json
func (chatStatisticsObjectTypeMessage *ChatStatisticsObjectTypeMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MessageID int64 `json:"message_id"` // Message identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatStatisticsObjectTypeMessage.tdCommon = tempObj.tdCommon
	chatStatisticsObjectTypeMessage.MessageID = tempObj.MessageID

	return nil
}

// GetChatStatisticsObjectTypeEnum return the enum type of this object
func (chatStatisticsObjectTypeMessage *ChatStatisticsObjectTypeMessage) GetChatStatisticsObjectTypeEnum() ChatStatisticsObjectTypeEnum {
	return ChatStatisticsObjectTypeMessageType
}

// ChatStatisticsObjectTypeStory Describes a story sent by the chat
type ChatStatisticsObjectTypeStory struct {
	tdCommon
	StoryID int32 `json:"story_id"` // Story identifier
}

// MessageType return the string telegram-type of ChatStatisticsObjectTypeStory
func (chatStatisticsObjectTypeStory *ChatStatisticsObjectTypeStory) MessageType() string {
	return "chatStatisticsObjectTypeStory"
}

// NewChatStatisticsObjectTypeStory creates a new ChatStatisticsObjectTypeStory
//
// @param storyID Story identifier
func NewChatStatisticsObjectTypeStory(storyID int32) *ChatStatisticsObjectTypeStory {
	chatStatisticsObjectTypeStoryTemp := ChatStatisticsObjectTypeStory{
		tdCommon: tdCommon{Type: "chatStatisticsObjectTypeStory"},
		StoryID:  storyID,
	}

	return &chatStatisticsObjectTypeStoryTemp
}

// UnmarshalJSON unmarshal to json
func (chatStatisticsObjectTypeStory *ChatStatisticsObjectTypeStory) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StoryID int32 `json:"story_id"` // Story identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatStatisticsObjectTypeStory.tdCommon = tempObj.tdCommon
	chatStatisticsObjectTypeStory.StoryID = tempObj.StoryID

	return nil
}

// GetChatStatisticsObjectTypeEnum return the enum type of this object
func (chatStatisticsObjectTypeStory *ChatStatisticsObjectTypeStory) GetChatStatisticsObjectTypeEnum() ChatStatisticsObjectTypeEnum {
	return ChatStatisticsObjectTypeStoryType
}

// ChatStatisticsInteractionInfo Contains statistics about interactions with a message sent in the chat or a story sent by the chat
type ChatStatisticsInteractionInfo struct {
	tdCommon
	ObjectType    ChatStatisticsObjectType `json:"object_type"`    // Type of the object
	ViewCount     int32                    `json:"view_count"`     // Number of times the object was viewed
	ForwardCount  int32                    `json:"forward_count"`  // Number of times the object was forwarded
	ReactionCount int32                    `json:"reaction_count"` // Number of times reactions were added to the object
}

// MessageType return the string telegram-type of ChatStatisticsInteractionInfo
func (chatStatisticsInteractionInfo *ChatStatisticsInteractionInfo) MessageType() string {
	return "chatStatisticsInteractionInfo"
}

// NewChatStatisticsInteractionInfo creates a new ChatStatisticsInteractionInfo
//
// @param objectType Type of the object
// @param viewCount Number of times the object was viewed
// @param forwardCount Number of times the object was forwarded
// @param reactionCount Number of times reactions were added to the object
func NewChatStatisticsInteractionInfo(objectType ChatStatisticsObjectType, viewCount int32, forwardCount int32, reactionCount int32) *ChatStatisticsInteractionInfo {
	chatStatisticsInteractionInfoTemp := ChatStatisticsInteractionInfo{
		tdCommon:      tdCommon{Type: "chatStatisticsInteractionInfo"},
		ObjectType:    objectType,
		ViewCount:     viewCount,
		ForwardCount:  forwardCount,
		ReactionCount: reactionCount,
	}

	return &chatStatisticsInteractionInfoTemp
}

// UnmarshalJSON unmarshal to json
func (chatStatisticsInteractionInfo *ChatStatisticsInteractionInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ViewCount     int32 `json:"view_count"`     // Number of times the object was viewed
		ForwardCount  int32 `json:"forward_count"`  // Number of times the object was forwarded
		ReactionCount int32 `json:"reaction_count"` // Number of times reactions were added to the object
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatStatisticsInteractionInfo.tdCommon = tempObj.tdCommon
	chatStatisticsInteractionInfo.ViewCount = tempObj.ViewCount
	chatStatisticsInteractionInfo.ForwardCount = tempObj.ForwardCount
	chatStatisticsInteractionInfo.ReactionCount = tempObj.ReactionCount

	fieldObjectType, _ := unmarshalChatStatisticsObjectType(objMap["object_type"])
	chatStatisticsInteractionInfo.ObjectType = fieldObjectType

	return nil
}

// ChatStatisticsMessageSenderInfo Contains statistics about messages sent by a user
type ChatStatisticsMessageSenderInfo struct {
	tdCommon
	UserID                int64 `json:"user_id"`                 // User identifier
	SentMessageCount      int32 `json:"sent_message_count"`      // Number of sent messages
	AverageCharacterCount int32 `json:"average_character_count"` // Average number of characters in sent messages; 0 if unknown
}

// MessageType return the string telegram-type of ChatStatisticsMessageSenderInfo
func (chatStatisticsMessageSenderInfo *ChatStatisticsMessageSenderInfo) MessageType() string {
	return "chatStatisticsMessageSenderInfo"
}

// NewChatStatisticsMessageSenderInfo creates a new ChatStatisticsMessageSenderInfo
//
// @param userID User identifier
// @param sentMessageCount Number of sent messages
// @param averageCharacterCount Average number of characters in sent messages; 0 if unknown
func NewChatStatisticsMessageSenderInfo(userID int64, sentMessageCount int32, averageCharacterCount int32) *ChatStatisticsMessageSenderInfo {
	chatStatisticsMessageSenderInfoTemp := ChatStatisticsMessageSenderInfo{
		tdCommon:              tdCommon{Type: "chatStatisticsMessageSenderInfo"},
		UserID:                userID,
		SentMessageCount:      sentMessageCount,
		AverageCharacterCount: averageCharacterCount,
	}

	return &chatStatisticsMessageSenderInfoTemp
}

// UnmarshalJSON unmarshal to json
func (chatStatisticsMessageSenderInfo *ChatStatisticsMessageSenderInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID                int64 `json:"user_id"`                 // User identifier
		SentMessageCount      int32 `json:"sent_message_count"`      // Number of sent messages
		AverageCharacterCount int32 `json:"average_character_count"` // Average number of characters in sent messages; 0 if unknown
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatStatisticsMessageSenderInfo.tdCommon = tempObj.tdCommon
	chatStatisticsMessageSenderInfo.UserID = tempObj.UserID
	chatStatisticsMessageSenderInfo.SentMessageCount = tempObj.SentMessageCount
	chatStatisticsMessageSenderInfo.AverageCharacterCount = tempObj.AverageCharacterCount

	return nil
}

// ChatStatisticsAdministratorActionsInfo Contains statistics about administrator actions done by a user
type ChatStatisticsAdministratorActionsInfo struct {
	tdCommon
	UserID              int64 `json:"user_id"`               // Administrator user identifier
	DeletedMessageCount int32 `json:"deleted_message_count"` // Number of messages deleted by the administrator
	BannedUserCount     int32 `json:"banned_user_count"`     // Number of users banned by the administrator
	RestrictedUserCount int32 `json:"restricted_user_count"` // Number of users restricted by the administrator
}

// MessageType return the string telegram-type of ChatStatisticsAdministratorActionsInfo
func (chatStatisticsAdministratorActionsInfo *ChatStatisticsAdministratorActionsInfo) MessageType() string {
	return "chatStatisticsAdministratorActionsInfo"
}

// NewChatStatisticsAdministratorActionsInfo creates a new ChatStatisticsAdministratorActionsInfo
//
// @param userID Administrator user identifier
// @param deletedMessageCount Number of messages deleted by the administrator
// @param bannedUserCount Number of users banned by the administrator
// @param restrictedUserCount Number of users restricted by the administrator
func NewChatStatisticsAdministratorActionsInfo(userID int64, deletedMessageCount int32, bannedUserCount int32, restrictedUserCount int32) *ChatStatisticsAdministratorActionsInfo {
	chatStatisticsAdministratorActionsInfoTemp := ChatStatisticsAdministratorActionsInfo{
		tdCommon:            tdCommon{Type: "chatStatisticsAdministratorActionsInfo"},
		UserID:              userID,
		DeletedMessageCount: deletedMessageCount,
		BannedUserCount:     bannedUserCount,
		RestrictedUserCount: restrictedUserCount,
	}

	return &chatStatisticsAdministratorActionsInfoTemp
}

// UnmarshalJSON unmarshal to json
func (chatStatisticsAdministratorActionsInfo *ChatStatisticsAdministratorActionsInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID              int64 `json:"user_id"`               // Administrator user identifier
		DeletedMessageCount int32 `json:"deleted_message_count"` // Number of messages deleted by the administrator
		BannedUserCount     int32 `json:"banned_user_count"`     // Number of users banned by the administrator
		RestrictedUserCount int32 `json:"restricted_user_count"` // Number of users restricted by the administrator
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatStatisticsAdministratorActionsInfo.tdCommon = tempObj.tdCommon
	chatStatisticsAdministratorActionsInfo.UserID = tempObj.UserID
	chatStatisticsAdministratorActionsInfo.DeletedMessageCount = tempObj.DeletedMessageCount
	chatStatisticsAdministratorActionsInfo.BannedUserCount = tempObj.BannedUserCount
	chatStatisticsAdministratorActionsInfo.RestrictedUserCount = tempObj.RestrictedUserCount

	return nil
}

// ChatStatisticsInviterInfo Contains statistics about number of new members invited by a user
type ChatStatisticsInviterInfo struct {
	tdCommon
	UserID           int64 `json:"user_id"`            // User identifier
	AddedMemberCount int32 `json:"added_member_count"` // Number of new members invited by the user
}

// MessageType return the string telegram-type of ChatStatisticsInviterInfo
func (chatStatisticsInviterInfo *ChatStatisticsInviterInfo) MessageType() string {
	return "chatStatisticsInviterInfo"
}

// NewChatStatisticsInviterInfo creates a new ChatStatisticsInviterInfo
//
// @param userID User identifier
// @param addedMemberCount Number of new members invited by the user
func NewChatStatisticsInviterInfo(userID int64, addedMemberCount int32) *ChatStatisticsInviterInfo {
	chatStatisticsInviterInfoTemp := ChatStatisticsInviterInfo{
		tdCommon:         tdCommon{Type: "chatStatisticsInviterInfo"},
		UserID:           userID,
		AddedMemberCount: addedMemberCount,
	}

	return &chatStatisticsInviterInfoTemp
}

// UnmarshalJSON unmarshal to json
func (chatStatisticsInviterInfo *ChatStatisticsInviterInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID           int64 `json:"user_id"`            // User identifier
		AddedMemberCount int32 `json:"added_member_count"` // Number of new members invited by the user
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatStatisticsInviterInfo.tdCommon = tempObj.tdCommon
	chatStatisticsInviterInfo.UserID = tempObj.UserID
	chatStatisticsInviterInfo.AddedMemberCount = tempObj.AddedMemberCount

	return nil
}

// ChatStatisticsSupergroup A detailed statistics about a supergroup chat
type ChatStatisticsSupergroup struct {
	tdCommon
	Period              *DateRange                               `json:"period"`                // A period to which the statistics applies
	MemberCount         *StatisticalValue                        `json:"member_count"`          // Number of members in the chat
	MessageCount        *StatisticalValue                        `json:"message_count"`         // Number of messages sent to the chat
	ViewerCount         *StatisticalValue                        `json:"viewer_count"`          // Number of users who viewed messages in the chat
	SenderCount         *StatisticalValue                        `json:"sender_count"`          // Number of users who sent messages to the chat
	MemberCountGraph    StatisticalGraph                         `json:"member_count_graph"`    // A graph containing number of members in the chat
	JoinGraph           StatisticalGraph                         `json:"join_graph"`            // A graph containing number of members joined and left the chat
	JoinBySourceGraph   StatisticalGraph                         `json:"join_by_source_graph"`  // A graph containing number of new member joins per source
	LanguageGraph       StatisticalGraph                         `json:"language_graph"`        // A graph containing distribution of active users per language
	MessageContentGraph StatisticalGraph                         `json:"message_content_graph"` // A graph containing distribution of sent messages by content type
	ActionGraph         StatisticalGraph                         `json:"action_graph"`          // A graph containing number of different actions in the chat
	DayGraph            StatisticalGraph                         `json:"day_graph"`             // A graph containing distribution of message views per hour
	WeekGraph           StatisticalGraph                         `json:"week_graph"`            // A graph containing distribution of message views per day of week
	TopSenders          []ChatStatisticsMessageSenderInfo        `json:"top_senders"`           // List of users sent most messages in the last week
	TopAdministrators   []ChatStatisticsAdministratorActionsInfo `json:"top_administrators"`    // List of most active administrators in the last week
	TopInviters         []ChatStatisticsInviterInfo              `json:"top_inviters"`          // List of most active inviters of new members in the last week
}

// MessageType return the string telegram-type of ChatStatisticsSupergroup
func (chatStatisticsSupergroup *ChatStatisticsSupergroup) MessageType() string {
	return "chatStatisticsSupergroup"
}

// NewChatStatisticsSupergroup creates a new ChatStatisticsSupergroup
//
// @param period A period to which the statistics applies
// @param memberCount Number of members in the chat
// @param messageCount Number of messages sent to the chat
// @param viewerCount Number of users who viewed messages in the chat
// @param senderCount Number of users who sent messages to the chat
// @param memberCountGraph A graph containing number of members in the chat
// @param joinGraph A graph containing number of members joined and left the chat
// @param joinBySourceGraph A graph containing number of new member joins per source
// @param languageGraph A graph containing distribution of active users per language
// @param messageContentGraph A graph containing distribution of sent messages by content type
// @param actionGraph A graph containing number of different actions in the chat
// @param dayGraph A graph containing distribution of message views per hour
// @param weekGraph A graph containing distribution of message views per day of week
// @param topSenders List of users sent most messages in the last week
// @param topAdministrators List of most active administrators in the last week
// @param topInviters List of most active inviters of new members in the last week
func NewChatStatisticsSupergroup(period *DateRange, memberCount *StatisticalValue, messageCount *StatisticalValue, viewerCount *StatisticalValue, senderCount *StatisticalValue, memberCountGraph StatisticalGraph, joinGraph StatisticalGraph, joinBySourceGraph StatisticalGraph, languageGraph StatisticalGraph, messageContentGraph StatisticalGraph, actionGraph StatisticalGraph, dayGraph StatisticalGraph, weekGraph StatisticalGraph, topSenders []ChatStatisticsMessageSenderInfo, topAdministrators []ChatStatisticsAdministratorActionsInfo, topInviters []ChatStatisticsInviterInfo) *ChatStatisticsSupergroup {
	chatStatisticsSupergroupTemp := ChatStatisticsSupergroup{
		tdCommon:            tdCommon{Type: "chatStatisticsSupergroup"},
		Period:              period,
		MemberCount:         memberCount,
		MessageCount:        messageCount,
		ViewerCount:         viewerCount,
		SenderCount:         senderCount,
		MemberCountGraph:    memberCountGraph,
		JoinGraph:           joinGraph,
		JoinBySourceGraph:   joinBySourceGraph,
		LanguageGraph:       languageGraph,
		MessageContentGraph: messageContentGraph,
		ActionGraph:         actionGraph,
		DayGraph:            dayGraph,
		WeekGraph:           weekGraph,
		TopSenders:          topSenders,
		TopAdministrators:   topAdministrators,
		TopInviters:         topInviters,
	}

	return &chatStatisticsSupergroupTemp
}

// UnmarshalJSON unmarshal to json
func (chatStatisticsSupergroup *ChatStatisticsSupergroup) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Period            *DateRange                               `json:"period"`             // A period to which the statistics applies
		MemberCount       *StatisticalValue                        `json:"member_count"`       // Number of members in the chat
		MessageCount      *StatisticalValue                        `json:"message_count"`      // Number of messages sent to the chat
		ViewerCount       *StatisticalValue                        `json:"viewer_count"`       // Number of users who viewed messages in the chat
		SenderCount       *StatisticalValue                        `json:"sender_count"`       // Number of users who sent messages to the chat
		TopSenders        []ChatStatisticsMessageSenderInfo        `json:"top_senders"`        // List of users sent most messages in the last week
		TopAdministrators []ChatStatisticsAdministratorActionsInfo `json:"top_administrators"` // List of most active administrators in the last week
		TopInviters       []ChatStatisticsInviterInfo              `json:"top_inviters"`       // List of most active inviters of new members in the last week
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatStatisticsSupergroup.tdCommon = tempObj.tdCommon
	chatStatisticsSupergroup.Period = tempObj.Period
	chatStatisticsSupergroup.MemberCount = tempObj.MemberCount
	chatStatisticsSupergroup.MessageCount = tempObj.MessageCount
	chatStatisticsSupergroup.ViewerCount = tempObj.ViewerCount
	chatStatisticsSupergroup.SenderCount = tempObj.SenderCount
	chatStatisticsSupergroup.TopSenders = tempObj.TopSenders
	chatStatisticsSupergroup.TopAdministrators = tempObj.TopAdministrators
	chatStatisticsSupergroup.TopInviters = tempObj.TopInviters

	fieldMemberCountGraph, _ := unmarshalStatisticalGraph(objMap["member_count_graph"])
	chatStatisticsSupergroup.MemberCountGraph = fieldMemberCountGraph

	fieldJoinGraph, _ := unmarshalStatisticalGraph(objMap["join_graph"])
	chatStatisticsSupergroup.JoinGraph = fieldJoinGraph

	fieldJoinBySourceGraph, _ := unmarshalStatisticalGraph(objMap["join_by_source_graph"])
	chatStatisticsSupergroup.JoinBySourceGraph = fieldJoinBySourceGraph

	fieldLanguageGraph, _ := unmarshalStatisticalGraph(objMap["language_graph"])
	chatStatisticsSupergroup.LanguageGraph = fieldLanguageGraph

	fieldMessageContentGraph, _ := unmarshalStatisticalGraph(objMap["message_content_graph"])
	chatStatisticsSupergroup.MessageContentGraph = fieldMessageContentGraph

	fieldActionGraph, _ := unmarshalStatisticalGraph(objMap["action_graph"])
	chatStatisticsSupergroup.ActionGraph = fieldActionGraph

	fieldDayGraph, _ := unmarshalStatisticalGraph(objMap["day_graph"])
	chatStatisticsSupergroup.DayGraph = fieldDayGraph

	fieldWeekGraph, _ := unmarshalStatisticalGraph(objMap["week_graph"])
	chatStatisticsSupergroup.WeekGraph = fieldWeekGraph

	return nil
}

// GetChatStatisticsEnum return the enum type of this object
func (chatStatisticsSupergroup *ChatStatisticsSupergroup) GetChatStatisticsEnum() ChatStatisticsEnum {
	return ChatStatisticsSupergroupType
}

// ChatStatisticsChannel A detailed statistics about a channel chat
type ChatStatisticsChannel struct {
	tdCommon
	Period                         *DateRange                      `json:"period"`                           // A period to which the statistics applies
	MemberCount                    *StatisticalValue               `json:"member_count"`                     // Number of members in the chat
	MeanMessageViewCount           *StatisticalValue               `json:"mean_message_view_count"`          // Mean number of times the recently sent messages were viewed
	MeanMessageShareCount          *StatisticalValue               `json:"mean_message_share_count"`         // Mean number of times the recently sent messages were shared
	MeanMessageReactionCount       *StatisticalValue               `json:"mean_message_reaction_count"`      // Mean number of times reactions were added to the recently sent messages
	MeanStoryViewCount             *StatisticalValue               `json:"mean_story_view_count"`            // Mean number of times the recently sent stories were viewed
	MeanStoryShareCount            *StatisticalValue               `json:"mean_story_share_count"`           // Mean number of times the recently sent stories were shared
	MeanStoryReactionCount         *StatisticalValue               `json:"mean_story_reaction_count"`        // Mean number of times reactions were added to the recently sent stories
	EnabledNotificationsPercentage float64                         `json:"enabled_notifications_percentage"` // A percentage of users with enabled notifications for the chat; 0-100
	MemberCountGraph               StatisticalGraph                `json:"member_count_graph"`               // A graph containing number of members in the chat
	JoinGraph                      StatisticalGraph                `json:"join_graph"`                       // A graph containing number of members joined and left the chat
	MuteGraph                      StatisticalGraph                `json:"mute_graph"`                       // A graph containing number of members muted and unmuted the chat
	ViewCountByHourGraph           StatisticalGraph                `json:"view_count_by_hour_graph"`         // A graph containing number of message views in a given hour in the last two weeks
	ViewCountBySourceGraph         StatisticalGraph                `json:"view_count_by_source_graph"`       // A graph containing number of message views per source
	JoinBySourceGraph              StatisticalGraph                `json:"join_by_source_graph"`             // A graph containing number of new member joins per source
	LanguageGraph                  StatisticalGraph                `json:"language_graph"`                   // A graph containing number of users viewed chat messages per language
	MessageInteractionGraph        StatisticalGraph                `json:"message_interaction_graph"`        // A graph containing number of chat message views and shares
	MessageReactionGraph           StatisticalGraph                `json:"message_reaction_graph"`           // A graph containing number of reactions on messages
	StoryInteractionGraph          StatisticalGraph                `json:"story_interaction_graph"`          // A graph containing number of story views and shares
	StoryReactionGraph             StatisticalGraph                `json:"story_reaction_graph"`             // A graph containing number of reactions on stories
	InstantViewInteractionGraph    StatisticalGraph                `json:"instant_view_interaction_graph"`   // A graph containing number of views of associated with the chat instant views
	RecentInteractions             []ChatStatisticsInteractionInfo `json:"recent_interactions"`              // Detailed statistics about number of views and shares of recently sent messages and stories
}

// MessageType return the string telegram-type of ChatStatisticsChannel
func (chatStatisticsChannel *ChatStatisticsChannel) MessageType() string {
	return "chatStatisticsChannel"
}

// NewChatStatisticsChannel creates a new ChatStatisticsChannel
//
// @param period A period to which the statistics applies
// @param memberCount Number of members in the chat
// @param meanMessageViewCount Mean number of times the recently sent messages were viewed
// @param meanMessageShareCount Mean number of times the recently sent messages were shared
// @param meanMessageReactionCount Mean number of times reactions were added to the recently sent messages
// @param meanStoryViewCount Mean number of times the recently sent stories were viewed
// @param meanStoryShareCount Mean number of times the recently sent stories were shared
// @param meanStoryReactionCount Mean number of times reactions were added to the recently sent stories
// @param enabledNotificationsPercentage A percentage of users with enabled notifications for the chat; 0-100
// @param memberCountGraph A graph containing number of members in the chat
// @param joinGraph A graph containing number of members joined and left the chat
// @param muteGraph A graph containing number of members muted and unmuted the chat
// @param viewCountByHourGraph A graph containing number of message views in a given hour in the last two weeks
// @param viewCountBySourceGraph A graph containing number of message views per source
// @param joinBySourceGraph A graph containing number of new member joins per source
// @param languageGraph A graph containing number of users viewed chat messages per language
// @param messageInteractionGraph A graph containing number of chat message views and shares
// @param messageReactionGraph A graph containing number of reactions on messages
// @param storyInteractionGraph A graph containing number of story views and shares
// @param storyReactionGraph A graph containing number of reactions on stories
// @param instantViewInteractionGraph A graph containing number of views of associated with the chat instant views
// @param recentInteractions Detailed statistics about number of views and shares of recently sent messages and stories
func NewChatStatisticsChannel(period *DateRange, memberCount *StatisticalValue, meanMessageViewCount *StatisticalValue, meanMessageShareCount *StatisticalValue, meanMessageReactionCount *StatisticalValue, meanStoryViewCount *StatisticalValue, meanStoryShareCount *StatisticalValue, meanStoryReactionCount *StatisticalValue, enabledNotificationsPercentage float64, memberCountGraph StatisticalGraph, joinGraph StatisticalGraph, muteGraph StatisticalGraph, viewCountByHourGraph StatisticalGraph, viewCountBySourceGraph StatisticalGraph, joinBySourceGraph StatisticalGraph, languageGraph StatisticalGraph, messageInteractionGraph StatisticalGraph, messageReactionGraph StatisticalGraph, storyInteractionGraph StatisticalGraph, storyReactionGraph StatisticalGraph, instantViewInteractionGraph StatisticalGraph, recentInteractions []ChatStatisticsInteractionInfo) *ChatStatisticsChannel {
	chatStatisticsChannelTemp := ChatStatisticsChannel{
		tdCommon:                       tdCommon{Type: "chatStatisticsChannel"},
		Period:                         period,
		MemberCount:                    memberCount,
		MeanMessageViewCount:           meanMessageViewCount,
		MeanMessageShareCount:          meanMessageShareCount,
		MeanMessageReactionCount:       meanMessageReactionCount,
		MeanStoryViewCount:             meanStoryViewCount,
		MeanStoryShareCount:            meanStoryShareCount,
		MeanStoryReactionCount:         meanStoryReactionCount,
		EnabledNotificationsPercentage: enabledNotificationsPercentage,
		MemberCountGraph:               memberCountGraph,
		JoinGraph:                      joinGraph,
		MuteGraph:                      muteGraph,
		ViewCountByHourGraph:           viewCountByHourGraph,
		ViewCountBySourceGraph:         viewCountBySourceGraph,
		JoinBySourceGraph:              joinBySourceGraph,
		LanguageGraph:                  languageGraph,
		MessageInteractionGraph:        messageInteractionGraph,
		MessageReactionGraph:           messageReactionGraph,
		StoryInteractionGraph:          storyInteractionGraph,
		StoryReactionGraph:             storyReactionGraph,
		InstantViewInteractionGraph:    instantViewInteractionGraph,
		RecentInteractions:             recentInteractions,
	}

	return &chatStatisticsChannelTemp
}

// UnmarshalJSON unmarshal to json
func (chatStatisticsChannel *ChatStatisticsChannel) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Period                         *DateRange                      `json:"period"`                           // A period to which the statistics applies
		MemberCount                    *StatisticalValue               `json:"member_count"`                     // Number of members in the chat
		MeanMessageViewCount           *StatisticalValue               `json:"mean_message_view_count"`          // Mean number of times the recently sent messages were viewed
		MeanMessageShareCount          *StatisticalValue               `json:"mean_message_share_count"`         // Mean number of times the recently sent messages were shared
		MeanMessageReactionCount       *StatisticalValue               `json:"mean_message_reaction_count"`      // Mean number of times reactions were added to the recently sent messages
		MeanStoryViewCount             *StatisticalValue               `json:"mean_story_view_count"`            // Mean number of times the recently sent stories were viewed
		MeanStoryShareCount            *StatisticalValue               `json:"mean_story_share_count"`           // Mean number of times the recently sent stories were shared
		MeanStoryReactionCount         *StatisticalValue               `json:"mean_story_reaction_count"`        // Mean number of times reactions were added to the recently sent stories
		EnabledNotificationsPercentage float64                         `json:"enabled_notifications_percentage"` // A percentage of users with enabled notifications for the chat; 0-100
		RecentInteractions             []ChatStatisticsInteractionInfo `json:"recent_interactions"`              // Detailed statistics about number of views and shares of recently sent messages and stories
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatStatisticsChannel.tdCommon = tempObj.tdCommon
	chatStatisticsChannel.Period = tempObj.Period
	chatStatisticsChannel.MemberCount = tempObj.MemberCount
	chatStatisticsChannel.MeanMessageViewCount = tempObj.MeanMessageViewCount
	chatStatisticsChannel.MeanMessageShareCount = tempObj.MeanMessageShareCount
	chatStatisticsChannel.MeanMessageReactionCount = tempObj.MeanMessageReactionCount
	chatStatisticsChannel.MeanStoryViewCount = tempObj.MeanStoryViewCount
	chatStatisticsChannel.MeanStoryShareCount = tempObj.MeanStoryShareCount
	chatStatisticsChannel.MeanStoryReactionCount = tempObj.MeanStoryReactionCount
	chatStatisticsChannel.EnabledNotificationsPercentage = tempObj.EnabledNotificationsPercentage
	chatStatisticsChannel.RecentInteractions = tempObj.RecentInteractions

	fieldMemberCountGraph, _ := unmarshalStatisticalGraph(objMap["member_count_graph"])
	chatStatisticsChannel.MemberCountGraph = fieldMemberCountGraph

	fieldJoinGraph, _ := unmarshalStatisticalGraph(objMap["join_graph"])
	chatStatisticsChannel.JoinGraph = fieldJoinGraph

	fieldMuteGraph, _ := unmarshalStatisticalGraph(objMap["mute_graph"])
	chatStatisticsChannel.MuteGraph = fieldMuteGraph

	fieldViewCountByHourGraph, _ := unmarshalStatisticalGraph(objMap["view_count_by_hour_graph"])
	chatStatisticsChannel.ViewCountByHourGraph = fieldViewCountByHourGraph

	fieldViewCountBySourceGraph, _ := unmarshalStatisticalGraph(objMap["view_count_by_source_graph"])
	chatStatisticsChannel.ViewCountBySourceGraph = fieldViewCountBySourceGraph

	fieldJoinBySourceGraph, _ := unmarshalStatisticalGraph(objMap["join_by_source_graph"])
	chatStatisticsChannel.JoinBySourceGraph = fieldJoinBySourceGraph

	fieldLanguageGraph, _ := unmarshalStatisticalGraph(objMap["language_graph"])
	chatStatisticsChannel.LanguageGraph = fieldLanguageGraph

	fieldMessageInteractionGraph, _ := unmarshalStatisticalGraph(objMap["message_interaction_graph"])
	chatStatisticsChannel.MessageInteractionGraph = fieldMessageInteractionGraph

	fieldMessageReactionGraph, _ := unmarshalStatisticalGraph(objMap["message_reaction_graph"])
	chatStatisticsChannel.MessageReactionGraph = fieldMessageReactionGraph

	fieldStoryInteractionGraph, _ := unmarshalStatisticalGraph(objMap["story_interaction_graph"])
	chatStatisticsChannel.StoryInteractionGraph = fieldStoryInteractionGraph

	fieldStoryReactionGraph, _ := unmarshalStatisticalGraph(objMap["story_reaction_graph"])
	chatStatisticsChannel.StoryReactionGraph = fieldStoryReactionGraph

	fieldInstantViewInteractionGraph, _ := unmarshalStatisticalGraph(objMap["instant_view_interaction_graph"])
	chatStatisticsChannel.InstantViewInteractionGraph = fieldInstantViewInteractionGraph

	return nil
}

// GetChatStatisticsEnum return the enum type of this object
func (chatStatisticsChannel *ChatStatisticsChannel) GetChatStatisticsEnum() ChatStatisticsEnum {
	return ChatStatisticsChannelType
}

// ChatRevenueAmount Contains information about revenue earned from sponsored messages in a chat
type ChatRevenueAmount struct {
	tdCommon
	Cryptocurrency    string    `json:"cryptocurrency"`     // Cryptocurrency in which revenue is calculated
	TotalAmount       JSONInt64 `json:"total_amount"`       // Total amount of the cryptocurrency earned, in the smallest units of the cryptocurrency
	BalanceAmount     JSONInt64 `json:"balance_amount"`     // Amount of the cryptocurrency that isn't withdrawn yet, in the smallest units of the cryptocurrency
	AvailableAmount   JSONInt64 `json:"available_amount"`   // Amount of the cryptocurrency available for withdrawal, in the smallest units of the cryptocurrency
	WithdrawalEnabled bool      `json:"withdrawal_enabled"` // True, if Telegram Stars can be withdrawn now or later
}

// MessageType return the string telegram-type of ChatRevenueAmount
func (chatRevenueAmount *ChatRevenueAmount) MessageType() string {
	return "chatRevenueAmount"
}

// NewChatRevenueAmount creates a new ChatRevenueAmount
//
// @param cryptocurrency Cryptocurrency in which revenue is calculated
// @param totalAmount Total amount of the cryptocurrency earned, in the smallest units of the cryptocurrency
// @param balanceAmount Amount of the cryptocurrency that isn't withdrawn yet, in the smallest units of the cryptocurrency
// @param availableAmount Amount of the cryptocurrency available for withdrawal, in the smallest units of the cryptocurrency
// @param withdrawalEnabled True, if Telegram Stars can be withdrawn now or later
func NewChatRevenueAmount(cryptocurrency string, totalAmount JSONInt64, balanceAmount JSONInt64, availableAmount JSONInt64, withdrawalEnabled bool) *ChatRevenueAmount {
	chatRevenueAmountTemp := ChatRevenueAmount{
		tdCommon:          tdCommon{Type: "chatRevenueAmount"},
		Cryptocurrency:    cryptocurrency,
		TotalAmount:       totalAmount,
		BalanceAmount:     balanceAmount,
		AvailableAmount:   availableAmount,
		WithdrawalEnabled: withdrawalEnabled,
	}

	return &chatRevenueAmountTemp
}

// UnmarshalJSON unmarshal to json
func (chatRevenueAmount *ChatRevenueAmount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Cryptocurrency    string    `json:"cryptocurrency"`     // Cryptocurrency in which revenue is calculated
		TotalAmount       JSONInt64 `json:"total_amount"`       // Total amount of the cryptocurrency earned, in the smallest units of the cryptocurrency
		BalanceAmount     JSONInt64 `json:"balance_amount"`     // Amount of the cryptocurrency that isn't withdrawn yet, in the smallest units of the cryptocurrency
		AvailableAmount   JSONInt64 `json:"available_amount"`   // Amount of the cryptocurrency available for withdrawal, in the smallest units of the cryptocurrency
		WithdrawalEnabled bool      `json:"withdrawal_enabled"` // True, if Telegram Stars can be withdrawn now or later
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatRevenueAmount.tdCommon = tempObj.tdCommon
	chatRevenueAmount.Cryptocurrency = tempObj.Cryptocurrency
	chatRevenueAmount.TotalAmount = tempObj.TotalAmount
	chatRevenueAmount.BalanceAmount = tempObj.BalanceAmount
	chatRevenueAmount.AvailableAmount = tempObj.AvailableAmount
	chatRevenueAmount.WithdrawalEnabled = tempObj.WithdrawalEnabled

	return nil
}

// ChatRevenueStatistics A detailed statistics about revenue earned from sponsored messages in a chat
type ChatRevenueStatistics struct {
	tdCommon
	RevenueByHourGraph StatisticalGraph   `json:"revenue_by_hour_graph"` // A graph containing amount of revenue in a given hour
	RevenueGraph       StatisticalGraph   `json:"revenue_graph"`         // A graph containing amount of revenue
	RevenueAmount      *ChatRevenueAmount `json:"revenue_amount"`        // Amount of earned revenue
	UsdRate            float64            `json:"usd_rate"`              // Current conversion rate of the cryptocurrency in which revenue is calculated to USD
}

// MessageType return the string telegram-type of ChatRevenueStatistics
func (chatRevenueStatistics *ChatRevenueStatistics) MessageType() string {
	return "chatRevenueStatistics"
}

// NewChatRevenueStatistics creates a new ChatRevenueStatistics
//
// @param revenueByHourGraph A graph containing amount of revenue in a given hour
// @param revenueGraph A graph containing amount of revenue
// @param revenueAmount Amount of earned revenue
// @param usdRate Current conversion rate of the cryptocurrency in which revenue is calculated to USD
func NewChatRevenueStatistics(revenueByHourGraph StatisticalGraph, revenueGraph StatisticalGraph, revenueAmount *ChatRevenueAmount, usdRate float64) *ChatRevenueStatistics {
	chatRevenueStatisticsTemp := ChatRevenueStatistics{
		tdCommon:           tdCommon{Type: "chatRevenueStatistics"},
		RevenueByHourGraph: revenueByHourGraph,
		RevenueGraph:       revenueGraph,
		RevenueAmount:      revenueAmount,
		UsdRate:            usdRate,
	}

	return &chatRevenueStatisticsTemp
}

// UnmarshalJSON unmarshal to json
func (chatRevenueStatistics *ChatRevenueStatistics) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		RevenueAmount *ChatRevenueAmount `json:"revenue_amount"` // Amount of earned revenue
		UsdRate       float64            `json:"usd_rate"`       // Current conversion rate of the cryptocurrency in which revenue is calculated to USD
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatRevenueStatistics.tdCommon = tempObj.tdCommon
	chatRevenueStatistics.RevenueAmount = tempObj.RevenueAmount
	chatRevenueStatistics.UsdRate = tempObj.UsdRate

	fieldRevenueByHourGraph, _ := unmarshalStatisticalGraph(objMap["revenue_by_hour_graph"])
	chatRevenueStatistics.RevenueByHourGraph = fieldRevenueByHourGraph

	fieldRevenueGraph, _ := unmarshalStatisticalGraph(objMap["revenue_graph"])
	chatRevenueStatistics.RevenueGraph = fieldRevenueGraph

	return nil
}

// MessageStatistics A detailed statistics about a message
type MessageStatistics struct {
	tdCommon
	MessageInteractionGraph StatisticalGraph `json:"message_interaction_graph"` // A graph containing number of message views and shares
	MessageReactionGraph    StatisticalGraph `json:"message_reaction_graph"`    // A graph containing number of message reactions
}

// MessageType return the string telegram-type of MessageStatistics
func (messageStatistics *MessageStatistics) MessageType() string {
	return "messageStatistics"
}

// NewMessageStatistics creates a new MessageStatistics
//
// @param messageInteractionGraph A graph containing number of message views and shares
// @param messageReactionGraph A graph containing number of message reactions
func NewMessageStatistics(messageInteractionGraph StatisticalGraph, messageReactionGraph StatisticalGraph) *MessageStatistics {
	messageStatisticsTemp := MessageStatistics{
		tdCommon:                tdCommon{Type: "messageStatistics"},
		MessageInteractionGraph: messageInteractionGraph,
		MessageReactionGraph:    messageReactionGraph,
	}

	return &messageStatisticsTemp
}

// UnmarshalJSON unmarshal to json
func (messageStatistics *MessageStatistics) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	messageStatistics.tdCommon = tempObj.tdCommon

	fieldMessageInteractionGraph, _ := unmarshalStatisticalGraph(objMap["message_interaction_graph"])
	messageStatistics.MessageInteractionGraph = fieldMessageInteractionGraph

	fieldMessageReactionGraph, _ := unmarshalStatisticalGraph(objMap["message_reaction_graph"])
	messageStatistics.MessageReactionGraph = fieldMessageReactionGraph

	return nil
}

// StoryStatistics A detailed statistics about a story
type StoryStatistics struct {
	tdCommon
	StoryInteractionGraph StatisticalGraph `json:"story_interaction_graph"` // A graph containing number of story views and shares
	StoryReactionGraph    StatisticalGraph `json:"story_reaction_graph"`    // A graph containing number of story reactions
}

// MessageType return the string telegram-type of StoryStatistics
func (storyStatistics *StoryStatistics) MessageType() string {
	return "storyStatistics"
}

// NewStoryStatistics creates a new StoryStatistics
//
// @param storyInteractionGraph A graph containing number of story views and shares
// @param storyReactionGraph A graph containing number of story reactions
func NewStoryStatistics(storyInteractionGraph StatisticalGraph, storyReactionGraph StatisticalGraph) *StoryStatistics {
	storyStatisticsTemp := StoryStatistics{
		tdCommon:              tdCommon{Type: "storyStatistics"},
		StoryInteractionGraph: storyInteractionGraph,
		StoryReactionGraph:    storyReactionGraph,
	}

	return &storyStatisticsTemp
}

// UnmarshalJSON unmarshal to json
func (storyStatistics *StoryStatistics) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	storyStatistics.tdCommon = tempObj.tdCommon

	fieldStoryInteractionGraph, _ := unmarshalStatisticalGraph(objMap["story_interaction_graph"])
	storyStatistics.StoryInteractionGraph = fieldStoryInteractionGraph

	fieldStoryReactionGraph, _ := unmarshalStatisticalGraph(objMap["story_reaction_graph"])
	storyStatistics.StoryReactionGraph = fieldStoryReactionGraph

	return nil
}

// RevenueWithdrawalStatePending Withdrawal is pending
type RevenueWithdrawalStatePending struct {
	tdCommon
}

// MessageType return the string telegram-type of RevenueWithdrawalStatePending
func (revenueWithdrawalStatePending *RevenueWithdrawalStatePending) MessageType() string {
	return "revenueWithdrawalStatePending"
}

// NewRevenueWithdrawalStatePending creates a new RevenueWithdrawalStatePending
//
func NewRevenueWithdrawalStatePending() *RevenueWithdrawalStatePending {
	revenueWithdrawalStatePendingTemp := RevenueWithdrawalStatePending{
		tdCommon: tdCommon{Type: "revenueWithdrawalStatePending"},
	}

	return &revenueWithdrawalStatePendingTemp
}

// UnmarshalJSON unmarshal to json
func (revenueWithdrawalStatePending *RevenueWithdrawalStatePending) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	revenueWithdrawalStatePending.tdCommon = tempObj.tdCommon

	return nil
}

// GetRevenueWithdrawalStateEnum return the enum type of this object
func (revenueWithdrawalStatePending *RevenueWithdrawalStatePending) GetRevenueWithdrawalStateEnum() RevenueWithdrawalStateEnum {
	return RevenueWithdrawalStatePendingType
}

// RevenueWithdrawalStateSucceeded Withdrawal succeeded
type RevenueWithdrawalStateSucceeded struct {
	tdCommon
	Date int32  `json:"date"` // Point in time (Unix timestamp) when the withdrawal was completed
	URL  string `json:"url"`  // The URL where the withdrawal transaction can be viewed
}

// MessageType return the string telegram-type of RevenueWithdrawalStateSucceeded
func (revenueWithdrawalStateSucceeded *RevenueWithdrawalStateSucceeded) MessageType() string {
	return "revenueWithdrawalStateSucceeded"
}

// NewRevenueWithdrawalStateSucceeded creates a new RevenueWithdrawalStateSucceeded
//
// @param date Point in time (Unix timestamp) when the withdrawal was completed
// @param uRL The URL where the withdrawal transaction can be viewed
func NewRevenueWithdrawalStateSucceeded(date int32, uRL string) *RevenueWithdrawalStateSucceeded {
	revenueWithdrawalStateSucceededTemp := RevenueWithdrawalStateSucceeded{
		tdCommon: tdCommon{Type: "revenueWithdrawalStateSucceeded"},
		Date:     date,
		URL:      uRL,
	}

	return &revenueWithdrawalStateSucceededTemp
}

// UnmarshalJSON unmarshal to json
func (revenueWithdrawalStateSucceeded *RevenueWithdrawalStateSucceeded) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Date int32  `json:"date"` // Point in time (Unix timestamp) when the withdrawal was completed
		URL  string `json:"url"`  // The URL where the withdrawal transaction can be viewed
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	revenueWithdrawalStateSucceeded.tdCommon = tempObj.tdCommon
	revenueWithdrawalStateSucceeded.Date = tempObj.Date
	revenueWithdrawalStateSucceeded.URL = tempObj.URL

	return nil
}

// GetRevenueWithdrawalStateEnum return the enum type of this object
func (revenueWithdrawalStateSucceeded *RevenueWithdrawalStateSucceeded) GetRevenueWithdrawalStateEnum() RevenueWithdrawalStateEnum {
	return RevenueWithdrawalStateSucceededType
}

// RevenueWithdrawalStateFailed Withdrawal failed
type RevenueWithdrawalStateFailed struct {
	tdCommon
}

// MessageType return the string telegram-type of RevenueWithdrawalStateFailed
func (revenueWithdrawalStateFailed *RevenueWithdrawalStateFailed) MessageType() string {
	return "revenueWithdrawalStateFailed"
}

// NewRevenueWithdrawalStateFailed creates a new RevenueWithdrawalStateFailed
//
func NewRevenueWithdrawalStateFailed() *RevenueWithdrawalStateFailed {
	revenueWithdrawalStateFailedTemp := RevenueWithdrawalStateFailed{
		tdCommon: tdCommon{Type: "revenueWithdrawalStateFailed"},
	}

	return &revenueWithdrawalStateFailedTemp
}

// UnmarshalJSON unmarshal to json
func (revenueWithdrawalStateFailed *RevenueWithdrawalStateFailed) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	revenueWithdrawalStateFailed.tdCommon = tempObj.tdCommon

	return nil
}

// GetRevenueWithdrawalStateEnum return the enum type of this object
func (revenueWithdrawalStateFailed *RevenueWithdrawalStateFailed) GetRevenueWithdrawalStateEnum() RevenueWithdrawalStateEnum {
	return RevenueWithdrawalStateFailedType
}

// ChatRevenueTransactionTypeEarnings Describes earnings from sponsored messages in a chat in some time frame
type ChatRevenueTransactionTypeEarnings struct {
	tdCommon
	StartDate int32 `json:"start_date"` // Point in time (Unix timestamp) when the earnings started
	EndDate   int32 `json:"end_date"`   // Point in time (Unix timestamp) when the earnings ended
}

// MessageType return the string telegram-type of ChatRevenueTransactionTypeEarnings
func (chatRevenueTransactionTypeEarnings *ChatRevenueTransactionTypeEarnings) MessageType() string {
	return "chatRevenueTransactionTypeEarnings"
}

// NewChatRevenueTransactionTypeEarnings creates a new ChatRevenueTransactionTypeEarnings
//
// @param startDate Point in time (Unix timestamp) when the earnings started
// @param endDate Point in time (Unix timestamp) when the earnings ended
func NewChatRevenueTransactionTypeEarnings(startDate int32, endDate int32) *ChatRevenueTransactionTypeEarnings {
	chatRevenueTransactionTypeEarningsTemp := ChatRevenueTransactionTypeEarnings{
		tdCommon:  tdCommon{Type: "chatRevenueTransactionTypeEarnings"},
		StartDate: startDate,
		EndDate:   endDate,
	}

	return &chatRevenueTransactionTypeEarningsTemp
}

// UnmarshalJSON unmarshal to json
func (chatRevenueTransactionTypeEarnings *ChatRevenueTransactionTypeEarnings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StartDate int32 `json:"start_date"` // Point in time (Unix timestamp) when the earnings started
		EndDate   int32 `json:"end_date"`   // Point in time (Unix timestamp) when the earnings ended
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatRevenueTransactionTypeEarnings.tdCommon = tempObj.tdCommon
	chatRevenueTransactionTypeEarnings.StartDate = tempObj.StartDate
	chatRevenueTransactionTypeEarnings.EndDate = tempObj.EndDate

	return nil
}

// GetChatRevenueTransactionTypeEnum return the enum type of this object
func (chatRevenueTransactionTypeEarnings *ChatRevenueTransactionTypeEarnings) GetChatRevenueTransactionTypeEnum() ChatRevenueTransactionTypeEnum {
	return ChatRevenueTransactionTypeEarningsType
}

// ChatRevenueTransactionTypeWithdrawal Describes a withdrawal of earnings
type ChatRevenueTransactionTypeWithdrawal struct {
	tdCommon
	WithdrawalDate int32                  `json:"withdrawal_date"` // Point in time (Unix timestamp) when the earnings withdrawal started
	Provider       string                 `json:"provider"`        // Name of the payment provider
	State          RevenueWithdrawalState `json:"state"`           // State of the withdrawal
}

// MessageType return the string telegram-type of ChatRevenueTransactionTypeWithdrawal
func (chatRevenueTransactionTypeWithdrawal *ChatRevenueTransactionTypeWithdrawal) MessageType() string {
	return "chatRevenueTransactionTypeWithdrawal"
}

// NewChatRevenueTransactionTypeWithdrawal creates a new ChatRevenueTransactionTypeWithdrawal
//
// @param withdrawalDate Point in time (Unix timestamp) when the earnings withdrawal started
// @param provider Name of the payment provider
// @param state State of the withdrawal
func NewChatRevenueTransactionTypeWithdrawal(withdrawalDate int32, provider string, state RevenueWithdrawalState) *ChatRevenueTransactionTypeWithdrawal {
	chatRevenueTransactionTypeWithdrawalTemp := ChatRevenueTransactionTypeWithdrawal{
		tdCommon:       tdCommon{Type: "chatRevenueTransactionTypeWithdrawal"},
		WithdrawalDate: withdrawalDate,
		Provider:       provider,
		State:          state,
	}

	return &chatRevenueTransactionTypeWithdrawalTemp
}

// UnmarshalJSON unmarshal to json
func (chatRevenueTransactionTypeWithdrawal *ChatRevenueTransactionTypeWithdrawal) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		WithdrawalDate int32  `json:"withdrawal_date"` // Point in time (Unix timestamp) when the earnings withdrawal started
		Provider       string `json:"provider"`        // Name of the payment provider

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatRevenueTransactionTypeWithdrawal.tdCommon = tempObj.tdCommon
	chatRevenueTransactionTypeWithdrawal.WithdrawalDate = tempObj.WithdrawalDate
	chatRevenueTransactionTypeWithdrawal.Provider = tempObj.Provider

	fieldState, _ := unmarshalRevenueWithdrawalState(objMap["state"])
	chatRevenueTransactionTypeWithdrawal.State = fieldState

	return nil
}

// GetChatRevenueTransactionTypeEnum return the enum type of this object
func (chatRevenueTransactionTypeWithdrawal *ChatRevenueTransactionTypeWithdrawal) GetChatRevenueTransactionTypeEnum() ChatRevenueTransactionTypeEnum {
	return ChatRevenueTransactionTypeWithdrawalType
}

// ChatRevenueTransactionTypeRefund Describes a refund for failed withdrawal of earnings
type ChatRevenueTransactionTypeRefund struct {
	tdCommon
	RefundDate int32  `json:"refund_date"` // Point in time (Unix timestamp) when the transaction was refunded
	Provider   string `json:"provider"`    // Name of the payment provider
}

// MessageType return the string telegram-type of ChatRevenueTransactionTypeRefund
func (chatRevenueTransactionTypeRefund *ChatRevenueTransactionTypeRefund) MessageType() string {
	return "chatRevenueTransactionTypeRefund"
}

// NewChatRevenueTransactionTypeRefund creates a new ChatRevenueTransactionTypeRefund
//
// @param refundDate Point in time (Unix timestamp) when the transaction was refunded
// @param provider Name of the payment provider
func NewChatRevenueTransactionTypeRefund(refundDate int32, provider string) *ChatRevenueTransactionTypeRefund {
	chatRevenueTransactionTypeRefundTemp := ChatRevenueTransactionTypeRefund{
		tdCommon:   tdCommon{Type: "chatRevenueTransactionTypeRefund"},
		RefundDate: refundDate,
		Provider:   provider,
	}

	return &chatRevenueTransactionTypeRefundTemp
}

// UnmarshalJSON unmarshal to json
func (chatRevenueTransactionTypeRefund *ChatRevenueTransactionTypeRefund) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		RefundDate int32  `json:"refund_date"` // Point in time (Unix timestamp) when the transaction was refunded
		Provider   string `json:"provider"`    // Name of the payment provider
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatRevenueTransactionTypeRefund.tdCommon = tempObj.tdCommon
	chatRevenueTransactionTypeRefund.RefundDate = tempObj.RefundDate
	chatRevenueTransactionTypeRefund.Provider = tempObj.Provider

	return nil
}

// GetChatRevenueTransactionTypeEnum return the enum type of this object
func (chatRevenueTransactionTypeRefund *ChatRevenueTransactionTypeRefund) GetChatRevenueTransactionTypeEnum() ChatRevenueTransactionTypeEnum {
	return ChatRevenueTransactionTypeRefundType
}

// ChatRevenueTransaction Contains a chat revenue transactions
type ChatRevenueTransaction struct {
	tdCommon
	Cryptocurrency       string                     `json:"cryptocurrency"`        // Cryptocurrency in which revenue is calculated
	CryptocurrencyAmount JSONInt64                  `json:"cryptocurrency_amount"` // The withdrawn amount, in the smallest units of the cryptocurrency
	Type                 ChatRevenueTransactionType `json:"type"`                  // Type of the transaction
}

// MessageType return the string telegram-type of ChatRevenueTransaction
func (chatRevenueTransaction *ChatRevenueTransaction) MessageType() string {
	return "chatRevenueTransaction"
}

// NewChatRevenueTransaction creates a new ChatRevenueTransaction
//
// @param cryptocurrency Cryptocurrency in which revenue is calculated
// @param cryptocurrencyAmount The withdrawn amount, in the smallest units of the cryptocurrency
// @param typeParam Type of the transaction
func NewChatRevenueTransaction(cryptocurrency string, cryptocurrencyAmount JSONInt64, typeParam ChatRevenueTransactionType) *ChatRevenueTransaction {
	chatRevenueTransactionTemp := ChatRevenueTransaction{
		tdCommon:             tdCommon{Type: "chatRevenueTransaction"},
		Cryptocurrency:       cryptocurrency,
		CryptocurrencyAmount: cryptocurrencyAmount,
		Type:                 typeParam,
	}

	return &chatRevenueTransactionTemp
}

// UnmarshalJSON unmarshal to json
func (chatRevenueTransaction *ChatRevenueTransaction) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Cryptocurrency       string    `json:"cryptocurrency"`        // Cryptocurrency in which revenue is calculated
		CryptocurrencyAmount JSONInt64 `json:"cryptocurrency_amount"` // The withdrawn amount, in the smallest units of the cryptocurrency

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatRevenueTransaction.tdCommon = tempObj.tdCommon
	chatRevenueTransaction.Cryptocurrency = tempObj.Cryptocurrency
	chatRevenueTransaction.CryptocurrencyAmount = tempObj.CryptocurrencyAmount

	fieldType, _ := unmarshalChatRevenueTransactionType(objMap["type"])
	chatRevenueTransaction.Type = fieldType

	return nil
}

// ChatRevenueTransactions Contains a list of chat revenue transactions
type ChatRevenueTransactions struct {
	tdCommon
	TotalCount   int32                    `json:"total_count"`  // Total number of transactions
	Transactions []ChatRevenueTransaction `json:"transactions"` // List of transactions
}

// MessageType return the string telegram-type of ChatRevenueTransactions
func (chatRevenueTransactions *ChatRevenueTransactions) MessageType() string {
	return "chatRevenueTransactions"
}

// NewChatRevenueTransactions creates a new ChatRevenueTransactions
//
// @param totalCount Total number of transactions
// @param transactions List of transactions
func NewChatRevenueTransactions(totalCount int32, transactions []ChatRevenueTransaction) *ChatRevenueTransactions {
	chatRevenueTransactionsTemp := ChatRevenueTransactions{
		tdCommon:     tdCommon{Type: "chatRevenueTransactions"},
		TotalCount:   totalCount,
		Transactions: transactions,
	}

	return &chatRevenueTransactionsTemp
}

// UnmarshalJSON unmarshal to json
func (chatRevenueTransactions *ChatRevenueTransactions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount   int32                    `json:"total_count"`  // Total number of transactions
		Transactions []ChatRevenueTransaction `json:"transactions"` // List of transactions
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	chatRevenueTransactions.tdCommon = tempObj.tdCommon
	chatRevenueTransactions.TotalCount = tempObj.TotalCount
	chatRevenueTransactions.Transactions = tempObj.Transactions

	return nil
}

// StarRevenueStatus Contains information about Telegram Stars earned by a bot or a chat
type StarRevenueStatus struct {
	tdCommon
	TotalCount        int64 `json:"total_count"`        // Total number of Telegram Stars earned
	CurrentCount      int64 `json:"current_count"`      // The number of Telegram Stars that aren't withdrawn yet
	AvailableCount    int64 `json:"available_count"`    // The number of Telegram Stars that are available for withdrawal
	WithdrawalEnabled bool  `json:"withdrawal_enabled"` // True, if Telegram Stars can be withdrawn now or later
	NextWithdrawalIn  int32 `json:"next_withdrawal_in"` // Time left before the next withdrawal can be started, in seconds; 0 if withdrawal can be started now
}

// MessageType return the string telegram-type of StarRevenueStatus
func (starRevenueStatus *StarRevenueStatus) MessageType() string {
	return "starRevenueStatus"
}

// NewStarRevenueStatus creates a new StarRevenueStatus
//
// @param totalCount Total number of Telegram Stars earned
// @param currentCount The number of Telegram Stars that aren't withdrawn yet
// @param availableCount The number of Telegram Stars that are available for withdrawal
// @param withdrawalEnabled True, if Telegram Stars can be withdrawn now or later
// @param nextWithdrawalIn Time left before the next withdrawal can be started, in seconds; 0 if withdrawal can be started now
func NewStarRevenueStatus(totalCount int64, currentCount int64, availableCount int64, withdrawalEnabled bool, nextWithdrawalIn int32) *StarRevenueStatus {
	starRevenueStatusTemp := StarRevenueStatus{
		tdCommon:          tdCommon{Type: "starRevenueStatus"},
		TotalCount:        totalCount,
		CurrentCount:      currentCount,
		AvailableCount:    availableCount,
		WithdrawalEnabled: withdrawalEnabled,
		NextWithdrawalIn:  nextWithdrawalIn,
	}

	return &starRevenueStatusTemp
}

// UnmarshalJSON unmarshal to json
func (starRevenueStatus *StarRevenueStatus) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount        int64 `json:"total_count"`        // Total number of Telegram Stars earned
		CurrentCount      int64 `json:"current_count"`      // The number of Telegram Stars that aren't withdrawn yet
		AvailableCount    int64 `json:"available_count"`    // The number of Telegram Stars that are available for withdrawal
		WithdrawalEnabled bool  `json:"withdrawal_enabled"` // True, if Telegram Stars can be withdrawn now or later
		NextWithdrawalIn  int32 `json:"next_withdrawal_in"` // Time left before the next withdrawal can be started, in seconds; 0 if withdrawal can be started now
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starRevenueStatus.tdCommon = tempObj.tdCommon
	starRevenueStatus.TotalCount = tempObj.TotalCount
	starRevenueStatus.CurrentCount = tempObj.CurrentCount
	starRevenueStatus.AvailableCount = tempObj.AvailableCount
	starRevenueStatus.WithdrawalEnabled = tempObj.WithdrawalEnabled
	starRevenueStatus.NextWithdrawalIn = tempObj.NextWithdrawalIn

	return nil
}

// StarRevenueStatistics A detailed statistics about Telegram Stars earned by a bot or a chat
type StarRevenueStatistics struct {
	tdCommon
	RevenueByDayGraph StatisticalGraph   `json:"revenue_by_day_graph"` // A graph containing amount of revenue in a given day
	Status            *StarRevenueStatus `json:"status"`               // Telegram Star revenue status
	UsdRate           float64            `json:"usd_rate"`             // Current conversion rate of a Telegram Star to USD
}

// MessageType return the string telegram-type of StarRevenueStatistics
func (starRevenueStatistics *StarRevenueStatistics) MessageType() string {
	return "starRevenueStatistics"
}

// NewStarRevenueStatistics creates a new StarRevenueStatistics
//
// @param revenueByDayGraph A graph containing amount of revenue in a given day
// @param status Telegram Star revenue status
// @param usdRate Current conversion rate of a Telegram Star to USD
func NewStarRevenueStatistics(revenueByDayGraph StatisticalGraph, status *StarRevenueStatus, usdRate float64) *StarRevenueStatistics {
	starRevenueStatisticsTemp := StarRevenueStatistics{
		tdCommon:          tdCommon{Type: "starRevenueStatistics"},
		RevenueByDayGraph: revenueByDayGraph,
		Status:            status,
		UsdRate:           usdRate,
	}

	return &starRevenueStatisticsTemp
}

// UnmarshalJSON unmarshal to json
func (starRevenueStatistics *StarRevenueStatistics) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Status  *StarRevenueStatus `json:"status"`   // Telegram Star revenue status
		UsdRate float64            `json:"usd_rate"` // Current conversion rate of a Telegram Star to USD
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	starRevenueStatistics.tdCommon = tempObj.tdCommon
	starRevenueStatistics.Status = tempObj.Status
	starRevenueStatistics.UsdRate = tempObj.UsdRate

	fieldRevenueByDayGraph, _ := unmarshalStatisticalGraph(objMap["revenue_by_day_graph"])
	starRevenueStatistics.RevenueByDayGraph = fieldRevenueByDayGraph

	return nil
}

// Point A point on a Cartesian plane
type Point struct {
	tdCommon
	X float64 `json:"x"` // The point's first coordinate
	Y float64 `json:"y"` // The point's second coordinate
}

// MessageType return the string telegram-type of Point
func (point *Point) MessageType() string {
	return "point"
}

// NewPoint creates a new Point
//
// @param x The point's first coordinate
// @param y The point's second coordinate
func NewPoint(x float64, y float64) *Point {
	pointTemp := Point{
		tdCommon: tdCommon{Type: "point"},
		X:        x,
		Y:        y,
	}

	return &pointTemp
}

// UnmarshalJSON unmarshal to json
func (point *Point) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		X float64 `json:"x"` // The point's first coordinate
		Y float64 `json:"y"` // The point's second coordinate
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	point.tdCommon = tempObj.tdCommon
	point.X = tempObj.X
	point.Y = tempObj.Y

	return nil
}

// VectorPathCommandLine A straight line to a given point
type VectorPathCommandLine struct {
	tdCommon
	EndPoint *Point `json:"end_point"` // The end point of the straight line
}

// MessageType return the string telegram-type of VectorPathCommandLine
func (vectorPathCommandLine *VectorPathCommandLine) MessageType() string {
	return "vectorPathCommandLine"
}

// NewVectorPathCommandLine creates a new VectorPathCommandLine
//
// @param endPoint The end point of the straight line
func NewVectorPathCommandLine(endPoint *Point) *VectorPathCommandLine {
	vectorPathCommandLineTemp := VectorPathCommandLine{
		tdCommon: tdCommon{Type: "vectorPathCommandLine"},
		EndPoint: endPoint,
	}

	return &vectorPathCommandLineTemp
}

// UnmarshalJSON unmarshal to json
func (vectorPathCommandLine *VectorPathCommandLine) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		EndPoint *Point `json:"end_point"` // The end point of the straight line
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	vectorPathCommandLine.tdCommon = tempObj.tdCommon
	vectorPathCommandLine.EndPoint = tempObj.EndPoint

	return nil
}

// GetVectorPathCommandEnum return the enum type of this object
func (vectorPathCommandLine *VectorPathCommandLine) GetVectorPathCommandEnum() VectorPathCommandEnum {
	return VectorPathCommandLineType
}

// VectorPathCommandCubicBezierCurve A cubic Bézier curve to a given point
type VectorPathCommandCubicBezierCurve struct {
	tdCommon
	StartControlPoint *Point `json:"start_control_point"` // The start control point of the curve
	EndControlPoint   *Point `json:"end_control_point"`   // The end control point of the curve
	EndPoint          *Point `json:"end_point"`           // The end point of the curve
}

// MessageType return the string telegram-type of VectorPathCommandCubicBezierCurve
func (vectorPathCommandCubicBezierCurve *VectorPathCommandCubicBezierCurve) MessageType() string {
	return "vectorPathCommandCubicBezierCurve"
}

// NewVectorPathCommandCubicBezierCurve creates a new VectorPathCommandCubicBezierCurve
//
// @param startControlPoint The start control point of the curve
// @param endControlPoint The end control point of the curve
// @param endPoint The end point of the curve
func NewVectorPathCommandCubicBezierCurve(startControlPoint *Point, endControlPoint *Point, endPoint *Point) *VectorPathCommandCubicBezierCurve {
	vectorPathCommandCubicBezierCurveTemp := VectorPathCommandCubicBezierCurve{
		tdCommon:          tdCommon{Type: "vectorPathCommandCubicBezierCurve"},
		StartControlPoint: startControlPoint,
		EndControlPoint:   endControlPoint,
		EndPoint:          endPoint,
	}

	return &vectorPathCommandCubicBezierCurveTemp
}

// UnmarshalJSON unmarshal to json
func (vectorPathCommandCubicBezierCurve *VectorPathCommandCubicBezierCurve) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StartControlPoint *Point `json:"start_control_point"` // The start control point of the curve
		EndControlPoint   *Point `json:"end_control_point"`   // The end control point of the curve
		EndPoint          *Point `json:"end_point"`           // The end point of the curve
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	vectorPathCommandCubicBezierCurve.tdCommon = tempObj.tdCommon
	vectorPathCommandCubicBezierCurve.StartControlPoint = tempObj.StartControlPoint
	vectorPathCommandCubicBezierCurve.EndControlPoint = tempObj.EndControlPoint
	vectorPathCommandCubicBezierCurve.EndPoint = tempObj.EndPoint

	return nil
}

// GetVectorPathCommandEnum return the enum type of this object
func (vectorPathCommandCubicBezierCurve *VectorPathCommandCubicBezierCurve) GetVectorPathCommandEnum() VectorPathCommandEnum {
	return VectorPathCommandCubicBezierCurveType
}

// BotCommandScopeDefault A scope covering all users
type BotCommandScopeDefault struct {
	tdCommon
}

// MessageType return the string telegram-type of BotCommandScopeDefault
func (botCommandScopeDefault *BotCommandScopeDefault) MessageType() string {
	return "botCommandScopeDefault"
}

// NewBotCommandScopeDefault creates a new BotCommandScopeDefault
//
func NewBotCommandScopeDefault() *BotCommandScopeDefault {
	botCommandScopeDefaultTemp := BotCommandScopeDefault{
		tdCommon: tdCommon{Type: "botCommandScopeDefault"},
	}

	return &botCommandScopeDefaultTemp
}

// UnmarshalJSON unmarshal to json
func (botCommandScopeDefault *BotCommandScopeDefault) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	botCommandScopeDefault.tdCommon = tempObj.tdCommon

	return nil
}

// GetBotCommandScopeEnum return the enum type of this object
func (botCommandScopeDefault *BotCommandScopeDefault) GetBotCommandScopeEnum() BotCommandScopeEnum {
	return BotCommandScopeDefaultType
}

// BotCommandScopeAllPrivateChats A scope covering all private chats
type BotCommandScopeAllPrivateChats struct {
	tdCommon
}

// MessageType return the string telegram-type of BotCommandScopeAllPrivateChats
func (botCommandScopeAllPrivateChats *BotCommandScopeAllPrivateChats) MessageType() string {
	return "botCommandScopeAllPrivateChats"
}

// NewBotCommandScopeAllPrivateChats creates a new BotCommandScopeAllPrivateChats
//
func NewBotCommandScopeAllPrivateChats() *BotCommandScopeAllPrivateChats {
	botCommandScopeAllPrivateChatsTemp := BotCommandScopeAllPrivateChats{
		tdCommon: tdCommon{Type: "botCommandScopeAllPrivateChats"},
	}

	return &botCommandScopeAllPrivateChatsTemp
}

// UnmarshalJSON unmarshal to json
func (botCommandScopeAllPrivateChats *BotCommandScopeAllPrivateChats) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	botCommandScopeAllPrivateChats.tdCommon = tempObj.tdCommon

	return nil
}

// GetBotCommandScopeEnum return the enum type of this object
func (botCommandScopeAllPrivateChats *BotCommandScopeAllPrivateChats) GetBotCommandScopeEnum() BotCommandScopeEnum {
	return BotCommandScopeAllPrivateChatsType
}

// BotCommandScopeAllGroupChats A scope covering all group and supergroup chats
type BotCommandScopeAllGroupChats struct {
	tdCommon
}

// MessageType return the string telegram-type of BotCommandScopeAllGroupChats
func (botCommandScopeAllGroupChats *BotCommandScopeAllGroupChats) MessageType() string {
	return "botCommandScopeAllGroupChats"
}

// NewBotCommandScopeAllGroupChats creates a new BotCommandScopeAllGroupChats
//
func NewBotCommandScopeAllGroupChats() *BotCommandScopeAllGroupChats {
	botCommandScopeAllGroupChatsTemp := BotCommandScopeAllGroupChats{
		tdCommon: tdCommon{Type: "botCommandScopeAllGroupChats"},
	}

	return &botCommandScopeAllGroupChatsTemp
}

// UnmarshalJSON unmarshal to json
func (botCommandScopeAllGroupChats *BotCommandScopeAllGroupChats) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	botCommandScopeAllGroupChats.tdCommon = tempObj.tdCommon

	return nil
}

// GetBotCommandScopeEnum return the enum type of this object
func (botCommandScopeAllGroupChats *BotCommandScopeAllGroupChats) GetBotCommandScopeEnum() BotCommandScopeEnum {
	return BotCommandScopeAllGroupChatsType
}

// BotCommandScopeAllChatAdministrators A scope covering all group and supergroup chat administrators
type BotCommandScopeAllChatAdministrators struct {
	tdCommon
}

// MessageType return the string telegram-type of BotCommandScopeAllChatAdministrators
func (botCommandScopeAllChatAdministrators *BotCommandScopeAllChatAdministrators) MessageType() string {
	return "botCommandScopeAllChatAdministrators"
}

// NewBotCommandScopeAllChatAdministrators creates a new BotCommandScopeAllChatAdministrators
//
func NewBotCommandScopeAllChatAdministrators() *BotCommandScopeAllChatAdministrators {
	botCommandScopeAllChatAdministratorsTemp := BotCommandScopeAllChatAdministrators{
		tdCommon: tdCommon{Type: "botCommandScopeAllChatAdministrators"},
	}

	return &botCommandScopeAllChatAdministratorsTemp
}

// UnmarshalJSON unmarshal to json
func (botCommandScopeAllChatAdministrators *BotCommandScopeAllChatAdministrators) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	botCommandScopeAllChatAdministrators.tdCommon = tempObj.tdCommon

	return nil
}

// GetBotCommandScopeEnum return the enum type of this object
func (botCommandScopeAllChatAdministrators *BotCommandScopeAllChatAdministrators) GetBotCommandScopeEnum() BotCommandScopeEnum {
	return BotCommandScopeAllChatAdministratorsType
}

// BotCommandScopeChat A scope covering all members of a chat
type BotCommandScopeChat struct {
	tdCommon
	ChatID int64 `json:"chat_id"` // Chat identifier
}

// MessageType return the string telegram-type of BotCommandScopeChat
func (botCommandScopeChat *BotCommandScopeChat) MessageType() string {
	return "botCommandScopeChat"
}

// NewBotCommandScopeChat creates a new BotCommandScopeChat
//
// @param chatID Chat identifier
func NewBotCommandScopeChat(chatID int64) *BotCommandScopeChat {
	botCommandScopeChatTemp := BotCommandScopeChat{
		tdCommon: tdCommon{Type: "botCommandScopeChat"},
		ChatID:   chatID,
	}

	return &botCommandScopeChatTemp
}

// UnmarshalJSON unmarshal to json
func (botCommandScopeChat *BotCommandScopeChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID int64 `json:"chat_id"` // Chat identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	botCommandScopeChat.tdCommon = tempObj.tdCommon
	botCommandScopeChat.ChatID = tempObj.ChatID

	return nil
}

// GetBotCommandScopeEnum return the enum type of this object
func (botCommandScopeChat *BotCommandScopeChat) GetBotCommandScopeEnum() BotCommandScopeEnum {
	return BotCommandScopeChatType
}

// BotCommandScopeChatAdministrators A scope covering all administrators of a chat
type BotCommandScopeChatAdministrators struct {
	tdCommon
	ChatID int64 `json:"chat_id"` // Chat identifier
}

// MessageType return the string telegram-type of BotCommandScopeChatAdministrators
func (botCommandScopeChatAdministrators *BotCommandScopeChatAdministrators) MessageType() string {
	return "botCommandScopeChatAdministrators"
}

// NewBotCommandScopeChatAdministrators creates a new BotCommandScopeChatAdministrators
//
// @param chatID Chat identifier
func NewBotCommandScopeChatAdministrators(chatID int64) *BotCommandScopeChatAdministrators {
	botCommandScopeChatAdministratorsTemp := BotCommandScopeChatAdministrators{
		tdCommon: tdCommon{Type: "botCommandScopeChatAdministrators"},
		ChatID:   chatID,
	}

	return &botCommandScopeChatAdministratorsTemp
}

// UnmarshalJSON unmarshal to json
func (botCommandScopeChatAdministrators *BotCommandScopeChatAdministrators) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID int64 `json:"chat_id"` // Chat identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	botCommandScopeChatAdministrators.tdCommon = tempObj.tdCommon
	botCommandScopeChatAdministrators.ChatID = tempObj.ChatID

	return nil
}

// GetBotCommandScopeEnum return the enum type of this object
func (botCommandScopeChatAdministrators *BotCommandScopeChatAdministrators) GetBotCommandScopeEnum() BotCommandScopeEnum {
	return BotCommandScopeChatAdministratorsType
}

// BotCommandScopeChatMember A scope covering a member of a chat
type BotCommandScopeChatMember struct {
	tdCommon
	ChatID int64 `json:"chat_id"` // Chat identifier
	UserID int64 `json:"user_id"` // User identifier
}

// MessageType return the string telegram-type of BotCommandScopeChatMember
func (botCommandScopeChatMember *BotCommandScopeChatMember) MessageType() string {
	return "botCommandScopeChatMember"
}

// NewBotCommandScopeChatMember creates a new BotCommandScopeChatMember
//
// @param chatID Chat identifier
// @param userID User identifier
func NewBotCommandScopeChatMember(chatID int64, userID int64) *BotCommandScopeChatMember {
	botCommandScopeChatMemberTemp := BotCommandScopeChatMember{
		tdCommon: tdCommon{Type: "botCommandScopeChatMember"},
		ChatID:   chatID,
		UserID:   userID,
	}

	return &botCommandScopeChatMemberTemp
}

// UnmarshalJSON unmarshal to json
func (botCommandScopeChatMember *BotCommandScopeChatMember) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID int64 `json:"chat_id"` // Chat identifier
		UserID int64 `json:"user_id"` // User identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	botCommandScopeChatMember.tdCommon = tempObj.tdCommon
	botCommandScopeChatMember.ChatID = tempObj.ChatID
	botCommandScopeChatMember.UserID = tempObj.UserID

	return nil
}

// GetBotCommandScopeEnum return the enum type of this object
func (botCommandScopeChatMember *BotCommandScopeChatMember) GetBotCommandScopeEnum() BotCommandScopeEnum {
	return BotCommandScopeChatMemberType
}

// PhoneNumberCodeTypeChange Checks ownership of a new phone number to change the user's authentication phone number; for official Android and iOS applications only
type PhoneNumberCodeTypeChange struct {
	tdCommon
}

// MessageType return the string telegram-type of PhoneNumberCodeTypeChange
func (phoneNumberCodeTypeChange *PhoneNumberCodeTypeChange) MessageType() string {
	return "phoneNumberCodeTypeChange"
}

// NewPhoneNumberCodeTypeChange creates a new PhoneNumberCodeTypeChange
//
func NewPhoneNumberCodeTypeChange() *PhoneNumberCodeTypeChange {
	phoneNumberCodeTypeChangeTemp := PhoneNumberCodeTypeChange{
		tdCommon: tdCommon{Type: "phoneNumberCodeTypeChange"},
	}

	return &phoneNumberCodeTypeChangeTemp
}

// UnmarshalJSON unmarshal to json
func (phoneNumberCodeTypeChange *PhoneNumberCodeTypeChange) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	phoneNumberCodeTypeChange.tdCommon = tempObj.tdCommon

	return nil
}

// GetPhoneNumberCodeTypeEnum return the enum type of this object
func (phoneNumberCodeTypeChange *PhoneNumberCodeTypeChange) GetPhoneNumberCodeTypeEnum() PhoneNumberCodeTypeEnum {
	return PhoneNumberCodeTypeChangeType
}

// PhoneNumberCodeTypeVerify Verifies ownership of a phone number to be added to the user's Telegram Passport
type PhoneNumberCodeTypeVerify struct {
	tdCommon
}

// MessageType return the string telegram-type of PhoneNumberCodeTypeVerify
func (phoneNumberCodeTypeVerify *PhoneNumberCodeTypeVerify) MessageType() string {
	return "phoneNumberCodeTypeVerify"
}

// NewPhoneNumberCodeTypeVerify creates a new PhoneNumberCodeTypeVerify
//
func NewPhoneNumberCodeTypeVerify() *PhoneNumberCodeTypeVerify {
	phoneNumberCodeTypeVerifyTemp := PhoneNumberCodeTypeVerify{
		tdCommon: tdCommon{Type: "phoneNumberCodeTypeVerify"},
	}

	return &phoneNumberCodeTypeVerifyTemp
}

// UnmarshalJSON unmarshal to json
func (phoneNumberCodeTypeVerify *PhoneNumberCodeTypeVerify) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	phoneNumberCodeTypeVerify.tdCommon = tempObj.tdCommon

	return nil
}

// GetPhoneNumberCodeTypeEnum return the enum type of this object
func (phoneNumberCodeTypeVerify *PhoneNumberCodeTypeVerify) GetPhoneNumberCodeTypeEnum() PhoneNumberCodeTypeEnum {
	return PhoneNumberCodeTypeVerifyType
}

// PhoneNumberCodeTypeConfirmOwnership Confirms ownership of a phone number to prevent account deletion while handling links of the type internalLinkTypePhoneNumberConfirmation
type PhoneNumberCodeTypeConfirmOwnership struct {
	tdCommon
	Hash string `json:"hash"` // Hash value from the link
}

// MessageType return the string telegram-type of PhoneNumberCodeTypeConfirmOwnership
func (phoneNumberCodeTypeConfirmOwnership *PhoneNumberCodeTypeConfirmOwnership) MessageType() string {
	return "phoneNumberCodeTypeConfirmOwnership"
}

// NewPhoneNumberCodeTypeConfirmOwnership creates a new PhoneNumberCodeTypeConfirmOwnership
//
// @param hash Hash value from the link
func NewPhoneNumberCodeTypeConfirmOwnership(hash string) *PhoneNumberCodeTypeConfirmOwnership {
	phoneNumberCodeTypeConfirmOwnershipTemp := PhoneNumberCodeTypeConfirmOwnership{
		tdCommon: tdCommon{Type: "phoneNumberCodeTypeConfirmOwnership"},
		Hash:     hash,
	}

	return &phoneNumberCodeTypeConfirmOwnershipTemp
}

// UnmarshalJSON unmarshal to json
func (phoneNumberCodeTypeConfirmOwnership *PhoneNumberCodeTypeConfirmOwnership) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Hash string `json:"hash"` // Hash value from the link
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	phoneNumberCodeTypeConfirmOwnership.tdCommon = tempObj.tdCommon
	phoneNumberCodeTypeConfirmOwnership.Hash = tempObj.Hash

	return nil
}

// GetPhoneNumberCodeTypeEnum return the enum type of this object
func (phoneNumberCodeTypeConfirmOwnership *PhoneNumberCodeTypeConfirmOwnership) GetPhoneNumberCodeTypeEnum() PhoneNumberCodeTypeEnum {
	return PhoneNumberCodeTypeConfirmOwnershipType
}

// UpdateAuthorizationState The user authorization state has changed
type UpdateAuthorizationState struct {
	tdCommon
	AuthorizationState AuthorizationState `json:"authorization_state"` // New authorization state
}

// MessageType return the string telegram-type of UpdateAuthorizationState
func (updateAuthorizationState *UpdateAuthorizationState) MessageType() string {
	return "updateAuthorizationState"
}

// NewUpdateAuthorizationState creates a new UpdateAuthorizationState
//
// @param authorizationState New authorization state
func NewUpdateAuthorizationState(authorizationState AuthorizationState) *UpdateAuthorizationState {
	updateAuthorizationStateTemp := UpdateAuthorizationState{
		tdCommon:           tdCommon{Type: "updateAuthorizationState"},
		AuthorizationState: authorizationState,
	}

	return &updateAuthorizationStateTemp
}

// UnmarshalJSON unmarshal to json
func (updateAuthorizationState *UpdateAuthorizationState) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateAuthorizationState.tdCommon = tempObj.tdCommon

	fieldAuthorizationState, _ := unmarshalAuthorizationState(objMap["authorization_state"])
	updateAuthorizationState.AuthorizationState = fieldAuthorizationState

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateAuthorizationState *UpdateAuthorizationState) GetUpdateEnum() UpdateEnum {
	return UpdateAuthorizationStateType
}

// UpdateNewMessage A new message was received; can also be an outgoing message
type UpdateNewMessage struct {
	tdCommon
	Message *Message `json:"message"` // The new message
}

// MessageType return the string telegram-type of UpdateNewMessage
func (updateNewMessage *UpdateNewMessage) MessageType() string {
	return "updateNewMessage"
}

// NewUpdateNewMessage creates a new UpdateNewMessage
//
// @param message The new message
func NewUpdateNewMessage(message *Message) *UpdateNewMessage {
	updateNewMessageTemp := UpdateNewMessage{
		tdCommon: tdCommon{Type: "updateNewMessage"},
		Message:  message,
	}

	return &updateNewMessageTemp
}

// UnmarshalJSON unmarshal to json
func (updateNewMessage *UpdateNewMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateNewMessage.tdCommon = tempObj.tdCommon

	var message Message
	if objMap["message"] != nil {
		err = message.UnmarshalJSON(*objMap["message"])
		if err != nil {
			return err
		}
	}

	updateNewMessage.Message = &message

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateNewMessage *UpdateNewMessage) GetUpdateEnum() UpdateEnum {
	return UpdateNewMessageType
}

// UpdateMessageSendAcknowledged A request to send a message has reached the Telegram server. This doesn't mean that the message will be sent successfully. This update is sent only if the option "use_quick_ack" is set to true. This update may be sent multiple times for the same message
type UpdateMessageSendAcknowledged struct {
	tdCommon
	ChatID    int64 `json:"chat_id"`    // The chat identifier of the sent message
	MessageID int64 `json:"message_id"` // A temporary message identifier
}

// MessageType return the string telegram-type of UpdateMessageSendAcknowledged
func (updateMessageSendAcknowledged *UpdateMessageSendAcknowledged) MessageType() string {
	return "updateMessageSendAcknowledged"
}

// NewUpdateMessageSendAcknowledged creates a new UpdateMessageSendAcknowledged
//
// @param chatID The chat identifier of the sent message
// @param messageID A temporary message identifier
func NewUpdateMessageSendAcknowledged(chatID int64, messageID int64) *UpdateMessageSendAcknowledged {
	updateMessageSendAcknowledgedTemp := UpdateMessageSendAcknowledged{
		tdCommon:  tdCommon{Type: "updateMessageSendAcknowledged"},
		ChatID:    chatID,
		MessageID: messageID,
	}

	return &updateMessageSendAcknowledgedTemp
}

// UnmarshalJSON unmarshal to json
func (updateMessageSendAcknowledged *UpdateMessageSendAcknowledged) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID    int64 `json:"chat_id"`    // The chat identifier of the sent message
		MessageID int64 `json:"message_id"` // A temporary message identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateMessageSendAcknowledged.tdCommon = tempObj.tdCommon
	updateMessageSendAcknowledged.ChatID = tempObj.ChatID
	updateMessageSendAcknowledged.MessageID = tempObj.MessageID

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateMessageSendAcknowledged *UpdateMessageSendAcknowledged) GetUpdateEnum() UpdateEnum {
	return UpdateMessageSendAcknowledgedType
}

// UpdateMessageSendSucceeded A message has been successfully sent
type UpdateMessageSendSucceeded struct {
	tdCommon
	Message      *Message `json:"message"`        // The sent message. Usually only the message identifier, date, and content are changed, but almost all other fields can also change
	OldMessageID int64    `json:"old_message_id"` // The previous temporary message identifier
}

// MessageType return the string telegram-type of UpdateMessageSendSucceeded
func (updateMessageSendSucceeded *UpdateMessageSendSucceeded) MessageType() string {
	return "updateMessageSendSucceeded"
}

// NewUpdateMessageSendSucceeded creates a new UpdateMessageSendSucceeded
//
// @param message The sent message. Usually only the message identifier, date, and content are changed, but almost all other fields can also change
// @param oldMessageID The previous temporary message identifier
func NewUpdateMessageSendSucceeded(message *Message, oldMessageID int64) *UpdateMessageSendSucceeded {
	updateMessageSendSucceededTemp := UpdateMessageSendSucceeded{
		tdCommon:     tdCommon{Type: "updateMessageSendSucceeded"},
		Message:      message,
		OldMessageID: oldMessageID,
	}

	return &updateMessageSendSucceededTemp
}

// UnmarshalJSON unmarshal to json
func (updateMessageSendSucceeded *UpdateMessageSendSucceeded) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OldMessageID int64 `json:"old_message_id"` // The previous temporary message identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateMessageSendSucceeded.tdCommon = tempObj.tdCommon
	updateMessageSendSucceeded.OldMessageID = tempObj.OldMessageID

	var message Message
	if objMap["message"] != nil {
		err = message.UnmarshalJSON(*objMap["message"])
		if err != nil {
			return err
		}
	}

	updateMessageSendSucceeded.Message = &message

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateMessageSendSucceeded *UpdateMessageSendSucceeded) GetUpdateEnum() UpdateEnum {
	return UpdateMessageSendSucceededType
}

// UpdateMessageSendFailed A message failed to send. Be aware that some messages being sent can be irrecoverably deleted, in which case updateDeleteMessages will be received instead of this update
type UpdateMessageSendFailed struct {
	tdCommon
	Message      *Message `json:"message"`        // The failed to send message
	OldMessageID int64    `json:"old_message_id"` // The previous temporary message identifier
	Error        *Error   `json:"error"`          // The cause of the message sending failure
}

// MessageType return the string telegram-type of UpdateMessageSendFailed
func (updateMessageSendFailed *UpdateMessageSendFailed) MessageType() string {
	return "updateMessageSendFailed"
}

// NewUpdateMessageSendFailed creates a new UpdateMessageSendFailed
//
// @param message The failed to send message
// @param oldMessageID The previous temporary message identifier
// @param errParam The cause of the message sending failure
func NewUpdateMessageSendFailed(message *Message, oldMessageID int64, errParam *Error) *UpdateMessageSendFailed {
	updateMessageSendFailedTemp := UpdateMessageSendFailed{
		tdCommon:     tdCommon{Type: "updateMessageSendFailed"},
		Message:      message,
		OldMessageID: oldMessageID,
		Error:        errParam,
	}

	return &updateMessageSendFailedTemp
}

// UnmarshalJSON unmarshal to json
func (updateMessageSendFailed *UpdateMessageSendFailed) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OldMessageID int64  `json:"old_message_id"` // The previous temporary message identifier
		Error        *Error `json:"error"`          // The cause of the message sending failure
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateMessageSendFailed.tdCommon = tempObj.tdCommon
	updateMessageSendFailed.OldMessageID = tempObj.OldMessageID
	updateMessageSendFailed.Error = tempObj.Error

	var message Message
	if objMap["message"] != nil {
		err = message.UnmarshalJSON(*objMap["message"])
		if err != nil {
			return err
		}
	}

	updateMessageSendFailed.Message = &message

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateMessageSendFailed *UpdateMessageSendFailed) GetUpdateEnum() UpdateEnum {
	return UpdateMessageSendFailedType
}

// UpdateMessageContent The message content has changed
type UpdateMessageContent struct {
	tdCommon
	ChatID     int64          `json:"chat_id"`     // Chat identifier
	MessageID  int64          `json:"message_id"`  // Message identifier
	NewContent MessageContent `json:"new_content"` // New message content
}

// MessageType return the string telegram-type of UpdateMessageContent
func (updateMessageContent *UpdateMessageContent) MessageType() string {
	return "updateMessageContent"
}

// NewUpdateMessageContent creates a new UpdateMessageContent
//
// @param chatID Chat identifier
// @param messageID Message identifier
// @param newContent New message content
func NewUpdateMessageContent(chatID int64, messageID int64, newContent MessageContent) *UpdateMessageContent {
	updateMessageContentTemp := UpdateMessageContent{
		tdCommon:   tdCommon{Type: "updateMessageContent"},
		ChatID:     chatID,
		MessageID:  messageID,
		NewContent: newContent,
	}

	return &updateMessageContentTemp
}

// UnmarshalJSON unmarshal to json
func (updateMessageContent *UpdateMessageContent) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID    int64 `json:"chat_id"`    // Chat identifier
		MessageID int64 `json:"message_id"` // Message identifier

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateMessageContent.tdCommon = tempObj.tdCommon
	updateMessageContent.ChatID = tempObj.ChatID
	updateMessageContent.MessageID = tempObj.MessageID

	fieldNewContent, _ := unmarshalMessageContent(objMap["new_content"])
	updateMessageContent.NewContent = fieldNewContent

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateMessageContent *UpdateMessageContent) GetUpdateEnum() UpdateEnum {
	return UpdateMessageContentType
}

// UpdateMessageEdited A message was edited. Changes in the message content will come in a separate updateMessageContent
type UpdateMessageEdited struct {
	tdCommon
	ChatID      int64        `json:"chat_id"`      // Chat identifier
	MessageID   int64        `json:"message_id"`   // Message identifier
	EditDate    int32        `json:"edit_date"`    // Point in time (Unix timestamp) when the message was edited
	ReplyMarkup *ReplyMarkup `json:"reply_markup"` // New message reply markup; may be null
}

// MessageType return the string telegram-type of UpdateMessageEdited
func (updateMessageEdited *UpdateMessageEdited) MessageType() string {
	return "updateMessageEdited"
}

// NewUpdateMessageEdited creates a new UpdateMessageEdited
//
// @param chatID Chat identifier
// @param messageID Message identifier
// @param editDate Point in time (Unix timestamp) when the message was edited
// @param replyMarkup New message reply markup; may be null
func NewUpdateMessageEdited(chatID int64, messageID int64, editDate int32, replyMarkup *ReplyMarkup) *UpdateMessageEdited {
	updateMessageEditedTemp := UpdateMessageEdited{
		tdCommon:    tdCommon{Type: "updateMessageEdited"},
		ChatID:      chatID,
		MessageID:   messageID,
		EditDate:    editDate,
		ReplyMarkup: replyMarkup,
	}

	return &updateMessageEditedTemp
}

// UnmarshalJSON unmarshal to json
func (updateMessageEdited *UpdateMessageEdited) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID    int64 `json:"chat_id"`    // Chat identifier
		MessageID int64 `json:"message_id"` // Message identifier
		EditDate  int32 `json:"edit_date"`  // Point in time (Unix timestamp) when the message was edited

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateMessageEdited.tdCommon = tempObj.tdCommon
	updateMessageEdited.ChatID = tempObj.ChatID
	updateMessageEdited.MessageID = tempObj.MessageID
	updateMessageEdited.EditDate = tempObj.EditDate

	fieldReplyMarkup, _ := unmarshalReplyMarkup(objMap["reply_markup"])
	updateMessageEdited.ReplyMarkup = &fieldReplyMarkup

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateMessageEdited *UpdateMessageEdited) GetUpdateEnum() UpdateEnum {
	return UpdateMessageEditedType
}

// UpdateMessageIsPinned The message pinned state was changed
type UpdateMessageIsPinned struct {
	tdCommon
	ChatID    int64 `json:"chat_id"`    // Chat identifier
	MessageID int64 `json:"message_id"` // The message identifier
	IsPinned  bool  `json:"is_pinned"`  // True, if the message is pinned
}

// MessageType return the string telegram-type of UpdateMessageIsPinned
func (updateMessageIsPinned *UpdateMessageIsPinned) MessageType() string {
	return "updateMessageIsPinned"
}

// NewUpdateMessageIsPinned creates a new UpdateMessageIsPinned
//
// @param chatID Chat identifier
// @param messageID The message identifier
// @param isPinned True, if the message is pinned
func NewUpdateMessageIsPinned(chatID int64, messageID int64, isPinned bool) *UpdateMessageIsPinned {
	updateMessageIsPinnedTemp := UpdateMessageIsPinned{
		tdCommon:  tdCommon{Type: "updateMessageIsPinned"},
		ChatID:    chatID,
		MessageID: messageID,
		IsPinned:  isPinned,
	}

	return &updateMessageIsPinnedTemp
}

// UnmarshalJSON unmarshal to json
func (updateMessageIsPinned *UpdateMessageIsPinned) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID    int64 `json:"chat_id"`    // Chat identifier
		MessageID int64 `json:"message_id"` // The message identifier
		IsPinned  bool  `json:"is_pinned"`  // True, if the message is pinned
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateMessageIsPinned.tdCommon = tempObj.tdCommon
	updateMessageIsPinned.ChatID = tempObj.ChatID
	updateMessageIsPinned.MessageID = tempObj.MessageID
	updateMessageIsPinned.IsPinned = tempObj.IsPinned

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateMessageIsPinned *UpdateMessageIsPinned) GetUpdateEnum() UpdateEnum {
	return UpdateMessageIsPinnedType
}

// UpdateMessageInteractionInfo The information about interactions with a message has changed
type UpdateMessageInteractionInfo struct {
	tdCommon
	ChatID          int64                   `json:"chat_id"`          // Chat identifier
	MessageID       int64                   `json:"message_id"`       // Message identifier
	InteractionInfo *MessageInteractionInfo `json:"interaction_info"` // New information about interactions with the message; may be null
}

// MessageType return the string telegram-type of UpdateMessageInteractionInfo
func (updateMessageInteractionInfo *UpdateMessageInteractionInfo) MessageType() string {
	return "updateMessageInteractionInfo"
}

// NewUpdateMessageInteractionInfo creates a new UpdateMessageInteractionInfo
//
// @param chatID Chat identifier
// @param messageID Message identifier
// @param interactionInfo New information about interactions with the message; may be null
func NewUpdateMessageInteractionInfo(chatID int64, messageID int64, interactionInfo *MessageInteractionInfo) *UpdateMessageInteractionInfo {
	updateMessageInteractionInfoTemp := UpdateMessageInteractionInfo{
		tdCommon:        tdCommon{Type: "updateMessageInteractionInfo"},
		ChatID:          chatID,
		MessageID:       messageID,
		InteractionInfo: interactionInfo,
	}

	return &updateMessageInteractionInfoTemp
}

// UnmarshalJSON unmarshal to json
func (updateMessageInteractionInfo *UpdateMessageInteractionInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID          int64                   `json:"chat_id"`          // Chat identifier
		MessageID       int64                   `json:"message_id"`       // Message identifier
		InteractionInfo *MessageInteractionInfo `json:"interaction_info"` // New information about interactions with the message; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateMessageInteractionInfo.tdCommon = tempObj.tdCommon
	updateMessageInteractionInfo.ChatID = tempObj.ChatID
	updateMessageInteractionInfo.MessageID = tempObj.MessageID
	updateMessageInteractionInfo.InteractionInfo = tempObj.InteractionInfo

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateMessageInteractionInfo *UpdateMessageInteractionInfo) GetUpdateEnum() UpdateEnum {
	return UpdateMessageInteractionInfoType
}

// UpdateMessageContentOpened The message content was opened. Updates voice note messages to "listened", video note messages to "viewed" and starts the self-destruct timer
type UpdateMessageContentOpened struct {
	tdCommon
	ChatID    int64 `json:"chat_id"`    // Chat identifier
	MessageID int64 `json:"message_id"` // Message identifier
}

// MessageType return the string telegram-type of UpdateMessageContentOpened
func (updateMessageContentOpened *UpdateMessageContentOpened) MessageType() string {
	return "updateMessageContentOpened"
}

// NewUpdateMessageContentOpened creates a new UpdateMessageContentOpened
//
// @param chatID Chat identifier
// @param messageID Message identifier
func NewUpdateMessageContentOpened(chatID int64, messageID int64) *UpdateMessageContentOpened {
	updateMessageContentOpenedTemp := UpdateMessageContentOpened{
		tdCommon:  tdCommon{Type: "updateMessageContentOpened"},
		ChatID:    chatID,
		MessageID: messageID,
	}

	return &updateMessageContentOpenedTemp
}

// UnmarshalJSON unmarshal to json
func (updateMessageContentOpened *UpdateMessageContentOpened) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID    int64 `json:"chat_id"`    // Chat identifier
		MessageID int64 `json:"message_id"` // Message identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateMessageContentOpened.tdCommon = tempObj.tdCommon
	updateMessageContentOpened.ChatID = tempObj.ChatID
	updateMessageContentOpened.MessageID = tempObj.MessageID

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateMessageContentOpened *UpdateMessageContentOpened) GetUpdateEnum() UpdateEnum {
	return UpdateMessageContentOpenedType
}

// UpdateMessageMentionRead A message with an unread mention was read
type UpdateMessageMentionRead struct {
	tdCommon
	ChatID             int64 `json:"chat_id"`              // Chat identifier
	MessageID          int64 `json:"message_id"`           // Message identifier
	UnreadMentionCount int32 `json:"unread_mention_count"` // The new number of unread mention messages left in the chat
}

// MessageType return the string telegram-type of UpdateMessageMentionRead
func (updateMessageMentionRead *UpdateMessageMentionRead) MessageType() string {
	return "updateMessageMentionRead"
}

// NewUpdateMessageMentionRead creates a new UpdateMessageMentionRead
//
// @param chatID Chat identifier
// @param messageID Message identifier
// @param unreadMentionCount The new number of unread mention messages left in the chat
func NewUpdateMessageMentionRead(chatID int64, messageID int64, unreadMentionCount int32) *UpdateMessageMentionRead {
	updateMessageMentionReadTemp := UpdateMessageMentionRead{
		tdCommon:           tdCommon{Type: "updateMessageMentionRead"},
		ChatID:             chatID,
		MessageID:          messageID,
		UnreadMentionCount: unreadMentionCount,
	}

	return &updateMessageMentionReadTemp
}

// UnmarshalJSON unmarshal to json
func (updateMessageMentionRead *UpdateMessageMentionRead) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID             int64 `json:"chat_id"`              // Chat identifier
		MessageID          int64 `json:"message_id"`           // Message identifier
		UnreadMentionCount int32 `json:"unread_mention_count"` // The new number of unread mention messages left in the chat
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateMessageMentionRead.tdCommon = tempObj.tdCommon
	updateMessageMentionRead.ChatID = tempObj.ChatID
	updateMessageMentionRead.MessageID = tempObj.MessageID
	updateMessageMentionRead.UnreadMentionCount = tempObj.UnreadMentionCount

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateMessageMentionRead *UpdateMessageMentionRead) GetUpdateEnum() UpdateEnum {
	return UpdateMessageMentionReadType
}

// UpdateMessageUnreadReactions The list of unread reactions added to a message was changed
type UpdateMessageUnreadReactions struct {
	tdCommon
	ChatID              int64            `json:"chat_id"`               // Chat identifier
	MessageID           int64            `json:"message_id"`            // Message identifier
	UnreadReactions     []UnreadReaction `json:"unread_reactions"`      // The new list of unread reactions
	UnreadReactionCount int32            `json:"unread_reaction_count"` // The new number of messages with unread reactions left in the chat
}

// MessageType return the string telegram-type of UpdateMessageUnreadReactions
func (updateMessageUnreadReactions *UpdateMessageUnreadReactions) MessageType() string {
	return "updateMessageUnreadReactions"
}

// NewUpdateMessageUnreadReactions creates a new UpdateMessageUnreadReactions
//
// @param chatID Chat identifier
// @param messageID Message identifier
// @param unreadReactions The new list of unread reactions
// @param unreadReactionCount The new number of messages with unread reactions left in the chat
func NewUpdateMessageUnreadReactions(chatID int64, messageID int64, unreadReactions []UnreadReaction, unreadReactionCount int32) *UpdateMessageUnreadReactions {
	updateMessageUnreadReactionsTemp := UpdateMessageUnreadReactions{
		tdCommon:            tdCommon{Type: "updateMessageUnreadReactions"},
		ChatID:              chatID,
		MessageID:           messageID,
		UnreadReactions:     unreadReactions,
		UnreadReactionCount: unreadReactionCount,
	}

	return &updateMessageUnreadReactionsTemp
}

// UnmarshalJSON unmarshal to json
func (updateMessageUnreadReactions *UpdateMessageUnreadReactions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID              int64            `json:"chat_id"`               // Chat identifier
		MessageID           int64            `json:"message_id"`            // Message identifier
		UnreadReactions     []UnreadReaction `json:"unread_reactions"`      // The new list of unread reactions
		UnreadReactionCount int32            `json:"unread_reaction_count"` // The new number of messages with unread reactions left in the chat
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateMessageUnreadReactions.tdCommon = tempObj.tdCommon
	updateMessageUnreadReactions.ChatID = tempObj.ChatID
	updateMessageUnreadReactions.MessageID = tempObj.MessageID
	updateMessageUnreadReactions.UnreadReactions = tempObj.UnreadReactions
	updateMessageUnreadReactions.UnreadReactionCount = tempObj.UnreadReactionCount

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateMessageUnreadReactions *UpdateMessageUnreadReactions) GetUpdateEnum() UpdateEnum {
	return UpdateMessageUnreadReactionsType
}

// UpdateMessageFactCheck A fact-check added to a message was changed
type UpdateMessageFactCheck struct {
	tdCommon
	ChatID    int64      `json:"chat_id"`    // Chat identifier
	MessageID int64      `json:"message_id"` // Message identifier
	FactCheck *FactCheck `json:"fact_check"` // The new fact-check
}

// MessageType return the string telegram-type of UpdateMessageFactCheck
func (updateMessageFactCheck *UpdateMessageFactCheck) MessageType() string {
	return "updateMessageFactCheck"
}

// NewUpdateMessageFactCheck creates a new UpdateMessageFactCheck
//
// @param chatID Chat identifier
// @param messageID Message identifier
// @param factCheck The new fact-check
func NewUpdateMessageFactCheck(chatID int64, messageID int64, factCheck *FactCheck) *UpdateMessageFactCheck {
	updateMessageFactCheckTemp := UpdateMessageFactCheck{
		tdCommon:  tdCommon{Type: "updateMessageFactCheck"},
		ChatID:    chatID,
		MessageID: messageID,
		FactCheck: factCheck,
	}

	return &updateMessageFactCheckTemp
}

// UnmarshalJSON unmarshal to json
func (updateMessageFactCheck *UpdateMessageFactCheck) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID    int64      `json:"chat_id"`    // Chat identifier
		MessageID int64      `json:"message_id"` // Message identifier
		FactCheck *FactCheck `json:"fact_check"` // The new fact-check
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateMessageFactCheck.tdCommon = tempObj.tdCommon
	updateMessageFactCheck.ChatID = tempObj.ChatID
	updateMessageFactCheck.MessageID = tempObj.MessageID
	updateMessageFactCheck.FactCheck = tempObj.FactCheck

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateMessageFactCheck *UpdateMessageFactCheck) GetUpdateEnum() UpdateEnum {
	return UpdateMessageFactCheckType
}

// UpdateMessageLiveLocationViewed A message with a live location was viewed. When the update is received, the application is supposed to update the live location
type UpdateMessageLiveLocationViewed struct {
	tdCommon
	ChatID    int64 `json:"chat_id"`    // Identifier of the chat with the live location message
	MessageID int64 `json:"message_id"` // Identifier of the message with live location
}

// MessageType return the string telegram-type of UpdateMessageLiveLocationViewed
func (updateMessageLiveLocationViewed *UpdateMessageLiveLocationViewed) MessageType() string {
	return "updateMessageLiveLocationViewed"
}

// NewUpdateMessageLiveLocationViewed creates a new UpdateMessageLiveLocationViewed
//
// @param chatID Identifier of the chat with the live location message
// @param messageID Identifier of the message with live location
func NewUpdateMessageLiveLocationViewed(chatID int64, messageID int64) *UpdateMessageLiveLocationViewed {
	updateMessageLiveLocationViewedTemp := UpdateMessageLiveLocationViewed{
		tdCommon:  tdCommon{Type: "updateMessageLiveLocationViewed"},
		ChatID:    chatID,
		MessageID: messageID,
	}

	return &updateMessageLiveLocationViewedTemp
}

// UnmarshalJSON unmarshal to json
func (updateMessageLiveLocationViewed *UpdateMessageLiveLocationViewed) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID    int64 `json:"chat_id"`    // Identifier of the chat with the live location message
		MessageID int64 `json:"message_id"` // Identifier of the message with live location
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateMessageLiveLocationViewed.tdCommon = tempObj.tdCommon
	updateMessageLiveLocationViewed.ChatID = tempObj.ChatID
	updateMessageLiveLocationViewed.MessageID = tempObj.MessageID

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateMessageLiveLocationViewed *UpdateMessageLiveLocationViewed) GetUpdateEnum() UpdateEnum {
	return UpdateMessageLiveLocationViewedType
}

// UpdateNewChat A new chat has been loaded/created. This update is guaranteed to come before the chat identifier is returned to the application. The chat field changes will be reported through separate updates
type UpdateNewChat struct {
	tdCommon
	Chat *Chat `json:"chat"` // The chat
}

// MessageType return the string telegram-type of UpdateNewChat
func (updateNewChat *UpdateNewChat) MessageType() string {
	return "updateNewChat"
}

// NewUpdateNewChat creates a new UpdateNewChat
//
// @param chat The chat
func NewUpdateNewChat(chat *Chat) *UpdateNewChat {
	updateNewChatTemp := UpdateNewChat{
		tdCommon: tdCommon{Type: "updateNewChat"},
		Chat:     chat,
	}

	return &updateNewChatTemp
}

// UnmarshalJSON unmarshal to json
func (updateNewChat *UpdateNewChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateNewChat.tdCommon = tempObj.tdCommon

	var chat Chat
	if objMap["chat"] != nil {
		err = chat.UnmarshalJSON(*objMap["chat"])
		if err != nil {
			return err
		}
	}

	updateNewChat.Chat = &chat

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateNewChat *UpdateNewChat) GetUpdateEnum() UpdateEnum {
	return UpdateNewChatType
}

// UpdateChatTitle The title of a chat was changed
type UpdateChatTitle struct {
	tdCommon
	ChatID int64  `json:"chat_id"` // Chat identifier
	Title  string `json:"title"`   // The new chat title
}

// MessageType return the string telegram-type of UpdateChatTitle
func (updateChatTitle *UpdateChatTitle) MessageType() string {
	return "updateChatTitle"
}

// NewUpdateChatTitle creates a new UpdateChatTitle
//
// @param chatID Chat identifier
// @param title The new chat title
func NewUpdateChatTitle(chatID int64, title string) *UpdateChatTitle {
	updateChatTitleTemp := UpdateChatTitle{
		tdCommon: tdCommon{Type: "updateChatTitle"},
		ChatID:   chatID,
		Title:    title,
	}

	return &updateChatTitleTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatTitle *UpdateChatTitle) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID int64  `json:"chat_id"` // Chat identifier
		Title  string `json:"title"`   // The new chat title
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatTitle.tdCommon = tempObj.tdCommon
	updateChatTitle.ChatID = tempObj.ChatID
	updateChatTitle.Title = tempObj.Title

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatTitle *UpdateChatTitle) GetUpdateEnum() UpdateEnum {
	return UpdateChatTitleType
}

// UpdateChatPhoto A chat photo was changed
type UpdateChatPhoto struct {
	tdCommon
	ChatID int64          `json:"chat_id"` // Chat identifier
	Photo  *ChatPhotoInfo `json:"photo"`   // The new chat photo; may be null
}

// MessageType return the string telegram-type of UpdateChatPhoto
func (updateChatPhoto *UpdateChatPhoto) MessageType() string {
	return "updateChatPhoto"
}

// NewUpdateChatPhoto creates a new UpdateChatPhoto
//
// @param chatID Chat identifier
// @param photo The new chat photo; may be null
func NewUpdateChatPhoto(chatID int64, photo *ChatPhotoInfo) *UpdateChatPhoto {
	updateChatPhotoTemp := UpdateChatPhoto{
		tdCommon: tdCommon{Type: "updateChatPhoto"},
		ChatID:   chatID,
		Photo:    photo,
	}

	return &updateChatPhotoTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatPhoto *UpdateChatPhoto) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID int64          `json:"chat_id"` // Chat identifier
		Photo  *ChatPhotoInfo `json:"photo"`   // The new chat photo; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatPhoto.tdCommon = tempObj.tdCommon
	updateChatPhoto.ChatID = tempObj.ChatID
	updateChatPhoto.Photo = tempObj.Photo

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatPhoto *UpdateChatPhoto) GetUpdateEnum() UpdateEnum {
	return UpdateChatPhotoType
}

// UpdateChatAccentColors Chat accent colors have changed
type UpdateChatAccentColors struct {
	tdCommon
	ChatID                         int64     `json:"chat_id"`                            // Chat identifier
	AccentColorID                  int32     `json:"accent_color_id"`                    // The new chat accent color identifier
	BackgroundCustomEmojiID        JSONInt64 `json:"background_custom_emoji_id"`         // The new identifier of a custom emoji to be shown on the reply header and link preview background; 0 if none
	ProfileAccentColorID           int32     `json:"profile_accent_color_id"`            // The new chat profile accent color identifier; -1 if none
	ProfileBackgroundCustomEmojiID JSONInt64 `json:"profile_background_custom_emoji_id"` // The new identifier of a custom emoji to be shown on the profile background; 0 if none
}

// MessageType return the string telegram-type of UpdateChatAccentColors
func (updateChatAccentColors *UpdateChatAccentColors) MessageType() string {
	return "updateChatAccentColors"
}

// NewUpdateChatAccentColors creates a new UpdateChatAccentColors
//
// @param chatID Chat identifier
// @param accentColorID The new chat accent color identifier
// @param backgroundCustomEmojiID The new identifier of a custom emoji to be shown on the reply header and link preview background; 0 if none
// @param profileAccentColorID The new chat profile accent color identifier; -1 if none
// @param profileBackgroundCustomEmojiID The new identifier of a custom emoji to be shown on the profile background; 0 if none
func NewUpdateChatAccentColors(chatID int64, accentColorID int32, backgroundCustomEmojiID JSONInt64, profileAccentColorID int32, profileBackgroundCustomEmojiID JSONInt64) *UpdateChatAccentColors {
	updateChatAccentColorsTemp := UpdateChatAccentColors{
		tdCommon:                       tdCommon{Type: "updateChatAccentColors"},
		ChatID:                         chatID,
		AccentColorID:                  accentColorID,
		BackgroundCustomEmojiID:        backgroundCustomEmojiID,
		ProfileAccentColorID:           profileAccentColorID,
		ProfileBackgroundCustomEmojiID: profileBackgroundCustomEmojiID,
	}

	return &updateChatAccentColorsTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatAccentColors *UpdateChatAccentColors) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID                         int64     `json:"chat_id"`                            // Chat identifier
		AccentColorID                  int32     `json:"accent_color_id"`                    // The new chat accent color identifier
		BackgroundCustomEmojiID        JSONInt64 `json:"background_custom_emoji_id"`         // The new identifier of a custom emoji to be shown on the reply header and link preview background; 0 if none
		ProfileAccentColorID           int32     `json:"profile_accent_color_id"`            // The new chat profile accent color identifier; -1 if none
		ProfileBackgroundCustomEmojiID JSONInt64 `json:"profile_background_custom_emoji_id"` // The new identifier of a custom emoji to be shown on the profile background; 0 if none
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatAccentColors.tdCommon = tempObj.tdCommon
	updateChatAccentColors.ChatID = tempObj.ChatID
	updateChatAccentColors.AccentColorID = tempObj.AccentColorID
	updateChatAccentColors.BackgroundCustomEmojiID = tempObj.BackgroundCustomEmojiID
	updateChatAccentColors.ProfileAccentColorID = tempObj.ProfileAccentColorID
	updateChatAccentColors.ProfileBackgroundCustomEmojiID = tempObj.ProfileBackgroundCustomEmojiID

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatAccentColors *UpdateChatAccentColors) GetUpdateEnum() UpdateEnum {
	return UpdateChatAccentColorsType
}

// UpdateChatPermissions Chat permissions were changed
type UpdateChatPermissions struct {
	tdCommon
	ChatID      int64            `json:"chat_id"`     // Chat identifier
	Permissions *ChatPermissions `json:"permissions"` // The new chat permissions
}

// MessageType return the string telegram-type of UpdateChatPermissions
func (updateChatPermissions *UpdateChatPermissions) MessageType() string {
	return "updateChatPermissions"
}

// NewUpdateChatPermissions creates a new UpdateChatPermissions
//
// @param chatID Chat identifier
// @param permissions The new chat permissions
func NewUpdateChatPermissions(chatID int64, permissions *ChatPermissions) *UpdateChatPermissions {
	updateChatPermissionsTemp := UpdateChatPermissions{
		tdCommon:    tdCommon{Type: "updateChatPermissions"},
		ChatID:      chatID,
		Permissions: permissions,
	}

	return &updateChatPermissionsTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatPermissions *UpdateChatPermissions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID      int64            `json:"chat_id"`     // Chat identifier
		Permissions *ChatPermissions `json:"permissions"` // The new chat permissions
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatPermissions.tdCommon = tempObj.tdCommon
	updateChatPermissions.ChatID = tempObj.ChatID
	updateChatPermissions.Permissions = tempObj.Permissions

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatPermissions *UpdateChatPermissions) GetUpdateEnum() UpdateEnum {
	return UpdateChatPermissionsType
}

// UpdateChatLastMessage The last message of a chat was changed
type UpdateChatLastMessage struct {
	tdCommon
	ChatID      int64          `json:"chat_id"`      // Chat identifier
	LastMessage *Message       `json:"last_message"` // The new last message in the chat; may be null if the last message became unknown. While the last message is unknown, new messages can be added to the chat without corresponding updateNewMessage update
	Positions   []ChatPosition `json:"positions"`    // The new chat positions in the chat lists
}

// MessageType return the string telegram-type of UpdateChatLastMessage
func (updateChatLastMessage *UpdateChatLastMessage) MessageType() string {
	return "updateChatLastMessage"
}

// NewUpdateChatLastMessage creates a new UpdateChatLastMessage
//
// @param chatID Chat identifier
// @param lastMessage The new last message in the chat; may be null if the last message became unknown. While the last message is unknown, new messages can be added to the chat without corresponding updateNewMessage update
// @param positions The new chat positions in the chat lists
func NewUpdateChatLastMessage(chatID int64, lastMessage *Message, positions []ChatPosition) *UpdateChatLastMessage {
	updateChatLastMessageTemp := UpdateChatLastMessage{
		tdCommon:    tdCommon{Type: "updateChatLastMessage"},
		ChatID:      chatID,
		LastMessage: lastMessage,
		Positions:   positions,
	}

	return &updateChatLastMessageTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatLastMessage *UpdateChatLastMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID    int64          `json:"chat_id"`   // Chat identifier
		Positions []ChatPosition `json:"positions"` // The new chat positions in the chat lists
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatLastMessage.tdCommon = tempObj.tdCommon
	updateChatLastMessage.ChatID = tempObj.ChatID
	updateChatLastMessage.Positions = tempObj.Positions

	var lastMessage Message
	if objMap["last_message"] != nil {
		err = lastMessage.UnmarshalJSON(*objMap["last_message"])
		if err != nil {
			return err
		}
	}

	updateChatLastMessage.LastMessage = &lastMessage

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatLastMessage *UpdateChatLastMessage) GetUpdateEnum() UpdateEnum {
	return UpdateChatLastMessageType
}

// UpdateChatPosition The position of a chat in a chat list has changed. An updateChatLastMessage or updateChatDraftMessage update might be sent instead of the update
type UpdateChatPosition struct {
	tdCommon
	ChatID   int64         `json:"chat_id"`  // Chat identifier
	Position *ChatPosition `json:"position"` // New chat position. If new order is 0, then the chat needs to be removed from the list
}

// MessageType return the string telegram-type of UpdateChatPosition
func (updateChatPosition *UpdateChatPosition) MessageType() string {
	return "updateChatPosition"
}

// NewUpdateChatPosition creates a new UpdateChatPosition
//
// @param chatID Chat identifier
// @param position New chat position. If new order is 0, then the chat needs to be removed from the list
func NewUpdateChatPosition(chatID int64, position *ChatPosition) *UpdateChatPosition {
	updateChatPositionTemp := UpdateChatPosition{
		tdCommon: tdCommon{Type: "updateChatPosition"},
		ChatID:   chatID,
		Position: position,
	}

	return &updateChatPositionTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatPosition *UpdateChatPosition) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID int64 `json:"chat_id"` // Chat identifier

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatPosition.tdCommon = tempObj.tdCommon
	updateChatPosition.ChatID = tempObj.ChatID

	var position ChatPosition
	if objMap["position"] != nil {
		err = position.UnmarshalJSON(*objMap["position"])
		if err != nil {
			return err
		}
	}

	updateChatPosition.Position = &position

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatPosition *UpdateChatPosition) GetUpdateEnum() UpdateEnum {
	return UpdateChatPositionType
}

// UpdateChatAddedToList A chat was added to a chat list
type UpdateChatAddedToList struct {
	tdCommon
	ChatID   int64    `json:"chat_id"`   // Chat identifier
	ChatList ChatList `json:"chat_list"` // The chat list to which the chat was added
}

// MessageType return the string telegram-type of UpdateChatAddedToList
func (updateChatAddedToList *UpdateChatAddedToList) MessageType() string {
	return "updateChatAddedToList"
}

// NewUpdateChatAddedToList creates a new UpdateChatAddedToList
//
// @param chatID Chat identifier
// @param chatList The chat list to which the chat was added
func NewUpdateChatAddedToList(chatID int64, chatList ChatList) *UpdateChatAddedToList {
	updateChatAddedToListTemp := UpdateChatAddedToList{
		tdCommon: tdCommon{Type: "updateChatAddedToList"},
		ChatID:   chatID,
		ChatList: chatList,
	}

	return &updateChatAddedToListTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatAddedToList *UpdateChatAddedToList) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID int64 `json:"chat_id"` // Chat identifier

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatAddedToList.tdCommon = tempObj.tdCommon
	updateChatAddedToList.ChatID = tempObj.ChatID

	fieldChatList, _ := unmarshalChatList(objMap["chat_list"])
	updateChatAddedToList.ChatList = fieldChatList

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatAddedToList *UpdateChatAddedToList) GetUpdateEnum() UpdateEnum {
	return UpdateChatAddedToListType
}

// UpdateChatRemovedFromList A chat was removed from a chat list
type UpdateChatRemovedFromList struct {
	tdCommon
	ChatID   int64    `json:"chat_id"`   // Chat identifier
	ChatList ChatList `json:"chat_list"` // The chat list from which the chat was removed
}

// MessageType return the string telegram-type of UpdateChatRemovedFromList
func (updateChatRemovedFromList *UpdateChatRemovedFromList) MessageType() string {
	return "updateChatRemovedFromList"
}

// NewUpdateChatRemovedFromList creates a new UpdateChatRemovedFromList
//
// @param chatID Chat identifier
// @param chatList The chat list from which the chat was removed
func NewUpdateChatRemovedFromList(chatID int64, chatList ChatList) *UpdateChatRemovedFromList {
	updateChatRemovedFromListTemp := UpdateChatRemovedFromList{
		tdCommon: tdCommon{Type: "updateChatRemovedFromList"},
		ChatID:   chatID,
		ChatList: chatList,
	}

	return &updateChatRemovedFromListTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatRemovedFromList *UpdateChatRemovedFromList) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID int64 `json:"chat_id"` // Chat identifier

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatRemovedFromList.tdCommon = tempObj.tdCommon
	updateChatRemovedFromList.ChatID = tempObj.ChatID

	fieldChatList, _ := unmarshalChatList(objMap["chat_list"])
	updateChatRemovedFromList.ChatList = fieldChatList

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatRemovedFromList *UpdateChatRemovedFromList) GetUpdateEnum() UpdateEnum {
	return UpdateChatRemovedFromListType
}

// UpdateChatReadInbox Incoming messages were read or the number of unread messages has been changed
type UpdateChatReadInbox struct {
	tdCommon
	ChatID                 int64 `json:"chat_id"`                    // Chat identifier
	LastReadInboxMessageID int64 `json:"last_read_inbox_message_id"` // Identifier of the last read incoming message
	UnreadCount            int32 `json:"unread_count"`               // The number of unread messages left in the chat
}

// MessageType return the string telegram-type of UpdateChatReadInbox
func (updateChatReadInbox *UpdateChatReadInbox) MessageType() string {
	return "updateChatReadInbox"
}

// NewUpdateChatReadInbox creates a new UpdateChatReadInbox
//
// @param chatID Chat identifier
// @param lastReadInboxMessageID Identifier of the last read incoming message
// @param unreadCount The number of unread messages left in the chat
func NewUpdateChatReadInbox(chatID int64, lastReadInboxMessageID int64, unreadCount int32) *UpdateChatReadInbox {
	updateChatReadInboxTemp := UpdateChatReadInbox{
		tdCommon:               tdCommon{Type: "updateChatReadInbox"},
		ChatID:                 chatID,
		LastReadInboxMessageID: lastReadInboxMessageID,
		UnreadCount:            unreadCount,
	}

	return &updateChatReadInboxTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatReadInbox *UpdateChatReadInbox) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID                 int64 `json:"chat_id"`                    // Chat identifier
		LastReadInboxMessageID int64 `json:"last_read_inbox_message_id"` // Identifier of the last read incoming message
		UnreadCount            int32 `json:"unread_count"`               // The number of unread messages left in the chat
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatReadInbox.tdCommon = tempObj.tdCommon
	updateChatReadInbox.ChatID = tempObj.ChatID
	updateChatReadInbox.LastReadInboxMessageID = tempObj.LastReadInboxMessageID
	updateChatReadInbox.UnreadCount = tempObj.UnreadCount

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatReadInbox *UpdateChatReadInbox) GetUpdateEnum() UpdateEnum {
	return UpdateChatReadInboxType
}

// UpdateChatReadOutbox Outgoing messages were read
type UpdateChatReadOutbox struct {
	tdCommon
	ChatID                  int64 `json:"chat_id"`                     // Chat identifier
	LastReadOutboxMessageID int64 `json:"last_read_outbox_message_id"` // Identifier of last read outgoing message
}

// MessageType return the string telegram-type of UpdateChatReadOutbox
func (updateChatReadOutbox *UpdateChatReadOutbox) MessageType() string {
	return "updateChatReadOutbox"
}

// NewUpdateChatReadOutbox creates a new UpdateChatReadOutbox
//
// @param chatID Chat identifier
// @param lastReadOutboxMessageID Identifier of last read outgoing message
func NewUpdateChatReadOutbox(chatID int64, lastReadOutboxMessageID int64) *UpdateChatReadOutbox {
	updateChatReadOutboxTemp := UpdateChatReadOutbox{
		tdCommon:                tdCommon{Type: "updateChatReadOutbox"},
		ChatID:                  chatID,
		LastReadOutboxMessageID: lastReadOutboxMessageID,
	}

	return &updateChatReadOutboxTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatReadOutbox *UpdateChatReadOutbox) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID                  int64 `json:"chat_id"`                     // Chat identifier
		LastReadOutboxMessageID int64 `json:"last_read_outbox_message_id"` // Identifier of last read outgoing message
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatReadOutbox.tdCommon = tempObj.tdCommon
	updateChatReadOutbox.ChatID = tempObj.ChatID
	updateChatReadOutbox.LastReadOutboxMessageID = tempObj.LastReadOutboxMessageID

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatReadOutbox *UpdateChatReadOutbox) GetUpdateEnum() UpdateEnum {
	return UpdateChatReadOutboxType
}

// UpdateChatActionBar The chat action bar was changed
type UpdateChatActionBar struct {
	tdCommon
	ChatID    int64          `json:"chat_id"`    // Chat identifier
	ActionBar *ChatActionBar `json:"action_bar"` // The new value of the action bar; may be null
}

// MessageType return the string telegram-type of UpdateChatActionBar
func (updateChatActionBar *UpdateChatActionBar) MessageType() string {
	return "updateChatActionBar"
}

// NewUpdateChatActionBar creates a new UpdateChatActionBar
//
// @param chatID Chat identifier
// @param actionBar The new value of the action bar; may be null
func NewUpdateChatActionBar(chatID int64, actionBar *ChatActionBar) *UpdateChatActionBar {
	updateChatActionBarTemp := UpdateChatActionBar{
		tdCommon:  tdCommon{Type: "updateChatActionBar"},
		ChatID:    chatID,
		ActionBar: actionBar,
	}

	return &updateChatActionBarTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatActionBar *UpdateChatActionBar) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID int64 `json:"chat_id"` // Chat identifier

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatActionBar.tdCommon = tempObj.tdCommon
	updateChatActionBar.ChatID = tempObj.ChatID

	fieldActionBar, _ := unmarshalChatActionBar(objMap["action_bar"])
	updateChatActionBar.ActionBar = &fieldActionBar

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatActionBar *UpdateChatActionBar) GetUpdateEnum() UpdateEnum {
	return UpdateChatActionBarType
}

// UpdateChatBusinessBotManageBar The bar for managing business bot was changed in a chat
type UpdateChatBusinessBotManageBar struct {
	tdCommon
	ChatID               int64                 `json:"chat_id"`                 // Chat identifier
	BusinessBotManageBar *BusinessBotManageBar `json:"business_bot_manage_bar"` // The new value of the business bot manage bar; may be null
}

// MessageType return the string telegram-type of UpdateChatBusinessBotManageBar
func (updateChatBusinessBotManageBar *UpdateChatBusinessBotManageBar) MessageType() string {
	return "updateChatBusinessBotManageBar"
}

// NewUpdateChatBusinessBotManageBar creates a new UpdateChatBusinessBotManageBar
//
// @param chatID Chat identifier
// @param businessBotManageBar The new value of the business bot manage bar; may be null
func NewUpdateChatBusinessBotManageBar(chatID int64, businessBotManageBar *BusinessBotManageBar) *UpdateChatBusinessBotManageBar {
	updateChatBusinessBotManageBarTemp := UpdateChatBusinessBotManageBar{
		tdCommon:             tdCommon{Type: "updateChatBusinessBotManageBar"},
		ChatID:               chatID,
		BusinessBotManageBar: businessBotManageBar,
	}

	return &updateChatBusinessBotManageBarTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatBusinessBotManageBar *UpdateChatBusinessBotManageBar) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID               int64                 `json:"chat_id"`                 // Chat identifier
		BusinessBotManageBar *BusinessBotManageBar `json:"business_bot_manage_bar"` // The new value of the business bot manage bar; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatBusinessBotManageBar.tdCommon = tempObj.tdCommon
	updateChatBusinessBotManageBar.ChatID = tempObj.ChatID
	updateChatBusinessBotManageBar.BusinessBotManageBar = tempObj.BusinessBotManageBar

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatBusinessBotManageBar *UpdateChatBusinessBotManageBar) GetUpdateEnum() UpdateEnum {
	return UpdateChatBusinessBotManageBarType
}

// UpdateChatAvailableReactions The chat available reactions were changed
type UpdateChatAvailableReactions struct {
	tdCommon
	ChatID             int64                  `json:"chat_id"`             // Chat identifier
	AvailableReactions ChatAvailableReactions `json:"available_reactions"` // The new reactions, available in the chat
}

// MessageType return the string telegram-type of UpdateChatAvailableReactions
func (updateChatAvailableReactions *UpdateChatAvailableReactions) MessageType() string {
	return "updateChatAvailableReactions"
}

// NewUpdateChatAvailableReactions creates a new UpdateChatAvailableReactions
//
// @param chatID Chat identifier
// @param availableReactions The new reactions, available in the chat
func NewUpdateChatAvailableReactions(chatID int64, availableReactions ChatAvailableReactions) *UpdateChatAvailableReactions {
	updateChatAvailableReactionsTemp := UpdateChatAvailableReactions{
		tdCommon:           tdCommon{Type: "updateChatAvailableReactions"},
		ChatID:             chatID,
		AvailableReactions: availableReactions,
	}

	return &updateChatAvailableReactionsTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatAvailableReactions *UpdateChatAvailableReactions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID int64 `json:"chat_id"` // Chat identifier

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatAvailableReactions.tdCommon = tempObj.tdCommon
	updateChatAvailableReactions.ChatID = tempObj.ChatID

	fieldAvailableReactions, _ := unmarshalChatAvailableReactions(objMap["available_reactions"])
	updateChatAvailableReactions.AvailableReactions = fieldAvailableReactions

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatAvailableReactions *UpdateChatAvailableReactions) GetUpdateEnum() UpdateEnum {
	return UpdateChatAvailableReactionsType
}

// UpdateChatDraftMessage A chat draft has changed. Be aware that the update may come in the currently opened chat but with old content of the draft. If the user has changed the content of the draft, this update mustn't be applied
type UpdateChatDraftMessage struct {
	tdCommon
	ChatID       int64          `json:"chat_id"`       // Chat identifier
	DraftMessage *DraftMessage  `json:"draft_message"` // The new draft message; may be null if none
	Positions    []ChatPosition `json:"positions"`     // The new chat positions in the chat lists
}

// MessageType return the string telegram-type of UpdateChatDraftMessage
func (updateChatDraftMessage *UpdateChatDraftMessage) MessageType() string {
	return "updateChatDraftMessage"
}

// NewUpdateChatDraftMessage creates a new UpdateChatDraftMessage
//
// @param chatID Chat identifier
// @param draftMessage The new draft message; may be null if none
// @param positions The new chat positions in the chat lists
func NewUpdateChatDraftMessage(chatID int64, draftMessage *DraftMessage, positions []ChatPosition) *UpdateChatDraftMessage {
	updateChatDraftMessageTemp := UpdateChatDraftMessage{
		tdCommon:     tdCommon{Type: "updateChatDraftMessage"},
		ChatID:       chatID,
		DraftMessage: draftMessage,
		Positions:    positions,
	}

	return &updateChatDraftMessageTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatDraftMessage *UpdateChatDraftMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID    int64          `json:"chat_id"`   // Chat identifier
		Positions []ChatPosition `json:"positions"` // The new chat positions in the chat lists
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatDraftMessage.tdCommon = tempObj.tdCommon
	updateChatDraftMessage.ChatID = tempObj.ChatID
	updateChatDraftMessage.Positions = tempObj.Positions

	var draftMessage DraftMessage
	if objMap["draft_message"] != nil {
		err = draftMessage.UnmarshalJSON(*objMap["draft_message"])
		if err != nil {
			return err
		}
	}

	updateChatDraftMessage.DraftMessage = &draftMessage

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatDraftMessage *UpdateChatDraftMessage) GetUpdateEnum() UpdateEnum {
	return UpdateChatDraftMessageType
}

// UpdateChatEmojiStatus Chat emoji status has changed
type UpdateChatEmojiStatus struct {
	tdCommon
	ChatID      int64        `json:"chat_id"`      // Chat identifier
	EmojiStatus *EmojiStatus `json:"emoji_status"` // The new chat emoji status; may be null
}

// MessageType return the string telegram-type of UpdateChatEmojiStatus
func (updateChatEmojiStatus *UpdateChatEmojiStatus) MessageType() string {
	return "updateChatEmojiStatus"
}

// NewUpdateChatEmojiStatus creates a new UpdateChatEmojiStatus
//
// @param chatID Chat identifier
// @param emojiStatus The new chat emoji status; may be null
func NewUpdateChatEmojiStatus(chatID int64, emojiStatus *EmojiStatus) *UpdateChatEmojiStatus {
	updateChatEmojiStatusTemp := UpdateChatEmojiStatus{
		tdCommon:    tdCommon{Type: "updateChatEmojiStatus"},
		ChatID:      chatID,
		EmojiStatus: emojiStatus,
	}

	return &updateChatEmojiStatusTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatEmojiStatus *UpdateChatEmojiStatus) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID      int64        `json:"chat_id"`      // Chat identifier
		EmojiStatus *EmojiStatus `json:"emoji_status"` // The new chat emoji status; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatEmojiStatus.tdCommon = tempObj.tdCommon
	updateChatEmojiStatus.ChatID = tempObj.ChatID
	updateChatEmojiStatus.EmojiStatus = tempObj.EmojiStatus

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatEmojiStatus *UpdateChatEmojiStatus) GetUpdateEnum() UpdateEnum {
	return UpdateChatEmojiStatusType
}

// UpdateChatMessageSender The message sender that is selected to send messages in a chat has changed
type UpdateChatMessageSender struct {
	tdCommon
	ChatID          int64          `json:"chat_id"`           // Chat identifier
	MessageSenderID *MessageSender `json:"message_sender_id"` // New value of message_sender_id; may be null if the user can't change message sender
}

// MessageType return the string telegram-type of UpdateChatMessageSender
func (updateChatMessageSender *UpdateChatMessageSender) MessageType() string {
	return "updateChatMessageSender"
}

// NewUpdateChatMessageSender creates a new UpdateChatMessageSender
//
// @param chatID Chat identifier
// @param messageSenderID New value of message_sender_id; may be null if the user can't change message sender
func NewUpdateChatMessageSender(chatID int64, messageSenderID *MessageSender) *UpdateChatMessageSender {
	updateChatMessageSenderTemp := UpdateChatMessageSender{
		tdCommon:        tdCommon{Type: "updateChatMessageSender"},
		ChatID:          chatID,
		MessageSenderID: messageSenderID,
	}

	return &updateChatMessageSenderTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatMessageSender *UpdateChatMessageSender) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID int64 `json:"chat_id"` // Chat identifier

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatMessageSender.tdCommon = tempObj.tdCommon
	updateChatMessageSender.ChatID = tempObj.ChatID

	fieldMessageSenderID, _ := unmarshalMessageSender(objMap["message_sender_id"])
	updateChatMessageSender.MessageSenderID = &fieldMessageSenderID

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatMessageSender *UpdateChatMessageSender) GetUpdateEnum() UpdateEnum {
	return UpdateChatMessageSenderType
}

// UpdateChatMessageAutoDeleteTime The message auto-delete or self-destruct timer setting for a chat was changed
type UpdateChatMessageAutoDeleteTime struct {
	tdCommon
	ChatID                int64 `json:"chat_id"`                  // Chat identifier
	MessageAutoDeleteTime int32 `json:"message_auto_delete_time"` // New value of message_auto_delete_time
}

// MessageType return the string telegram-type of UpdateChatMessageAutoDeleteTime
func (updateChatMessageAutoDeleteTime *UpdateChatMessageAutoDeleteTime) MessageType() string {
	return "updateChatMessageAutoDeleteTime"
}

// NewUpdateChatMessageAutoDeleteTime creates a new UpdateChatMessageAutoDeleteTime
//
// @param chatID Chat identifier
// @param messageAutoDeleteTime New value of message_auto_delete_time
func NewUpdateChatMessageAutoDeleteTime(chatID int64, messageAutoDeleteTime int32) *UpdateChatMessageAutoDeleteTime {
	updateChatMessageAutoDeleteTimeTemp := UpdateChatMessageAutoDeleteTime{
		tdCommon:              tdCommon{Type: "updateChatMessageAutoDeleteTime"},
		ChatID:                chatID,
		MessageAutoDeleteTime: messageAutoDeleteTime,
	}

	return &updateChatMessageAutoDeleteTimeTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatMessageAutoDeleteTime *UpdateChatMessageAutoDeleteTime) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID                int64 `json:"chat_id"`                  // Chat identifier
		MessageAutoDeleteTime int32 `json:"message_auto_delete_time"` // New value of message_auto_delete_time
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatMessageAutoDeleteTime.tdCommon = tempObj.tdCommon
	updateChatMessageAutoDeleteTime.ChatID = tempObj.ChatID
	updateChatMessageAutoDeleteTime.MessageAutoDeleteTime = tempObj.MessageAutoDeleteTime

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatMessageAutoDeleteTime *UpdateChatMessageAutoDeleteTime) GetUpdateEnum() UpdateEnum {
	return UpdateChatMessageAutoDeleteTimeType
}

// UpdateChatNotificationSettings Notification settings for a chat were changed
type UpdateChatNotificationSettings struct {
	tdCommon
	ChatID               int64                     `json:"chat_id"`               // Chat identifier
	NotificationSettings *ChatNotificationSettings `json:"notification_settings"` // The new notification settings
}

// MessageType return the string telegram-type of UpdateChatNotificationSettings
func (updateChatNotificationSettings *UpdateChatNotificationSettings) MessageType() string {
	return "updateChatNotificationSettings"
}

// NewUpdateChatNotificationSettings creates a new UpdateChatNotificationSettings
//
// @param chatID Chat identifier
// @param notificationSettings The new notification settings
func NewUpdateChatNotificationSettings(chatID int64, notificationSettings *ChatNotificationSettings) *UpdateChatNotificationSettings {
	updateChatNotificationSettingsTemp := UpdateChatNotificationSettings{
		tdCommon:             tdCommon{Type: "updateChatNotificationSettings"},
		ChatID:               chatID,
		NotificationSettings: notificationSettings,
	}

	return &updateChatNotificationSettingsTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatNotificationSettings *UpdateChatNotificationSettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID               int64                     `json:"chat_id"`               // Chat identifier
		NotificationSettings *ChatNotificationSettings `json:"notification_settings"` // The new notification settings
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatNotificationSettings.tdCommon = tempObj.tdCommon
	updateChatNotificationSettings.ChatID = tempObj.ChatID
	updateChatNotificationSettings.NotificationSettings = tempObj.NotificationSettings

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatNotificationSettings *UpdateChatNotificationSettings) GetUpdateEnum() UpdateEnum {
	return UpdateChatNotificationSettingsType
}

// UpdateChatPendingJoinRequests The chat pending join requests were changed
type UpdateChatPendingJoinRequests struct {
	tdCommon
	ChatID              int64                 `json:"chat_id"`               // Chat identifier
	PendingJoinRequests *ChatJoinRequestsInfo `json:"pending_join_requests"` // The new data about pending join requests; may be null
}

// MessageType return the string telegram-type of UpdateChatPendingJoinRequests
func (updateChatPendingJoinRequests *UpdateChatPendingJoinRequests) MessageType() string {
	return "updateChatPendingJoinRequests"
}

// NewUpdateChatPendingJoinRequests creates a new UpdateChatPendingJoinRequests
//
// @param chatID Chat identifier
// @param pendingJoinRequests The new data about pending join requests; may be null
func NewUpdateChatPendingJoinRequests(chatID int64, pendingJoinRequests *ChatJoinRequestsInfo) *UpdateChatPendingJoinRequests {
	updateChatPendingJoinRequestsTemp := UpdateChatPendingJoinRequests{
		tdCommon:            tdCommon{Type: "updateChatPendingJoinRequests"},
		ChatID:              chatID,
		PendingJoinRequests: pendingJoinRequests,
	}

	return &updateChatPendingJoinRequestsTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatPendingJoinRequests *UpdateChatPendingJoinRequests) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID              int64                 `json:"chat_id"`               // Chat identifier
		PendingJoinRequests *ChatJoinRequestsInfo `json:"pending_join_requests"` // The new data about pending join requests; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatPendingJoinRequests.tdCommon = tempObj.tdCommon
	updateChatPendingJoinRequests.ChatID = tempObj.ChatID
	updateChatPendingJoinRequests.PendingJoinRequests = tempObj.PendingJoinRequests

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatPendingJoinRequests *UpdateChatPendingJoinRequests) GetUpdateEnum() UpdateEnum {
	return UpdateChatPendingJoinRequestsType
}

// UpdateChatReplyMarkup The default chat reply markup was changed. Can occur because new messages with reply markup were received or because an old reply markup was hidden by the user
type UpdateChatReplyMarkup struct {
	tdCommon
	ChatID               int64 `json:"chat_id"`                 // Chat identifier
	ReplyMarkupMessageID int64 `json:"reply_markup_message_id"` // Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
}

// MessageType return the string telegram-type of UpdateChatReplyMarkup
func (updateChatReplyMarkup *UpdateChatReplyMarkup) MessageType() string {
	return "updateChatReplyMarkup"
}

// NewUpdateChatReplyMarkup creates a new UpdateChatReplyMarkup
//
// @param chatID Chat identifier
// @param replyMarkupMessageID Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
func NewUpdateChatReplyMarkup(chatID int64, replyMarkupMessageID int64) *UpdateChatReplyMarkup {
	updateChatReplyMarkupTemp := UpdateChatReplyMarkup{
		tdCommon:             tdCommon{Type: "updateChatReplyMarkup"},
		ChatID:               chatID,
		ReplyMarkupMessageID: replyMarkupMessageID,
	}

	return &updateChatReplyMarkupTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatReplyMarkup *UpdateChatReplyMarkup) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID               int64 `json:"chat_id"`                 // Chat identifier
		ReplyMarkupMessageID int64 `json:"reply_markup_message_id"` // Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatReplyMarkup.tdCommon = tempObj.tdCommon
	updateChatReplyMarkup.ChatID = tempObj.ChatID
	updateChatReplyMarkup.ReplyMarkupMessageID = tempObj.ReplyMarkupMessageID

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatReplyMarkup *UpdateChatReplyMarkup) GetUpdateEnum() UpdateEnum {
	return UpdateChatReplyMarkupType
}

// UpdateChatBackground The chat background was changed
type UpdateChatBackground struct {
	tdCommon
	ChatID     int64           `json:"chat_id"`    // Chat identifier
	Background *ChatBackground `json:"background"` // The new chat background; may be null if background was reset to default
}

// MessageType return the string telegram-type of UpdateChatBackground
func (updateChatBackground *UpdateChatBackground) MessageType() string {
	return "updateChatBackground"
}

// NewUpdateChatBackground creates a new UpdateChatBackground
//
// @param chatID Chat identifier
// @param background The new chat background; may be null if background was reset to default
func NewUpdateChatBackground(chatID int64, background *ChatBackground) *UpdateChatBackground {
	updateChatBackgroundTemp := UpdateChatBackground{
		tdCommon:   tdCommon{Type: "updateChatBackground"},
		ChatID:     chatID,
		Background: background,
	}

	return &updateChatBackgroundTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatBackground *UpdateChatBackground) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID     int64           `json:"chat_id"`    // Chat identifier
		Background *ChatBackground `json:"background"` // The new chat background; may be null if background was reset to default
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatBackground.tdCommon = tempObj.tdCommon
	updateChatBackground.ChatID = tempObj.ChatID
	updateChatBackground.Background = tempObj.Background

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatBackground *UpdateChatBackground) GetUpdateEnum() UpdateEnum {
	return UpdateChatBackgroundType
}

// UpdateChatTheme The chat theme was changed
type UpdateChatTheme struct {
	tdCommon
	ChatID    int64  `json:"chat_id"`    // Chat identifier
	ThemeName string `json:"theme_name"` // The new name of the chat theme; may be empty if theme was reset to default
}

// MessageType return the string telegram-type of UpdateChatTheme
func (updateChatTheme *UpdateChatTheme) MessageType() string {
	return "updateChatTheme"
}

// NewUpdateChatTheme creates a new UpdateChatTheme
//
// @param chatID Chat identifier
// @param themeName The new name of the chat theme; may be empty if theme was reset to default
func NewUpdateChatTheme(chatID int64, themeName string) *UpdateChatTheme {
	updateChatThemeTemp := UpdateChatTheme{
		tdCommon:  tdCommon{Type: "updateChatTheme"},
		ChatID:    chatID,
		ThemeName: themeName,
	}

	return &updateChatThemeTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatTheme *UpdateChatTheme) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID    int64  `json:"chat_id"`    // Chat identifier
		ThemeName string `json:"theme_name"` // The new name of the chat theme; may be empty if theme was reset to default
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatTheme.tdCommon = tempObj.tdCommon
	updateChatTheme.ChatID = tempObj.ChatID
	updateChatTheme.ThemeName = tempObj.ThemeName

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatTheme *UpdateChatTheme) GetUpdateEnum() UpdateEnum {
	return UpdateChatThemeType
}

// UpdateChatUnreadMentionCount The chat unread_mention_count has changed
type UpdateChatUnreadMentionCount struct {
	tdCommon
	ChatID             int64 `json:"chat_id"`              // Chat identifier
	UnreadMentionCount int32 `json:"unread_mention_count"` // The number of unread mention messages left in the chat
}

// MessageType return the string telegram-type of UpdateChatUnreadMentionCount
func (updateChatUnreadMentionCount *UpdateChatUnreadMentionCount) MessageType() string {
	return "updateChatUnreadMentionCount"
}

// NewUpdateChatUnreadMentionCount creates a new UpdateChatUnreadMentionCount
//
// @param chatID Chat identifier
// @param unreadMentionCount The number of unread mention messages left in the chat
func NewUpdateChatUnreadMentionCount(chatID int64, unreadMentionCount int32) *UpdateChatUnreadMentionCount {
	updateChatUnreadMentionCountTemp := UpdateChatUnreadMentionCount{
		tdCommon:           tdCommon{Type: "updateChatUnreadMentionCount"},
		ChatID:             chatID,
		UnreadMentionCount: unreadMentionCount,
	}

	return &updateChatUnreadMentionCountTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatUnreadMentionCount *UpdateChatUnreadMentionCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID             int64 `json:"chat_id"`              // Chat identifier
		UnreadMentionCount int32 `json:"unread_mention_count"` // The number of unread mention messages left in the chat
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatUnreadMentionCount.tdCommon = tempObj.tdCommon
	updateChatUnreadMentionCount.ChatID = tempObj.ChatID
	updateChatUnreadMentionCount.UnreadMentionCount = tempObj.UnreadMentionCount

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatUnreadMentionCount *UpdateChatUnreadMentionCount) GetUpdateEnum() UpdateEnum {
	return UpdateChatUnreadMentionCountType
}

// UpdateChatUnreadReactionCount The chat unread_reaction_count has changed
type UpdateChatUnreadReactionCount struct {
	tdCommon
	ChatID              int64 `json:"chat_id"`               // Chat identifier
	UnreadReactionCount int32 `json:"unread_reaction_count"` // The number of messages with unread reactions left in the chat
}

// MessageType return the string telegram-type of UpdateChatUnreadReactionCount
func (updateChatUnreadReactionCount *UpdateChatUnreadReactionCount) MessageType() string {
	return "updateChatUnreadReactionCount"
}

// NewUpdateChatUnreadReactionCount creates a new UpdateChatUnreadReactionCount
//
// @param chatID Chat identifier
// @param unreadReactionCount The number of messages with unread reactions left in the chat
func NewUpdateChatUnreadReactionCount(chatID int64, unreadReactionCount int32) *UpdateChatUnreadReactionCount {
	updateChatUnreadReactionCountTemp := UpdateChatUnreadReactionCount{
		tdCommon:            tdCommon{Type: "updateChatUnreadReactionCount"},
		ChatID:              chatID,
		UnreadReactionCount: unreadReactionCount,
	}

	return &updateChatUnreadReactionCountTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatUnreadReactionCount *UpdateChatUnreadReactionCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID              int64 `json:"chat_id"`               // Chat identifier
		UnreadReactionCount int32 `json:"unread_reaction_count"` // The number of messages with unread reactions left in the chat
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatUnreadReactionCount.tdCommon = tempObj.tdCommon
	updateChatUnreadReactionCount.ChatID = tempObj.ChatID
	updateChatUnreadReactionCount.UnreadReactionCount = tempObj.UnreadReactionCount

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatUnreadReactionCount *UpdateChatUnreadReactionCount) GetUpdateEnum() UpdateEnum {
	return UpdateChatUnreadReactionCountType
}

// UpdateChatVideoChat A chat video chat state has changed
type UpdateChatVideoChat struct {
	tdCommon
	ChatID    int64      `json:"chat_id"`    // Chat identifier
	VideoChat *VideoChat `json:"video_chat"` // New value of video_chat
}

// MessageType return the string telegram-type of UpdateChatVideoChat
func (updateChatVideoChat *UpdateChatVideoChat) MessageType() string {
	return "updateChatVideoChat"
}

// NewUpdateChatVideoChat creates a new UpdateChatVideoChat
//
// @param chatID Chat identifier
// @param videoChat New value of video_chat
func NewUpdateChatVideoChat(chatID int64, videoChat *VideoChat) *UpdateChatVideoChat {
	updateChatVideoChatTemp := UpdateChatVideoChat{
		tdCommon:  tdCommon{Type: "updateChatVideoChat"},
		ChatID:    chatID,
		VideoChat: videoChat,
	}

	return &updateChatVideoChatTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatVideoChat *UpdateChatVideoChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID int64 `json:"chat_id"` // Chat identifier

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatVideoChat.tdCommon = tempObj.tdCommon
	updateChatVideoChat.ChatID = tempObj.ChatID

	var videoChat VideoChat
	if objMap["video_chat"] != nil {
		err = videoChat.UnmarshalJSON(*objMap["video_chat"])
		if err != nil {
			return err
		}
	}

	updateChatVideoChat.VideoChat = &videoChat

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatVideoChat *UpdateChatVideoChat) GetUpdateEnum() UpdateEnum {
	return UpdateChatVideoChatType
}

// UpdateChatDefaultDisableNotification The value of the default disable_notification parameter, used when a message is sent to the chat, was changed
type UpdateChatDefaultDisableNotification struct {
	tdCommon
	ChatID                     int64 `json:"chat_id"`                      // Chat identifier
	DefaultDisableNotification bool  `json:"default_disable_notification"` // The new default_disable_notification value
}

// MessageType return the string telegram-type of UpdateChatDefaultDisableNotification
func (updateChatDefaultDisableNotification *UpdateChatDefaultDisableNotification) MessageType() string {
	return "updateChatDefaultDisableNotification"
}

// NewUpdateChatDefaultDisableNotification creates a new UpdateChatDefaultDisableNotification
//
// @param chatID Chat identifier
// @param defaultDisableNotification The new default_disable_notification value
func NewUpdateChatDefaultDisableNotification(chatID int64, defaultDisableNotification bool) *UpdateChatDefaultDisableNotification {
	updateChatDefaultDisableNotificationTemp := UpdateChatDefaultDisableNotification{
		tdCommon:                   tdCommon{Type: "updateChatDefaultDisableNotification"},
		ChatID:                     chatID,
		DefaultDisableNotification: defaultDisableNotification,
	}

	return &updateChatDefaultDisableNotificationTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatDefaultDisableNotification *UpdateChatDefaultDisableNotification) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID                     int64 `json:"chat_id"`                      // Chat identifier
		DefaultDisableNotification bool  `json:"default_disable_notification"` // The new default_disable_notification value
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatDefaultDisableNotification.tdCommon = tempObj.tdCommon
	updateChatDefaultDisableNotification.ChatID = tempObj.ChatID
	updateChatDefaultDisableNotification.DefaultDisableNotification = tempObj.DefaultDisableNotification

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatDefaultDisableNotification *UpdateChatDefaultDisableNotification) GetUpdateEnum() UpdateEnum {
	return UpdateChatDefaultDisableNotificationType
}

// UpdateChatHasProtectedContent A chat content was allowed or restricted for saving
type UpdateChatHasProtectedContent struct {
	tdCommon
	ChatID              int64 `json:"chat_id"`               // Chat identifier
	HasProtectedContent bool  `json:"has_protected_content"` // New value of has_protected_content
}

// MessageType return the string telegram-type of UpdateChatHasProtectedContent
func (updateChatHasProtectedContent *UpdateChatHasProtectedContent) MessageType() string {
	return "updateChatHasProtectedContent"
}

// NewUpdateChatHasProtectedContent creates a new UpdateChatHasProtectedContent
//
// @param chatID Chat identifier
// @param hasProtectedContent New value of has_protected_content
func NewUpdateChatHasProtectedContent(chatID int64, hasProtectedContent bool) *UpdateChatHasProtectedContent {
	updateChatHasProtectedContentTemp := UpdateChatHasProtectedContent{
		tdCommon:            tdCommon{Type: "updateChatHasProtectedContent"},
		ChatID:              chatID,
		HasProtectedContent: hasProtectedContent,
	}

	return &updateChatHasProtectedContentTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatHasProtectedContent *UpdateChatHasProtectedContent) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID              int64 `json:"chat_id"`               // Chat identifier
		HasProtectedContent bool  `json:"has_protected_content"` // New value of has_protected_content
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatHasProtectedContent.tdCommon = tempObj.tdCommon
	updateChatHasProtectedContent.ChatID = tempObj.ChatID
	updateChatHasProtectedContent.HasProtectedContent = tempObj.HasProtectedContent

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatHasProtectedContent *UpdateChatHasProtectedContent) GetUpdateEnum() UpdateEnum {
	return UpdateChatHasProtectedContentType
}

// UpdateChatIsTranslatable Translation of chat messages was enabled or disabled
type UpdateChatIsTranslatable struct {
	tdCommon
	ChatID         int64 `json:"chat_id"`         // Chat identifier
	IsTranslatable bool  `json:"is_translatable"` // New value of is_translatable
}

// MessageType return the string telegram-type of UpdateChatIsTranslatable
func (updateChatIsTranslatable *UpdateChatIsTranslatable) MessageType() string {
	return "updateChatIsTranslatable"
}

// NewUpdateChatIsTranslatable creates a new UpdateChatIsTranslatable
//
// @param chatID Chat identifier
// @param isTranslatable New value of is_translatable
func NewUpdateChatIsTranslatable(chatID int64, isTranslatable bool) *UpdateChatIsTranslatable {
	updateChatIsTranslatableTemp := UpdateChatIsTranslatable{
		tdCommon:       tdCommon{Type: "updateChatIsTranslatable"},
		ChatID:         chatID,
		IsTranslatable: isTranslatable,
	}

	return &updateChatIsTranslatableTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatIsTranslatable *UpdateChatIsTranslatable) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID         int64 `json:"chat_id"`         // Chat identifier
		IsTranslatable bool  `json:"is_translatable"` // New value of is_translatable
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatIsTranslatable.tdCommon = tempObj.tdCommon
	updateChatIsTranslatable.ChatID = tempObj.ChatID
	updateChatIsTranslatable.IsTranslatable = tempObj.IsTranslatable

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatIsTranslatable *UpdateChatIsTranslatable) GetUpdateEnum() UpdateEnum {
	return UpdateChatIsTranslatableType
}

// UpdateChatIsMarkedAsUnread A chat was marked as unread or was read
type UpdateChatIsMarkedAsUnread struct {
	tdCommon
	ChatID           int64 `json:"chat_id"`             // Chat identifier
	IsMarkedAsUnread bool  `json:"is_marked_as_unread"` // New value of is_marked_as_unread
}

// MessageType return the string telegram-type of UpdateChatIsMarkedAsUnread
func (updateChatIsMarkedAsUnread *UpdateChatIsMarkedAsUnread) MessageType() string {
	return "updateChatIsMarkedAsUnread"
}

// NewUpdateChatIsMarkedAsUnread creates a new UpdateChatIsMarkedAsUnread
//
// @param chatID Chat identifier
// @param isMarkedAsUnread New value of is_marked_as_unread
func NewUpdateChatIsMarkedAsUnread(chatID int64, isMarkedAsUnread bool) *UpdateChatIsMarkedAsUnread {
	updateChatIsMarkedAsUnreadTemp := UpdateChatIsMarkedAsUnread{
		tdCommon:         tdCommon{Type: "updateChatIsMarkedAsUnread"},
		ChatID:           chatID,
		IsMarkedAsUnread: isMarkedAsUnread,
	}

	return &updateChatIsMarkedAsUnreadTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatIsMarkedAsUnread *UpdateChatIsMarkedAsUnread) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID           int64 `json:"chat_id"`             // Chat identifier
		IsMarkedAsUnread bool  `json:"is_marked_as_unread"` // New value of is_marked_as_unread
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatIsMarkedAsUnread.tdCommon = tempObj.tdCommon
	updateChatIsMarkedAsUnread.ChatID = tempObj.ChatID
	updateChatIsMarkedAsUnread.IsMarkedAsUnread = tempObj.IsMarkedAsUnread

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatIsMarkedAsUnread *UpdateChatIsMarkedAsUnread) GetUpdateEnum() UpdateEnum {
	return UpdateChatIsMarkedAsUnreadType
}

// UpdateChatViewAsTopics A chat default appearance has changed
type UpdateChatViewAsTopics struct {
	tdCommon
	ChatID       int64 `json:"chat_id"`        // Chat identifier
	ViewAsTopics bool  `json:"view_as_topics"` // New value of view_as_topics
}

// MessageType return the string telegram-type of UpdateChatViewAsTopics
func (updateChatViewAsTopics *UpdateChatViewAsTopics) MessageType() string {
	return "updateChatViewAsTopics"
}

// NewUpdateChatViewAsTopics creates a new UpdateChatViewAsTopics
//
// @param chatID Chat identifier
// @param viewAsTopics New value of view_as_topics
func NewUpdateChatViewAsTopics(chatID int64, viewAsTopics bool) *UpdateChatViewAsTopics {
	updateChatViewAsTopicsTemp := UpdateChatViewAsTopics{
		tdCommon:     tdCommon{Type: "updateChatViewAsTopics"},
		ChatID:       chatID,
		ViewAsTopics: viewAsTopics,
	}

	return &updateChatViewAsTopicsTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatViewAsTopics *UpdateChatViewAsTopics) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID       int64 `json:"chat_id"`        // Chat identifier
		ViewAsTopics bool  `json:"view_as_topics"` // New value of view_as_topics
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatViewAsTopics.tdCommon = tempObj.tdCommon
	updateChatViewAsTopics.ChatID = tempObj.ChatID
	updateChatViewAsTopics.ViewAsTopics = tempObj.ViewAsTopics

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatViewAsTopics *UpdateChatViewAsTopics) GetUpdateEnum() UpdateEnum {
	return UpdateChatViewAsTopicsType
}

// UpdateChatBlockList A chat was blocked or unblocked
type UpdateChatBlockList struct {
	tdCommon
	ChatID    int64      `json:"chat_id"`    // Chat identifier
	BlockList *BlockList `json:"block_list"` // Block list to which the chat is added; may be null if none
}

// MessageType return the string telegram-type of UpdateChatBlockList
func (updateChatBlockList *UpdateChatBlockList) MessageType() string {
	return "updateChatBlockList"
}

// NewUpdateChatBlockList creates a new UpdateChatBlockList
//
// @param chatID Chat identifier
// @param blockList Block list to which the chat is added; may be null if none
func NewUpdateChatBlockList(chatID int64, blockList *BlockList) *UpdateChatBlockList {
	updateChatBlockListTemp := UpdateChatBlockList{
		tdCommon:  tdCommon{Type: "updateChatBlockList"},
		ChatID:    chatID,
		BlockList: blockList,
	}

	return &updateChatBlockListTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatBlockList *UpdateChatBlockList) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID int64 `json:"chat_id"` // Chat identifier

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatBlockList.tdCommon = tempObj.tdCommon
	updateChatBlockList.ChatID = tempObj.ChatID

	fieldBlockList, _ := unmarshalBlockList(objMap["block_list"])
	updateChatBlockList.BlockList = &fieldBlockList

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatBlockList *UpdateChatBlockList) GetUpdateEnum() UpdateEnum {
	return UpdateChatBlockListType
}

// UpdateChatHasScheduledMessages A chat's has_scheduled_messages field has changed
type UpdateChatHasScheduledMessages struct {
	tdCommon
	ChatID               int64 `json:"chat_id"`                // Chat identifier
	HasScheduledMessages bool  `json:"has_scheduled_messages"` // New value of has_scheduled_messages
}

// MessageType return the string telegram-type of UpdateChatHasScheduledMessages
func (updateChatHasScheduledMessages *UpdateChatHasScheduledMessages) MessageType() string {
	return "updateChatHasScheduledMessages"
}

// NewUpdateChatHasScheduledMessages creates a new UpdateChatHasScheduledMessages
//
// @param chatID Chat identifier
// @param hasScheduledMessages New value of has_scheduled_messages
func NewUpdateChatHasScheduledMessages(chatID int64, hasScheduledMessages bool) *UpdateChatHasScheduledMessages {
	updateChatHasScheduledMessagesTemp := UpdateChatHasScheduledMessages{
		tdCommon:             tdCommon{Type: "updateChatHasScheduledMessages"},
		ChatID:               chatID,
		HasScheduledMessages: hasScheduledMessages,
	}

	return &updateChatHasScheduledMessagesTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatHasScheduledMessages *UpdateChatHasScheduledMessages) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID               int64 `json:"chat_id"`                // Chat identifier
		HasScheduledMessages bool  `json:"has_scheduled_messages"` // New value of has_scheduled_messages
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatHasScheduledMessages.tdCommon = tempObj.tdCommon
	updateChatHasScheduledMessages.ChatID = tempObj.ChatID
	updateChatHasScheduledMessages.HasScheduledMessages = tempObj.HasScheduledMessages

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatHasScheduledMessages *UpdateChatHasScheduledMessages) GetUpdateEnum() UpdateEnum {
	return UpdateChatHasScheduledMessagesType
}

// UpdateChatFolders The list of chat folders or a chat folder has changed
type UpdateChatFolders struct {
	tdCommon
	ChatFolders          []ChatFolderInfo `json:"chat_folders"`            // The new list of chat folders
	MainChatListPosition int32            `json:"main_chat_list_position"` // Position of the main chat list among chat folders, 0-based
	AreTagsEnabled       bool             `json:"are_tags_enabled"`        // True, if folder tags are enabled
}

// MessageType return the string telegram-type of UpdateChatFolders
func (updateChatFolders *UpdateChatFolders) MessageType() string {
	return "updateChatFolders"
}

// NewUpdateChatFolders creates a new UpdateChatFolders
//
// @param chatFolders The new list of chat folders
// @param mainChatListPosition Position of the main chat list among chat folders, 0-based
// @param areTagsEnabled True, if folder tags are enabled
func NewUpdateChatFolders(chatFolders []ChatFolderInfo, mainChatListPosition int32, areTagsEnabled bool) *UpdateChatFolders {
	updateChatFoldersTemp := UpdateChatFolders{
		tdCommon:             tdCommon{Type: "updateChatFolders"},
		ChatFolders:          chatFolders,
		MainChatListPosition: mainChatListPosition,
		AreTagsEnabled:       areTagsEnabled,
	}

	return &updateChatFoldersTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatFolders *UpdateChatFolders) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatFolders          []ChatFolderInfo `json:"chat_folders"`            // The new list of chat folders
		MainChatListPosition int32            `json:"main_chat_list_position"` // Position of the main chat list among chat folders, 0-based
		AreTagsEnabled       bool             `json:"are_tags_enabled"`        // True, if folder tags are enabled
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatFolders.tdCommon = tempObj.tdCommon
	updateChatFolders.ChatFolders = tempObj.ChatFolders
	updateChatFolders.MainChatListPosition = tempObj.MainChatListPosition
	updateChatFolders.AreTagsEnabled = tempObj.AreTagsEnabled

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatFolders *UpdateChatFolders) GetUpdateEnum() UpdateEnum {
	return UpdateChatFoldersType
}

// UpdateChatOnlineMemberCount The number of online group members has changed. This update with non-zero number of online group members is sent only for currently opened chats. There is no guarantee that it is sent just after the number of online users has changed
type UpdateChatOnlineMemberCount struct {
	tdCommon
	ChatID            int64 `json:"chat_id"`             // Identifier of the chat
	OnlineMemberCount int32 `json:"online_member_count"` // New number of online members in the chat, or 0 if unknown
}

// MessageType return the string telegram-type of UpdateChatOnlineMemberCount
func (updateChatOnlineMemberCount *UpdateChatOnlineMemberCount) MessageType() string {
	return "updateChatOnlineMemberCount"
}

// NewUpdateChatOnlineMemberCount creates a new UpdateChatOnlineMemberCount
//
// @param chatID Identifier of the chat
// @param onlineMemberCount New number of online members in the chat, or 0 if unknown
func NewUpdateChatOnlineMemberCount(chatID int64, onlineMemberCount int32) *UpdateChatOnlineMemberCount {
	updateChatOnlineMemberCountTemp := UpdateChatOnlineMemberCount{
		tdCommon:          tdCommon{Type: "updateChatOnlineMemberCount"},
		ChatID:            chatID,
		OnlineMemberCount: onlineMemberCount,
	}

	return &updateChatOnlineMemberCountTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatOnlineMemberCount *UpdateChatOnlineMemberCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID            int64 `json:"chat_id"`             // Identifier of the chat
		OnlineMemberCount int32 `json:"online_member_count"` // New number of online members in the chat, or 0 if unknown
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatOnlineMemberCount.tdCommon = tempObj.tdCommon
	updateChatOnlineMemberCount.ChatID = tempObj.ChatID
	updateChatOnlineMemberCount.OnlineMemberCount = tempObj.OnlineMemberCount

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatOnlineMemberCount *UpdateChatOnlineMemberCount) GetUpdateEnum() UpdateEnum {
	return UpdateChatOnlineMemberCountType
}

// UpdateSavedMessagesTopic Basic information about a Saved Messages topic has changed. This update is guaranteed to come before the topic identifier is returned to the application
type UpdateSavedMessagesTopic struct {
	tdCommon
	Topic *SavedMessagesTopic `json:"topic"` // New data about the topic
}

// MessageType return the string telegram-type of UpdateSavedMessagesTopic
func (updateSavedMessagesTopic *UpdateSavedMessagesTopic) MessageType() string {
	return "updateSavedMessagesTopic"
}

// NewUpdateSavedMessagesTopic creates a new UpdateSavedMessagesTopic
//
// @param topic New data about the topic
func NewUpdateSavedMessagesTopic(topic *SavedMessagesTopic) *UpdateSavedMessagesTopic {
	updateSavedMessagesTopicTemp := UpdateSavedMessagesTopic{
		tdCommon: tdCommon{Type: "updateSavedMessagesTopic"},
		Topic:    topic,
	}

	return &updateSavedMessagesTopicTemp
}

// UnmarshalJSON unmarshal to json
func (updateSavedMessagesTopic *UpdateSavedMessagesTopic) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateSavedMessagesTopic.tdCommon = tempObj.tdCommon

	var topic SavedMessagesTopic
	if objMap["topic"] != nil {
		err = topic.UnmarshalJSON(*objMap["topic"])
		if err != nil {
			return err
		}
	}

	updateSavedMessagesTopic.Topic = &topic

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateSavedMessagesTopic *UpdateSavedMessagesTopic) GetUpdateEnum() UpdateEnum {
	return UpdateSavedMessagesTopicType
}

// UpdateSavedMessagesTopicCount Number of Saved Messages topics has changed
type UpdateSavedMessagesTopicCount struct {
	tdCommon
	TopicCount int32 `json:"topic_count"` // Approximate total number of Saved Messages topics
}

// MessageType return the string telegram-type of UpdateSavedMessagesTopicCount
func (updateSavedMessagesTopicCount *UpdateSavedMessagesTopicCount) MessageType() string {
	return "updateSavedMessagesTopicCount"
}

// NewUpdateSavedMessagesTopicCount creates a new UpdateSavedMessagesTopicCount
//
// @param topicCount Approximate total number of Saved Messages topics
func NewUpdateSavedMessagesTopicCount(topicCount int32) *UpdateSavedMessagesTopicCount {
	updateSavedMessagesTopicCountTemp := UpdateSavedMessagesTopicCount{
		tdCommon:   tdCommon{Type: "updateSavedMessagesTopicCount"},
		TopicCount: topicCount,
	}

	return &updateSavedMessagesTopicCountTemp
}

// UnmarshalJSON unmarshal to json
func (updateSavedMessagesTopicCount *UpdateSavedMessagesTopicCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TopicCount int32 `json:"topic_count"` // Approximate total number of Saved Messages topics
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateSavedMessagesTopicCount.tdCommon = tempObj.tdCommon
	updateSavedMessagesTopicCount.TopicCount = tempObj.TopicCount

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateSavedMessagesTopicCount *UpdateSavedMessagesTopicCount) GetUpdateEnum() UpdateEnum {
	return UpdateSavedMessagesTopicCountType
}

// UpdateQuickReplyShortcut Basic information about a quick reply shortcut has changed. This update is guaranteed to come before the quick shortcut name is returned to the application
type UpdateQuickReplyShortcut struct {
	tdCommon
	Shortcut *QuickReplyShortcut `json:"shortcut"` // New data about the shortcut
}

// MessageType return the string telegram-type of UpdateQuickReplyShortcut
func (updateQuickReplyShortcut *UpdateQuickReplyShortcut) MessageType() string {
	return "updateQuickReplyShortcut"
}

// NewUpdateQuickReplyShortcut creates a new UpdateQuickReplyShortcut
//
// @param shortcut New data about the shortcut
func NewUpdateQuickReplyShortcut(shortcut *QuickReplyShortcut) *UpdateQuickReplyShortcut {
	updateQuickReplyShortcutTemp := UpdateQuickReplyShortcut{
		tdCommon: tdCommon{Type: "updateQuickReplyShortcut"},
		Shortcut: shortcut,
	}

	return &updateQuickReplyShortcutTemp
}

// UnmarshalJSON unmarshal to json
func (updateQuickReplyShortcut *UpdateQuickReplyShortcut) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Shortcut *QuickReplyShortcut `json:"shortcut"` // New data about the shortcut
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateQuickReplyShortcut.tdCommon = tempObj.tdCommon
	updateQuickReplyShortcut.Shortcut = tempObj.Shortcut

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateQuickReplyShortcut *UpdateQuickReplyShortcut) GetUpdateEnum() UpdateEnum {
	return UpdateQuickReplyShortcutType
}

// UpdateQuickReplyShortcutDeleted A quick reply shortcut and all its messages were deleted
type UpdateQuickReplyShortcutDeleted struct {
	tdCommon
	ShortcutID int32 `json:"shortcut_id"` // The identifier of the deleted shortcut
}

// MessageType return the string telegram-type of UpdateQuickReplyShortcutDeleted
func (updateQuickReplyShortcutDeleted *UpdateQuickReplyShortcutDeleted) MessageType() string {
	return "updateQuickReplyShortcutDeleted"
}

// NewUpdateQuickReplyShortcutDeleted creates a new UpdateQuickReplyShortcutDeleted
//
// @param shortcutID The identifier of the deleted shortcut
func NewUpdateQuickReplyShortcutDeleted(shortcutID int32) *UpdateQuickReplyShortcutDeleted {
	updateQuickReplyShortcutDeletedTemp := UpdateQuickReplyShortcutDeleted{
		tdCommon:   tdCommon{Type: "updateQuickReplyShortcutDeleted"},
		ShortcutID: shortcutID,
	}

	return &updateQuickReplyShortcutDeletedTemp
}

// UnmarshalJSON unmarshal to json
func (updateQuickReplyShortcutDeleted *UpdateQuickReplyShortcutDeleted) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ShortcutID int32 `json:"shortcut_id"` // The identifier of the deleted shortcut
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateQuickReplyShortcutDeleted.tdCommon = tempObj.tdCommon
	updateQuickReplyShortcutDeleted.ShortcutID = tempObj.ShortcutID

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateQuickReplyShortcutDeleted *UpdateQuickReplyShortcutDeleted) GetUpdateEnum() UpdateEnum {
	return UpdateQuickReplyShortcutDeletedType
}

// UpdateQuickReplyShortcuts The list of quick reply shortcuts has changed
type UpdateQuickReplyShortcuts struct {
	tdCommon
	ShortcutIDs []int32 `json:"shortcut_ids"` // The new list of identifiers of quick reply shortcuts
}

// MessageType return the string telegram-type of UpdateQuickReplyShortcuts
func (updateQuickReplyShortcuts *UpdateQuickReplyShortcuts) MessageType() string {
	return "updateQuickReplyShortcuts"
}

// NewUpdateQuickReplyShortcuts creates a new UpdateQuickReplyShortcuts
//
// @param shortcutIDs The new list of identifiers of quick reply shortcuts
func NewUpdateQuickReplyShortcuts(shortcutIDs []int32) *UpdateQuickReplyShortcuts {
	updateQuickReplyShortcutsTemp := UpdateQuickReplyShortcuts{
		tdCommon:    tdCommon{Type: "updateQuickReplyShortcuts"},
		ShortcutIDs: shortcutIDs,
	}

	return &updateQuickReplyShortcutsTemp
}

// UnmarshalJSON unmarshal to json
func (updateQuickReplyShortcuts *UpdateQuickReplyShortcuts) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ShortcutIDs []int32 `json:"shortcut_ids"` // The new list of identifiers of quick reply shortcuts
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateQuickReplyShortcuts.tdCommon = tempObj.tdCommon
	updateQuickReplyShortcuts.ShortcutIDs = tempObj.ShortcutIDs

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateQuickReplyShortcuts *UpdateQuickReplyShortcuts) GetUpdateEnum() UpdateEnum {
	return UpdateQuickReplyShortcutsType
}

// UpdateQuickReplyShortcutMessages The list of quick reply shortcut messages has changed
type UpdateQuickReplyShortcutMessages struct {
	tdCommon
	ShortcutID int32               `json:"shortcut_id"` // The identifier of the shortcut
	Messages   []QuickReplyMessage `json:"messages"`    // The new list of quick reply messages for the shortcut in order from the first to the last sent
}

// MessageType return the string telegram-type of UpdateQuickReplyShortcutMessages
func (updateQuickReplyShortcutMessages *UpdateQuickReplyShortcutMessages) MessageType() string {
	return "updateQuickReplyShortcutMessages"
}

// NewUpdateQuickReplyShortcutMessages creates a new UpdateQuickReplyShortcutMessages
//
// @param shortcutID The identifier of the shortcut
// @param messages The new list of quick reply messages for the shortcut in order from the first to the last sent
func NewUpdateQuickReplyShortcutMessages(shortcutID int32, messages []QuickReplyMessage) *UpdateQuickReplyShortcutMessages {
	updateQuickReplyShortcutMessagesTemp := UpdateQuickReplyShortcutMessages{
		tdCommon:   tdCommon{Type: "updateQuickReplyShortcutMessages"},
		ShortcutID: shortcutID,
		Messages:   messages,
	}

	return &updateQuickReplyShortcutMessagesTemp
}

// UnmarshalJSON unmarshal to json
func (updateQuickReplyShortcutMessages *UpdateQuickReplyShortcutMessages) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ShortcutID int32               `json:"shortcut_id"` // The identifier of the shortcut
		Messages   []QuickReplyMessage `json:"messages"`    // The new list of quick reply messages for the shortcut in order from the first to the last sent
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateQuickReplyShortcutMessages.tdCommon = tempObj.tdCommon
	updateQuickReplyShortcutMessages.ShortcutID = tempObj.ShortcutID
	updateQuickReplyShortcutMessages.Messages = tempObj.Messages

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateQuickReplyShortcutMessages *UpdateQuickReplyShortcutMessages) GetUpdateEnum() UpdateEnum {
	return UpdateQuickReplyShortcutMessagesType
}

// UpdateForumTopicInfo Basic information about a topic in a forum chat was changed
type UpdateForumTopicInfo struct {
	tdCommon
	ChatID int64           `json:"chat_id"` // Chat identifier
	Info   *ForumTopicInfo `json:"info"`    // New information about the topic
}

// MessageType return the string telegram-type of UpdateForumTopicInfo
func (updateForumTopicInfo *UpdateForumTopicInfo) MessageType() string {
	return "updateForumTopicInfo"
}

// NewUpdateForumTopicInfo creates a new UpdateForumTopicInfo
//
// @param chatID Chat identifier
// @param info New information about the topic
func NewUpdateForumTopicInfo(chatID int64, info *ForumTopicInfo) *UpdateForumTopicInfo {
	updateForumTopicInfoTemp := UpdateForumTopicInfo{
		tdCommon: tdCommon{Type: "updateForumTopicInfo"},
		ChatID:   chatID,
		Info:     info,
	}

	return &updateForumTopicInfoTemp
}

// UnmarshalJSON unmarshal to json
func (updateForumTopicInfo *UpdateForumTopicInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID int64 `json:"chat_id"` // Chat identifier

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateForumTopicInfo.tdCommon = tempObj.tdCommon
	updateForumTopicInfo.ChatID = tempObj.ChatID

	var info ForumTopicInfo
	if objMap["info"] != nil {
		err = info.UnmarshalJSON(*objMap["info"])
		if err != nil {
			return err
		}
	}

	updateForumTopicInfo.Info = &info

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateForumTopicInfo *UpdateForumTopicInfo) GetUpdateEnum() UpdateEnum {
	return UpdateForumTopicInfoType
}

// UpdateScopeNotificationSettings Notification settings for some type of chats were updated
type UpdateScopeNotificationSettings struct {
	tdCommon
	Scope                NotificationSettingsScope  `json:"scope"`                 // Types of chats for which notification settings were updated
	NotificationSettings *ScopeNotificationSettings `json:"notification_settings"` // The new notification settings
}

// MessageType return the string telegram-type of UpdateScopeNotificationSettings
func (updateScopeNotificationSettings *UpdateScopeNotificationSettings) MessageType() string {
	return "updateScopeNotificationSettings"
}

// NewUpdateScopeNotificationSettings creates a new UpdateScopeNotificationSettings
//
// @param scope Types of chats for which notification settings were updated
// @param notificationSettings The new notification settings
func NewUpdateScopeNotificationSettings(scope NotificationSettingsScope, notificationSettings *ScopeNotificationSettings) *UpdateScopeNotificationSettings {
	updateScopeNotificationSettingsTemp := UpdateScopeNotificationSettings{
		tdCommon:             tdCommon{Type: "updateScopeNotificationSettings"},
		Scope:                scope,
		NotificationSettings: notificationSettings,
	}

	return &updateScopeNotificationSettingsTemp
}

// UnmarshalJSON unmarshal to json
func (updateScopeNotificationSettings *UpdateScopeNotificationSettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		NotificationSettings *ScopeNotificationSettings `json:"notification_settings"` // The new notification settings
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateScopeNotificationSettings.tdCommon = tempObj.tdCommon
	updateScopeNotificationSettings.NotificationSettings = tempObj.NotificationSettings

	fieldScope, _ := unmarshalNotificationSettingsScope(objMap["scope"])
	updateScopeNotificationSettings.Scope = fieldScope

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateScopeNotificationSettings *UpdateScopeNotificationSettings) GetUpdateEnum() UpdateEnum {
	return UpdateScopeNotificationSettingsType
}

// UpdateReactionNotificationSettings Notification settings for reactions were updated
type UpdateReactionNotificationSettings struct {
	tdCommon
	NotificationSettings *ReactionNotificationSettings `json:"notification_settings"` // The new notification settings
}

// MessageType return the string telegram-type of UpdateReactionNotificationSettings
func (updateReactionNotificationSettings *UpdateReactionNotificationSettings) MessageType() string {
	return "updateReactionNotificationSettings"
}

// NewUpdateReactionNotificationSettings creates a new UpdateReactionNotificationSettings
//
// @param notificationSettings The new notification settings
func NewUpdateReactionNotificationSettings(notificationSettings *ReactionNotificationSettings) *UpdateReactionNotificationSettings {
	updateReactionNotificationSettingsTemp := UpdateReactionNotificationSettings{
		tdCommon:             tdCommon{Type: "updateReactionNotificationSettings"},
		NotificationSettings: notificationSettings,
	}

	return &updateReactionNotificationSettingsTemp
}

// UnmarshalJSON unmarshal to json
func (updateReactionNotificationSettings *UpdateReactionNotificationSettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateReactionNotificationSettings.tdCommon = tempObj.tdCommon

	var notificationSettings ReactionNotificationSettings
	if objMap["notification_settings"] != nil {
		err = notificationSettings.UnmarshalJSON(*objMap["notification_settings"])
		if err != nil {
			return err
		}
	}

	updateReactionNotificationSettings.NotificationSettings = &notificationSettings

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateReactionNotificationSettings *UpdateReactionNotificationSettings) GetUpdateEnum() UpdateEnum {
	return UpdateReactionNotificationSettingsType
}

// UpdateNotification A notification was changed
type UpdateNotification struct {
	tdCommon
	NotificationGroupID int32         `json:"notification_group_id"` // Unique notification group identifier
	Notification        *Notification `json:"notification"`          // Changed notification
}

// MessageType return the string telegram-type of UpdateNotification
func (updateNotification *UpdateNotification) MessageType() string {
	return "updateNotification"
}

// NewUpdateNotification creates a new UpdateNotification
//
// @param notificationGroupID Unique notification group identifier
// @param notification Changed notification
func NewUpdateNotification(notificationGroupID int32, notification *Notification) *UpdateNotification {
	updateNotificationTemp := UpdateNotification{
		tdCommon:            tdCommon{Type: "updateNotification"},
		NotificationGroupID: notificationGroupID,
		Notification:        notification,
	}

	return &updateNotificationTemp
}

// UnmarshalJSON unmarshal to json
func (updateNotification *UpdateNotification) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		NotificationGroupID int32 `json:"notification_group_id"` // Unique notification group identifier

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateNotification.tdCommon = tempObj.tdCommon
	updateNotification.NotificationGroupID = tempObj.NotificationGroupID

	var notification Notification
	if objMap["notification"] != nil {
		err = notification.UnmarshalJSON(*objMap["notification"])
		if err != nil {
			return err
		}
	}

	updateNotification.Notification = &notification

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateNotification *UpdateNotification) GetUpdateEnum() UpdateEnum {
	return UpdateNotificationType
}

// UpdateNotificationGroup A list of active notifications in a notification group has changed
type UpdateNotificationGroup struct {
	tdCommon
	NotificationGroupID        int32                 `json:"notification_group_id"`         // Unique notification group identifier
	Type                       NotificationGroupType `json:"type"`                          // New type of the notification group
	ChatID                     int64                 `json:"chat_id"`                       // Identifier of a chat to which all notifications in the group belong
	NotificationSettingsChatID int64                 `json:"notification_settings_chat_id"` // Chat identifier, which notification settings must be applied to the added notifications
	NotificationSoundID        JSONInt64             `json:"notification_sound_id"`         // Identifier of the notification sound to be played; 0 if sound is disabled
	TotalCount                 int32                 `json:"total_count"`                   // Total number of unread notifications in the group, can be bigger than number of active notifications
	AddedNotifications         []Notification        `json:"added_notifications"`           // List of added group notifications, sorted by notification identifier
	RemovedNotificationIDs     []int32               `json:"removed_notification_ids"`      // Identifiers of removed group notifications, sorted by notification identifier
}

// MessageType return the string telegram-type of UpdateNotificationGroup
func (updateNotificationGroup *UpdateNotificationGroup) MessageType() string {
	return "updateNotificationGroup"
}

// NewUpdateNotificationGroup creates a new UpdateNotificationGroup
//
// @param notificationGroupID Unique notification group identifier
// @param typeParam New type of the notification group
// @param chatID Identifier of a chat to which all notifications in the group belong
// @param notificationSettingsChatID Chat identifier, which notification settings must be applied to the added notifications
// @param notificationSoundID Identifier of the notification sound to be played; 0 if sound is disabled
// @param totalCount Total number of unread notifications in the group, can be bigger than number of active notifications
// @param addedNotifications List of added group notifications, sorted by notification identifier
// @param removedNotificationIDs Identifiers of removed group notifications, sorted by notification identifier
func NewUpdateNotificationGroup(notificationGroupID int32, typeParam NotificationGroupType, chatID int64, notificationSettingsChatID int64, notificationSoundID JSONInt64, totalCount int32, addedNotifications []Notification, removedNotificationIDs []int32) *UpdateNotificationGroup {
	updateNotificationGroupTemp := UpdateNotificationGroup{
		tdCommon:                   tdCommon{Type: "updateNotificationGroup"},
		NotificationGroupID:        notificationGroupID,
		Type:                       typeParam,
		ChatID:                     chatID,
		NotificationSettingsChatID: notificationSettingsChatID,
		NotificationSoundID:        notificationSoundID,
		TotalCount:                 totalCount,
		AddedNotifications:         addedNotifications,
		RemovedNotificationIDs:     removedNotificationIDs,
	}

	return &updateNotificationGroupTemp
}

// UnmarshalJSON unmarshal to json
func (updateNotificationGroup *UpdateNotificationGroup) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		NotificationGroupID        int32          `json:"notification_group_id"`         // Unique notification group identifier
		ChatID                     int64          `json:"chat_id"`                       // Identifier of a chat to which all notifications in the group belong
		NotificationSettingsChatID int64          `json:"notification_settings_chat_id"` // Chat identifier, which notification settings must be applied to the added notifications
		NotificationSoundID        JSONInt64      `json:"notification_sound_id"`         // Identifier of the notification sound to be played; 0 if sound is disabled
		TotalCount                 int32          `json:"total_count"`                   // Total number of unread notifications in the group, can be bigger than number of active notifications
		AddedNotifications         []Notification `json:"added_notifications"`           // List of added group notifications, sorted by notification identifier
		RemovedNotificationIDs     []int32        `json:"removed_notification_ids"`      // Identifiers of removed group notifications, sorted by notification identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateNotificationGroup.tdCommon = tempObj.tdCommon
	updateNotificationGroup.NotificationGroupID = tempObj.NotificationGroupID
	updateNotificationGroup.ChatID = tempObj.ChatID
	updateNotificationGroup.NotificationSettingsChatID = tempObj.NotificationSettingsChatID
	updateNotificationGroup.NotificationSoundID = tempObj.NotificationSoundID
	updateNotificationGroup.TotalCount = tempObj.TotalCount
	updateNotificationGroup.AddedNotifications = tempObj.AddedNotifications
	updateNotificationGroup.RemovedNotificationIDs = tempObj.RemovedNotificationIDs

	fieldType, _ := unmarshalNotificationGroupType(objMap["type"])
	updateNotificationGroup.Type = fieldType

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateNotificationGroup *UpdateNotificationGroup) GetUpdateEnum() UpdateEnum {
	return UpdateNotificationGroupType
}

// UpdateActiveNotifications Contains active notifications that were shown on previous application launches. This update is sent only if the message database is used. In that case it comes once before any updateNotification and updateNotificationGroup update
type UpdateActiveNotifications struct {
	tdCommon
	Groups []NotificationGroup `json:"groups"` // Lists of active notification groups
}

// MessageType return the string telegram-type of UpdateActiveNotifications
func (updateActiveNotifications *UpdateActiveNotifications) MessageType() string {
	return "updateActiveNotifications"
}

// NewUpdateActiveNotifications creates a new UpdateActiveNotifications
//
// @param groups Lists of active notification groups
func NewUpdateActiveNotifications(groups []NotificationGroup) *UpdateActiveNotifications {
	updateActiveNotificationsTemp := UpdateActiveNotifications{
		tdCommon: tdCommon{Type: "updateActiveNotifications"},
		Groups:   groups,
	}

	return &updateActiveNotificationsTemp
}

// UnmarshalJSON unmarshal to json
func (updateActiveNotifications *UpdateActiveNotifications) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Groups []NotificationGroup `json:"groups"` // Lists of active notification groups
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateActiveNotifications.tdCommon = tempObj.tdCommon
	updateActiveNotifications.Groups = tempObj.Groups

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateActiveNotifications *UpdateActiveNotifications) GetUpdateEnum() UpdateEnum {
	return UpdateActiveNotificationsType
}

// UpdateHavePendingNotifications Describes whether there are some pending notification updates. Can be used to prevent application from killing, while there are some pending notifications
type UpdateHavePendingNotifications struct {
	tdCommon
	HaveDelayedNotifications    bool `json:"have_delayed_notifications"`    // True, if there are some delayed notification updates, which will be sent soon
	HaveUnreceivedNotifications bool `json:"have_unreceived_notifications"` // True, if there can be some yet unreceived notifications, which are being fetched from the server
}

// MessageType return the string telegram-type of UpdateHavePendingNotifications
func (updateHavePendingNotifications *UpdateHavePendingNotifications) MessageType() string {
	return "updateHavePendingNotifications"
}

// NewUpdateHavePendingNotifications creates a new UpdateHavePendingNotifications
//
// @param haveDelayedNotifications True, if there are some delayed notification updates, which will be sent soon
// @param haveUnreceivedNotifications True, if there can be some yet unreceived notifications, which are being fetched from the server
func NewUpdateHavePendingNotifications(haveDelayedNotifications bool, haveUnreceivedNotifications bool) *UpdateHavePendingNotifications {
	updateHavePendingNotificationsTemp := UpdateHavePendingNotifications{
		tdCommon:                    tdCommon{Type: "updateHavePendingNotifications"},
		HaveDelayedNotifications:    haveDelayedNotifications,
		HaveUnreceivedNotifications: haveUnreceivedNotifications,
	}

	return &updateHavePendingNotificationsTemp
}

// UnmarshalJSON unmarshal to json
func (updateHavePendingNotifications *UpdateHavePendingNotifications) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		HaveDelayedNotifications    bool `json:"have_delayed_notifications"`    // True, if there are some delayed notification updates, which will be sent soon
		HaveUnreceivedNotifications bool `json:"have_unreceived_notifications"` // True, if there can be some yet unreceived notifications, which are being fetched from the server
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateHavePendingNotifications.tdCommon = tempObj.tdCommon
	updateHavePendingNotifications.HaveDelayedNotifications = tempObj.HaveDelayedNotifications
	updateHavePendingNotifications.HaveUnreceivedNotifications = tempObj.HaveUnreceivedNotifications

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateHavePendingNotifications *UpdateHavePendingNotifications) GetUpdateEnum() UpdateEnum {
	return UpdateHavePendingNotificationsType
}

// UpdateDeleteMessages Some messages were deleted
type UpdateDeleteMessages struct {
	tdCommon
	ChatID      int64   `json:"chat_id"`      // Chat identifier
	MessageIDs  []int64 `json:"message_ids"`  // Identifiers of the deleted messages
	IsPermanent bool    `json:"is_permanent"` // True, if the messages are permanently deleted by a user (as opposed to just becoming inaccessible)
	FromCache   bool    `json:"from_cache"`   // True, if the messages are deleted only from the cache and can possibly be retrieved again in the future
}

// MessageType return the string telegram-type of UpdateDeleteMessages
func (updateDeleteMessages *UpdateDeleteMessages) MessageType() string {
	return "updateDeleteMessages"
}

// NewUpdateDeleteMessages creates a new UpdateDeleteMessages
//
// @param chatID Chat identifier
// @param messageIDs Identifiers of the deleted messages
// @param isPermanent True, if the messages are permanently deleted by a user (as opposed to just becoming inaccessible)
// @param fromCache True, if the messages are deleted only from the cache and can possibly be retrieved again in the future
func NewUpdateDeleteMessages(chatID int64, messageIDs []int64, isPermanent bool, fromCache bool) *UpdateDeleteMessages {
	updateDeleteMessagesTemp := UpdateDeleteMessages{
		tdCommon:    tdCommon{Type: "updateDeleteMessages"},
		ChatID:      chatID,
		MessageIDs:  messageIDs,
		IsPermanent: isPermanent,
		FromCache:   fromCache,
	}

	return &updateDeleteMessagesTemp
}

// UnmarshalJSON unmarshal to json
func (updateDeleteMessages *UpdateDeleteMessages) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID      int64   `json:"chat_id"`      // Chat identifier
		MessageIDs  []int64 `json:"message_ids"`  // Identifiers of the deleted messages
		IsPermanent bool    `json:"is_permanent"` // True, if the messages are permanently deleted by a user (as opposed to just becoming inaccessible)
		FromCache   bool    `json:"from_cache"`   // True, if the messages are deleted only from the cache and can possibly be retrieved again in the future
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateDeleteMessages.tdCommon = tempObj.tdCommon
	updateDeleteMessages.ChatID = tempObj.ChatID
	updateDeleteMessages.MessageIDs = tempObj.MessageIDs
	updateDeleteMessages.IsPermanent = tempObj.IsPermanent
	updateDeleteMessages.FromCache = tempObj.FromCache

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateDeleteMessages *UpdateDeleteMessages) GetUpdateEnum() UpdateEnum {
	return UpdateDeleteMessagesType
}

// UpdateChatAction A message sender activity in the chat has changed
type UpdateChatAction struct {
	tdCommon
	ChatID          int64         `json:"chat_id"`           // Chat identifier
	MessageThreadID int64         `json:"message_thread_id"` // If not 0, the message thread identifier in which the action was performed
	SenderID        MessageSender `json:"sender_id"`         // Identifier of a message sender performing the action
	Action          ChatAction    `json:"action"`            // The action
}

// MessageType return the string telegram-type of UpdateChatAction
func (updateChatAction *UpdateChatAction) MessageType() string {
	return "updateChatAction"
}

// NewUpdateChatAction creates a new UpdateChatAction
//
// @param chatID Chat identifier
// @param messageThreadID If not 0, the message thread identifier in which the action was performed
// @param senderID Identifier of a message sender performing the action
// @param action The action
func NewUpdateChatAction(chatID int64, messageThreadID int64, senderID MessageSender, action ChatAction) *UpdateChatAction {
	updateChatActionTemp := UpdateChatAction{
		tdCommon:        tdCommon{Type: "updateChatAction"},
		ChatID:          chatID,
		MessageThreadID: messageThreadID,
		SenderID:        senderID,
		Action:          action,
	}

	return &updateChatActionTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatAction *UpdateChatAction) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID          int64 `json:"chat_id"`           // Chat identifier
		MessageThreadID int64 `json:"message_thread_id"` // If not 0, the message thread identifier in which the action was performed

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatAction.tdCommon = tempObj.tdCommon
	updateChatAction.ChatID = tempObj.ChatID
	updateChatAction.MessageThreadID = tempObj.MessageThreadID

	fieldSenderID, _ := unmarshalMessageSender(objMap["sender_id"])
	updateChatAction.SenderID = fieldSenderID

	fieldAction, _ := unmarshalChatAction(objMap["action"])
	updateChatAction.Action = fieldAction

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatAction *UpdateChatAction) GetUpdateEnum() UpdateEnum {
	return UpdateChatActionType
}

// UpdateUserStatus The user went online or offline
type UpdateUserStatus struct {
	tdCommon
	UserID int64      `json:"user_id"` // User identifier
	Status UserStatus `json:"status"`  // New status of the user
}

// MessageType return the string telegram-type of UpdateUserStatus
func (updateUserStatus *UpdateUserStatus) MessageType() string {
	return "updateUserStatus"
}

// NewUpdateUserStatus creates a new UpdateUserStatus
//
// @param userID User identifier
// @param status New status of the user
func NewUpdateUserStatus(userID int64, status UserStatus) *UpdateUserStatus {
	updateUserStatusTemp := UpdateUserStatus{
		tdCommon: tdCommon{Type: "updateUserStatus"},
		UserID:   userID,
		Status:   status,
	}

	return &updateUserStatusTemp
}

// UnmarshalJSON unmarshal to json
func (updateUserStatus *UpdateUserStatus) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID int64 `json:"user_id"` // User identifier

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateUserStatus.tdCommon = tempObj.tdCommon
	updateUserStatus.UserID = tempObj.UserID

	fieldStatus, _ := unmarshalUserStatus(objMap["status"])
	updateUserStatus.Status = fieldStatus

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateUserStatus *UpdateUserStatus) GetUpdateEnum() UpdateEnum {
	return UpdateUserStatusType
}

// UpdateUser Some data of a user has changed. This update is guaranteed to come before the user identifier is returned to the application
type UpdateUser struct {
	tdCommon
	User *User `json:"user"` // New data about the user
}

// MessageType return the string telegram-type of UpdateUser
func (updateUser *UpdateUser) MessageType() string {
	return "updateUser"
}

// NewUpdateUser creates a new UpdateUser
//
// @param user New data about the user
func NewUpdateUser(user *User) *UpdateUser {
	updateUserTemp := UpdateUser{
		tdCommon: tdCommon{Type: "updateUser"},
		User:     user,
	}

	return &updateUserTemp
}

// UnmarshalJSON unmarshal to json
func (updateUser *UpdateUser) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateUser.tdCommon = tempObj.tdCommon

	var user User
	if objMap["user"] != nil {
		err = user.UnmarshalJSON(*objMap["user"])
		if err != nil {
			return err
		}
	}

	updateUser.User = &user

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateUser *UpdateUser) GetUpdateEnum() UpdateEnum {
	return UpdateUserType
}

// UpdateBasicGroup Some data of a basic group has changed. This update is guaranteed to come before the basic group identifier is returned to the application
type UpdateBasicGroup struct {
	tdCommon
	BasicGroup *BasicGroup `json:"basic_group"` // New data about the group
}

// MessageType return the string telegram-type of UpdateBasicGroup
func (updateBasicGroup *UpdateBasicGroup) MessageType() string {
	return "updateBasicGroup"
}

// NewUpdateBasicGroup creates a new UpdateBasicGroup
//
// @param basicGroup New data about the group
func NewUpdateBasicGroup(basicGroup *BasicGroup) *UpdateBasicGroup {
	updateBasicGroupTemp := UpdateBasicGroup{
		tdCommon:   tdCommon{Type: "updateBasicGroup"},
		BasicGroup: basicGroup,
	}

	return &updateBasicGroupTemp
}

// UnmarshalJSON unmarshal to json
func (updateBasicGroup *UpdateBasicGroup) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateBasicGroup.tdCommon = tempObj.tdCommon

	var basicGroup BasicGroup
	if objMap["basic_group"] != nil {
		err = basicGroup.UnmarshalJSON(*objMap["basic_group"])
		if err != nil {
			return err
		}
	}

	updateBasicGroup.BasicGroup = &basicGroup

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateBasicGroup *UpdateBasicGroup) GetUpdateEnum() UpdateEnum {
	return UpdateBasicGroupType
}

// UpdateSupergroup Some data of a supergroup or a channel has changed. This update is guaranteed to come before the supergroup identifier is returned to the application
type UpdateSupergroup struct {
	tdCommon
	Supergroup *Supergroup `json:"supergroup"` // New data about the supergroup
}

// MessageType return the string telegram-type of UpdateSupergroup
func (updateSupergroup *UpdateSupergroup) MessageType() string {
	return "updateSupergroup"
}

// NewUpdateSupergroup creates a new UpdateSupergroup
//
// @param supergroup New data about the supergroup
func NewUpdateSupergroup(supergroup *Supergroup) *UpdateSupergroup {
	updateSupergroupTemp := UpdateSupergroup{
		tdCommon:   tdCommon{Type: "updateSupergroup"},
		Supergroup: supergroup,
	}

	return &updateSupergroupTemp
}

// UnmarshalJSON unmarshal to json
func (updateSupergroup *UpdateSupergroup) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateSupergroup.tdCommon = tempObj.tdCommon

	var supergroup Supergroup
	if objMap["supergroup"] != nil {
		err = supergroup.UnmarshalJSON(*objMap["supergroup"])
		if err != nil {
			return err
		}
	}

	updateSupergroup.Supergroup = &supergroup

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateSupergroup *UpdateSupergroup) GetUpdateEnum() UpdateEnum {
	return UpdateSupergroupType
}

// UpdateSecretChat Some data of a secret chat has changed. This update is guaranteed to come before the secret chat identifier is returned to the application
type UpdateSecretChat struct {
	tdCommon
	SecretChat *SecretChat `json:"secret_chat"` // New data about the secret chat
}

// MessageType return the string telegram-type of UpdateSecretChat
func (updateSecretChat *UpdateSecretChat) MessageType() string {
	return "updateSecretChat"
}

// NewUpdateSecretChat creates a new UpdateSecretChat
//
// @param secretChat New data about the secret chat
func NewUpdateSecretChat(secretChat *SecretChat) *UpdateSecretChat {
	updateSecretChatTemp := UpdateSecretChat{
		tdCommon:   tdCommon{Type: "updateSecretChat"},
		SecretChat: secretChat,
	}

	return &updateSecretChatTemp
}

// UnmarshalJSON unmarshal to json
func (updateSecretChat *UpdateSecretChat) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateSecretChat.tdCommon = tempObj.tdCommon

	var secretChat SecretChat
	if objMap["secret_chat"] != nil {
		err = secretChat.UnmarshalJSON(*objMap["secret_chat"])
		if err != nil {
			return err
		}
	}

	updateSecretChat.SecretChat = &secretChat

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateSecretChat *UpdateSecretChat) GetUpdateEnum() UpdateEnum {
	return UpdateSecretChatType
}

// UpdateUserFullInfo Some data in userFullInfo has been changed
type UpdateUserFullInfo struct {
	tdCommon
	UserID       int64         `json:"user_id"`        // User identifier
	UserFullInfo *UserFullInfo `json:"user_full_info"` // New full information about the user
}

// MessageType return the string telegram-type of UpdateUserFullInfo
func (updateUserFullInfo *UpdateUserFullInfo) MessageType() string {
	return "updateUserFullInfo"
}

// NewUpdateUserFullInfo creates a new UpdateUserFullInfo
//
// @param userID User identifier
// @param userFullInfo New full information about the user
func NewUpdateUserFullInfo(userID int64, userFullInfo *UserFullInfo) *UpdateUserFullInfo {
	updateUserFullInfoTemp := UpdateUserFullInfo{
		tdCommon:     tdCommon{Type: "updateUserFullInfo"},
		UserID:       userID,
		UserFullInfo: userFullInfo,
	}

	return &updateUserFullInfoTemp
}

// UnmarshalJSON unmarshal to json
func (updateUserFullInfo *UpdateUserFullInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID int64 `json:"user_id"` // User identifier

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateUserFullInfo.tdCommon = tempObj.tdCommon
	updateUserFullInfo.UserID = tempObj.UserID

	var userFullInfo UserFullInfo
	if objMap["user_full_info"] != nil {
		err = userFullInfo.UnmarshalJSON(*objMap["user_full_info"])
		if err != nil {
			return err
		}
	}

	updateUserFullInfo.UserFullInfo = &userFullInfo

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateUserFullInfo *UpdateUserFullInfo) GetUpdateEnum() UpdateEnum {
	return UpdateUserFullInfoType
}

// UpdateBasicGroupFullInfo Some data in basicGroupFullInfo has been changed
type UpdateBasicGroupFullInfo struct {
	tdCommon
	BasicGroupID       int64               `json:"basic_group_id"`        // Identifier of a basic group
	BasicGroupFullInfo *BasicGroupFullInfo `json:"basic_group_full_info"` // New full information about the group
}

// MessageType return the string telegram-type of UpdateBasicGroupFullInfo
func (updateBasicGroupFullInfo *UpdateBasicGroupFullInfo) MessageType() string {
	return "updateBasicGroupFullInfo"
}

// NewUpdateBasicGroupFullInfo creates a new UpdateBasicGroupFullInfo
//
// @param basicGroupID Identifier of a basic group
// @param basicGroupFullInfo New full information about the group
func NewUpdateBasicGroupFullInfo(basicGroupID int64, basicGroupFullInfo *BasicGroupFullInfo) *UpdateBasicGroupFullInfo {
	updateBasicGroupFullInfoTemp := UpdateBasicGroupFullInfo{
		tdCommon:           tdCommon{Type: "updateBasicGroupFullInfo"},
		BasicGroupID:       basicGroupID,
		BasicGroupFullInfo: basicGroupFullInfo,
	}

	return &updateBasicGroupFullInfoTemp
}

// UnmarshalJSON unmarshal to json
func (updateBasicGroupFullInfo *UpdateBasicGroupFullInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		BasicGroupID       int64               `json:"basic_group_id"`        // Identifier of a basic group
		BasicGroupFullInfo *BasicGroupFullInfo `json:"basic_group_full_info"` // New full information about the group
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateBasicGroupFullInfo.tdCommon = tempObj.tdCommon
	updateBasicGroupFullInfo.BasicGroupID = tempObj.BasicGroupID
	updateBasicGroupFullInfo.BasicGroupFullInfo = tempObj.BasicGroupFullInfo

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateBasicGroupFullInfo *UpdateBasicGroupFullInfo) GetUpdateEnum() UpdateEnum {
	return UpdateBasicGroupFullInfoType
}

// UpdateSupergroupFullInfo Some data in supergroupFullInfo has been changed
type UpdateSupergroupFullInfo struct {
	tdCommon
	SupergroupID       int64               `json:"supergroup_id"`        // Identifier of the supergroup or channel
	SupergroupFullInfo *SupergroupFullInfo `json:"supergroup_full_info"` // New full information about the supergroup
}

// MessageType return the string telegram-type of UpdateSupergroupFullInfo
func (updateSupergroupFullInfo *UpdateSupergroupFullInfo) MessageType() string {
	return "updateSupergroupFullInfo"
}

// NewUpdateSupergroupFullInfo creates a new UpdateSupergroupFullInfo
//
// @param supergroupID Identifier of the supergroup or channel
// @param supergroupFullInfo New full information about the supergroup
func NewUpdateSupergroupFullInfo(supergroupID int64, supergroupFullInfo *SupergroupFullInfo) *UpdateSupergroupFullInfo {
	updateSupergroupFullInfoTemp := UpdateSupergroupFullInfo{
		tdCommon:           tdCommon{Type: "updateSupergroupFullInfo"},
		SupergroupID:       supergroupID,
		SupergroupFullInfo: supergroupFullInfo,
	}

	return &updateSupergroupFullInfoTemp
}

// UnmarshalJSON unmarshal to json
func (updateSupergroupFullInfo *UpdateSupergroupFullInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SupergroupID       int64               `json:"supergroup_id"`        // Identifier of the supergroup or channel
		SupergroupFullInfo *SupergroupFullInfo `json:"supergroup_full_info"` // New full information about the supergroup
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateSupergroupFullInfo.tdCommon = tempObj.tdCommon
	updateSupergroupFullInfo.SupergroupID = tempObj.SupergroupID
	updateSupergroupFullInfo.SupergroupFullInfo = tempObj.SupergroupFullInfo

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateSupergroupFullInfo *UpdateSupergroupFullInfo) GetUpdateEnum() UpdateEnum {
	return UpdateSupergroupFullInfoType
}

// UpdateServiceNotification A service notification from the server was received. Upon receiving this the application must show a popup with the content of the notification
type UpdateServiceNotification struct {
	tdCommon
	Type    string         `json:"type"`    // Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel" and "Log out" must be shown under notification; if user presses the second, all local data must be destroyed using Destroy method
	Content MessageContent `json:"content"` // Notification content
}

// MessageType return the string telegram-type of UpdateServiceNotification
func (updateServiceNotification *UpdateServiceNotification) MessageType() string {
	return "updateServiceNotification"
}

// NewUpdateServiceNotification creates a new UpdateServiceNotification
//
// @param typeParam Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel" and "Log out" must be shown under notification; if user presses the second, all local data must be destroyed using Destroy method
// @param content Notification content
func NewUpdateServiceNotification(typeParam string, content MessageContent) *UpdateServiceNotification {
	updateServiceNotificationTemp := UpdateServiceNotification{
		tdCommon: tdCommon{Type: "updateServiceNotification"},
		Type:     typeParam,
		Content:  content,
	}

	return &updateServiceNotificationTemp
}

// UnmarshalJSON unmarshal to json
func (updateServiceNotification *UpdateServiceNotification) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Type string `json:"type"` // Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel" and "Log out" must be shown under notification; if user presses the second, all local data must be destroyed using Destroy method

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateServiceNotification.tdCommon = tempObj.tdCommon
	updateServiceNotification.Type = tempObj.Type

	fieldContent, _ := unmarshalMessageContent(objMap["content"])
	updateServiceNotification.Content = fieldContent

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateServiceNotification *UpdateServiceNotification) GetUpdateEnum() UpdateEnum {
	return UpdateServiceNotificationType
}

// UpdateFile Information about a file was updated
type UpdateFile struct {
	tdCommon
	File *File `json:"file"` // New data about the file
}

// MessageType return the string telegram-type of UpdateFile
func (updateFile *UpdateFile) MessageType() string {
	return "updateFile"
}

// NewUpdateFile creates a new UpdateFile
//
// @param file New data about the file
func NewUpdateFile(file *File) *UpdateFile {
	updateFileTemp := UpdateFile{
		tdCommon: tdCommon{Type: "updateFile"},
		File:     file,
	}

	return &updateFileTemp
}

// UnmarshalJSON unmarshal to json
func (updateFile *UpdateFile) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		File *File `json:"file"` // New data about the file
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateFile.tdCommon = tempObj.tdCommon
	updateFile.File = tempObj.File

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateFile *UpdateFile) GetUpdateEnum() UpdateEnum {
	return UpdateFileType
}

// UpdateFileGenerationStart The file generation process needs to be started by the application
type UpdateFileGenerationStart struct {
	tdCommon
	GenerationID    JSONInt64 `json:"generation_id"`    // Unique identifier for the generation process
	OriginalPath    string    `json:"original_path"`    // The path to a file from which a new file is generated; may be empty
	DestinationPath string    `json:"destination_path"` // The path to a file that must be created and where the new file is generated
	Conversion      string    `json:"conversion"`       // String specifying the conversion applied to the original file. If conversion is "#url#" than original_path contains an HTTP/HTTPS URL of a file, which must be downloaded by the application
}

// MessageType return the string telegram-type of UpdateFileGenerationStart
func (updateFileGenerationStart *UpdateFileGenerationStart) MessageType() string {
	return "updateFileGenerationStart"
}

// NewUpdateFileGenerationStart creates a new UpdateFileGenerationStart
//
// @param generationID Unique identifier for the generation process
// @param originalPath The path to a file from which a new file is generated; may be empty
// @param destinationPath The path to a file that must be created and where the new file is generated
// @param conversion String specifying the conversion applied to the original file. If conversion is "#url#" than original_path contains an HTTP/HTTPS URL of a file, which must be downloaded by the application
func NewUpdateFileGenerationStart(generationID JSONInt64, originalPath string, destinationPath string, conversion string) *UpdateFileGenerationStart {
	updateFileGenerationStartTemp := UpdateFileGenerationStart{
		tdCommon:        tdCommon{Type: "updateFileGenerationStart"},
		GenerationID:    generationID,
		OriginalPath:    originalPath,
		DestinationPath: destinationPath,
		Conversion:      conversion,
	}

	return &updateFileGenerationStartTemp
}

// UnmarshalJSON unmarshal to json
func (updateFileGenerationStart *UpdateFileGenerationStart) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		GenerationID    JSONInt64 `json:"generation_id"`    // Unique identifier for the generation process
		OriginalPath    string    `json:"original_path"`    // The path to a file from which a new file is generated; may be empty
		DestinationPath string    `json:"destination_path"` // The path to a file that must be created and where the new file is generated
		Conversion      string    `json:"conversion"`       // String specifying the conversion applied to the original file. If conversion is "#url#" than original_path contains an HTTP/HTTPS URL of a file, which must be downloaded by the application
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateFileGenerationStart.tdCommon = tempObj.tdCommon
	updateFileGenerationStart.GenerationID = tempObj.GenerationID
	updateFileGenerationStart.OriginalPath = tempObj.OriginalPath
	updateFileGenerationStart.DestinationPath = tempObj.DestinationPath
	updateFileGenerationStart.Conversion = tempObj.Conversion

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateFileGenerationStart *UpdateFileGenerationStart) GetUpdateEnum() UpdateEnum {
	return UpdateFileGenerationStartType
}

// UpdateFileGenerationStop File generation is no longer needed
type UpdateFileGenerationStop struct {
	tdCommon
	GenerationID JSONInt64 `json:"generation_id"` // Unique identifier for the generation process
}

// MessageType return the string telegram-type of UpdateFileGenerationStop
func (updateFileGenerationStop *UpdateFileGenerationStop) MessageType() string {
	return "updateFileGenerationStop"
}

// NewUpdateFileGenerationStop creates a new UpdateFileGenerationStop
//
// @param generationID Unique identifier for the generation process
func NewUpdateFileGenerationStop(generationID JSONInt64) *UpdateFileGenerationStop {
	updateFileGenerationStopTemp := UpdateFileGenerationStop{
		tdCommon:     tdCommon{Type: "updateFileGenerationStop"},
		GenerationID: generationID,
	}

	return &updateFileGenerationStopTemp
}

// UnmarshalJSON unmarshal to json
func (updateFileGenerationStop *UpdateFileGenerationStop) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		GenerationID JSONInt64 `json:"generation_id"` // Unique identifier for the generation process
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateFileGenerationStop.tdCommon = tempObj.tdCommon
	updateFileGenerationStop.GenerationID = tempObj.GenerationID

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateFileGenerationStop *UpdateFileGenerationStop) GetUpdateEnum() UpdateEnum {
	return UpdateFileGenerationStopType
}

// UpdateFileDownloads The state of the file download list has changed
type UpdateFileDownloads struct {
	tdCommon
	TotalSize      int64 `json:"total_size"`      // Total size of files in the file download list, in bytes
	TotalCount     int32 `json:"total_count"`     // Total number of files in the file download list
	DownloadedSize int64 `json:"downloaded_size"` // Total downloaded size of files in the file download list, in bytes
}

// MessageType return the string telegram-type of UpdateFileDownloads
func (updateFileDownloads *UpdateFileDownloads) MessageType() string {
	return "updateFileDownloads"
}

// NewUpdateFileDownloads creates a new UpdateFileDownloads
//
// @param totalSize Total size of files in the file download list, in bytes
// @param totalCount Total number of files in the file download list
// @param downloadedSize Total downloaded size of files in the file download list, in bytes
func NewUpdateFileDownloads(totalSize int64, totalCount int32, downloadedSize int64) *UpdateFileDownloads {
	updateFileDownloadsTemp := UpdateFileDownloads{
		tdCommon:       tdCommon{Type: "updateFileDownloads"},
		TotalSize:      totalSize,
		TotalCount:     totalCount,
		DownloadedSize: downloadedSize,
	}

	return &updateFileDownloadsTemp
}

// UnmarshalJSON unmarshal to json
func (updateFileDownloads *UpdateFileDownloads) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalSize      int64 `json:"total_size"`      // Total size of files in the file download list, in bytes
		TotalCount     int32 `json:"total_count"`     // Total number of files in the file download list
		DownloadedSize int64 `json:"downloaded_size"` // Total downloaded size of files in the file download list, in bytes
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateFileDownloads.tdCommon = tempObj.tdCommon
	updateFileDownloads.TotalSize = tempObj.TotalSize
	updateFileDownloads.TotalCount = tempObj.TotalCount
	updateFileDownloads.DownloadedSize = tempObj.DownloadedSize

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateFileDownloads *UpdateFileDownloads) GetUpdateEnum() UpdateEnum {
	return UpdateFileDownloadsType
}

// UpdateFileAddedToDownloads A file was added to the file download list. This update is sent only after file download list is loaded for the first time
type UpdateFileAddedToDownloads struct {
	tdCommon
	FileDownload *FileDownload         `json:"file_download"` // The added file download
	Counts       *DownloadedFileCounts `json:"counts"`        // New number of being downloaded and recently downloaded files found
}

// MessageType return the string telegram-type of UpdateFileAddedToDownloads
func (updateFileAddedToDownloads *UpdateFileAddedToDownloads) MessageType() string {
	return "updateFileAddedToDownloads"
}

// NewUpdateFileAddedToDownloads creates a new UpdateFileAddedToDownloads
//
// @param fileDownload The added file download
// @param counts New number of being downloaded and recently downloaded files found
func NewUpdateFileAddedToDownloads(fileDownload *FileDownload, counts *DownloadedFileCounts) *UpdateFileAddedToDownloads {
	updateFileAddedToDownloadsTemp := UpdateFileAddedToDownloads{
		tdCommon:     tdCommon{Type: "updateFileAddedToDownloads"},
		FileDownload: fileDownload,
		Counts:       counts,
	}

	return &updateFileAddedToDownloadsTemp
}

// UnmarshalJSON unmarshal to json
func (updateFileAddedToDownloads *UpdateFileAddedToDownloads) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		FileDownload *FileDownload         `json:"file_download"` // The added file download
		Counts       *DownloadedFileCounts `json:"counts"`        // New number of being downloaded and recently downloaded files found
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateFileAddedToDownloads.tdCommon = tempObj.tdCommon
	updateFileAddedToDownloads.FileDownload = tempObj.FileDownload
	updateFileAddedToDownloads.Counts = tempObj.Counts

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateFileAddedToDownloads *UpdateFileAddedToDownloads) GetUpdateEnum() UpdateEnum {
	return UpdateFileAddedToDownloadsType
}

// UpdateFileDownload A file download was changed. This update is sent only after file download list is loaded for the first time
type UpdateFileDownload struct {
	tdCommon
	FileID       int32                 `json:"file_id"`       // File identifier
	CompleteDate int32                 `json:"complete_date"` // Point in time (Unix timestamp) when the file downloading was completed; 0 if the file downloading isn't completed
	IsPaused     bool                  `json:"is_paused"`     // True, if downloading of the file is paused
	Counts       *DownloadedFileCounts `json:"counts"`        // New number of being downloaded and recently downloaded files found
}

// MessageType return the string telegram-type of UpdateFileDownload
func (updateFileDownload *UpdateFileDownload) MessageType() string {
	return "updateFileDownload"
}

// NewUpdateFileDownload creates a new UpdateFileDownload
//
// @param fileID File identifier
// @param completeDate Point in time (Unix timestamp) when the file downloading was completed; 0 if the file downloading isn't completed
// @param isPaused True, if downloading of the file is paused
// @param counts New number of being downloaded and recently downloaded files found
func NewUpdateFileDownload(fileID int32, completeDate int32, isPaused bool, counts *DownloadedFileCounts) *UpdateFileDownload {
	updateFileDownloadTemp := UpdateFileDownload{
		tdCommon:     tdCommon{Type: "updateFileDownload"},
		FileID:       fileID,
		CompleteDate: completeDate,
		IsPaused:     isPaused,
		Counts:       counts,
	}

	return &updateFileDownloadTemp
}

// UnmarshalJSON unmarshal to json
func (updateFileDownload *UpdateFileDownload) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		FileID       int32                 `json:"file_id"`       // File identifier
		CompleteDate int32                 `json:"complete_date"` // Point in time (Unix timestamp) when the file downloading was completed; 0 if the file downloading isn't completed
		IsPaused     bool                  `json:"is_paused"`     // True, if downloading of the file is paused
		Counts       *DownloadedFileCounts `json:"counts"`        // New number of being downloaded and recently downloaded files found
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateFileDownload.tdCommon = tempObj.tdCommon
	updateFileDownload.FileID = tempObj.FileID
	updateFileDownload.CompleteDate = tempObj.CompleteDate
	updateFileDownload.IsPaused = tempObj.IsPaused
	updateFileDownload.Counts = tempObj.Counts

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateFileDownload *UpdateFileDownload) GetUpdateEnum() UpdateEnum {
	return UpdateFileDownloadType
}

// UpdateFileRemovedFromDownloads A file was removed from the file download list. This update is sent only after file download list is loaded for the first time
type UpdateFileRemovedFromDownloads struct {
	tdCommon
	FileID int32                 `json:"file_id"` // File identifier
	Counts *DownloadedFileCounts `json:"counts"`  // New number of being downloaded and recently downloaded files found
}

// MessageType return the string telegram-type of UpdateFileRemovedFromDownloads
func (updateFileRemovedFromDownloads *UpdateFileRemovedFromDownloads) MessageType() string {
	return "updateFileRemovedFromDownloads"
}

// NewUpdateFileRemovedFromDownloads creates a new UpdateFileRemovedFromDownloads
//
// @param fileID File identifier
// @param counts New number of being downloaded and recently downloaded files found
func NewUpdateFileRemovedFromDownloads(fileID int32, counts *DownloadedFileCounts) *UpdateFileRemovedFromDownloads {
	updateFileRemovedFromDownloadsTemp := UpdateFileRemovedFromDownloads{
		tdCommon: tdCommon{Type: "updateFileRemovedFromDownloads"},
		FileID:   fileID,
		Counts:   counts,
	}

	return &updateFileRemovedFromDownloadsTemp
}

// UnmarshalJSON unmarshal to json
func (updateFileRemovedFromDownloads *UpdateFileRemovedFromDownloads) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		FileID int32                 `json:"file_id"` // File identifier
		Counts *DownloadedFileCounts `json:"counts"`  // New number of being downloaded and recently downloaded files found
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateFileRemovedFromDownloads.tdCommon = tempObj.tdCommon
	updateFileRemovedFromDownloads.FileID = tempObj.FileID
	updateFileRemovedFromDownloads.Counts = tempObj.Counts

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateFileRemovedFromDownloads *UpdateFileRemovedFromDownloads) GetUpdateEnum() UpdateEnum {
	return UpdateFileRemovedFromDownloadsType
}

// UpdateApplicationVerificationRequired A request can't be completed unless application verification is performed; for official mobile applications only. The method setApplicationVerificationToken must be called once the verification is completed or failed
type UpdateApplicationVerificationRequired struct {
	tdCommon
	VerificationID     int64     `json:"verification_id"`      // Unique identifier for the verification process
	Nonce              string    `json:"nonce"`                // Unique base64url-encoded nonce for the classic Play Integrity verification (https://developer.android.com/google/play/integrity/classic) for Android, or a unique string to compare with verify_nonce field from a push notification for iOS
	CloudProjectNumber JSONInt64 `json:"cloud_project_number"` // Cloud project number to pass to the Play Integrity API on Android
}

// MessageType return the string telegram-type of UpdateApplicationVerificationRequired
func (updateApplicationVerificationRequired *UpdateApplicationVerificationRequired) MessageType() string {
	return "updateApplicationVerificationRequired"
}

// NewUpdateApplicationVerificationRequired creates a new UpdateApplicationVerificationRequired
//
// @param verificationID Unique identifier for the verification process
// @param nonce Unique base64url-encoded nonce for the classic Play Integrity verification (https://developer.android.com/google/play/integrity/classic) for Android, or a unique string to compare with verify_nonce field from a push notification for iOS
// @param cloudProjectNumber Cloud project number to pass to the Play Integrity API on Android
func NewUpdateApplicationVerificationRequired(verificationID int64, nonce string, cloudProjectNumber JSONInt64) *UpdateApplicationVerificationRequired {
	updateApplicationVerificationRequiredTemp := UpdateApplicationVerificationRequired{
		tdCommon:           tdCommon{Type: "updateApplicationVerificationRequired"},
		VerificationID:     verificationID,
		Nonce:              nonce,
		CloudProjectNumber: cloudProjectNumber,
	}

	return &updateApplicationVerificationRequiredTemp
}

// UnmarshalJSON unmarshal to json
func (updateApplicationVerificationRequired *UpdateApplicationVerificationRequired) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		VerificationID     int64     `json:"verification_id"`      // Unique identifier for the verification process
		Nonce              string    `json:"nonce"`                // Unique base64url-encoded nonce for the classic Play Integrity verification (https://developer.android.com/google/play/integrity/classic) for Android, or a unique string to compare with verify_nonce field from a push notification for iOS
		CloudProjectNumber JSONInt64 `json:"cloud_project_number"` // Cloud project number to pass to the Play Integrity API on Android
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateApplicationVerificationRequired.tdCommon = tempObj.tdCommon
	updateApplicationVerificationRequired.VerificationID = tempObj.VerificationID
	updateApplicationVerificationRequired.Nonce = tempObj.Nonce
	updateApplicationVerificationRequired.CloudProjectNumber = tempObj.CloudProjectNumber

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateApplicationVerificationRequired *UpdateApplicationVerificationRequired) GetUpdateEnum() UpdateEnum {
	return UpdateApplicationVerificationRequiredType
}

// UpdateCall New call was created or information about a call was updated
type UpdateCall struct {
	tdCommon
	Call *Call `json:"call"` // New data about a call
}

// MessageType return the string telegram-type of UpdateCall
func (updateCall *UpdateCall) MessageType() string {
	return "updateCall"
}

// NewUpdateCall creates a new UpdateCall
//
// @param call New data about a call
func NewUpdateCall(call *Call) *UpdateCall {
	updateCallTemp := UpdateCall{
		tdCommon: tdCommon{Type: "updateCall"},
		Call:     call,
	}

	return &updateCallTemp
}

// UnmarshalJSON unmarshal to json
func (updateCall *UpdateCall) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateCall.tdCommon = tempObj.tdCommon

	var call Call
	if objMap["call"] != nil {
		err = call.UnmarshalJSON(*objMap["call"])
		if err != nil {
			return err
		}
	}

	updateCall.Call = &call

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateCall *UpdateCall) GetUpdateEnum() UpdateEnum {
	return UpdateCallType
}

// UpdateGroupCall Information about a group call was updated
type UpdateGroupCall struct {
	tdCommon
	GroupCall *GroupCall `json:"group_call"` // New data about a group call
}

// MessageType return the string telegram-type of UpdateGroupCall
func (updateGroupCall *UpdateGroupCall) MessageType() string {
	return "updateGroupCall"
}

// NewUpdateGroupCall creates a new UpdateGroupCall
//
// @param groupCall New data about a group call
func NewUpdateGroupCall(groupCall *GroupCall) *UpdateGroupCall {
	updateGroupCallTemp := UpdateGroupCall{
		tdCommon:  tdCommon{Type: "updateGroupCall"},
		GroupCall: groupCall,
	}

	return &updateGroupCallTemp
}

// UnmarshalJSON unmarshal to json
func (updateGroupCall *UpdateGroupCall) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		GroupCall *GroupCall `json:"group_call"` // New data about a group call
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateGroupCall.tdCommon = tempObj.tdCommon
	updateGroupCall.GroupCall = tempObj.GroupCall

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateGroupCall *UpdateGroupCall) GetUpdateEnum() UpdateEnum {
	return UpdateGroupCallType
}

// UpdateGroupCallParticipant Information about a group call participant was changed. The updates are sent only after the group call is received through getGroupCall and only if the call is joined or being joined
type UpdateGroupCallParticipant struct {
	tdCommon
	GroupCallID int32                 `json:"group_call_id"` // Identifier of group call
	Participant *GroupCallParticipant `json:"participant"`   // New data about a participant
}

// MessageType return the string telegram-type of UpdateGroupCallParticipant
func (updateGroupCallParticipant *UpdateGroupCallParticipant) MessageType() string {
	return "updateGroupCallParticipant"
}

// NewUpdateGroupCallParticipant creates a new UpdateGroupCallParticipant
//
// @param groupCallID Identifier of group call
// @param participant New data about a participant
func NewUpdateGroupCallParticipant(groupCallID int32, participant *GroupCallParticipant) *UpdateGroupCallParticipant {
	updateGroupCallParticipantTemp := UpdateGroupCallParticipant{
		tdCommon:    tdCommon{Type: "updateGroupCallParticipant"},
		GroupCallID: groupCallID,
		Participant: participant,
	}

	return &updateGroupCallParticipantTemp
}

// UnmarshalJSON unmarshal to json
func (updateGroupCallParticipant *UpdateGroupCallParticipant) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		GroupCallID int32 `json:"group_call_id"` // Identifier of group call

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateGroupCallParticipant.tdCommon = tempObj.tdCommon
	updateGroupCallParticipant.GroupCallID = tempObj.GroupCallID

	var participant GroupCallParticipant
	if objMap["participant"] != nil {
		err = participant.UnmarshalJSON(*objMap["participant"])
		if err != nil {
			return err
		}
	}

	updateGroupCallParticipant.Participant = &participant

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateGroupCallParticipant *UpdateGroupCallParticipant) GetUpdateEnum() UpdateEnum {
	return UpdateGroupCallParticipantType
}

// UpdateNewCallSignalingData New call signaling data arrived
type UpdateNewCallSignalingData struct {
	tdCommon
	CallID int32  `json:"call_id"` // The call identifier
	Data   []byte `json:"data"`    // The data
}

// MessageType return the string telegram-type of UpdateNewCallSignalingData
func (updateNewCallSignalingData *UpdateNewCallSignalingData) MessageType() string {
	return "updateNewCallSignalingData"
}

// NewUpdateNewCallSignalingData creates a new UpdateNewCallSignalingData
//
// @param callID The call identifier
// @param data The data
func NewUpdateNewCallSignalingData(callID int32, data []byte) *UpdateNewCallSignalingData {
	updateNewCallSignalingDataTemp := UpdateNewCallSignalingData{
		tdCommon: tdCommon{Type: "updateNewCallSignalingData"},
		CallID:   callID,
		Data:     data,
	}

	return &updateNewCallSignalingDataTemp
}

// UnmarshalJSON unmarshal to json
func (updateNewCallSignalingData *UpdateNewCallSignalingData) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CallID int32  `json:"call_id"` // The call identifier
		Data   []byte `json:"data"`    // The data
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateNewCallSignalingData.tdCommon = tempObj.tdCommon
	updateNewCallSignalingData.CallID = tempObj.CallID
	updateNewCallSignalingData.Data = tempObj.Data

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateNewCallSignalingData *UpdateNewCallSignalingData) GetUpdateEnum() UpdateEnum {
	return UpdateNewCallSignalingDataType
}

// UpdateUserPrivacySettingRules Some privacy setting rules have been changed
type UpdateUserPrivacySettingRules struct {
	tdCommon
	Setting UserPrivacySetting       `json:"setting"` // The privacy setting
	Rules   *UserPrivacySettingRules `json:"rules"`   // New privacy rules
}

// MessageType return the string telegram-type of UpdateUserPrivacySettingRules
func (updateUserPrivacySettingRules *UpdateUserPrivacySettingRules) MessageType() string {
	return "updateUserPrivacySettingRules"
}

// NewUpdateUserPrivacySettingRules creates a new UpdateUserPrivacySettingRules
//
// @param setting The privacy setting
// @param rules New privacy rules
func NewUpdateUserPrivacySettingRules(setting UserPrivacySetting, rules *UserPrivacySettingRules) *UpdateUserPrivacySettingRules {
	updateUserPrivacySettingRulesTemp := UpdateUserPrivacySettingRules{
		tdCommon: tdCommon{Type: "updateUserPrivacySettingRules"},
		Setting:  setting,
		Rules:    rules,
	}

	return &updateUserPrivacySettingRulesTemp
}

// UnmarshalJSON unmarshal to json
func (updateUserPrivacySettingRules *UpdateUserPrivacySettingRules) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateUserPrivacySettingRules.tdCommon = tempObj.tdCommon

	fieldSetting, _ := unmarshalUserPrivacySetting(objMap["setting"])
	updateUserPrivacySettingRules.Setting = fieldSetting

	var rules UserPrivacySettingRules
	if objMap["rules"] != nil {
		err = rules.UnmarshalJSON(*objMap["rules"])
		if err != nil {
			return err
		}
	}

	updateUserPrivacySettingRules.Rules = &rules

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateUserPrivacySettingRules *UpdateUserPrivacySettingRules) GetUpdateEnum() UpdateEnum {
	return UpdateUserPrivacySettingRulesType
}

// UpdateUnreadMessageCount Number of unread messages in a chat list has changed. This update is sent only if the message database is used
type UpdateUnreadMessageCount struct {
	tdCommon
	ChatList           ChatList `json:"chat_list"`            // The chat list with changed number of unread messages
	UnreadCount        int32    `json:"unread_count"`         // Total number of unread messages
	UnreadUnmutedCount int32    `json:"unread_unmuted_count"` // Total number of unread messages in unmuted chats
}

// MessageType return the string telegram-type of UpdateUnreadMessageCount
func (updateUnreadMessageCount *UpdateUnreadMessageCount) MessageType() string {
	return "updateUnreadMessageCount"
}

// NewUpdateUnreadMessageCount creates a new UpdateUnreadMessageCount
//
// @param chatList The chat list with changed number of unread messages
// @param unreadCount Total number of unread messages
// @param unreadUnmutedCount Total number of unread messages in unmuted chats
func NewUpdateUnreadMessageCount(chatList ChatList, unreadCount int32, unreadUnmutedCount int32) *UpdateUnreadMessageCount {
	updateUnreadMessageCountTemp := UpdateUnreadMessageCount{
		tdCommon:           tdCommon{Type: "updateUnreadMessageCount"},
		ChatList:           chatList,
		UnreadCount:        unreadCount,
		UnreadUnmutedCount: unreadUnmutedCount,
	}

	return &updateUnreadMessageCountTemp
}

// UnmarshalJSON unmarshal to json
func (updateUnreadMessageCount *UpdateUnreadMessageCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UnreadCount        int32 `json:"unread_count"`         // Total number of unread messages
		UnreadUnmutedCount int32 `json:"unread_unmuted_count"` // Total number of unread messages in unmuted chats
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateUnreadMessageCount.tdCommon = tempObj.tdCommon
	updateUnreadMessageCount.UnreadCount = tempObj.UnreadCount
	updateUnreadMessageCount.UnreadUnmutedCount = tempObj.UnreadUnmutedCount

	fieldChatList, _ := unmarshalChatList(objMap["chat_list"])
	updateUnreadMessageCount.ChatList = fieldChatList

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateUnreadMessageCount *UpdateUnreadMessageCount) GetUpdateEnum() UpdateEnum {
	return UpdateUnreadMessageCountType
}

// UpdateUnreadChatCount Number of unread chats, i.e. with unread messages or marked as unread, has changed. This update is sent only if the message database is used
type UpdateUnreadChatCount struct {
	tdCommon
	ChatList                   ChatList `json:"chat_list"`                      // The chat list with changed number of unread messages
	TotalCount                 int32    `json:"total_count"`                    // Approximate total number of chats in the chat list
	UnreadCount                int32    `json:"unread_count"`                   // Total number of unread chats
	UnreadUnmutedCount         int32    `json:"unread_unmuted_count"`           // Total number of unread unmuted chats
	MarkedAsUnreadCount        int32    `json:"marked_as_unread_count"`         // Total number of chats marked as unread
	MarkedAsUnreadUnmutedCount int32    `json:"marked_as_unread_unmuted_count"` // Total number of unmuted chats marked as unread
}

// MessageType return the string telegram-type of UpdateUnreadChatCount
func (updateUnreadChatCount *UpdateUnreadChatCount) MessageType() string {
	return "updateUnreadChatCount"
}

// NewUpdateUnreadChatCount creates a new UpdateUnreadChatCount
//
// @param chatList The chat list with changed number of unread messages
// @param totalCount Approximate total number of chats in the chat list
// @param unreadCount Total number of unread chats
// @param unreadUnmutedCount Total number of unread unmuted chats
// @param markedAsUnreadCount Total number of chats marked as unread
// @param markedAsUnreadUnmutedCount Total number of unmuted chats marked as unread
func NewUpdateUnreadChatCount(chatList ChatList, totalCount int32, unreadCount int32, unreadUnmutedCount int32, markedAsUnreadCount int32, markedAsUnreadUnmutedCount int32) *UpdateUnreadChatCount {
	updateUnreadChatCountTemp := UpdateUnreadChatCount{
		tdCommon:                   tdCommon{Type: "updateUnreadChatCount"},
		ChatList:                   chatList,
		TotalCount:                 totalCount,
		UnreadCount:                unreadCount,
		UnreadUnmutedCount:         unreadUnmutedCount,
		MarkedAsUnreadCount:        markedAsUnreadCount,
		MarkedAsUnreadUnmutedCount: markedAsUnreadUnmutedCount,
	}

	return &updateUnreadChatCountTemp
}

// UnmarshalJSON unmarshal to json
func (updateUnreadChatCount *UpdateUnreadChatCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TotalCount                 int32 `json:"total_count"`                    // Approximate total number of chats in the chat list
		UnreadCount                int32 `json:"unread_count"`                   // Total number of unread chats
		UnreadUnmutedCount         int32 `json:"unread_unmuted_count"`           // Total number of unread unmuted chats
		MarkedAsUnreadCount        int32 `json:"marked_as_unread_count"`         // Total number of chats marked as unread
		MarkedAsUnreadUnmutedCount int32 `json:"marked_as_unread_unmuted_count"` // Total number of unmuted chats marked as unread
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateUnreadChatCount.tdCommon = tempObj.tdCommon
	updateUnreadChatCount.TotalCount = tempObj.TotalCount
	updateUnreadChatCount.UnreadCount = tempObj.UnreadCount
	updateUnreadChatCount.UnreadUnmutedCount = tempObj.UnreadUnmutedCount
	updateUnreadChatCount.MarkedAsUnreadCount = tempObj.MarkedAsUnreadCount
	updateUnreadChatCount.MarkedAsUnreadUnmutedCount = tempObj.MarkedAsUnreadUnmutedCount

	fieldChatList, _ := unmarshalChatList(objMap["chat_list"])
	updateUnreadChatCount.ChatList = fieldChatList

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateUnreadChatCount *UpdateUnreadChatCount) GetUpdateEnum() UpdateEnum {
	return UpdateUnreadChatCountType
}

// UpdateStory A story was changed
type UpdateStory struct {
	tdCommon
	Story *Story `json:"story"` // The new information about the story
}

// MessageType return the string telegram-type of UpdateStory
func (updateStory *UpdateStory) MessageType() string {
	return "updateStory"
}

// NewUpdateStory creates a new UpdateStory
//
// @param story The new information about the story
func NewUpdateStory(story *Story) *UpdateStory {
	updateStoryTemp := UpdateStory{
		tdCommon: tdCommon{Type: "updateStory"},
		Story:    story,
	}

	return &updateStoryTemp
}

// UnmarshalJSON unmarshal to json
func (updateStory *UpdateStory) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateStory.tdCommon = tempObj.tdCommon

	var story Story
	if objMap["story"] != nil {
		err = story.UnmarshalJSON(*objMap["story"])
		if err != nil {
			return err
		}
	}

	updateStory.Story = &story

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateStory *UpdateStory) GetUpdateEnum() UpdateEnum {
	return UpdateStoryType
}

// UpdateStoryDeleted A story became inaccessible
type UpdateStoryDeleted struct {
	tdCommon
	StorySenderChatID int64 `json:"story_sender_chat_id"` // Identifier of the chat that posted the story
	StoryID           int32 `json:"story_id"`             // Story identifier
}

// MessageType return the string telegram-type of UpdateStoryDeleted
func (updateStoryDeleted *UpdateStoryDeleted) MessageType() string {
	return "updateStoryDeleted"
}

// NewUpdateStoryDeleted creates a new UpdateStoryDeleted
//
// @param storySenderChatID Identifier of the chat that posted the story
// @param storyID Story identifier
func NewUpdateStoryDeleted(storySenderChatID int64, storyID int32) *UpdateStoryDeleted {
	updateStoryDeletedTemp := UpdateStoryDeleted{
		tdCommon:          tdCommon{Type: "updateStoryDeleted"},
		StorySenderChatID: storySenderChatID,
		StoryID:           storyID,
	}

	return &updateStoryDeletedTemp
}

// UnmarshalJSON unmarshal to json
func (updateStoryDeleted *UpdateStoryDeleted) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StorySenderChatID int64 `json:"story_sender_chat_id"` // Identifier of the chat that posted the story
		StoryID           int32 `json:"story_id"`             // Story identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateStoryDeleted.tdCommon = tempObj.tdCommon
	updateStoryDeleted.StorySenderChatID = tempObj.StorySenderChatID
	updateStoryDeleted.StoryID = tempObj.StoryID

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateStoryDeleted *UpdateStoryDeleted) GetUpdateEnum() UpdateEnum {
	return UpdateStoryDeletedType
}

// UpdateStorySendSucceeded A story has been successfully sent
type UpdateStorySendSucceeded struct {
	tdCommon
	Story      *Story `json:"story"`        // The sent story
	OldStoryID int32  `json:"old_story_id"` // The previous temporary story identifier
}

// MessageType return the string telegram-type of UpdateStorySendSucceeded
func (updateStorySendSucceeded *UpdateStorySendSucceeded) MessageType() string {
	return "updateStorySendSucceeded"
}

// NewUpdateStorySendSucceeded creates a new UpdateStorySendSucceeded
//
// @param story The sent story
// @param oldStoryID The previous temporary story identifier
func NewUpdateStorySendSucceeded(story *Story, oldStoryID int32) *UpdateStorySendSucceeded {
	updateStorySendSucceededTemp := UpdateStorySendSucceeded{
		tdCommon:   tdCommon{Type: "updateStorySendSucceeded"},
		Story:      story,
		OldStoryID: oldStoryID,
	}

	return &updateStorySendSucceededTemp
}

// UnmarshalJSON unmarshal to json
func (updateStorySendSucceeded *UpdateStorySendSucceeded) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		OldStoryID int32 `json:"old_story_id"` // The previous temporary story identifier
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateStorySendSucceeded.tdCommon = tempObj.tdCommon
	updateStorySendSucceeded.OldStoryID = tempObj.OldStoryID

	var story Story
	if objMap["story"] != nil {
		err = story.UnmarshalJSON(*objMap["story"])
		if err != nil {
			return err
		}
	}

	updateStorySendSucceeded.Story = &story

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateStorySendSucceeded *UpdateStorySendSucceeded) GetUpdateEnum() UpdateEnum {
	return UpdateStorySendSucceededType
}

// UpdateStorySendFailed A story failed to send. If the story sending is canceled, then updateStoryDeleted will be received instead of this update
type UpdateStorySendFailed struct {
	tdCommon
	Story     *Story              `json:"story"`      // The failed to send story
	Error     *Error              `json:"error"`      // The cause of the story sending failure
	ErrorType *CanSendStoryResult `json:"error_type"` // Type of the error; may be null if unknown
}

// MessageType return the string telegram-type of UpdateStorySendFailed
func (updateStorySendFailed *UpdateStorySendFailed) MessageType() string {
	return "updateStorySendFailed"
}

// NewUpdateStorySendFailed creates a new UpdateStorySendFailed
//
// @param story The failed to send story
// @param errParam The cause of the story sending failure
// @param errParamType Type of the error; may be null if unknown
func NewUpdateStorySendFailed(story *Story, errParam *Error, errParamType *CanSendStoryResult) *UpdateStorySendFailed {
	updateStorySendFailedTemp := UpdateStorySendFailed{
		tdCommon:  tdCommon{Type: "updateStorySendFailed"},
		Story:     story,
		Error:     errParam,
		ErrorType: errParamType,
	}

	return &updateStorySendFailedTemp
}

// UnmarshalJSON unmarshal to json
func (updateStorySendFailed *UpdateStorySendFailed) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Error *Error `json:"error"` // The cause of the story sending failure

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateStorySendFailed.tdCommon = tempObj.tdCommon
	updateStorySendFailed.Error = tempObj.Error

	fieldErrorType, _ := unmarshalCanSendStoryResult(objMap["error_type"])
	updateStorySendFailed.ErrorType = &fieldErrorType

	var story Story
	if objMap["story"] != nil {
		err = story.UnmarshalJSON(*objMap["story"])
		if err != nil {
			return err
		}
	}

	updateStorySendFailed.Story = &story

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateStorySendFailed *UpdateStorySendFailed) GetUpdateEnum() UpdateEnum {
	return UpdateStorySendFailedType
}

// UpdateChatActiveStories The list of active stories posted by a specific chat has changed
type UpdateChatActiveStories struct {
	tdCommon
	ActiveStories *ChatActiveStories `json:"active_stories"` // The new list of active stories
}

// MessageType return the string telegram-type of UpdateChatActiveStories
func (updateChatActiveStories *UpdateChatActiveStories) MessageType() string {
	return "updateChatActiveStories"
}

// NewUpdateChatActiveStories creates a new UpdateChatActiveStories
//
// @param activeStories The new list of active stories
func NewUpdateChatActiveStories(activeStories *ChatActiveStories) *UpdateChatActiveStories {
	updateChatActiveStoriesTemp := UpdateChatActiveStories{
		tdCommon:      tdCommon{Type: "updateChatActiveStories"},
		ActiveStories: activeStories,
	}

	return &updateChatActiveStoriesTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatActiveStories *UpdateChatActiveStories) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatActiveStories.tdCommon = tempObj.tdCommon

	var activeStories ChatActiveStories
	if objMap["active_stories"] != nil {
		err = activeStories.UnmarshalJSON(*objMap["active_stories"])
		if err != nil {
			return err
		}
	}

	updateChatActiveStories.ActiveStories = &activeStories

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatActiveStories *UpdateChatActiveStories) GetUpdateEnum() UpdateEnum {
	return UpdateChatActiveStoriesType
}

// UpdateStoryListChatCount Number of chats in a story list has changed
type UpdateStoryListChatCount struct {
	tdCommon
	StoryList StoryList `json:"story_list"` // The story list
	ChatCount int32     `json:"chat_count"` // Approximate total number of chats with active stories in the list
}

// MessageType return the string telegram-type of UpdateStoryListChatCount
func (updateStoryListChatCount *UpdateStoryListChatCount) MessageType() string {
	return "updateStoryListChatCount"
}

// NewUpdateStoryListChatCount creates a new UpdateStoryListChatCount
//
// @param storyList The story list
// @param chatCount Approximate total number of chats with active stories in the list
func NewUpdateStoryListChatCount(storyList StoryList, chatCount int32) *UpdateStoryListChatCount {
	updateStoryListChatCountTemp := UpdateStoryListChatCount{
		tdCommon:  tdCommon{Type: "updateStoryListChatCount"},
		StoryList: storyList,
		ChatCount: chatCount,
	}

	return &updateStoryListChatCountTemp
}

// UnmarshalJSON unmarshal to json
func (updateStoryListChatCount *UpdateStoryListChatCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatCount int32 `json:"chat_count"` // Approximate total number of chats with active stories in the list
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateStoryListChatCount.tdCommon = tempObj.tdCommon
	updateStoryListChatCount.ChatCount = tempObj.ChatCount

	fieldStoryList, _ := unmarshalStoryList(objMap["story_list"])
	updateStoryListChatCount.StoryList = fieldStoryList

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateStoryListChatCount *UpdateStoryListChatCount) GetUpdateEnum() UpdateEnum {
	return UpdateStoryListChatCountType
}

// UpdateStoryStealthMode Story stealth mode settings have changed
type UpdateStoryStealthMode struct {
	tdCommon
	ActiveUntilDate   int32 `json:"active_until_date"`   // Point in time (Unix timestamp) until stealth mode is active; 0 if it is disabled
	CooldownUntilDate int32 `json:"cooldown_until_date"` // Point in time (Unix timestamp) when stealth mode can be enabled again; 0 if there is no active cooldown
}

// MessageType return the string telegram-type of UpdateStoryStealthMode
func (updateStoryStealthMode *UpdateStoryStealthMode) MessageType() string {
	return "updateStoryStealthMode"
}

// NewUpdateStoryStealthMode creates a new UpdateStoryStealthMode
//
// @param activeUntilDate Point in time (Unix timestamp) until stealth mode is active; 0 if it is disabled
// @param cooldownUntilDate Point in time (Unix timestamp) when stealth mode can be enabled again; 0 if there is no active cooldown
func NewUpdateStoryStealthMode(activeUntilDate int32, cooldownUntilDate int32) *UpdateStoryStealthMode {
	updateStoryStealthModeTemp := UpdateStoryStealthMode{
		tdCommon:          tdCommon{Type: "updateStoryStealthMode"},
		ActiveUntilDate:   activeUntilDate,
		CooldownUntilDate: cooldownUntilDate,
	}

	return &updateStoryStealthModeTemp
}

// UnmarshalJSON unmarshal to json
func (updateStoryStealthMode *UpdateStoryStealthMode) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ActiveUntilDate   int32 `json:"active_until_date"`   // Point in time (Unix timestamp) until stealth mode is active; 0 if it is disabled
		CooldownUntilDate int32 `json:"cooldown_until_date"` // Point in time (Unix timestamp) when stealth mode can be enabled again; 0 if there is no active cooldown
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateStoryStealthMode.tdCommon = tempObj.tdCommon
	updateStoryStealthMode.ActiveUntilDate = tempObj.ActiveUntilDate
	updateStoryStealthMode.CooldownUntilDate = tempObj.CooldownUntilDate

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateStoryStealthMode *UpdateStoryStealthMode) GetUpdateEnum() UpdateEnum {
	return UpdateStoryStealthModeType
}

// UpdateOption An option changed its value
type UpdateOption struct {
	tdCommon
	Name  string      `json:"name"`  // The option name
	Value OptionValue `json:"value"` // The new option value
}

// MessageType return the string telegram-type of UpdateOption
func (updateOption *UpdateOption) MessageType() string {
	return "updateOption"
}

// NewUpdateOption creates a new UpdateOption
//
// @param name The option name
// @param value The new option value
func NewUpdateOption(name string, value OptionValue) *UpdateOption {
	updateOptionTemp := UpdateOption{
		tdCommon: tdCommon{Type: "updateOption"},
		Name:     name,
		Value:    value,
	}

	return &updateOptionTemp
}

// UnmarshalJSON unmarshal to json
func (updateOption *UpdateOption) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Name string `json:"name"` // The option name

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateOption.tdCommon = tempObj.tdCommon
	updateOption.Name = tempObj.Name

	fieldValue, _ := unmarshalOptionValue(objMap["value"])
	updateOption.Value = fieldValue

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateOption *UpdateOption) GetUpdateEnum() UpdateEnum {
	return UpdateOptionType
}

// UpdateStickerSet A sticker set has changed
type UpdateStickerSet struct {
	tdCommon
	StickerSet *StickerSet `json:"sticker_set"` // The sticker set
}

// MessageType return the string telegram-type of UpdateStickerSet
func (updateStickerSet *UpdateStickerSet) MessageType() string {
	return "updateStickerSet"
}

// NewUpdateStickerSet creates a new UpdateStickerSet
//
// @param stickerSet The sticker set
func NewUpdateStickerSet(stickerSet *StickerSet) *UpdateStickerSet {
	updateStickerSetTemp := UpdateStickerSet{
		tdCommon:   tdCommon{Type: "updateStickerSet"},
		StickerSet: stickerSet,
	}

	return &updateStickerSetTemp
}

// UnmarshalJSON unmarshal to json
func (updateStickerSet *UpdateStickerSet) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateStickerSet.tdCommon = tempObj.tdCommon

	var stickerSet StickerSet
	if objMap["sticker_set"] != nil {
		err = stickerSet.UnmarshalJSON(*objMap["sticker_set"])
		if err != nil {
			return err
		}
	}

	updateStickerSet.StickerSet = &stickerSet

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateStickerSet *UpdateStickerSet) GetUpdateEnum() UpdateEnum {
	return UpdateStickerSetType
}

// UpdateInstalledStickerSets The list of installed sticker sets was updated
type UpdateInstalledStickerSets struct {
	tdCommon
	StickerType   StickerType `json:"sticker_type"`    // Type of the affected stickers
	StickerSetIDs []JSONInt64 `json:"sticker_set_ids"` // The new list of installed ordinary sticker sets
}

// MessageType return the string telegram-type of UpdateInstalledStickerSets
func (updateInstalledStickerSets *UpdateInstalledStickerSets) MessageType() string {
	return "updateInstalledStickerSets"
}

// NewUpdateInstalledStickerSets creates a new UpdateInstalledStickerSets
//
// @param stickerType Type of the affected stickers
// @param stickerSetIDs The new list of installed ordinary sticker sets
func NewUpdateInstalledStickerSets(stickerType StickerType, stickerSetIDs []JSONInt64) *UpdateInstalledStickerSets {
	updateInstalledStickerSetsTemp := UpdateInstalledStickerSets{
		tdCommon:      tdCommon{Type: "updateInstalledStickerSets"},
		StickerType:   stickerType,
		StickerSetIDs: stickerSetIDs,
	}

	return &updateInstalledStickerSetsTemp
}

// UnmarshalJSON unmarshal to json
func (updateInstalledStickerSets *UpdateInstalledStickerSets) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StickerSetIDs []JSONInt64 `json:"sticker_set_ids"` // The new list of installed ordinary sticker sets
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateInstalledStickerSets.tdCommon = tempObj.tdCommon
	updateInstalledStickerSets.StickerSetIDs = tempObj.StickerSetIDs

	fieldStickerType, _ := unmarshalStickerType(objMap["sticker_type"])
	updateInstalledStickerSets.StickerType = fieldStickerType

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateInstalledStickerSets *UpdateInstalledStickerSets) GetUpdateEnum() UpdateEnum {
	return UpdateInstalledStickerSetsType
}

// UpdateTrendingStickerSets The list of trending sticker sets was updated or some of them were viewed
type UpdateTrendingStickerSets struct {
	tdCommon
	StickerType StickerType          `json:"sticker_type"` // Type of the affected stickers
	StickerSets *TrendingStickerSets `json:"sticker_sets"` // The prefix of the list of trending sticker sets with the newest trending sticker sets
}

// MessageType return the string telegram-type of UpdateTrendingStickerSets
func (updateTrendingStickerSets *UpdateTrendingStickerSets) MessageType() string {
	return "updateTrendingStickerSets"
}

// NewUpdateTrendingStickerSets creates a new UpdateTrendingStickerSets
//
// @param stickerType Type of the affected stickers
// @param stickerSets The prefix of the list of trending sticker sets with the newest trending sticker sets
func NewUpdateTrendingStickerSets(stickerType StickerType, stickerSets *TrendingStickerSets) *UpdateTrendingStickerSets {
	updateTrendingStickerSetsTemp := UpdateTrendingStickerSets{
		tdCommon:    tdCommon{Type: "updateTrendingStickerSets"},
		StickerType: stickerType,
		StickerSets: stickerSets,
	}

	return &updateTrendingStickerSetsTemp
}

// UnmarshalJSON unmarshal to json
func (updateTrendingStickerSets *UpdateTrendingStickerSets) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StickerSets *TrendingStickerSets `json:"sticker_sets"` // The prefix of the list of trending sticker sets with the newest trending sticker sets
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateTrendingStickerSets.tdCommon = tempObj.tdCommon
	updateTrendingStickerSets.StickerSets = tempObj.StickerSets

	fieldStickerType, _ := unmarshalStickerType(objMap["sticker_type"])
	updateTrendingStickerSets.StickerType = fieldStickerType

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateTrendingStickerSets *UpdateTrendingStickerSets) GetUpdateEnum() UpdateEnum {
	return UpdateTrendingStickerSetsType
}

// UpdateRecentStickers The list of recently used stickers was updated
type UpdateRecentStickers struct {
	tdCommon
	IsAttached bool    `json:"is_attached"` // True, if the list of stickers attached to photo or video files was updated; otherwise, the list of sent stickers is updated
	StickerIDs []int32 `json:"sticker_ids"` // The new list of file identifiers of recently used stickers
}

// MessageType return the string telegram-type of UpdateRecentStickers
func (updateRecentStickers *UpdateRecentStickers) MessageType() string {
	return "updateRecentStickers"
}

// NewUpdateRecentStickers creates a new UpdateRecentStickers
//
// @param isAttached True, if the list of stickers attached to photo or video files was updated; otherwise, the list of sent stickers is updated
// @param stickerIDs The new list of file identifiers of recently used stickers
func NewUpdateRecentStickers(isAttached bool, stickerIDs []int32) *UpdateRecentStickers {
	updateRecentStickersTemp := UpdateRecentStickers{
		tdCommon:   tdCommon{Type: "updateRecentStickers"},
		IsAttached: isAttached,
		StickerIDs: stickerIDs,
	}

	return &updateRecentStickersTemp
}

// UnmarshalJSON unmarshal to json
func (updateRecentStickers *UpdateRecentStickers) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsAttached bool    `json:"is_attached"` // True, if the list of stickers attached to photo or video files was updated; otherwise, the list of sent stickers is updated
		StickerIDs []int32 `json:"sticker_ids"` // The new list of file identifiers of recently used stickers
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateRecentStickers.tdCommon = tempObj.tdCommon
	updateRecentStickers.IsAttached = tempObj.IsAttached
	updateRecentStickers.StickerIDs = tempObj.StickerIDs

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateRecentStickers *UpdateRecentStickers) GetUpdateEnum() UpdateEnum {
	return UpdateRecentStickersType
}

// UpdateFavoriteStickers The list of favorite stickers was updated
type UpdateFavoriteStickers struct {
	tdCommon
	StickerIDs []int32 `json:"sticker_ids"` // The new list of file identifiers of favorite stickers
}

// MessageType return the string telegram-type of UpdateFavoriteStickers
func (updateFavoriteStickers *UpdateFavoriteStickers) MessageType() string {
	return "updateFavoriteStickers"
}

// NewUpdateFavoriteStickers creates a new UpdateFavoriteStickers
//
// @param stickerIDs The new list of file identifiers of favorite stickers
func NewUpdateFavoriteStickers(stickerIDs []int32) *UpdateFavoriteStickers {
	updateFavoriteStickersTemp := UpdateFavoriteStickers{
		tdCommon:   tdCommon{Type: "updateFavoriteStickers"},
		StickerIDs: stickerIDs,
	}

	return &updateFavoriteStickersTemp
}

// UnmarshalJSON unmarshal to json
func (updateFavoriteStickers *UpdateFavoriteStickers) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StickerIDs []int32 `json:"sticker_ids"` // The new list of file identifiers of favorite stickers
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateFavoriteStickers.tdCommon = tempObj.tdCommon
	updateFavoriteStickers.StickerIDs = tempObj.StickerIDs

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateFavoriteStickers *UpdateFavoriteStickers) GetUpdateEnum() UpdateEnum {
	return UpdateFavoriteStickersType
}

// UpdateSavedAnimations The list of saved animations was updated
type UpdateSavedAnimations struct {
	tdCommon
	AnimationIDs []int32 `json:"animation_ids"` // The new list of file identifiers of saved animations
}

// MessageType return the string telegram-type of UpdateSavedAnimations
func (updateSavedAnimations *UpdateSavedAnimations) MessageType() string {
	return "updateSavedAnimations"
}

// NewUpdateSavedAnimations creates a new UpdateSavedAnimations
//
// @param animationIDs The new list of file identifiers of saved animations
func NewUpdateSavedAnimations(animationIDs []int32) *UpdateSavedAnimations {
	updateSavedAnimationsTemp := UpdateSavedAnimations{
		tdCommon:     tdCommon{Type: "updateSavedAnimations"},
		AnimationIDs: animationIDs,
	}

	return &updateSavedAnimationsTemp
}

// UnmarshalJSON unmarshal to json
func (updateSavedAnimations *UpdateSavedAnimations) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		AnimationIDs []int32 `json:"animation_ids"` // The new list of file identifiers of saved animations
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateSavedAnimations.tdCommon = tempObj.tdCommon
	updateSavedAnimations.AnimationIDs = tempObj.AnimationIDs

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateSavedAnimations *UpdateSavedAnimations) GetUpdateEnum() UpdateEnum {
	return UpdateSavedAnimationsType
}

// UpdateSavedNotificationSounds The list of saved notification sounds was updated. This update may not be sent until information about a notification sound was requested for the first time
type UpdateSavedNotificationSounds struct {
	tdCommon
	NotificationSoundIDs []JSONInt64 `json:"notification_sound_ids"` // The new list of identifiers of saved notification sounds
}

// MessageType return the string telegram-type of UpdateSavedNotificationSounds
func (updateSavedNotificationSounds *UpdateSavedNotificationSounds) MessageType() string {
	return "updateSavedNotificationSounds"
}

// NewUpdateSavedNotificationSounds creates a new UpdateSavedNotificationSounds
//
// @param notificationSoundIDs The new list of identifiers of saved notification sounds
func NewUpdateSavedNotificationSounds(notificationSoundIDs []JSONInt64) *UpdateSavedNotificationSounds {
	updateSavedNotificationSoundsTemp := UpdateSavedNotificationSounds{
		tdCommon:             tdCommon{Type: "updateSavedNotificationSounds"},
		NotificationSoundIDs: notificationSoundIDs,
	}

	return &updateSavedNotificationSoundsTemp
}

// UnmarshalJSON unmarshal to json
func (updateSavedNotificationSounds *UpdateSavedNotificationSounds) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		NotificationSoundIDs []JSONInt64 `json:"notification_sound_ids"` // The new list of identifiers of saved notification sounds
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateSavedNotificationSounds.tdCommon = tempObj.tdCommon
	updateSavedNotificationSounds.NotificationSoundIDs = tempObj.NotificationSoundIDs

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateSavedNotificationSounds *UpdateSavedNotificationSounds) GetUpdateEnum() UpdateEnum {
	return UpdateSavedNotificationSoundsType
}

// UpdateDefaultBackground The default background has changed
type UpdateDefaultBackground struct {
	tdCommon
	ForDarkTheme bool        `json:"for_dark_theme"` // True, if default background for dark theme has changed
	Background   *Background `json:"background"`     // The new default background; may be null
}

// MessageType return the string telegram-type of UpdateDefaultBackground
func (updateDefaultBackground *UpdateDefaultBackground) MessageType() string {
	return "updateDefaultBackground"
}

// NewUpdateDefaultBackground creates a new UpdateDefaultBackground
//
// @param forDarkTheme True, if default background for dark theme has changed
// @param background The new default background; may be null
func NewUpdateDefaultBackground(forDarkTheme bool, background *Background) *UpdateDefaultBackground {
	updateDefaultBackgroundTemp := UpdateDefaultBackground{
		tdCommon:     tdCommon{Type: "updateDefaultBackground"},
		ForDarkTheme: forDarkTheme,
		Background:   background,
	}

	return &updateDefaultBackgroundTemp
}

// UnmarshalJSON unmarshal to json
func (updateDefaultBackground *UpdateDefaultBackground) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ForDarkTheme bool `json:"for_dark_theme"` // True, if default background for dark theme has changed

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateDefaultBackground.tdCommon = tempObj.tdCommon
	updateDefaultBackground.ForDarkTheme = tempObj.ForDarkTheme

	var background Background
	if objMap["background"] != nil {
		err = background.UnmarshalJSON(*objMap["background"])
		if err != nil {
			return err
		}
	}

	updateDefaultBackground.Background = &background

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateDefaultBackground *UpdateDefaultBackground) GetUpdateEnum() UpdateEnum {
	return UpdateDefaultBackgroundType
}

// UpdateChatThemes The list of available chat themes has changed
type UpdateChatThemes struct {
	tdCommon
	ChatThemes []ChatTheme `json:"chat_themes"` // The new list of chat themes
}

// MessageType return the string telegram-type of UpdateChatThemes
func (updateChatThemes *UpdateChatThemes) MessageType() string {
	return "updateChatThemes"
}

// NewUpdateChatThemes creates a new UpdateChatThemes
//
// @param chatThemes The new list of chat themes
func NewUpdateChatThemes(chatThemes []ChatTheme) *UpdateChatThemes {
	updateChatThemesTemp := UpdateChatThemes{
		tdCommon:   tdCommon{Type: "updateChatThemes"},
		ChatThemes: chatThemes,
	}

	return &updateChatThemesTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatThemes *UpdateChatThemes) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatThemes []ChatTheme `json:"chat_themes"` // The new list of chat themes
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatThemes.tdCommon = tempObj.tdCommon
	updateChatThemes.ChatThemes = tempObj.ChatThemes

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatThemes *UpdateChatThemes) GetUpdateEnum() UpdateEnum {
	return UpdateChatThemesType
}

// UpdateAccentColors The list of supported accent colors has changed
type UpdateAccentColors struct {
	tdCommon
	Colors                  []AccentColor `json:"colors"`                     // Information about supported colors; colors with identifiers 0 (red), 1 (orange), 2 (purple/violet), 3 (green), 4 (cyan), 5 (blue), 6 (pink) must always be supported and aren't included in the list. The exact colors for the accent colors with identifiers 0-6 must be taken from the app theme
	AvailableAccentColorIDs []int32       `json:"available_accent_color_ids"` // The list of accent color identifiers, which can be set through setAccentColor and setChatAccentColor. The colors must be shown in the specififed order
}

// MessageType return the string telegram-type of UpdateAccentColors
func (updateAccentColors *UpdateAccentColors) MessageType() string {
	return "updateAccentColors"
}

// NewUpdateAccentColors creates a new UpdateAccentColors
//
// @param colors Information about supported colors; colors with identifiers 0 (red), 1 (orange), 2 (purple/violet), 3 (green), 4 (cyan), 5 (blue), 6 (pink) must always be supported and aren't included in the list. The exact colors for the accent colors with identifiers 0-6 must be taken from the app theme
// @param availableAccentColorIDs The list of accent color identifiers, which can be set through setAccentColor and setChatAccentColor. The colors must be shown in the specififed order
func NewUpdateAccentColors(colors []AccentColor, availableAccentColorIDs []int32) *UpdateAccentColors {
	updateAccentColorsTemp := UpdateAccentColors{
		tdCommon:                tdCommon{Type: "updateAccentColors"},
		Colors:                  colors,
		AvailableAccentColorIDs: availableAccentColorIDs,
	}

	return &updateAccentColorsTemp
}

// UnmarshalJSON unmarshal to json
func (updateAccentColors *UpdateAccentColors) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Colors                  []AccentColor `json:"colors"`                     // Information about supported colors; colors with identifiers 0 (red), 1 (orange), 2 (purple/violet), 3 (green), 4 (cyan), 5 (blue), 6 (pink) must always be supported and aren't included in the list. The exact colors for the accent colors with identifiers 0-6 must be taken from the app theme
		AvailableAccentColorIDs []int32       `json:"available_accent_color_ids"` // The list of accent color identifiers, which can be set through setAccentColor and setChatAccentColor. The colors must be shown in the specififed order
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateAccentColors.tdCommon = tempObj.tdCommon
	updateAccentColors.Colors = tempObj.Colors
	updateAccentColors.AvailableAccentColorIDs = tempObj.AvailableAccentColorIDs

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateAccentColors *UpdateAccentColors) GetUpdateEnum() UpdateEnum {
	return UpdateAccentColorsType
}

// UpdateProfileAccentColors The list of supported accent colors for user profiles has changed
type UpdateProfileAccentColors struct {
	tdCommon
	Colors                  []ProfileAccentColor `json:"colors"`                     // Information about supported colors
	AvailableAccentColorIDs []int32              `json:"available_accent_color_ids"` // The list of accent color identifiers, which can be set through setProfileAccentColor and setChatProfileAccentColor. The colors must be shown in the specififed order
}

// MessageType return the string telegram-type of UpdateProfileAccentColors
func (updateProfileAccentColors *UpdateProfileAccentColors) MessageType() string {
	return "updateProfileAccentColors"
}

// NewUpdateProfileAccentColors creates a new UpdateProfileAccentColors
//
// @param colors Information about supported colors
// @param availableAccentColorIDs The list of accent color identifiers, which can be set through setProfileAccentColor and setChatProfileAccentColor. The colors must be shown in the specififed order
func NewUpdateProfileAccentColors(colors []ProfileAccentColor, availableAccentColorIDs []int32) *UpdateProfileAccentColors {
	updateProfileAccentColorsTemp := UpdateProfileAccentColors{
		tdCommon:                tdCommon{Type: "updateProfileAccentColors"},
		Colors:                  colors,
		AvailableAccentColorIDs: availableAccentColorIDs,
	}

	return &updateProfileAccentColorsTemp
}

// UnmarshalJSON unmarshal to json
func (updateProfileAccentColors *UpdateProfileAccentColors) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Colors                  []ProfileAccentColor `json:"colors"`                     // Information about supported colors
		AvailableAccentColorIDs []int32              `json:"available_accent_color_ids"` // The list of accent color identifiers, which can be set through setProfileAccentColor and setChatProfileAccentColor. The colors must be shown in the specififed order
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateProfileAccentColors.tdCommon = tempObj.tdCommon
	updateProfileAccentColors.Colors = tempObj.Colors
	updateProfileAccentColors.AvailableAccentColorIDs = tempObj.AvailableAccentColorIDs

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateProfileAccentColors *UpdateProfileAccentColors) GetUpdateEnum() UpdateEnum {
	return UpdateProfileAccentColorsType
}

// UpdateLanguagePackStrings Some language pack strings have been updated
type UpdateLanguagePackStrings struct {
	tdCommon
	LocalizationTarget string               `json:"localization_target"` // Localization target to which the language pack belongs
	LanguagePackID     string               `json:"language_pack_id"`    // Identifier of the updated language pack
	Strings            []LanguagePackString `json:"strings"`             // List of changed language pack strings; empty if all strings have changed
}

// MessageType return the string telegram-type of UpdateLanguagePackStrings
func (updateLanguagePackStrings *UpdateLanguagePackStrings) MessageType() string {
	return "updateLanguagePackStrings"
}

// NewUpdateLanguagePackStrings creates a new UpdateLanguagePackStrings
//
// @param localizationTarget Localization target to which the language pack belongs
// @param languagePackID Identifier of the updated language pack
// @param strings List of changed language pack strings; empty if all strings have changed
func NewUpdateLanguagePackStrings(localizationTarget string, languagePackID string, strings []LanguagePackString) *UpdateLanguagePackStrings {
	updateLanguagePackStringsTemp := UpdateLanguagePackStrings{
		tdCommon:           tdCommon{Type: "updateLanguagePackStrings"},
		LocalizationTarget: localizationTarget,
		LanguagePackID:     languagePackID,
		Strings:            strings,
	}

	return &updateLanguagePackStringsTemp
}

// UnmarshalJSON unmarshal to json
func (updateLanguagePackStrings *UpdateLanguagePackStrings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		LocalizationTarget string               `json:"localization_target"` // Localization target to which the language pack belongs
		LanguagePackID     string               `json:"language_pack_id"`    // Identifier of the updated language pack
		Strings            []LanguagePackString `json:"strings"`             // List of changed language pack strings; empty if all strings have changed
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateLanguagePackStrings.tdCommon = tempObj.tdCommon
	updateLanguagePackStrings.LocalizationTarget = tempObj.LocalizationTarget
	updateLanguagePackStrings.LanguagePackID = tempObj.LanguagePackID
	updateLanguagePackStrings.Strings = tempObj.Strings

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateLanguagePackStrings *UpdateLanguagePackStrings) GetUpdateEnum() UpdateEnum {
	return UpdateLanguagePackStringsType
}

// UpdateConnectionState The connection state has changed. This update must be used only to show a human-readable description of the connection state
type UpdateConnectionState struct {
	tdCommon
	State ConnectionState `json:"state"` // The new connection state
}

// MessageType return the string telegram-type of UpdateConnectionState
func (updateConnectionState *UpdateConnectionState) MessageType() string {
	return "updateConnectionState"
}

// NewUpdateConnectionState creates a new UpdateConnectionState
//
// @param state The new connection state
func NewUpdateConnectionState(state ConnectionState) *UpdateConnectionState {
	updateConnectionStateTemp := UpdateConnectionState{
		tdCommon: tdCommon{Type: "updateConnectionState"},
		State:    state,
	}

	return &updateConnectionStateTemp
}

// UnmarshalJSON unmarshal to json
func (updateConnectionState *UpdateConnectionState) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateConnectionState.tdCommon = tempObj.tdCommon

	fieldState, _ := unmarshalConnectionState(objMap["state"])
	updateConnectionState.State = fieldState

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateConnectionState *UpdateConnectionState) GetUpdateEnum() UpdateEnum {
	return UpdateConnectionStateType
}

// UpdateTermsOfService New terms of service must be accepted by the user. If the terms of service are declined, then the deleteAccount method must be called with the reason "Decline ToS update"
type UpdateTermsOfService struct {
	tdCommon
	TermsOfServiceID string          `json:"terms_of_service_id"` // Identifier of the terms of service
	TermsOfService   *TermsOfService `json:"terms_of_service"`    // The new terms of service
}

// MessageType return the string telegram-type of UpdateTermsOfService
func (updateTermsOfService *UpdateTermsOfService) MessageType() string {
	return "updateTermsOfService"
}

// NewUpdateTermsOfService creates a new UpdateTermsOfService
//
// @param termsOfServiceID Identifier of the terms of service
// @param termsOfService The new terms of service
func NewUpdateTermsOfService(termsOfServiceID string, termsOfService *TermsOfService) *UpdateTermsOfService {
	updateTermsOfServiceTemp := UpdateTermsOfService{
		tdCommon:         tdCommon{Type: "updateTermsOfService"},
		TermsOfServiceID: termsOfServiceID,
		TermsOfService:   termsOfService,
	}

	return &updateTermsOfServiceTemp
}

// UnmarshalJSON unmarshal to json
func (updateTermsOfService *UpdateTermsOfService) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		TermsOfServiceID string          `json:"terms_of_service_id"` // Identifier of the terms of service
		TermsOfService   *TermsOfService `json:"terms_of_service"`    // The new terms of service
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateTermsOfService.tdCommon = tempObj.tdCommon
	updateTermsOfService.TermsOfServiceID = tempObj.TermsOfServiceID
	updateTermsOfService.TermsOfService = tempObj.TermsOfService

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateTermsOfService *UpdateTermsOfService) GetUpdateEnum() UpdateEnum {
	return UpdateTermsOfServiceType
}

// UpdateUsersNearby The list of users nearby has changed. The update is guaranteed to be sent only 60 seconds after a successful searchChatsNearby request
type UpdateUsersNearby struct {
	tdCommon
	UsersNearby []ChatNearby `json:"users_nearby"` // The new list of users nearby
}

// MessageType return the string telegram-type of UpdateUsersNearby
func (updateUsersNearby *UpdateUsersNearby) MessageType() string {
	return "updateUsersNearby"
}

// NewUpdateUsersNearby creates a new UpdateUsersNearby
//
// @param usersNearby The new list of users nearby
func NewUpdateUsersNearby(usersNearby []ChatNearby) *UpdateUsersNearby {
	updateUsersNearbyTemp := UpdateUsersNearby{
		tdCommon:    tdCommon{Type: "updateUsersNearby"},
		UsersNearby: usersNearby,
	}

	return &updateUsersNearbyTemp
}

// UnmarshalJSON unmarshal to json
func (updateUsersNearby *UpdateUsersNearby) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UsersNearby []ChatNearby `json:"users_nearby"` // The new list of users nearby
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateUsersNearby.tdCommon = tempObj.tdCommon
	updateUsersNearby.UsersNearby = tempObj.UsersNearby

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateUsersNearby *UpdateUsersNearby) GetUpdateEnum() UpdateEnum {
	return UpdateUsersNearbyType
}

// UpdateUnconfirmedSession The first unconfirmed session has changed
type UpdateUnconfirmedSession struct {
	tdCommon
	Session *UnconfirmedSession `json:"session"` // The unconfirmed session; may be null if none
}

// MessageType return the string telegram-type of UpdateUnconfirmedSession
func (updateUnconfirmedSession *UpdateUnconfirmedSession) MessageType() string {
	return "updateUnconfirmedSession"
}

// NewUpdateUnconfirmedSession creates a new UpdateUnconfirmedSession
//
// @param session The unconfirmed session; may be null if none
func NewUpdateUnconfirmedSession(session *UnconfirmedSession) *UpdateUnconfirmedSession {
	updateUnconfirmedSessionTemp := UpdateUnconfirmedSession{
		tdCommon: tdCommon{Type: "updateUnconfirmedSession"},
		Session:  session,
	}

	return &updateUnconfirmedSessionTemp
}

// UnmarshalJSON unmarshal to json
func (updateUnconfirmedSession *UpdateUnconfirmedSession) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Session *UnconfirmedSession `json:"session"` // The unconfirmed session; may be null if none
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateUnconfirmedSession.tdCommon = tempObj.tdCommon
	updateUnconfirmedSession.Session = tempObj.Session

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateUnconfirmedSession *UpdateUnconfirmedSession) GetUpdateEnum() UpdateEnum {
	return UpdateUnconfirmedSessionType
}

// UpdateAttachmentMenuBots The list of bots added to attachment or side menu has changed
type UpdateAttachmentMenuBots struct {
	tdCommon
	Bots []AttachmentMenuBot `json:"bots"` // The new list of bots. The bots must not be shown on scheduled messages screen
}

// MessageType return the string telegram-type of UpdateAttachmentMenuBots
func (updateAttachmentMenuBots *UpdateAttachmentMenuBots) MessageType() string {
	return "updateAttachmentMenuBots"
}

// NewUpdateAttachmentMenuBots creates a new UpdateAttachmentMenuBots
//
// @param bots The new list of bots. The bots must not be shown on scheduled messages screen
func NewUpdateAttachmentMenuBots(bots []AttachmentMenuBot) *UpdateAttachmentMenuBots {
	updateAttachmentMenuBotsTemp := UpdateAttachmentMenuBots{
		tdCommon: tdCommon{Type: "updateAttachmentMenuBots"},
		Bots:     bots,
	}

	return &updateAttachmentMenuBotsTemp
}

// UnmarshalJSON unmarshal to json
func (updateAttachmentMenuBots *UpdateAttachmentMenuBots) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Bots []AttachmentMenuBot `json:"bots"` // The new list of bots. The bots must not be shown on scheduled messages screen
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateAttachmentMenuBots.tdCommon = tempObj.tdCommon
	updateAttachmentMenuBots.Bots = tempObj.Bots

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateAttachmentMenuBots *UpdateAttachmentMenuBots) GetUpdateEnum() UpdateEnum {
	return UpdateAttachmentMenuBotsType
}

// UpdateWebAppMessageSent A message was sent by an opened Web App, so the Web App needs to be closed
type UpdateWebAppMessageSent struct {
	tdCommon
	WebAppLaunchID JSONInt64 `json:"web_app_launch_id"` // Identifier of Web App launch
}

// MessageType return the string telegram-type of UpdateWebAppMessageSent
func (updateWebAppMessageSent *UpdateWebAppMessageSent) MessageType() string {
	return "updateWebAppMessageSent"
}

// NewUpdateWebAppMessageSent creates a new UpdateWebAppMessageSent
//
// @param webAppLaunchID Identifier of Web App launch
func NewUpdateWebAppMessageSent(webAppLaunchID JSONInt64) *UpdateWebAppMessageSent {
	updateWebAppMessageSentTemp := UpdateWebAppMessageSent{
		tdCommon:       tdCommon{Type: "updateWebAppMessageSent"},
		WebAppLaunchID: webAppLaunchID,
	}

	return &updateWebAppMessageSentTemp
}

// UnmarshalJSON unmarshal to json
func (updateWebAppMessageSent *UpdateWebAppMessageSent) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		WebAppLaunchID JSONInt64 `json:"web_app_launch_id"` // Identifier of Web App launch
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateWebAppMessageSent.tdCommon = tempObj.tdCommon
	updateWebAppMessageSent.WebAppLaunchID = tempObj.WebAppLaunchID

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateWebAppMessageSent *UpdateWebAppMessageSent) GetUpdateEnum() UpdateEnum {
	return UpdateWebAppMessageSentType
}

// UpdateActiveEmojiReactions The list of active emoji reactions has changed
type UpdateActiveEmojiReactions struct {
	tdCommon
	Emojis []string `json:"emojis"` // The new list of active emoji reactions
}

// MessageType return the string telegram-type of UpdateActiveEmojiReactions
func (updateActiveEmojiReactions *UpdateActiveEmojiReactions) MessageType() string {
	return "updateActiveEmojiReactions"
}

// NewUpdateActiveEmojiReactions creates a new UpdateActiveEmojiReactions
//
// @param emojis The new list of active emoji reactions
func NewUpdateActiveEmojiReactions(emojis []string) *UpdateActiveEmojiReactions {
	updateActiveEmojiReactionsTemp := UpdateActiveEmojiReactions{
		tdCommon: tdCommon{Type: "updateActiveEmojiReactions"},
		Emojis:   emojis,
	}

	return &updateActiveEmojiReactionsTemp
}

// UnmarshalJSON unmarshal to json
func (updateActiveEmojiReactions *UpdateActiveEmojiReactions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Emojis []string `json:"emojis"` // The new list of active emoji reactions
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateActiveEmojiReactions.tdCommon = tempObj.tdCommon
	updateActiveEmojiReactions.Emojis = tempObj.Emojis

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateActiveEmojiReactions *UpdateActiveEmojiReactions) GetUpdateEnum() UpdateEnum {
	return UpdateActiveEmojiReactionsType
}

// UpdateAvailableMessageEffects The list of available message effects has changed
type UpdateAvailableMessageEffects struct {
	tdCommon
	ReactionEffectIDs []JSONInt64 `json:"reaction_effect_ids"` // The new list of available message effects from emoji reactions
	StickerEffectIDs  []JSONInt64 `json:"sticker_effect_ids"`  // The new list of available message effects from Premium stickers
}

// MessageType return the string telegram-type of UpdateAvailableMessageEffects
func (updateAvailableMessageEffects *UpdateAvailableMessageEffects) MessageType() string {
	return "updateAvailableMessageEffects"
}

// NewUpdateAvailableMessageEffects creates a new UpdateAvailableMessageEffects
//
// @param reactionEffectIDs The new list of available message effects from emoji reactions
// @param stickerEffectIDs The new list of available message effects from Premium stickers
func NewUpdateAvailableMessageEffects(reactionEffectIDs []JSONInt64, stickerEffectIDs []JSONInt64) *UpdateAvailableMessageEffects {
	updateAvailableMessageEffectsTemp := UpdateAvailableMessageEffects{
		tdCommon:          tdCommon{Type: "updateAvailableMessageEffects"},
		ReactionEffectIDs: reactionEffectIDs,
		StickerEffectIDs:  stickerEffectIDs,
	}

	return &updateAvailableMessageEffectsTemp
}

// UnmarshalJSON unmarshal to json
func (updateAvailableMessageEffects *UpdateAvailableMessageEffects) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ReactionEffectIDs []JSONInt64 `json:"reaction_effect_ids"` // The new list of available message effects from emoji reactions
		StickerEffectIDs  []JSONInt64 `json:"sticker_effect_ids"`  // The new list of available message effects from Premium stickers
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateAvailableMessageEffects.tdCommon = tempObj.tdCommon
	updateAvailableMessageEffects.ReactionEffectIDs = tempObj.ReactionEffectIDs
	updateAvailableMessageEffects.StickerEffectIDs = tempObj.StickerEffectIDs

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateAvailableMessageEffects *UpdateAvailableMessageEffects) GetUpdateEnum() UpdateEnum {
	return UpdateAvailableMessageEffectsType
}

// UpdateDefaultReactionType The type of default reaction has changed
type UpdateDefaultReactionType struct {
	tdCommon
	ReactionType ReactionType `json:"reaction_type"` // The new type of the default reaction
}

// MessageType return the string telegram-type of UpdateDefaultReactionType
func (updateDefaultReactionType *UpdateDefaultReactionType) MessageType() string {
	return "updateDefaultReactionType"
}

// NewUpdateDefaultReactionType creates a new UpdateDefaultReactionType
//
// @param reactionType The new type of the default reaction
func NewUpdateDefaultReactionType(reactionType ReactionType) *UpdateDefaultReactionType {
	updateDefaultReactionTypeTemp := UpdateDefaultReactionType{
		tdCommon:     tdCommon{Type: "updateDefaultReactionType"},
		ReactionType: reactionType,
	}

	return &updateDefaultReactionTypeTemp
}

// UnmarshalJSON unmarshal to json
func (updateDefaultReactionType *UpdateDefaultReactionType) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateDefaultReactionType.tdCommon = tempObj.tdCommon

	fieldReactionType, _ := unmarshalReactionType(objMap["reaction_type"])
	updateDefaultReactionType.ReactionType = fieldReactionType

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateDefaultReactionType *UpdateDefaultReactionType) GetUpdateEnum() UpdateEnum {
	return UpdateDefaultReactionTypeType
}

// UpdateSavedMessagesTags Tags used in Saved Messages or a Saved Messages topic have changed
type UpdateSavedMessagesTags struct {
	tdCommon
	SavedMessagesTopicID int64              `json:"saved_messages_topic_id"` // Identifier of Saved Messages topic which tags were changed; 0 if tags for the whole chat has changed
	Tags                 *SavedMessagesTags `json:"tags"`                    // The new tags
}

// MessageType return the string telegram-type of UpdateSavedMessagesTags
func (updateSavedMessagesTags *UpdateSavedMessagesTags) MessageType() string {
	return "updateSavedMessagesTags"
}

// NewUpdateSavedMessagesTags creates a new UpdateSavedMessagesTags
//
// @param savedMessagesTopicID Identifier of Saved Messages topic which tags were changed; 0 if tags for the whole chat has changed
// @param tags The new tags
func NewUpdateSavedMessagesTags(savedMessagesTopicID int64, tags *SavedMessagesTags) *UpdateSavedMessagesTags {
	updateSavedMessagesTagsTemp := UpdateSavedMessagesTags{
		tdCommon:             tdCommon{Type: "updateSavedMessagesTags"},
		SavedMessagesTopicID: savedMessagesTopicID,
		Tags:                 tags,
	}

	return &updateSavedMessagesTagsTemp
}

// UnmarshalJSON unmarshal to json
func (updateSavedMessagesTags *UpdateSavedMessagesTags) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SavedMessagesTopicID int64              `json:"saved_messages_topic_id"` // Identifier of Saved Messages topic which tags were changed; 0 if tags for the whole chat has changed
		Tags                 *SavedMessagesTags `json:"tags"`                    // The new tags
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateSavedMessagesTags.tdCommon = tempObj.tdCommon
	updateSavedMessagesTags.SavedMessagesTopicID = tempObj.SavedMessagesTopicID
	updateSavedMessagesTags.Tags = tempObj.Tags

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateSavedMessagesTags *UpdateSavedMessagesTags) GetUpdateEnum() UpdateEnum {
	return UpdateSavedMessagesTagsType
}

// UpdateActiveLiveLocationMessages The list of messages with active live location that need to be updated by the application has changed. The list is persistent across application restarts only if the message database is used
type UpdateActiveLiveLocationMessages struct {
	tdCommon
	Messages []Message `json:"messages"` // The list of messages with active live locations
}

// MessageType return the string telegram-type of UpdateActiveLiveLocationMessages
func (updateActiveLiveLocationMessages *UpdateActiveLiveLocationMessages) MessageType() string {
	return "updateActiveLiveLocationMessages"
}

// NewUpdateActiveLiveLocationMessages creates a new UpdateActiveLiveLocationMessages
//
// @param messages The list of messages with active live locations
func NewUpdateActiveLiveLocationMessages(messages []Message) *UpdateActiveLiveLocationMessages {
	updateActiveLiveLocationMessagesTemp := UpdateActiveLiveLocationMessages{
		tdCommon: tdCommon{Type: "updateActiveLiveLocationMessages"},
		Messages: messages,
	}

	return &updateActiveLiveLocationMessagesTemp
}

// UnmarshalJSON unmarshal to json
func (updateActiveLiveLocationMessages *UpdateActiveLiveLocationMessages) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Messages []Message `json:"messages"` // The list of messages with active live locations
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateActiveLiveLocationMessages.tdCommon = tempObj.tdCommon
	updateActiveLiveLocationMessages.Messages = tempObj.Messages

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateActiveLiveLocationMessages *UpdateActiveLiveLocationMessages) GetUpdateEnum() UpdateEnum {
	return UpdateActiveLiveLocationMessagesType
}

// UpdateOwnedStarCount The number of Telegram Stars owned by the current user has changed
type UpdateOwnedStarCount struct {
	tdCommon
	StarCount int64 `json:"star_count"` // The new number of Telegram Stars owned
}

// MessageType return the string telegram-type of UpdateOwnedStarCount
func (updateOwnedStarCount *UpdateOwnedStarCount) MessageType() string {
	return "updateOwnedStarCount"
}

// NewUpdateOwnedStarCount creates a new UpdateOwnedStarCount
//
// @param starCount The new number of Telegram Stars owned
func NewUpdateOwnedStarCount(starCount int64) *UpdateOwnedStarCount {
	updateOwnedStarCountTemp := UpdateOwnedStarCount{
		tdCommon:  tdCommon{Type: "updateOwnedStarCount"},
		StarCount: starCount,
	}

	return &updateOwnedStarCountTemp
}

// UnmarshalJSON unmarshal to json
func (updateOwnedStarCount *UpdateOwnedStarCount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		StarCount int64 `json:"star_count"` // The new number of Telegram Stars owned
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateOwnedStarCount.tdCommon = tempObj.tdCommon
	updateOwnedStarCount.StarCount = tempObj.StarCount

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateOwnedStarCount *UpdateOwnedStarCount) GetUpdateEnum() UpdateEnum {
	return UpdateOwnedStarCountType
}

// UpdateChatRevenueAmount The revenue earned from sponsored messages in a chat has changed. If chat revenue screen is opened, then getChatRevenueTransactions may be called to fetch new transactions
type UpdateChatRevenueAmount struct {
	tdCommon
	ChatID        int64              `json:"chat_id"`        // Identifier of the chat
	RevenueAmount *ChatRevenueAmount `json:"revenue_amount"` // New amount of earned revenue
}

// MessageType return the string telegram-type of UpdateChatRevenueAmount
func (updateChatRevenueAmount *UpdateChatRevenueAmount) MessageType() string {
	return "updateChatRevenueAmount"
}

// NewUpdateChatRevenueAmount creates a new UpdateChatRevenueAmount
//
// @param chatID Identifier of the chat
// @param revenueAmount New amount of earned revenue
func NewUpdateChatRevenueAmount(chatID int64, revenueAmount *ChatRevenueAmount) *UpdateChatRevenueAmount {
	updateChatRevenueAmountTemp := UpdateChatRevenueAmount{
		tdCommon:      tdCommon{Type: "updateChatRevenueAmount"},
		ChatID:        chatID,
		RevenueAmount: revenueAmount,
	}

	return &updateChatRevenueAmountTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatRevenueAmount *UpdateChatRevenueAmount) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID        int64              `json:"chat_id"`        // Identifier of the chat
		RevenueAmount *ChatRevenueAmount `json:"revenue_amount"` // New amount of earned revenue
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatRevenueAmount.tdCommon = tempObj.tdCommon
	updateChatRevenueAmount.ChatID = tempObj.ChatID
	updateChatRevenueAmount.RevenueAmount = tempObj.RevenueAmount

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatRevenueAmount *UpdateChatRevenueAmount) GetUpdateEnum() UpdateEnum {
	return UpdateChatRevenueAmountType
}

// UpdateStarRevenueStatus The Telegram Star revenue earned by a bot or a chat has changed. If Telegram Star transaction screen of the chat is opened, then getStarTransactions may be called to fetch new transactions
type UpdateStarRevenueStatus struct {
	tdCommon
	OwnerID MessageSender      `json:"owner_id"` // Identifier of the owner of the Telegram Stars
	Status  *StarRevenueStatus `json:"status"`   // New Telegram Star revenue status
}

// MessageType return the string telegram-type of UpdateStarRevenueStatus
func (updateStarRevenueStatus *UpdateStarRevenueStatus) MessageType() string {
	return "updateStarRevenueStatus"
}

// NewUpdateStarRevenueStatus creates a new UpdateStarRevenueStatus
//
// @param ownerID Identifier of the owner of the Telegram Stars
// @param status New Telegram Star revenue status
func NewUpdateStarRevenueStatus(ownerID MessageSender, status *StarRevenueStatus) *UpdateStarRevenueStatus {
	updateStarRevenueStatusTemp := UpdateStarRevenueStatus{
		tdCommon: tdCommon{Type: "updateStarRevenueStatus"},
		OwnerID:  ownerID,
		Status:   status,
	}

	return &updateStarRevenueStatusTemp
}

// UnmarshalJSON unmarshal to json
func (updateStarRevenueStatus *UpdateStarRevenueStatus) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Status *StarRevenueStatus `json:"status"` // New Telegram Star revenue status
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateStarRevenueStatus.tdCommon = tempObj.tdCommon
	updateStarRevenueStatus.Status = tempObj.Status

	fieldOwnerID, _ := unmarshalMessageSender(objMap["owner_id"])
	updateStarRevenueStatus.OwnerID = fieldOwnerID

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateStarRevenueStatus *UpdateStarRevenueStatus) GetUpdateEnum() UpdateEnum {
	return UpdateStarRevenueStatusType
}

// UpdateSpeechRecognitionTrial The parameters of speech recognition without Telegram Premium subscription has changed
type UpdateSpeechRecognitionTrial struct {
	tdCommon
	MaxMediaDuration int32 `json:"max_media_duration"` // The maximum allowed duration of media for speech recognition without Telegram Premium subscription, in seconds
	WeeklyCount      int32 `json:"weekly_count"`       // The total number of allowed speech recognitions per week; 0 if none
	LeftCount        int32 `json:"left_count"`         // Number of left speech recognition attempts this week
	NextResetDate    int32 `json:"next_reset_date"`    // Point in time (Unix timestamp) when the weekly number of tries will reset; 0 if unknown
}

// MessageType return the string telegram-type of UpdateSpeechRecognitionTrial
func (updateSpeechRecognitionTrial *UpdateSpeechRecognitionTrial) MessageType() string {
	return "updateSpeechRecognitionTrial"
}

// NewUpdateSpeechRecognitionTrial creates a new UpdateSpeechRecognitionTrial
//
// @param maxMediaDuration The maximum allowed duration of media for speech recognition without Telegram Premium subscription, in seconds
// @param weeklyCount The total number of allowed speech recognitions per week; 0 if none
// @param leftCount Number of left speech recognition attempts this week
// @param nextResetDate Point in time (Unix timestamp) when the weekly number of tries will reset; 0 if unknown
func NewUpdateSpeechRecognitionTrial(maxMediaDuration int32, weeklyCount int32, leftCount int32, nextResetDate int32) *UpdateSpeechRecognitionTrial {
	updateSpeechRecognitionTrialTemp := UpdateSpeechRecognitionTrial{
		tdCommon:         tdCommon{Type: "updateSpeechRecognitionTrial"},
		MaxMediaDuration: maxMediaDuration,
		WeeklyCount:      weeklyCount,
		LeftCount:        leftCount,
		NextResetDate:    nextResetDate,
	}

	return &updateSpeechRecognitionTrialTemp
}

// UnmarshalJSON unmarshal to json
func (updateSpeechRecognitionTrial *UpdateSpeechRecognitionTrial) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		MaxMediaDuration int32 `json:"max_media_duration"` // The maximum allowed duration of media for speech recognition without Telegram Premium subscription, in seconds
		WeeklyCount      int32 `json:"weekly_count"`       // The total number of allowed speech recognitions per week; 0 if none
		LeftCount        int32 `json:"left_count"`         // Number of left speech recognition attempts this week
		NextResetDate    int32 `json:"next_reset_date"`    // Point in time (Unix timestamp) when the weekly number of tries will reset; 0 if unknown
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateSpeechRecognitionTrial.tdCommon = tempObj.tdCommon
	updateSpeechRecognitionTrial.MaxMediaDuration = tempObj.MaxMediaDuration
	updateSpeechRecognitionTrial.WeeklyCount = tempObj.WeeklyCount
	updateSpeechRecognitionTrial.LeftCount = tempObj.LeftCount
	updateSpeechRecognitionTrial.NextResetDate = tempObj.NextResetDate

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateSpeechRecognitionTrial *UpdateSpeechRecognitionTrial) GetUpdateEnum() UpdateEnum {
	return UpdateSpeechRecognitionTrialType
}

// UpdateDiceEmojis The list of supported dice emojis has changed
type UpdateDiceEmojis struct {
	tdCommon
	Emojis []string `json:"emojis"` // The new list of supported dice emojis
}

// MessageType return the string telegram-type of UpdateDiceEmojis
func (updateDiceEmojis *UpdateDiceEmojis) MessageType() string {
	return "updateDiceEmojis"
}

// NewUpdateDiceEmojis creates a new UpdateDiceEmojis
//
// @param emojis The new list of supported dice emojis
func NewUpdateDiceEmojis(emojis []string) *UpdateDiceEmojis {
	updateDiceEmojisTemp := UpdateDiceEmojis{
		tdCommon: tdCommon{Type: "updateDiceEmojis"},
		Emojis:   emojis,
	}

	return &updateDiceEmojisTemp
}

// UnmarshalJSON unmarshal to json
func (updateDiceEmojis *UpdateDiceEmojis) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Emojis []string `json:"emojis"` // The new list of supported dice emojis
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateDiceEmojis.tdCommon = tempObj.tdCommon
	updateDiceEmojis.Emojis = tempObj.Emojis

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateDiceEmojis *UpdateDiceEmojis) GetUpdateEnum() UpdateEnum {
	return UpdateDiceEmojisType
}

// UpdateAnimatedEmojiMessageClicked Some animated emoji message was clicked and a big animated sticker must be played if the message is visible on the screen. chatActionWatchingAnimations with the text of the message needs to be sent if the sticker is played
type UpdateAnimatedEmojiMessageClicked struct {
	tdCommon
	ChatID    int64    `json:"chat_id"`    // Chat identifier
	MessageID int64    `json:"message_id"` // Message identifier
	Sticker   *Sticker `json:"sticker"`    // The animated sticker to be played
}

// MessageType return the string telegram-type of UpdateAnimatedEmojiMessageClicked
func (updateAnimatedEmojiMessageClicked *UpdateAnimatedEmojiMessageClicked) MessageType() string {
	return "updateAnimatedEmojiMessageClicked"
}

// NewUpdateAnimatedEmojiMessageClicked creates a new UpdateAnimatedEmojiMessageClicked
//
// @param chatID Chat identifier
// @param messageID Message identifier
// @param sticker The animated sticker to be played
func NewUpdateAnimatedEmojiMessageClicked(chatID int64, messageID int64, sticker *Sticker) *UpdateAnimatedEmojiMessageClicked {
	updateAnimatedEmojiMessageClickedTemp := UpdateAnimatedEmojiMessageClicked{
		tdCommon:  tdCommon{Type: "updateAnimatedEmojiMessageClicked"},
		ChatID:    chatID,
		MessageID: messageID,
		Sticker:   sticker,
	}

	return &updateAnimatedEmojiMessageClickedTemp
}

// UnmarshalJSON unmarshal to json
func (updateAnimatedEmojiMessageClicked *UpdateAnimatedEmojiMessageClicked) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID    int64 `json:"chat_id"`    // Chat identifier
		MessageID int64 `json:"message_id"` // Message identifier

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateAnimatedEmojiMessageClicked.tdCommon = tempObj.tdCommon
	updateAnimatedEmojiMessageClicked.ChatID = tempObj.ChatID
	updateAnimatedEmojiMessageClicked.MessageID = tempObj.MessageID

	var sticker Sticker
	if objMap["sticker"] != nil {
		err = sticker.UnmarshalJSON(*objMap["sticker"])
		if err != nil {
			return err
		}
	}

	updateAnimatedEmojiMessageClicked.Sticker = &sticker

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateAnimatedEmojiMessageClicked *UpdateAnimatedEmojiMessageClicked) GetUpdateEnum() UpdateEnum {
	return UpdateAnimatedEmojiMessageClickedType
}

// UpdateAnimationSearchParameters The parameters of animation search through getOption("animation_search_bot_username") bot has changed
type UpdateAnimationSearchParameters struct {
	tdCommon
	Provider string   `json:"provider"` // Name of the animation search provider
	Emojis   []string `json:"emojis"`   // The new list of emojis suggested for searching
}

// MessageType return the string telegram-type of UpdateAnimationSearchParameters
func (updateAnimationSearchParameters *UpdateAnimationSearchParameters) MessageType() string {
	return "updateAnimationSearchParameters"
}

// NewUpdateAnimationSearchParameters creates a new UpdateAnimationSearchParameters
//
// @param provider Name of the animation search provider
// @param emojis The new list of emojis suggested for searching
func NewUpdateAnimationSearchParameters(provider string, emojis []string) *UpdateAnimationSearchParameters {
	updateAnimationSearchParametersTemp := UpdateAnimationSearchParameters{
		tdCommon: tdCommon{Type: "updateAnimationSearchParameters"},
		Provider: provider,
		Emojis:   emojis,
	}

	return &updateAnimationSearchParametersTemp
}

// UnmarshalJSON unmarshal to json
func (updateAnimationSearchParameters *UpdateAnimationSearchParameters) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Provider string   `json:"provider"` // Name of the animation search provider
		Emojis   []string `json:"emojis"`   // The new list of emojis suggested for searching
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateAnimationSearchParameters.tdCommon = tempObj.tdCommon
	updateAnimationSearchParameters.Provider = tempObj.Provider
	updateAnimationSearchParameters.Emojis = tempObj.Emojis

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateAnimationSearchParameters *UpdateAnimationSearchParameters) GetUpdateEnum() UpdateEnum {
	return UpdateAnimationSearchParametersType
}

// UpdateSuggestedActions The list of suggested to the user actions has changed
type UpdateSuggestedActions struct {
	tdCommon
	AddedActions   []SuggestedAction `json:"added_actions"`   // Added suggested actions
	RemovedActions []SuggestedAction `json:"removed_actions"` // Removed suggested actions
}

// MessageType return the string telegram-type of UpdateSuggestedActions
func (updateSuggestedActions *UpdateSuggestedActions) MessageType() string {
	return "updateSuggestedActions"
}

// NewUpdateSuggestedActions creates a new UpdateSuggestedActions
//
// @param addedActions Added suggested actions
// @param removedActions Removed suggested actions
func NewUpdateSuggestedActions(addedActions []SuggestedAction, removedActions []SuggestedAction) *UpdateSuggestedActions {
	updateSuggestedActionsTemp := UpdateSuggestedActions{
		tdCommon:       tdCommon{Type: "updateSuggestedActions"},
		AddedActions:   addedActions,
		RemovedActions: removedActions,
	}

	return &updateSuggestedActionsTemp
}

// UnmarshalJSON unmarshal to json
func (updateSuggestedActions *UpdateSuggestedActions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateSuggestedActions.tdCommon = tempObj.tdCommon

	fieldAddedActions, _ := unmarshalSuggestedActionSlice(objMap["added_actions"])
	updateSuggestedActions.AddedActions = fieldAddedActions

	fieldRemovedActions, _ := unmarshalSuggestedActionSlice(objMap["removed_actions"])
	updateSuggestedActions.RemovedActions = fieldRemovedActions

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateSuggestedActions *UpdateSuggestedActions) GetUpdateEnum() UpdateEnum {
	return UpdateSuggestedActionsType
}

// UpdateSpeedLimitNotification Download or upload file speed for the user was limited, but it can be restored by subscription to Telegram Premium. The notification can be postponed until a being downloaded or uploaded file is visible to the user Use getOption("premium_download_speedup") or getOption("premium_upload_speedup") to get expected speedup after subscription to Telegram Premium
type UpdateSpeedLimitNotification struct {
	tdCommon
	IsUpload bool `json:"is_upload"` // True, if upload speed was limited; false, if download speed was limited
}

// MessageType return the string telegram-type of UpdateSpeedLimitNotification
func (updateSpeedLimitNotification *UpdateSpeedLimitNotification) MessageType() string {
	return "updateSpeedLimitNotification"
}

// NewUpdateSpeedLimitNotification creates a new UpdateSpeedLimitNotification
//
// @param isUpload True, if upload speed was limited; false, if download speed was limited
func NewUpdateSpeedLimitNotification(isUpload bool) *UpdateSpeedLimitNotification {
	updateSpeedLimitNotificationTemp := UpdateSpeedLimitNotification{
		tdCommon: tdCommon{Type: "updateSpeedLimitNotification"},
		IsUpload: isUpload,
	}

	return &updateSpeedLimitNotificationTemp
}

// UnmarshalJSON unmarshal to json
func (updateSpeedLimitNotification *UpdateSpeedLimitNotification) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		IsUpload bool `json:"is_upload"` // True, if upload speed was limited; false, if download speed was limited
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateSpeedLimitNotification.tdCommon = tempObj.tdCommon
	updateSpeedLimitNotification.IsUpload = tempObj.IsUpload

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateSpeedLimitNotification *UpdateSpeedLimitNotification) GetUpdateEnum() UpdateEnum {
	return UpdateSpeedLimitNotificationType
}

// UpdateContactCloseBirthdays The list of contacts that had birthdays recently or will have birthday soon has changed
type UpdateContactCloseBirthdays struct {
	tdCommon
	CloseBirthdayUsers []CloseBirthdayUser `json:"close_birthday_users"` // List of contact users with close birthday
}

// MessageType return the string telegram-type of UpdateContactCloseBirthdays
func (updateContactCloseBirthdays *UpdateContactCloseBirthdays) MessageType() string {
	return "updateContactCloseBirthdays"
}

// NewUpdateContactCloseBirthdays creates a new UpdateContactCloseBirthdays
//
// @param closeBirthdayUsers List of contact users with close birthday
func NewUpdateContactCloseBirthdays(closeBirthdayUsers []CloseBirthdayUser) *UpdateContactCloseBirthdays {
	updateContactCloseBirthdaysTemp := UpdateContactCloseBirthdays{
		tdCommon:           tdCommon{Type: "updateContactCloseBirthdays"},
		CloseBirthdayUsers: closeBirthdayUsers,
	}

	return &updateContactCloseBirthdaysTemp
}

// UnmarshalJSON unmarshal to json
func (updateContactCloseBirthdays *UpdateContactCloseBirthdays) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		CloseBirthdayUsers []CloseBirthdayUser `json:"close_birthday_users"` // List of contact users with close birthday
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateContactCloseBirthdays.tdCommon = tempObj.tdCommon
	updateContactCloseBirthdays.CloseBirthdayUsers = tempObj.CloseBirthdayUsers

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateContactCloseBirthdays *UpdateContactCloseBirthdays) GetUpdateEnum() UpdateEnum {
	return UpdateContactCloseBirthdaysType
}

// UpdateAutosaveSettings Autosave settings for some type of chats were updated
type UpdateAutosaveSettings struct {
	tdCommon
	Scope    AutosaveSettingsScope  `json:"scope"`    // Type of chats for which autosave settings were updated
	Settings *ScopeAutosaveSettings `json:"settings"` // The new autosave settings; may be null if the settings are reset to default
}

// MessageType return the string telegram-type of UpdateAutosaveSettings
func (updateAutosaveSettings *UpdateAutosaveSettings) MessageType() string {
	return "updateAutosaveSettings"
}

// NewUpdateAutosaveSettings creates a new UpdateAutosaveSettings
//
// @param scope Type of chats for which autosave settings were updated
// @param settings The new autosave settings; may be null if the settings are reset to default
func NewUpdateAutosaveSettings(scope AutosaveSettingsScope, settings *ScopeAutosaveSettings) *UpdateAutosaveSettings {
	updateAutosaveSettingsTemp := UpdateAutosaveSettings{
		tdCommon: tdCommon{Type: "updateAutosaveSettings"},
		Scope:    scope,
		Settings: settings,
	}

	return &updateAutosaveSettingsTemp
}

// UnmarshalJSON unmarshal to json
func (updateAutosaveSettings *UpdateAutosaveSettings) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Settings *ScopeAutosaveSettings `json:"settings"` // The new autosave settings; may be null if the settings are reset to default
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateAutosaveSettings.tdCommon = tempObj.tdCommon
	updateAutosaveSettings.Settings = tempObj.Settings

	fieldScope, _ := unmarshalAutosaveSettingsScope(objMap["scope"])
	updateAutosaveSettings.Scope = fieldScope

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateAutosaveSettings *UpdateAutosaveSettings) GetUpdateEnum() UpdateEnum {
	return UpdateAutosaveSettingsType
}

// UpdateBusinessConnection A business connection has changed; for bots only
type UpdateBusinessConnection struct {
	tdCommon
	Connection *BusinessConnection `json:"connection"` // New data about the connection
}

// MessageType return the string telegram-type of UpdateBusinessConnection
func (updateBusinessConnection *UpdateBusinessConnection) MessageType() string {
	return "updateBusinessConnection"
}

// NewUpdateBusinessConnection creates a new UpdateBusinessConnection
//
// @param connection New data about the connection
func NewUpdateBusinessConnection(connection *BusinessConnection) *UpdateBusinessConnection {
	updateBusinessConnectionTemp := UpdateBusinessConnection{
		tdCommon:   tdCommon{Type: "updateBusinessConnection"},
		Connection: connection,
	}

	return &updateBusinessConnectionTemp
}

// UnmarshalJSON unmarshal to json
func (updateBusinessConnection *UpdateBusinessConnection) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Connection *BusinessConnection `json:"connection"` // New data about the connection
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateBusinessConnection.tdCommon = tempObj.tdCommon
	updateBusinessConnection.Connection = tempObj.Connection

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateBusinessConnection *UpdateBusinessConnection) GetUpdateEnum() UpdateEnum {
	return UpdateBusinessConnectionType
}

// UpdateNewBusinessMessage A new message was added to a business account; for bots only
type UpdateNewBusinessMessage struct {
	tdCommon
	ConnectionID string           `json:"connection_id"` // Unique identifier of the business connection
	Message      *BusinessMessage `json:"message"`       // The new message
}

// MessageType return the string telegram-type of UpdateNewBusinessMessage
func (updateNewBusinessMessage *UpdateNewBusinessMessage) MessageType() string {
	return "updateNewBusinessMessage"
}

// NewUpdateNewBusinessMessage creates a new UpdateNewBusinessMessage
//
// @param connectionID Unique identifier of the business connection
// @param message The new message
func NewUpdateNewBusinessMessage(connectionID string, message *BusinessMessage) *UpdateNewBusinessMessage {
	updateNewBusinessMessageTemp := UpdateNewBusinessMessage{
		tdCommon:     tdCommon{Type: "updateNewBusinessMessage"},
		ConnectionID: connectionID,
		Message:      message,
	}

	return &updateNewBusinessMessageTemp
}

// UnmarshalJSON unmarshal to json
func (updateNewBusinessMessage *UpdateNewBusinessMessage) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ConnectionID string           `json:"connection_id"` // Unique identifier of the business connection
		Message      *BusinessMessage `json:"message"`       // The new message
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateNewBusinessMessage.tdCommon = tempObj.tdCommon
	updateNewBusinessMessage.ConnectionID = tempObj.ConnectionID
	updateNewBusinessMessage.Message = tempObj.Message

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateNewBusinessMessage *UpdateNewBusinessMessage) GetUpdateEnum() UpdateEnum {
	return UpdateNewBusinessMessageType
}

// UpdateBusinessMessageEdited A message in a business account was edited; for bots only
type UpdateBusinessMessageEdited struct {
	tdCommon
	ConnectionID string           `json:"connection_id"` // Unique identifier of the business connection
	Message      *BusinessMessage `json:"message"`       // The edited message
}

// MessageType return the string telegram-type of UpdateBusinessMessageEdited
func (updateBusinessMessageEdited *UpdateBusinessMessageEdited) MessageType() string {
	return "updateBusinessMessageEdited"
}

// NewUpdateBusinessMessageEdited creates a new UpdateBusinessMessageEdited
//
// @param connectionID Unique identifier of the business connection
// @param message The edited message
func NewUpdateBusinessMessageEdited(connectionID string, message *BusinessMessage) *UpdateBusinessMessageEdited {
	updateBusinessMessageEditedTemp := UpdateBusinessMessageEdited{
		tdCommon:     tdCommon{Type: "updateBusinessMessageEdited"},
		ConnectionID: connectionID,
		Message:      message,
	}

	return &updateBusinessMessageEditedTemp
}

// UnmarshalJSON unmarshal to json
func (updateBusinessMessageEdited *UpdateBusinessMessageEdited) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ConnectionID string           `json:"connection_id"` // Unique identifier of the business connection
		Message      *BusinessMessage `json:"message"`       // The edited message
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateBusinessMessageEdited.tdCommon = tempObj.tdCommon
	updateBusinessMessageEdited.ConnectionID = tempObj.ConnectionID
	updateBusinessMessageEdited.Message = tempObj.Message

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateBusinessMessageEdited *UpdateBusinessMessageEdited) GetUpdateEnum() UpdateEnum {
	return UpdateBusinessMessageEditedType
}

// UpdateBusinessMessagesDeleted Messages in a business account were deleted; for bots only
type UpdateBusinessMessagesDeleted struct {
	tdCommon
	ConnectionID string  `json:"connection_id"` // Unique identifier of the business connection
	ChatID       int64   `json:"chat_id"`       // Identifier of a chat in the business account in which messages were deleted
	MessageIDs   []int64 `json:"message_ids"`   // Unique message identifiers of the deleted messages
}

// MessageType return the string telegram-type of UpdateBusinessMessagesDeleted
func (updateBusinessMessagesDeleted *UpdateBusinessMessagesDeleted) MessageType() string {
	return "updateBusinessMessagesDeleted"
}

// NewUpdateBusinessMessagesDeleted creates a new UpdateBusinessMessagesDeleted
//
// @param connectionID Unique identifier of the business connection
// @param chatID Identifier of a chat in the business account in which messages were deleted
// @param messageIDs Unique message identifiers of the deleted messages
func NewUpdateBusinessMessagesDeleted(connectionID string, chatID int64, messageIDs []int64) *UpdateBusinessMessagesDeleted {
	updateBusinessMessagesDeletedTemp := UpdateBusinessMessagesDeleted{
		tdCommon:     tdCommon{Type: "updateBusinessMessagesDeleted"},
		ConnectionID: connectionID,
		ChatID:       chatID,
		MessageIDs:   messageIDs,
	}

	return &updateBusinessMessagesDeletedTemp
}

// UnmarshalJSON unmarshal to json
func (updateBusinessMessagesDeleted *UpdateBusinessMessagesDeleted) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ConnectionID string  `json:"connection_id"` // Unique identifier of the business connection
		ChatID       int64   `json:"chat_id"`       // Identifier of a chat in the business account in which messages were deleted
		MessageIDs   []int64 `json:"message_ids"`   // Unique message identifiers of the deleted messages
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateBusinessMessagesDeleted.tdCommon = tempObj.tdCommon
	updateBusinessMessagesDeleted.ConnectionID = tempObj.ConnectionID
	updateBusinessMessagesDeleted.ChatID = tempObj.ChatID
	updateBusinessMessagesDeleted.MessageIDs = tempObj.MessageIDs

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateBusinessMessagesDeleted *UpdateBusinessMessagesDeleted) GetUpdateEnum() UpdateEnum {
	return UpdateBusinessMessagesDeletedType
}

// UpdateNewInlineQuery A new incoming inline query; for bots only
type UpdateNewInlineQuery struct {
	tdCommon
	ID           JSONInt64 `json:"id"`             // Unique query identifier
	SenderUserID int64     `json:"sender_user_id"` // Identifier of the user who sent the query
	UserLocation *Location `json:"user_location"`  // User location; may be null
	ChatType     *ChatType `json:"chat_type"`      // The type of the chat from which the query originated; may be null if unknown
	Query        string    `json:"query"`          // Text of the query
	Offset       string    `json:"offset"`         // Offset of the first entry to return
}

// MessageType return the string telegram-type of UpdateNewInlineQuery
func (updateNewInlineQuery *UpdateNewInlineQuery) MessageType() string {
	return "updateNewInlineQuery"
}

// NewUpdateNewInlineQuery creates a new UpdateNewInlineQuery
//
// @param iD Unique query identifier
// @param senderUserID Identifier of the user who sent the query
// @param userLocation User location; may be null
// @param chatType The type of the chat from which the query originated; may be null if unknown
// @param query Text of the query
// @param offset Offset of the first entry to return
func NewUpdateNewInlineQuery(iD JSONInt64, senderUserID int64, userLocation *Location, chatType *ChatType, query string, offset string) *UpdateNewInlineQuery {
	updateNewInlineQueryTemp := UpdateNewInlineQuery{
		tdCommon:     tdCommon{Type: "updateNewInlineQuery"},
		ID:           iD,
		SenderUserID: senderUserID,
		UserLocation: userLocation,
		ChatType:     chatType,
		Query:        query,
		Offset:       offset,
	}

	return &updateNewInlineQueryTemp
}

// UnmarshalJSON unmarshal to json
func (updateNewInlineQuery *UpdateNewInlineQuery) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID           JSONInt64 `json:"id"`             // Unique query identifier
		SenderUserID int64     `json:"sender_user_id"` // Identifier of the user who sent the query
		UserLocation *Location `json:"user_location"`  // User location; may be null
		Query        string    `json:"query"`          // Text of the query
		Offset       string    `json:"offset"`         // Offset of the first entry to return
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateNewInlineQuery.tdCommon = tempObj.tdCommon
	updateNewInlineQuery.ID = tempObj.ID
	updateNewInlineQuery.SenderUserID = tempObj.SenderUserID
	updateNewInlineQuery.UserLocation = tempObj.UserLocation
	updateNewInlineQuery.Query = tempObj.Query
	updateNewInlineQuery.Offset = tempObj.Offset

	fieldChatType, _ := unmarshalChatType(objMap["chat_type"])
	updateNewInlineQuery.ChatType = &fieldChatType

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateNewInlineQuery *UpdateNewInlineQuery) GetUpdateEnum() UpdateEnum {
	return UpdateNewInlineQueryType
}

// UpdateNewChosenInlineResult The user has chosen a result of an inline query; for bots only
type UpdateNewChosenInlineResult struct {
	tdCommon
	SenderUserID    int64     `json:"sender_user_id"`    // Identifier of the user who sent the query
	UserLocation    *Location `json:"user_location"`     // User location; may be null
	Query           string    `json:"query"`             // Text of the query
	ResultID        string    `json:"result_id"`         // Identifier of the chosen result
	InlineMessageID string    `json:"inline_message_id"` // Identifier of the sent inline message, if known
}

// MessageType return the string telegram-type of UpdateNewChosenInlineResult
func (updateNewChosenInlineResult *UpdateNewChosenInlineResult) MessageType() string {
	return "updateNewChosenInlineResult"
}

// NewUpdateNewChosenInlineResult creates a new UpdateNewChosenInlineResult
//
// @param senderUserID Identifier of the user who sent the query
// @param userLocation User location; may be null
// @param query Text of the query
// @param resultID Identifier of the chosen result
// @param inlineMessageID Identifier of the sent inline message, if known
func NewUpdateNewChosenInlineResult(senderUserID int64, userLocation *Location, query string, resultID string, inlineMessageID string) *UpdateNewChosenInlineResult {
	updateNewChosenInlineResultTemp := UpdateNewChosenInlineResult{
		tdCommon:        tdCommon{Type: "updateNewChosenInlineResult"},
		SenderUserID:    senderUserID,
		UserLocation:    userLocation,
		Query:           query,
		ResultID:        resultID,
		InlineMessageID: inlineMessageID,
	}

	return &updateNewChosenInlineResultTemp
}

// UnmarshalJSON unmarshal to json
func (updateNewChosenInlineResult *UpdateNewChosenInlineResult) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		SenderUserID    int64     `json:"sender_user_id"`    // Identifier of the user who sent the query
		UserLocation    *Location `json:"user_location"`     // User location; may be null
		Query           string    `json:"query"`             // Text of the query
		ResultID        string    `json:"result_id"`         // Identifier of the chosen result
		InlineMessageID string    `json:"inline_message_id"` // Identifier of the sent inline message, if known
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateNewChosenInlineResult.tdCommon = tempObj.tdCommon
	updateNewChosenInlineResult.SenderUserID = tempObj.SenderUserID
	updateNewChosenInlineResult.UserLocation = tempObj.UserLocation
	updateNewChosenInlineResult.Query = tempObj.Query
	updateNewChosenInlineResult.ResultID = tempObj.ResultID
	updateNewChosenInlineResult.InlineMessageID = tempObj.InlineMessageID

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateNewChosenInlineResult *UpdateNewChosenInlineResult) GetUpdateEnum() UpdateEnum {
	return UpdateNewChosenInlineResultType
}

// UpdateNewCallbackQuery A new incoming callback query; for bots only
type UpdateNewCallbackQuery struct {
	tdCommon
	ID           JSONInt64            `json:"id"`             // Unique query identifier
	SenderUserID int64                `json:"sender_user_id"` // Identifier of the user who sent the query
	ChatID       int64                `json:"chat_id"`        // Identifier of the chat where the query was sent
	MessageID    int64                `json:"message_id"`     // Identifier of the message from which the query originated
	ChatInstance JSONInt64            `json:"chat_instance"`  // Identifier that uniquely corresponds to the chat to which the message was sent
	Payload      CallbackQueryPayload `json:"payload"`        // Query payload
}

// MessageType return the string telegram-type of UpdateNewCallbackQuery
func (updateNewCallbackQuery *UpdateNewCallbackQuery) MessageType() string {
	return "updateNewCallbackQuery"
}

// NewUpdateNewCallbackQuery creates a new UpdateNewCallbackQuery
//
// @param iD Unique query identifier
// @param senderUserID Identifier of the user who sent the query
// @param chatID Identifier of the chat where the query was sent
// @param messageID Identifier of the message from which the query originated
// @param chatInstance Identifier that uniquely corresponds to the chat to which the message was sent
// @param payload Query payload
func NewUpdateNewCallbackQuery(iD JSONInt64, senderUserID int64, chatID int64, messageID int64, chatInstance JSONInt64, payload CallbackQueryPayload) *UpdateNewCallbackQuery {
	updateNewCallbackQueryTemp := UpdateNewCallbackQuery{
		tdCommon:     tdCommon{Type: "updateNewCallbackQuery"},
		ID:           iD,
		SenderUserID: senderUserID,
		ChatID:       chatID,
		MessageID:    messageID,
		ChatInstance: chatInstance,
		Payload:      payload,
	}

	return &updateNewCallbackQueryTemp
}

// UnmarshalJSON unmarshal to json
func (updateNewCallbackQuery *UpdateNewCallbackQuery) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID           JSONInt64 `json:"id"`             // Unique query identifier
		SenderUserID int64     `json:"sender_user_id"` // Identifier of the user who sent the query
		ChatID       int64     `json:"chat_id"`        // Identifier of the chat where the query was sent
		MessageID    int64     `json:"message_id"`     // Identifier of the message from which the query originated
		ChatInstance JSONInt64 `json:"chat_instance"`  // Identifier that uniquely corresponds to the chat to which the message was sent

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateNewCallbackQuery.tdCommon = tempObj.tdCommon
	updateNewCallbackQuery.ID = tempObj.ID
	updateNewCallbackQuery.SenderUserID = tempObj.SenderUserID
	updateNewCallbackQuery.ChatID = tempObj.ChatID
	updateNewCallbackQuery.MessageID = tempObj.MessageID
	updateNewCallbackQuery.ChatInstance = tempObj.ChatInstance

	fieldPayload, _ := unmarshalCallbackQueryPayload(objMap["payload"])
	updateNewCallbackQuery.Payload = fieldPayload

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateNewCallbackQuery *UpdateNewCallbackQuery) GetUpdateEnum() UpdateEnum {
	return UpdateNewCallbackQueryType
}

// UpdateNewInlineCallbackQuery A new incoming callback query from a message sent via a bot; for bots only
type UpdateNewInlineCallbackQuery struct {
	tdCommon
	ID              JSONInt64            `json:"id"`                // Unique query identifier
	SenderUserID    int64                `json:"sender_user_id"`    // Identifier of the user who sent the query
	InlineMessageID string               `json:"inline_message_id"` // Identifier of the inline message from which the query originated
	ChatInstance    JSONInt64            `json:"chat_instance"`     // An identifier uniquely corresponding to the chat a message was sent to
	Payload         CallbackQueryPayload `json:"payload"`           // Query payload
}

// MessageType return the string telegram-type of UpdateNewInlineCallbackQuery
func (updateNewInlineCallbackQuery *UpdateNewInlineCallbackQuery) MessageType() string {
	return "updateNewInlineCallbackQuery"
}

// NewUpdateNewInlineCallbackQuery creates a new UpdateNewInlineCallbackQuery
//
// @param iD Unique query identifier
// @param senderUserID Identifier of the user who sent the query
// @param inlineMessageID Identifier of the inline message from which the query originated
// @param chatInstance An identifier uniquely corresponding to the chat a message was sent to
// @param payload Query payload
func NewUpdateNewInlineCallbackQuery(iD JSONInt64, senderUserID int64, inlineMessageID string, chatInstance JSONInt64, payload CallbackQueryPayload) *UpdateNewInlineCallbackQuery {
	updateNewInlineCallbackQueryTemp := UpdateNewInlineCallbackQuery{
		tdCommon:        tdCommon{Type: "updateNewInlineCallbackQuery"},
		ID:              iD,
		SenderUserID:    senderUserID,
		InlineMessageID: inlineMessageID,
		ChatInstance:    chatInstance,
		Payload:         payload,
	}

	return &updateNewInlineCallbackQueryTemp
}

// UnmarshalJSON unmarshal to json
func (updateNewInlineCallbackQuery *UpdateNewInlineCallbackQuery) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID              JSONInt64 `json:"id"`                // Unique query identifier
		SenderUserID    int64     `json:"sender_user_id"`    // Identifier of the user who sent the query
		InlineMessageID string    `json:"inline_message_id"` // Identifier of the inline message from which the query originated
		ChatInstance    JSONInt64 `json:"chat_instance"`     // An identifier uniquely corresponding to the chat a message was sent to

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateNewInlineCallbackQuery.tdCommon = tempObj.tdCommon
	updateNewInlineCallbackQuery.ID = tempObj.ID
	updateNewInlineCallbackQuery.SenderUserID = tempObj.SenderUserID
	updateNewInlineCallbackQuery.InlineMessageID = tempObj.InlineMessageID
	updateNewInlineCallbackQuery.ChatInstance = tempObj.ChatInstance

	fieldPayload, _ := unmarshalCallbackQueryPayload(objMap["payload"])
	updateNewInlineCallbackQuery.Payload = fieldPayload

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateNewInlineCallbackQuery *UpdateNewInlineCallbackQuery) GetUpdateEnum() UpdateEnum {
	return UpdateNewInlineCallbackQueryType
}

// UpdateNewBusinessCallbackQuery A new incoming callback query from a business message; for bots only
type UpdateNewBusinessCallbackQuery struct {
	tdCommon
	ID           JSONInt64            `json:"id"`             // Unique query identifier
	SenderUserID int64                `json:"sender_user_id"` // Identifier of the user who sent the query
	ConnectionID string               `json:"connection_id"`  // Unique identifier of the business connection
	Message      *BusinessMessage     `json:"message"`        // The message from the business account from which the query originated
	ChatInstance JSONInt64            `json:"chat_instance"`  // An identifier uniquely corresponding to the chat a message was sent to
	Payload      CallbackQueryPayload `json:"payload"`        // Query payload
}

// MessageType return the string telegram-type of UpdateNewBusinessCallbackQuery
func (updateNewBusinessCallbackQuery *UpdateNewBusinessCallbackQuery) MessageType() string {
	return "updateNewBusinessCallbackQuery"
}

// NewUpdateNewBusinessCallbackQuery creates a new UpdateNewBusinessCallbackQuery
//
// @param iD Unique query identifier
// @param senderUserID Identifier of the user who sent the query
// @param connectionID Unique identifier of the business connection
// @param message The message from the business account from which the query originated
// @param chatInstance An identifier uniquely corresponding to the chat a message was sent to
// @param payload Query payload
func NewUpdateNewBusinessCallbackQuery(iD JSONInt64, senderUserID int64, connectionID string, message *BusinessMessage, chatInstance JSONInt64, payload CallbackQueryPayload) *UpdateNewBusinessCallbackQuery {
	updateNewBusinessCallbackQueryTemp := UpdateNewBusinessCallbackQuery{
		tdCommon:     tdCommon{Type: "updateNewBusinessCallbackQuery"},
		ID:           iD,
		SenderUserID: senderUserID,
		ConnectionID: connectionID,
		Message:      message,
		ChatInstance: chatInstance,
		Payload:      payload,
	}

	return &updateNewBusinessCallbackQueryTemp
}

// UnmarshalJSON unmarshal to json
func (updateNewBusinessCallbackQuery *UpdateNewBusinessCallbackQuery) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID           JSONInt64        `json:"id"`             // Unique query identifier
		SenderUserID int64            `json:"sender_user_id"` // Identifier of the user who sent the query
		ConnectionID string           `json:"connection_id"`  // Unique identifier of the business connection
		Message      *BusinessMessage `json:"message"`        // The message from the business account from which the query originated
		ChatInstance JSONInt64        `json:"chat_instance"`  // An identifier uniquely corresponding to the chat a message was sent to

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateNewBusinessCallbackQuery.tdCommon = tempObj.tdCommon
	updateNewBusinessCallbackQuery.ID = tempObj.ID
	updateNewBusinessCallbackQuery.SenderUserID = tempObj.SenderUserID
	updateNewBusinessCallbackQuery.ConnectionID = tempObj.ConnectionID
	updateNewBusinessCallbackQuery.Message = tempObj.Message
	updateNewBusinessCallbackQuery.ChatInstance = tempObj.ChatInstance

	fieldPayload, _ := unmarshalCallbackQueryPayload(objMap["payload"])
	updateNewBusinessCallbackQuery.Payload = fieldPayload

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateNewBusinessCallbackQuery *UpdateNewBusinessCallbackQuery) GetUpdateEnum() UpdateEnum {
	return UpdateNewBusinessCallbackQueryType
}

// UpdateNewShippingQuery A new incoming shipping query; for bots only. Only for invoices with flexible price
type UpdateNewShippingQuery struct {
	tdCommon
	ID              JSONInt64 `json:"id"`               // Unique query identifier
	SenderUserID    int64     `json:"sender_user_id"`   // Identifier of the user who sent the query
	InvoicePayload  string    `json:"invoice_payload"`  // Invoice payload
	ShippingAddress *Address  `json:"shipping_address"` // User shipping address
}

// MessageType return the string telegram-type of UpdateNewShippingQuery
func (updateNewShippingQuery *UpdateNewShippingQuery) MessageType() string {
	return "updateNewShippingQuery"
}

// NewUpdateNewShippingQuery creates a new UpdateNewShippingQuery
//
// @param iD Unique query identifier
// @param senderUserID Identifier of the user who sent the query
// @param invoicePayload Invoice payload
// @param shippingAddress User shipping address
func NewUpdateNewShippingQuery(iD JSONInt64, senderUserID int64, invoicePayload string, shippingAddress *Address) *UpdateNewShippingQuery {
	updateNewShippingQueryTemp := UpdateNewShippingQuery{
		tdCommon:        tdCommon{Type: "updateNewShippingQuery"},
		ID:              iD,
		SenderUserID:    senderUserID,
		InvoicePayload:  invoicePayload,
		ShippingAddress: shippingAddress,
	}

	return &updateNewShippingQueryTemp
}

// UnmarshalJSON unmarshal to json
func (updateNewShippingQuery *UpdateNewShippingQuery) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID              JSONInt64 `json:"id"`               // Unique query identifier
		SenderUserID    int64     `json:"sender_user_id"`   // Identifier of the user who sent the query
		InvoicePayload  string    `json:"invoice_payload"`  // Invoice payload
		ShippingAddress *Address  `json:"shipping_address"` // User shipping address
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateNewShippingQuery.tdCommon = tempObj.tdCommon
	updateNewShippingQuery.ID = tempObj.ID
	updateNewShippingQuery.SenderUserID = tempObj.SenderUserID
	updateNewShippingQuery.InvoicePayload = tempObj.InvoicePayload
	updateNewShippingQuery.ShippingAddress = tempObj.ShippingAddress

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateNewShippingQuery *UpdateNewShippingQuery) GetUpdateEnum() UpdateEnum {
	return UpdateNewShippingQueryType
}

// UpdateNewPreCheckoutQuery A new incoming pre-checkout query; for bots only. Contains full information about a checkout
type UpdateNewPreCheckoutQuery struct {
	tdCommon
	ID               JSONInt64  `json:"id"`                 // Unique query identifier
	SenderUserID     int64      `json:"sender_user_id"`     // Identifier of the user who sent the query
	Currency         string     `json:"currency"`           // Currency for the product price
	TotalAmount      int64      `json:"total_amount"`       // Total price for the product, in the smallest units of the currency
	InvoicePayload   []byte     `json:"invoice_payload"`    // Invoice payload
	ShippingOptionID string     `json:"shipping_option_id"` // Identifier of a shipping option chosen by the user; may be empty if not applicable
	OrderInfo        *OrderInfo `json:"order_info"`         // Information about the order; may be null
}

// MessageType return the string telegram-type of UpdateNewPreCheckoutQuery
func (updateNewPreCheckoutQuery *UpdateNewPreCheckoutQuery) MessageType() string {
	return "updateNewPreCheckoutQuery"
}

// NewUpdateNewPreCheckoutQuery creates a new UpdateNewPreCheckoutQuery
//
// @param iD Unique query identifier
// @param senderUserID Identifier of the user who sent the query
// @param currency Currency for the product price
// @param totalAmount Total price for the product, in the smallest units of the currency
// @param invoicePayload Invoice payload
// @param shippingOptionID Identifier of a shipping option chosen by the user; may be empty if not applicable
// @param orderInfo Information about the order; may be null
func NewUpdateNewPreCheckoutQuery(iD JSONInt64, senderUserID int64, currency string, totalAmount int64, invoicePayload []byte, shippingOptionID string, orderInfo *OrderInfo) *UpdateNewPreCheckoutQuery {
	updateNewPreCheckoutQueryTemp := UpdateNewPreCheckoutQuery{
		tdCommon:         tdCommon{Type: "updateNewPreCheckoutQuery"},
		ID:               iD,
		SenderUserID:     senderUserID,
		Currency:         currency,
		TotalAmount:      totalAmount,
		InvoicePayload:   invoicePayload,
		ShippingOptionID: shippingOptionID,
		OrderInfo:        orderInfo,
	}

	return &updateNewPreCheckoutQueryTemp
}

// UnmarshalJSON unmarshal to json
func (updateNewPreCheckoutQuery *UpdateNewPreCheckoutQuery) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID               JSONInt64  `json:"id"`                 // Unique query identifier
		SenderUserID     int64      `json:"sender_user_id"`     // Identifier of the user who sent the query
		Currency         string     `json:"currency"`           // Currency for the product price
		TotalAmount      int64      `json:"total_amount"`       // Total price for the product, in the smallest units of the currency
		InvoicePayload   []byte     `json:"invoice_payload"`    // Invoice payload
		ShippingOptionID string     `json:"shipping_option_id"` // Identifier of a shipping option chosen by the user; may be empty if not applicable
		OrderInfo        *OrderInfo `json:"order_info"`         // Information about the order; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateNewPreCheckoutQuery.tdCommon = tempObj.tdCommon
	updateNewPreCheckoutQuery.ID = tempObj.ID
	updateNewPreCheckoutQuery.SenderUserID = tempObj.SenderUserID
	updateNewPreCheckoutQuery.Currency = tempObj.Currency
	updateNewPreCheckoutQuery.TotalAmount = tempObj.TotalAmount
	updateNewPreCheckoutQuery.InvoicePayload = tempObj.InvoicePayload
	updateNewPreCheckoutQuery.ShippingOptionID = tempObj.ShippingOptionID
	updateNewPreCheckoutQuery.OrderInfo = tempObj.OrderInfo

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateNewPreCheckoutQuery *UpdateNewPreCheckoutQuery) GetUpdateEnum() UpdateEnum {
	return UpdateNewPreCheckoutQueryType
}

// UpdateNewCustomEvent A new incoming event; for bots only
type UpdateNewCustomEvent struct {
	tdCommon
	Event string `json:"event"` // A JSON-serialized event
}

// MessageType return the string telegram-type of UpdateNewCustomEvent
func (updateNewCustomEvent *UpdateNewCustomEvent) MessageType() string {
	return "updateNewCustomEvent"
}

// NewUpdateNewCustomEvent creates a new UpdateNewCustomEvent
//
// @param event A JSON-serialized event
func NewUpdateNewCustomEvent(event string) *UpdateNewCustomEvent {
	updateNewCustomEventTemp := UpdateNewCustomEvent{
		tdCommon: tdCommon{Type: "updateNewCustomEvent"},
		Event:    event,
	}

	return &updateNewCustomEventTemp
}

// UnmarshalJSON unmarshal to json
func (updateNewCustomEvent *UpdateNewCustomEvent) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Event string `json:"event"` // A JSON-serialized event
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateNewCustomEvent.tdCommon = tempObj.tdCommon
	updateNewCustomEvent.Event = tempObj.Event

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateNewCustomEvent *UpdateNewCustomEvent) GetUpdateEnum() UpdateEnum {
	return UpdateNewCustomEventType
}

// UpdateNewCustomQuery A new incoming query; for bots only
type UpdateNewCustomQuery struct {
	tdCommon
	ID      JSONInt64 `json:"id"`      // The query identifier
	Data    string    `json:"data"`    // JSON-serialized query data
	Timeout int32     `json:"timeout"` // Query timeout
}

// MessageType return the string telegram-type of UpdateNewCustomQuery
func (updateNewCustomQuery *UpdateNewCustomQuery) MessageType() string {
	return "updateNewCustomQuery"
}

// NewUpdateNewCustomQuery creates a new UpdateNewCustomQuery
//
// @param iD The query identifier
// @param data JSON-serialized query data
// @param timeout Query timeout
func NewUpdateNewCustomQuery(iD JSONInt64, data string, timeout int32) *UpdateNewCustomQuery {
	updateNewCustomQueryTemp := UpdateNewCustomQuery{
		tdCommon: tdCommon{Type: "updateNewCustomQuery"},
		ID:       iD,
		Data:     data,
		Timeout:  timeout,
	}

	return &updateNewCustomQueryTemp
}

// UnmarshalJSON unmarshal to json
func (updateNewCustomQuery *UpdateNewCustomQuery) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ID      JSONInt64 `json:"id"`      // The query identifier
		Data    string    `json:"data"`    // JSON-serialized query data
		Timeout int32     `json:"timeout"` // Query timeout
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateNewCustomQuery.tdCommon = tempObj.tdCommon
	updateNewCustomQuery.ID = tempObj.ID
	updateNewCustomQuery.Data = tempObj.Data
	updateNewCustomQuery.Timeout = tempObj.Timeout

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateNewCustomQuery *UpdateNewCustomQuery) GetUpdateEnum() UpdateEnum {
	return UpdateNewCustomQueryType
}

// UpdatePoll A poll was updated; for bots only
type UpdatePoll struct {
	tdCommon
	Poll *Poll `json:"poll"` // New data about the poll
}

// MessageType return the string telegram-type of UpdatePoll
func (updatePoll *UpdatePoll) MessageType() string {
	return "updatePoll"
}

// NewUpdatePoll creates a new UpdatePoll
//
// @param poll New data about the poll
func NewUpdatePoll(poll *Poll) *UpdatePoll {
	updatePollTemp := UpdatePoll{
		tdCommon: tdCommon{Type: "updatePoll"},
		Poll:     poll,
	}

	return &updatePollTemp
}

// UnmarshalJSON unmarshal to json
func (updatePoll *UpdatePoll) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updatePoll.tdCommon = tempObj.tdCommon

	var poll Poll
	if objMap["poll"] != nil {
		err = poll.UnmarshalJSON(*objMap["poll"])
		if err != nil {
			return err
		}
	}

	updatePoll.Poll = &poll

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updatePoll *UpdatePoll) GetUpdateEnum() UpdateEnum {
	return UpdatePollType
}

// UpdatePollAnswer A user changed the answer to a poll; for bots only
type UpdatePollAnswer struct {
	tdCommon
	PollID    JSONInt64     `json:"poll_id"`    // Unique poll identifier
	VoterID   MessageSender `json:"voter_id"`   // Identifier of the message sender that changed the answer to the poll
	OptionIDs []int32       `json:"option_ids"` // 0-based identifiers of answer options, chosen by the user
}

// MessageType return the string telegram-type of UpdatePollAnswer
func (updatePollAnswer *UpdatePollAnswer) MessageType() string {
	return "updatePollAnswer"
}

// NewUpdatePollAnswer creates a new UpdatePollAnswer
//
// @param pollID Unique poll identifier
// @param voterID Identifier of the message sender that changed the answer to the poll
// @param optionIDs 0-based identifiers of answer options, chosen by the user
func NewUpdatePollAnswer(pollID JSONInt64, voterID MessageSender, optionIDs []int32) *UpdatePollAnswer {
	updatePollAnswerTemp := UpdatePollAnswer{
		tdCommon:  tdCommon{Type: "updatePollAnswer"},
		PollID:    pollID,
		VoterID:   voterID,
		OptionIDs: optionIDs,
	}

	return &updatePollAnswerTemp
}

// UnmarshalJSON unmarshal to json
func (updatePollAnswer *UpdatePollAnswer) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		PollID    JSONInt64 `json:"poll_id"`    // Unique poll identifier
		OptionIDs []int32   `json:"option_ids"` // 0-based identifiers of answer options, chosen by the user
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updatePollAnswer.tdCommon = tempObj.tdCommon
	updatePollAnswer.PollID = tempObj.PollID
	updatePollAnswer.OptionIDs = tempObj.OptionIDs

	fieldVoterID, _ := unmarshalMessageSender(objMap["voter_id"])
	updatePollAnswer.VoterID = fieldVoterID

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updatePollAnswer *UpdatePollAnswer) GetUpdateEnum() UpdateEnum {
	return UpdatePollAnswerType
}

// UpdateChatMember User rights changed in a chat; for bots only
type UpdateChatMember struct {
	tdCommon
	ChatID                  int64           `json:"chat_id"`                     // Chat identifier
	ActorUserID             int64           `json:"actor_user_id"`               // Identifier of the user, changing the rights
	Date                    int32           `json:"date"`                        // Point in time (Unix timestamp) when the user rights were changed
	InviteLink              *ChatInviteLink `json:"invite_link"`                 // If user has joined the chat using an invite link, the invite link; may be null
	ViaJoinRequest          bool            `json:"via_join_request"`            // True, if the user has joined the chat after sending a join request and being approved by an administrator
	ViaChatFolderInviteLink bool            `json:"via_chat_folder_invite_link"` // True, if the user has joined the chat using an invite link for a chat folder
	OldChatMember           *ChatMember     `json:"old_chat_member"`             // Previous chat member
	NewChatMember           *ChatMember     `json:"new_chat_member"`             // New chat member
}

// MessageType return the string telegram-type of UpdateChatMember
func (updateChatMember *UpdateChatMember) MessageType() string {
	return "updateChatMember"
}

// NewUpdateChatMember creates a new UpdateChatMember
//
// @param chatID Chat identifier
// @param actorUserID Identifier of the user, changing the rights
// @param date Point in time (Unix timestamp) when the user rights were changed
// @param inviteLink If user has joined the chat using an invite link, the invite link; may be null
// @param viaJoinRequest True, if the user has joined the chat after sending a join request and being approved by an administrator
// @param viaChatFolderInviteLink True, if the user has joined the chat using an invite link for a chat folder
// @param oldChatMember Previous chat member
// @param newChatMember New chat member
func NewUpdateChatMember(chatID int64, actorUserID int64, date int32, inviteLink *ChatInviteLink, viaJoinRequest bool, viaChatFolderInviteLink bool, oldChatMember *ChatMember, newChatMember *ChatMember) *UpdateChatMember {
	updateChatMemberTemp := UpdateChatMember{
		tdCommon:                tdCommon{Type: "updateChatMember"},
		ChatID:                  chatID,
		ActorUserID:             actorUserID,
		Date:                    date,
		InviteLink:              inviteLink,
		ViaJoinRequest:          viaJoinRequest,
		ViaChatFolderInviteLink: viaChatFolderInviteLink,
		OldChatMember:           oldChatMember,
		NewChatMember:           newChatMember,
	}

	return &updateChatMemberTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatMember *UpdateChatMember) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID                  int64           `json:"chat_id"`                     // Chat identifier
		ActorUserID             int64           `json:"actor_user_id"`               // Identifier of the user, changing the rights
		Date                    int32           `json:"date"`                        // Point in time (Unix timestamp) when the user rights were changed
		InviteLink              *ChatInviteLink `json:"invite_link"`                 // If user has joined the chat using an invite link, the invite link; may be null
		ViaJoinRequest          bool            `json:"via_join_request"`            // True, if the user has joined the chat after sending a join request and being approved by an administrator
		ViaChatFolderInviteLink bool            `json:"via_chat_folder_invite_link"` // True, if the user has joined the chat using an invite link for a chat folder

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatMember.tdCommon = tempObj.tdCommon
	updateChatMember.ChatID = tempObj.ChatID
	updateChatMember.ActorUserID = tempObj.ActorUserID
	updateChatMember.Date = tempObj.Date
	updateChatMember.InviteLink = tempObj.InviteLink
	updateChatMember.ViaJoinRequest = tempObj.ViaJoinRequest
	updateChatMember.ViaChatFolderInviteLink = tempObj.ViaChatFolderInviteLink

	var oldChatMember ChatMember
	if objMap["old_chat_member"] != nil {
		err = oldChatMember.UnmarshalJSON(*objMap["old_chat_member"])
		if err != nil {
			return err
		}
	}

	updateChatMember.OldChatMember = &oldChatMember

	var newChatMember ChatMember
	if objMap["new_chat_member"] != nil {
		err = newChatMember.UnmarshalJSON(*objMap["new_chat_member"])
		if err != nil {
			return err
		}
	}

	updateChatMember.NewChatMember = &newChatMember

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatMember *UpdateChatMember) GetUpdateEnum() UpdateEnum {
	return UpdateChatMemberType
}

// UpdateNewChatJoinRequest A user sent a join request to a chat; for bots only
type UpdateNewChatJoinRequest struct {
	tdCommon
	ChatID     int64            `json:"chat_id"`      // Chat identifier
	Request    *ChatJoinRequest `json:"request"`      // Join request
	UserChatID int64            `json:"user_chat_id"` // Chat identifier of the private chat with the user
	InviteLink *ChatInviteLink  `json:"invite_link"`  // The invite link, which was used to send join request; may be null
}

// MessageType return the string telegram-type of UpdateNewChatJoinRequest
func (updateNewChatJoinRequest *UpdateNewChatJoinRequest) MessageType() string {
	return "updateNewChatJoinRequest"
}

// NewUpdateNewChatJoinRequest creates a new UpdateNewChatJoinRequest
//
// @param chatID Chat identifier
// @param request Join request
// @param userChatID Chat identifier of the private chat with the user
// @param inviteLink The invite link, which was used to send join request; may be null
func NewUpdateNewChatJoinRequest(chatID int64, request *ChatJoinRequest, userChatID int64, inviteLink *ChatInviteLink) *UpdateNewChatJoinRequest {
	updateNewChatJoinRequestTemp := UpdateNewChatJoinRequest{
		tdCommon:   tdCommon{Type: "updateNewChatJoinRequest"},
		ChatID:     chatID,
		Request:    request,
		UserChatID: userChatID,
		InviteLink: inviteLink,
	}

	return &updateNewChatJoinRequestTemp
}

// UnmarshalJSON unmarshal to json
func (updateNewChatJoinRequest *UpdateNewChatJoinRequest) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID     int64            `json:"chat_id"`      // Chat identifier
		Request    *ChatJoinRequest `json:"request"`      // Join request
		UserChatID int64            `json:"user_chat_id"` // Chat identifier of the private chat with the user
		InviteLink *ChatInviteLink  `json:"invite_link"`  // The invite link, which was used to send join request; may be null
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateNewChatJoinRequest.tdCommon = tempObj.tdCommon
	updateNewChatJoinRequest.ChatID = tempObj.ChatID
	updateNewChatJoinRequest.Request = tempObj.Request
	updateNewChatJoinRequest.UserChatID = tempObj.UserChatID
	updateNewChatJoinRequest.InviteLink = tempObj.InviteLink

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateNewChatJoinRequest *UpdateNewChatJoinRequest) GetUpdateEnum() UpdateEnum {
	return UpdateNewChatJoinRequestType
}

// UpdateChatBoost A chat boost has changed; for bots only
type UpdateChatBoost struct {
	tdCommon
	ChatID int64      `json:"chat_id"` // Chat identifier
	Boost  *ChatBoost `json:"boost"`   // New information about the boost
}

// MessageType return the string telegram-type of UpdateChatBoost
func (updateChatBoost *UpdateChatBoost) MessageType() string {
	return "updateChatBoost"
}

// NewUpdateChatBoost creates a new UpdateChatBoost
//
// @param chatID Chat identifier
// @param boost New information about the boost
func NewUpdateChatBoost(chatID int64, boost *ChatBoost) *UpdateChatBoost {
	updateChatBoostTemp := UpdateChatBoost{
		tdCommon: tdCommon{Type: "updateChatBoost"},
		ChatID:   chatID,
		Boost:    boost,
	}

	return &updateChatBoostTemp
}

// UnmarshalJSON unmarshal to json
func (updateChatBoost *UpdateChatBoost) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID int64 `json:"chat_id"` // Chat identifier

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateChatBoost.tdCommon = tempObj.tdCommon
	updateChatBoost.ChatID = tempObj.ChatID

	var boost ChatBoost
	if objMap["boost"] != nil {
		err = boost.UnmarshalJSON(*objMap["boost"])
		if err != nil {
			return err
		}
	}

	updateChatBoost.Boost = &boost

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateChatBoost *UpdateChatBoost) GetUpdateEnum() UpdateEnum {
	return UpdateChatBoostType
}

// UpdateMessageReaction User changed its reactions on a message with public reactions; for bots only
type UpdateMessageReaction struct {
	tdCommon
	ChatID           int64          `json:"chat_id"`            // Chat identifier
	MessageID        int64          `json:"message_id"`         // Message identifier
	ActorID          MessageSender  `json:"actor_id"`           // Identifier of the user or chat that changed reactions
	Date             int32          `json:"date"`               // Point in time (Unix timestamp) when the reactions were changed
	OldReactionTypes []ReactionType `json:"old_reaction_types"` // Old list of chosen reactions
	NewReactionTypes []ReactionType `json:"new_reaction_types"` // New list of chosen reactions
}

// MessageType return the string telegram-type of UpdateMessageReaction
func (updateMessageReaction *UpdateMessageReaction) MessageType() string {
	return "updateMessageReaction"
}

// NewUpdateMessageReaction creates a new UpdateMessageReaction
//
// @param chatID Chat identifier
// @param messageID Message identifier
// @param actorID Identifier of the user or chat that changed reactions
// @param date Point in time (Unix timestamp) when the reactions were changed
// @param oldReactionTypes Old list of chosen reactions
// @param newReactionTypes New list of chosen reactions
func NewUpdateMessageReaction(chatID int64, messageID int64, actorID MessageSender, date int32, oldReactionTypes []ReactionType, newReactionTypes []ReactionType) *UpdateMessageReaction {
	updateMessageReactionTemp := UpdateMessageReaction{
		tdCommon:         tdCommon{Type: "updateMessageReaction"},
		ChatID:           chatID,
		MessageID:        messageID,
		ActorID:          actorID,
		Date:             date,
		OldReactionTypes: oldReactionTypes,
		NewReactionTypes: newReactionTypes,
	}

	return &updateMessageReactionTemp
}

// UnmarshalJSON unmarshal to json
func (updateMessageReaction *UpdateMessageReaction) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID    int64 `json:"chat_id"`    // Chat identifier
		MessageID int64 `json:"message_id"` // Message identifier
		Date      int32 `json:"date"`       // Point in time (Unix timestamp) when the reactions were changed

	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateMessageReaction.tdCommon = tempObj.tdCommon
	updateMessageReaction.ChatID = tempObj.ChatID
	updateMessageReaction.MessageID = tempObj.MessageID
	updateMessageReaction.Date = tempObj.Date

	fieldActorID, _ := unmarshalMessageSender(objMap["actor_id"])
	updateMessageReaction.ActorID = fieldActorID

	fieldOldReactionTypes, _ := unmarshalReactionTypeSlice(objMap["old_reaction_types"])
	updateMessageReaction.OldReactionTypes = fieldOldReactionTypes

	fieldNewReactionTypes, _ := unmarshalReactionTypeSlice(objMap["new_reaction_types"])
	updateMessageReaction.NewReactionTypes = fieldNewReactionTypes

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateMessageReaction *UpdateMessageReaction) GetUpdateEnum() UpdateEnum {
	return UpdateMessageReactionType
}

// UpdateMessageReactions Reactions added to a message with anonymous reactions have changed; for bots only
type UpdateMessageReactions struct {
	tdCommon
	ChatID    int64             `json:"chat_id"`    // Chat identifier
	MessageID int64             `json:"message_id"` // Message identifier
	Date      int32             `json:"date"`       // Point in time (Unix timestamp) when the reactions were changed
	Reactions []MessageReaction `json:"reactions"`  // The list of reactions added to the message
}

// MessageType return the string telegram-type of UpdateMessageReactions
func (updateMessageReactions *UpdateMessageReactions) MessageType() string {
	return "updateMessageReactions"
}

// NewUpdateMessageReactions creates a new UpdateMessageReactions
//
// @param chatID Chat identifier
// @param messageID Message identifier
// @param date Point in time (Unix timestamp) when the reactions were changed
// @param reactions The list of reactions added to the message
func NewUpdateMessageReactions(chatID int64, messageID int64, date int32, reactions []MessageReaction) *UpdateMessageReactions {
	updateMessageReactionsTemp := UpdateMessageReactions{
		tdCommon:  tdCommon{Type: "updateMessageReactions"},
		ChatID:    chatID,
		MessageID: messageID,
		Date:      date,
		Reactions: reactions,
	}

	return &updateMessageReactionsTemp
}

// UnmarshalJSON unmarshal to json
func (updateMessageReactions *UpdateMessageReactions) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		ChatID    int64             `json:"chat_id"`    // Chat identifier
		MessageID int64             `json:"message_id"` // Message identifier
		Date      int32             `json:"date"`       // Point in time (Unix timestamp) when the reactions were changed
		Reactions []MessageReaction `json:"reactions"`  // The list of reactions added to the message
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updateMessageReactions.tdCommon = tempObj.tdCommon
	updateMessageReactions.ChatID = tempObj.ChatID
	updateMessageReactions.MessageID = tempObj.MessageID
	updateMessageReactions.Date = tempObj.Date
	updateMessageReactions.Reactions = tempObj.Reactions

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updateMessageReactions *UpdateMessageReactions) GetUpdateEnum() UpdateEnum {
	return UpdateMessageReactionsType
}

// UpdatePaidMediaPurchased Paid media were purchased by a user; for bots only
type UpdatePaidMediaPurchased struct {
	tdCommon
	UserID  int64  `json:"user_id"` // User identifier
	Payload string `json:"payload"` // Bot-specified payload for the paid media
}

// MessageType return the string telegram-type of UpdatePaidMediaPurchased
func (updatePaidMediaPurchased *UpdatePaidMediaPurchased) MessageType() string {
	return "updatePaidMediaPurchased"
}

// NewUpdatePaidMediaPurchased creates a new UpdatePaidMediaPurchased
//
// @param userID User identifier
// @param payload Bot-specified payload for the paid media
func NewUpdatePaidMediaPurchased(userID int64, payload string) *UpdatePaidMediaPurchased {
	updatePaidMediaPurchasedTemp := UpdatePaidMediaPurchased{
		tdCommon: tdCommon{Type: "updatePaidMediaPurchased"},
		UserID:   userID,
		Payload:  payload,
	}

	return &updatePaidMediaPurchasedTemp
}

// UnmarshalJSON unmarshal to json
func (updatePaidMediaPurchased *UpdatePaidMediaPurchased) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		UserID  int64  `json:"user_id"` // User identifier
		Payload string `json:"payload"` // Bot-specified payload for the paid media
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updatePaidMediaPurchased.tdCommon = tempObj.tdCommon
	updatePaidMediaPurchased.UserID = tempObj.UserID
	updatePaidMediaPurchased.Payload = tempObj.Payload

	return nil
}

// GetUpdateEnum return the enum type of this object
func (updatePaidMediaPurchased *UpdatePaidMediaPurchased) GetUpdateEnum() UpdateEnum {
	return UpdatePaidMediaPurchasedType
}

// Updates Contains a list of updates
type Updates struct {
	tdCommon
	Updates []Update `json:"updates"` // List of updates
}

// MessageType return the string telegram-type of Updates
func (updates *Updates) MessageType() string {
	return "updates"
}

// NewUpdates creates a new Updates
//
// @param updates List of updates
func NewUpdates(updates []Update) *Updates {
	updatesTemp := Updates{
		tdCommon: tdCommon{Type: "updates"},
		Updates:  updates,
	}

	return &updatesTemp
}

// UnmarshalJSON unmarshal to json
func (updates *Updates) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	updates.tdCommon = tempObj.tdCommon

	fieldUpdates, _ := unmarshalUpdateSlice(objMap["updates"])
	updates.Updates = fieldUpdates

	return nil
}

// LogStreamDefault The log is written to stderr or an OS specific log
type LogStreamDefault struct {
	tdCommon
}

// MessageType return the string telegram-type of LogStreamDefault
func (logStreamDefault *LogStreamDefault) MessageType() string {
	return "logStreamDefault"
}

// NewLogStreamDefault creates a new LogStreamDefault
//
func NewLogStreamDefault() *LogStreamDefault {
	logStreamDefaultTemp := LogStreamDefault{
		tdCommon: tdCommon{Type: "logStreamDefault"},
	}

	return &logStreamDefaultTemp
}

// UnmarshalJSON unmarshal to json
func (logStreamDefault *LogStreamDefault) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	logStreamDefault.tdCommon = tempObj.tdCommon

	return nil
}

// GetLogStreamEnum return the enum type of this object
func (logStreamDefault *LogStreamDefault) GetLogStreamEnum() LogStreamEnum {
	return LogStreamDefaultType
}

// LogStreamFile The log is written to a file
type LogStreamFile struct {
	tdCommon
	Path           string `json:"path"`            // Path to the file to where the internal TDLib log will be written
	MaxFileSize    int64  `json:"max_file_size"`   // The maximum size of the file to where the internal TDLib log is written before the file will automatically be rotated, in bytes
	RedirectStderr bool   `json:"redirect_stderr"` // Pass true to additionally redirect stderr to the log file. Ignored on Windows
}

// MessageType return the string telegram-type of LogStreamFile
func (logStreamFile *LogStreamFile) MessageType() string {
	return "logStreamFile"
}

// NewLogStreamFile creates a new LogStreamFile
//
// @param path Path to the file to where the internal TDLib log will be written
// @param maxFileSize The maximum size of the file to where the internal TDLib log is written before the file will automatically be rotated, in bytes
// @param redirectStderr Pass true to additionally redirect stderr to the log file. Ignored on Windows
func NewLogStreamFile(path string, maxFileSize int64, redirectStderr bool) *LogStreamFile {
	logStreamFileTemp := LogStreamFile{
		tdCommon:       tdCommon{Type: "logStreamFile"},
		Path:           path,
		MaxFileSize:    maxFileSize,
		RedirectStderr: redirectStderr,
	}

	return &logStreamFileTemp
}

// UnmarshalJSON unmarshal to json
func (logStreamFile *LogStreamFile) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Path           string `json:"path"`            // Path to the file to where the internal TDLib log will be written
		MaxFileSize    int64  `json:"max_file_size"`   // The maximum size of the file to where the internal TDLib log is written before the file will automatically be rotated, in bytes
		RedirectStderr bool   `json:"redirect_stderr"` // Pass true to additionally redirect stderr to the log file. Ignored on Windows
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	logStreamFile.tdCommon = tempObj.tdCommon
	logStreamFile.Path = tempObj.Path
	logStreamFile.MaxFileSize = tempObj.MaxFileSize
	logStreamFile.RedirectStderr = tempObj.RedirectStderr

	return nil
}

// GetLogStreamEnum return the enum type of this object
func (logStreamFile *LogStreamFile) GetLogStreamEnum() LogStreamEnum {
	return LogStreamFileType
}

// LogStreamEmpty The log is written nowhere
type LogStreamEmpty struct {
	tdCommon
}

// MessageType return the string telegram-type of LogStreamEmpty
func (logStreamEmpty *LogStreamEmpty) MessageType() string {
	return "logStreamEmpty"
}

// NewLogStreamEmpty creates a new LogStreamEmpty
//
func NewLogStreamEmpty() *LogStreamEmpty {
	logStreamEmptyTemp := LogStreamEmpty{
		tdCommon: tdCommon{Type: "logStreamEmpty"},
	}

	return &logStreamEmptyTemp
}

// UnmarshalJSON unmarshal to json
func (logStreamEmpty *LogStreamEmpty) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	logStreamEmpty.tdCommon = tempObj.tdCommon

	return nil
}

// GetLogStreamEnum return the enum type of this object
func (logStreamEmpty *LogStreamEmpty) GetLogStreamEnum() LogStreamEnum {
	return LogStreamEmptyType
}

// LogVerbosityLevel Contains a TDLib internal log verbosity level
type LogVerbosityLevel struct {
	tdCommon
	VerbosityLevel int32 `json:"verbosity_level"` // Log verbosity level
}

// MessageType return the string telegram-type of LogVerbosityLevel
func (logVerbosityLevel *LogVerbosityLevel) MessageType() string {
	return "logVerbosityLevel"
}

// NewLogVerbosityLevel creates a new LogVerbosityLevel
//
// @param verbosityLevel Log verbosity level
func NewLogVerbosityLevel(verbosityLevel int32) *LogVerbosityLevel {
	logVerbosityLevelTemp := LogVerbosityLevel{
		tdCommon:       tdCommon{Type: "logVerbosityLevel"},
		VerbosityLevel: verbosityLevel,
	}

	return &logVerbosityLevelTemp
}

// UnmarshalJSON unmarshal to json
func (logVerbosityLevel *LogVerbosityLevel) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		VerbosityLevel int32 `json:"verbosity_level"` // Log verbosity level
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	logVerbosityLevel.tdCommon = tempObj.tdCommon
	logVerbosityLevel.VerbosityLevel = tempObj.VerbosityLevel

	return nil
}

// LogTags Contains a list of available TDLib internal log tags
type LogTags struct {
	tdCommon
	Tags []string `json:"tags"` // List of log tags
}

// MessageType return the string telegram-type of LogTags
func (logTags *LogTags) MessageType() string {
	return "logTags"
}

// NewLogTags creates a new LogTags
//
// @param tags List of log tags
func NewLogTags(tags []string) *LogTags {
	logTagsTemp := LogTags{
		tdCommon: tdCommon{Type: "logTags"},
		Tags:     tags,
	}

	return &logTagsTemp
}

// UnmarshalJSON unmarshal to json
func (logTags *LogTags) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Tags []string `json:"tags"` // List of log tags
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	logTags.tdCommon = tempObj.tdCommon
	logTags.Tags = tempObj.Tags

	return nil
}

// UserSupportInfo Contains custom information about the user
type UserSupportInfo struct {
	tdCommon
	Message *FormattedText `json:"message"` // Information message
	Author  string         `json:"author"`  // Information author
	Date    int32          `json:"date"`    // Information change date
}

// MessageType return the string telegram-type of UserSupportInfo
func (userSupportInfo *UserSupportInfo) MessageType() string {
	return "userSupportInfo"
}

// NewUserSupportInfo creates a new UserSupportInfo
//
// @param message Information message
// @param author Information author
// @param date Information change date
func NewUserSupportInfo(message *FormattedText, author string, date int32) *UserSupportInfo {
	userSupportInfoTemp := UserSupportInfo{
		tdCommon: tdCommon{Type: "userSupportInfo"},
		Message:  message,
		Author:   author,
		Date:     date,
	}

	return &userSupportInfoTemp
}

// UnmarshalJSON unmarshal to json
func (userSupportInfo *UserSupportInfo) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Message *FormattedText `json:"message"` // Information message
		Author  string         `json:"author"`  // Information author
		Date    int32          `json:"date"`    // Information change date
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	userSupportInfo.tdCommon = tempObj.tdCommon
	userSupportInfo.Message = tempObj.Message
	userSupportInfo.Author = tempObj.Author
	userSupportInfo.Date = tempObj.Date

	return nil
}

// TestInt A simple object containing a number; for testing only
type TestInt struct {
	tdCommon
	Value int32 `json:"value"` // Number
}

// MessageType return the string telegram-type of TestInt
func (testInt *TestInt) MessageType() string {
	return "testInt"
}

// NewTestInt creates a new TestInt
//
// @param value Number
func NewTestInt(value int32) *TestInt {
	testIntTemp := TestInt{
		tdCommon: tdCommon{Type: "testInt"},
		Value:    value,
	}

	return &testIntTemp
}

// UnmarshalJSON unmarshal to json
func (testInt *TestInt) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Value int32 `json:"value"` // Number
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	testInt.tdCommon = tempObj.tdCommon
	testInt.Value = tempObj.Value

	return nil
}

// TestString A simple object containing a string; for testing only
type TestString struct {
	tdCommon
	Value string `json:"value"` // String
}

// MessageType return the string telegram-type of TestString
func (testString *TestString) MessageType() string {
	return "testString"
}

// NewTestString creates a new TestString
//
// @param value String
func NewTestString(value string) *TestString {
	testStringTemp := TestString{
		tdCommon: tdCommon{Type: "testString"},
		Value:    value,
	}

	return &testStringTemp
}

// UnmarshalJSON unmarshal to json
func (testString *TestString) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Value string `json:"value"` // String
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	testString.tdCommon = tempObj.tdCommon
	testString.Value = tempObj.Value

	return nil
}

// TestBytes A simple object containing a sequence of bytes; for testing only
type TestBytes struct {
	tdCommon
	Value []byte `json:"value"` // Bytes
}

// MessageType return the string telegram-type of TestBytes
func (testBytes *TestBytes) MessageType() string {
	return "testBytes"
}

// NewTestBytes creates a new TestBytes
//
// @param value Bytes
func NewTestBytes(value []byte) *TestBytes {
	testBytesTemp := TestBytes{
		tdCommon: tdCommon{Type: "testBytes"},
		Value:    value,
	}

	return &testBytesTemp
}

// UnmarshalJSON unmarshal to json
func (testBytes *TestBytes) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Value []byte `json:"value"` // Bytes
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	testBytes.tdCommon = tempObj.tdCommon
	testBytes.Value = tempObj.Value

	return nil
}

// TestVectorInt A simple object containing a vector of numbers; for testing only
type TestVectorInt struct {
	tdCommon
	Value []int32 `json:"value"` // Vector of numbers
}

// MessageType return the string telegram-type of TestVectorInt
func (testVectorInt *TestVectorInt) MessageType() string {
	return "testVectorInt"
}

// NewTestVectorInt creates a new TestVectorInt
//
// @param value Vector of numbers
func NewTestVectorInt(value []int32) *TestVectorInt {
	testVectorIntTemp := TestVectorInt{
		tdCommon: tdCommon{Type: "testVectorInt"},
		Value:    value,
	}

	return &testVectorIntTemp
}

// UnmarshalJSON unmarshal to json
func (testVectorInt *TestVectorInt) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Value []int32 `json:"value"` // Vector of numbers
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	testVectorInt.tdCommon = tempObj.tdCommon
	testVectorInt.Value = tempObj.Value

	return nil
}

// TestVectorIntObject A simple object containing a vector of objects that hold a number; for testing only
type TestVectorIntObject struct {
	tdCommon
	Value []TestInt `json:"value"` // Vector of objects
}

// MessageType return the string telegram-type of TestVectorIntObject
func (testVectorIntObject *TestVectorIntObject) MessageType() string {
	return "testVectorIntObject"
}

// NewTestVectorIntObject creates a new TestVectorIntObject
//
// @param value Vector of objects
func NewTestVectorIntObject(value []TestInt) *TestVectorIntObject {
	testVectorIntObjectTemp := TestVectorIntObject{
		tdCommon: tdCommon{Type: "testVectorIntObject"},
		Value:    value,
	}

	return &testVectorIntObjectTemp
}

// UnmarshalJSON unmarshal to json
func (testVectorIntObject *TestVectorIntObject) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Value []TestInt `json:"value"` // Vector of objects
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	testVectorIntObject.tdCommon = tempObj.tdCommon
	testVectorIntObject.Value = tempObj.Value

	return nil
}

// TestVectorString A simple object containing a vector of strings; for testing only
type TestVectorString struct {
	tdCommon
	Value []string `json:"value"` // Vector of strings
}

// MessageType return the string telegram-type of TestVectorString
func (testVectorString *TestVectorString) MessageType() string {
	return "testVectorString"
}

// NewTestVectorString creates a new TestVectorString
//
// @param value Vector of strings
func NewTestVectorString(value []string) *TestVectorString {
	testVectorStringTemp := TestVectorString{
		tdCommon: tdCommon{Type: "testVectorString"},
		Value:    value,
	}

	return &testVectorStringTemp
}

// UnmarshalJSON unmarshal to json
func (testVectorString *TestVectorString) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Value []string `json:"value"` // Vector of strings
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	testVectorString.tdCommon = tempObj.tdCommon
	testVectorString.Value = tempObj.Value

	return nil
}

// TestVectorStringObject A simple object containing a vector of objects that hold a string; for testing only
type TestVectorStringObject struct {
	tdCommon
	Value []TestString `json:"value"` // Vector of objects
}

// MessageType return the string telegram-type of TestVectorStringObject
func (testVectorStringObject *TestVectorStringObject) MessageType() string {
	return "testVectorStringObject"
}

// NewTestVectorStringObject creates a new TestVectorStringObject
//
// @param value Vector of objects
func NewTestVectorStringObject(value []TestString) *TestVectorStringObject {
	testVectorStringObjectTemp := TestVectorStringObject{
		tdCommon: tdCommon{Type: "testVectorStringObject"},
		Value:    value,
	}

	return &testVectorStringObjectTemp
}

// UnmarshalJSON unmarshal to json
func (testVectorStringObject *TestVectorStringObject) UnmarshalJSON(b []byte) error {
	var objMap map[string]*json.RawMessage
	err := json.Unmarshal(b, &objMap)
	if err != nil {
		return err
	}
	tempObj := struct {
		tdCommon
		Value []TestString `json:"value"` // Vector of objects
	}{}
	err = json.Unmarshal(b, &tempObj)
	if err != nil {
		return err
	}

	testVectorStringObject.tdCommon = tempObj.tdCommon
	testVectorStringObject.Value = tempObj.Value

	return nil
}
